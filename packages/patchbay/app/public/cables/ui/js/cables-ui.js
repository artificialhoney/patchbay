(function () {
  'use strict';

  /**
   * Ele - minimalistic html dom helper
   *
   * @class
   */
  class Ele {
    /**
     * shortcut for document.getElementById(id)
     *
     * @param {String} id
     * @returns {HTMLElement} DOM element
     */
    byId(id) {
      if (id && id[0] === "#") console.warn("ele.byId should not contain #");
      return document.getElementById(id);
    }

    /**
     * shortcut for document.querySelector(id)
     *
     * @param {String} q
     * @returns {any} DOM element
     */
    byQuery(q) {
      return document.querySelector(q);
    }

    /**
     * shortcut for document.querySelectorAll(id)
     *
     * @param {String} q
     * @returns {NodeListOf<HTMLElement>} DOM elements
     */
    byQueryAll(q) {
      return document.querySelectorAll(q);
    }

    /**
     * returns the first element with class
     *
     * @param {String} name
     * @returns {HTMLElement|null|Element} DOM element
     */
    byClass(name) {
      if (name && name[0] === ".")
        console.warn("ele.byClass should not contain .");
      const els = document.getElementsByClassName(name);
      if (els.length > 0) return els[0];
      return null;
    }

    /**
     * returns the all elements with class
     *
     * @param {String} name
     * @returns {HTMLCollectionOf<Element|HTMLElement>|Array} DOM elements
     */
    byClassAll(name) {
      if (name && name[0] === ".")
        console.warn("ele.byClassAll should not contain .");
      const els = document.getElementsByClassName(name);
      if (!els) return [];
      return els;
    }

    /**
     * runs the callback with all elements that have the given class as first argument
     *
     * @param {String} name
     */
    forEachClass(name, cb) {
      if (name && name[0] === ".")
        console.warn("ele.forEachClass should not contain .");

      const eles = document.getElementsByClassName(name);
      for (let i = 0; i < eles.length; i++) cb(eles[i]);
    }

    /**
     * returns the currently selected value for a <select>-element, or the text, if no value is set
     *
     * @param {HTMLElement|Element} el
     * @return {any}
     */
    getSelectValue(el) {
      if (!el.options) return;
      const selectedIndex = el.selectedIndex || 0;
      return el.options[selectedIndex].value || el.options[selectedIndex].text;
    }

    /**
     * makes an element clickable and executes the callback, also add keyboard support, when hitting enter on the element is same as clicking
     *
     * @param {Object} el
     * @param {Function} cb
     */
    asButton(el, cb) {
      this.clickable(el, cb);
    }

    /**
     * makes an element clickable and executes the callback, also add keyboard support, when hitting enter on the element is same as clicking
     *
     * @param {Object} el
     * @param {Function} cb
     */
    clickable(el, cb) {
      if (!el) return;

      if (el.getAttribute("tabindex") == null) el.setAttribute("tabindex", 0);
      el.classList.add("eleAsButton");
      el.addEventListener("click", (e) => {
        cb(e);
      });
      el.addEventListener("keydown", (e) => {
        if (e.keyCode === 13 || e.keyCode === 32) cb(e);
      });
    }

    /**
     * makes elements matching the query clickable and runs the callback on them when clicked
     *
     * @param {HTMLElement|Element} parent
     * @param {String} query
     * @param {Function} cb
     */
    clickables(parent, query, cb) {
      const clickEles = parent.querySelectorAll(query);
      for (let i = 0; i < clickEles.length; i++) {
        this.clickable(clickEles[i], (e) => {
          cb(e, e.currentTarget.dataset);
        });
      }
    }

    /**
     * can be used for making element keyboard usable and continue using inline onclick e.g. onkeypress="ele.keyClick(event,this)"
     *
     * @param {KeyboardEvent} event
     * @param  {HTMLElement} el
     */
    keyClick(event, el) {
      if ((event.keyCode === 13 || event.keyCode === 32) && el.onclick)
        el.click();
    }

    /**
     * remove class "hidden" from element
     *
     * @param {HTMLElement|Element} el
     */
    show(el) {
      if (el) el.classList.remove("hidden");
    }

    /**
     * add class "hidden" to element
     *
     * @param {HTMLElement|Element} el
     */
    hide(el) {
      if (el) el.classList.add("hidden");
    }

    /**
     * remove or add class "hidden" from element
     *
     * @param {HTMLElement|Element} el
     */
    toggle(el) {
      if (el.classList.contains("hidden")) {
        if (el) el.classList.remove("hidden");
      } else {
        if (el) el.classList.add("hidden");
      }
    }

    /**
     * create element with given tagname
     *
     * @param {String} n
     * @return {HTMLElement}
     */
    create(n) {
      return document.createElement(n);
    }

    /**
     * checks if given element is "activeElement"
     *
     * @param {HTMLElement|Element} el
     * @return {boolean}
     */
    hasFocus(el) {
      return document.activeElement == el;
    }
  }

  var ele = new Ele();

  /**
   * Shared helper methods for cables uis
   */
  class Helper {
    constructor() {
      this._simpleIdCounter = 0;
    }

    /**
     * generate a random v4 uuid
     *
     * @return {string}
     */
    uuid() {
      let d = new Date().getTime();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
      });
    }

    /**
     * checks value for !isNan and isFinite
     *
     * @param {string} n
     * @return {boolean}
     */
    isNumeric(n) {
      const nn = parseFloat(n);
      return !isNaN(nn) && isFinite(nn);
    }

    /**
     * generate a simple ID using an internal counter
     *
     * @return {Number} new id
     * @static
     */
    simpleId() {
      this._simpleIdCounter++;
      return this._simpleIdCounter;
    }

    pathLookup(obj, path) {
      const parts = path.split(".");
      if (parts.length == 1) {
        return obj[parts[0]];
      }
      return this.pathLookup(obj[parts[0]], parts.slice(1).join("."));
    }
  }
  var helper = new Helper();

  class Logger {
    /**
     * @param {any} initiator
     * @param {Object} options
     */
    constructor(initiator, options) {
      this.initiator = initiator;
      this._options = options;
    }

    /**
     * @param {string} t
     */
    stack(t) {
      console.info("[" + this.initiator + "] ", t);
      console.log(new Error().stack);
    }

    /**
     * @param {string} t
     */
    groupCollapsed(t) {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 0 },
            ...arguments,
          )) ||
        !CABLES.logSilent
      )
        console.log("[" + this.initiator + "]", ...arguments);

      console.groupCollapsed("[" + this.initiator + "] " + t);
    }

    /**
     * @param {any[][]} t
     */
    table(t) {
      console.table(t);
    }

    groupEnd() {
      console.groupEnd();
    }

    error() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 2 },
            ...arguments,
          )) ||
        !CABLES.UI
      ) {
        console.error("[" + this.initiator + "]", ...arguments);
      }

      if (this._options && this._options.onError) {
        this._options.onError(this.initiator, ...arguments);
        // console.log("emitevent onerror...");
        // CABLES.patch.emitEvent("onError", this.initiator, ...arguments);
        // CABLES.logErrorConsole("[" + this.initiator + "]", ...arguments);
      }
    }

    errorGui() {
      if (CABLES.UI)
        CABLES.UI.logFilter.filterLog(
          { initiator: this.initiator, level: 2 },
          ...arguments,
        );
    }

    warn() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 1 },
            ...arguments,
          )) ||
        !CABLES.logSilent
      )
        console.warn("[" + this.initiator + "]", ...arguments);
    }

    verbose() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 0 },
            ...arguments,
          )) ||
        !CABLES.logSilent
      )
        console.log("[" + this.initiator + "]", ...arguments);
    }

    info() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 0 },
            ...arguments,
          )) ||
        !CABLES.logSilent
      )
        console.info("[" + this.initiator + "]", ...arguments);
    }

    log() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 0 },
            ...arguments,
          )) ||
        !CABLES.logSilent
      )
        console.log("[" + this.initiator + "]", ...arguments);
    }

    logGui() {
      if (CABLES.UI)
        CABLES.UI.logFilter.filterLog(
          { initiator: this.initiator, level: 0 },
          ...arguments,
        );
    }

    userInteraction(text) {
      // this.log({ "initiator": "userinteraction", "text": text });
    }
  }

  /**
   * add eventlistener functionality to classes
   */
  class Events {
    #eventLog;
    constructor() {
      this.#eventLog = new Logger("eventtarget");
      this._eventCallbacks = {};
      this._logName = "";
      this._logEvents = false;
      this._listeners = {};

      this._countErrorUnknowns = 0;
    }

    /**
     * add event listener
     * @param {string} which event name
     * @param {function} cb callback
     * @param {string} idPrefix prefix for id, default empty
     * @return {string} event id
     */
    on(which, cb, idPrefix = "") {
      const event = {
        id: (idPrefix || "") + helper.simpleId(),
        name: which,
        cb: cb,
      };
      if (!this._eventCallbacks[which]) this._eventCallbacks[which] = [event];
      else this._eventCallbacks[which].push(event);

      this._listeners[event.id] = event;

      return event.id;
    }

    /** @deprecated */
    addEventListener(which, cb, idPrefix = "") {
      return this.on(which, cb, idPrefix);
    }

    /**
     * check event listener registration
     * @param {string} id event id
     * @param {function} cb callback - deprecated
     * @return {boolean}
     */
    hasEventListener(id, cb = null) {
      if (id && !cb) {
        // check by id
        return !!this._listeners[id];
      } else {
        this.#eventLog.warn("old eventtarget function haseventlistener!");
        if (id && cb) {
          if (this._eventCallbacks[id]) {
            const idx = this._eventCallbacks[id].indexOf(cb);
            return idx !== -1;
          }
        }
      }
    }

    /**
     * check event listener by name
     * @param eventName event name
     * @return {boolean}
     */
    hasListenerForEventName(eventName) {
      return (
        this._eventCallbacks[eventName] &&
        this._eventCallbacks[eventName].length > 0
      );
    }

    /** @deprecated */
    removeEventListener(id) {
      return this.off(id);
    }

    /**
     * remove event listener registration
     * @param {string} id event id
     * @return
     */
    off(id) {
      if (id === null || id === undefined) {
        this.#eventLog.warn("removeEventListener id null", id);
        return;
      }

      if (typeof id == "string") {
        // new style, remove by id, not by name/callback
        const event = this._listeners[id];
        if (!event) {
          if (this._countErrorUnknowns == 20)
            this.#eventLog.warn("stopped reporting unknown events");
          if (this._countErrorUnknowns < 20)
            this.#eventLog.warn("could not find event...", id);
          this._countErrorUnknowns++;
          return;
        }

        let removeCount = 0;

        let found = true;
        while (found) {
          found = false;
          let index = -1;
          for (let i = 0; i < this._eventCallbacks[event.name].length; i++) {
            if (this._eventCallbacks[event.name][i].id.indexOf(id) === 0) {
              // this._eventCallbacks[event.name][i].id == which ||
              found = true;
              index = i;
            }
          }

          if (index !== -1) {
            this._eventCallbacks[event.name].splice(index, 1);
            delete this._listeners[id];
            removeCount++;
          }
        }

        if (removeCount == 0) console.log("no events removed", event.name, id);

        return;
      } else {
        console.log(
          "old function signature: removeEventListener! use listener id",
        );
      }
    }

    /**
     * enable/disable logging of events for the class
     *
     * @param {boolean} enabled
     * @param {string} logName
     */
    logEvents(enabled, logName) {
      this._logEvents = enabled;
      this._logName = logName;
    }

    /**
     * emit event
     *
     * @param {string} which event name
     * @param {*} param1
     * @param {*} param2
     * @param {*} param3
     * @param {*} param4
     * @param {*} param5
     * @param {*} param6
     */
    emitEvent(
      which,
      param1 = null,
      param2 = null,
      param3 = null,
      param4 = null,
      param5 = null,
      param6 = null,
      param7 = null,
      param8 = null,
    ) {
      if (this._logEvents)
        this.#eventLog.log(
          "[event] ",
          this._logName,
          which,
          this._eventCallbacks,
        );

      if (this._eventCallbacks[which]) {
        for (let i = 0; i < this._eventCallbacks[which].length; i++) {
          if (this._eventCallbacks[which][i]) {
            this._eventCallbacks[which][i].cb(
              param1,
              param2,
              param3,
              param4,
              param5,
              param6,
              param7,
              param8,
            );
          }
        }
      } else {
        if (this._logEvents)
          this.#eventLog.log(
            "[event] has no event callback",
            which,
            this._eventCallbacks,
          );
      }
    }
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var talker_min = {exports: {}};

  var hasRequiredTalker_min;

  function requireTalker_min () {
  	if (hasRequiredTalker_min) return talker_min.exports;
  	hasRequiredTalker_min = 1;
  	(function (module, exports) {
  		!function(t,e){module.exports=e();}(window,function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:false,exports:{}};return t[r].call(o.exports,o,o.exports,n),o.l=true,o.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:true,get:r});},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:true});},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:true,value:t}),2&e&&"string"!=typeof t)for(var o in t)n.d(r,o,function(e){return t[e]}.bind(null,o));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=3)}([function(t,e,n){(function(e,n){
  		/*!
  		 * @overview es6-promise - a tiny implementation of Promises/A+.
  		 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
  		 * @license   Licensed under MIT license
  		 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
  		 * @version   v4.2.4+314e4831
  		 */var r;r=function(){function t(t){return "function"==typeof t}var r=Array.isArray?Array.isArray:function(t){return "[object Array]"===Object.prototype.toString.call(t)},o=0,i=void 0,s=void 0,u=function(t,e){p[o]=t,p[o+1]=e,2===(o+=2)&&(s?s(v):w());},a="undefined"!=typeof window?window:void 0,c=a||{},f=c.MutationObserver||c.WebKitMutationObserver,h="undefined"==typeof self&&void 0!==e&&"[object process]"==={}.toString.call(e),l="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel;function d(){var t=setTimeout;return function(){return t(v,1)}}var p=new Array(1e3);function v(){for(var t=0;t<o;t+=2){(0, p[t])(p[t+1]),p[t]=void 0,p[t+1]=void 0;}o=0;}var _,y,m,g,w=void 0;function b(t,e){var n=this,r=new this.constructor(j);void 0===r[k]&&N(r);var o=n._state;if(o){var i=arguments[o-1];u(function(){return H(o,r,i,n._result)});}else W(n,r,t,e);return r}function T(t){if(t&&"object"==typeof t&&t.constructor===this)return t;var e=new this(j);return P(e,t),e}h?w=function(){return e.nextTick(v)}:f?(y=0,m=new f(v),g=document.createTextNode(""),m.observe(g,{characterData:true}),w=function(){g.data=y=++y%2;}):l?((_=new MessageChannel).port1.onmessage=v,w=function(){return _.port2.postMessage(0)}):w=void 0===a?function(){try{var t=Function("return this")().require("vertx");return void 0!==(i=t.runOnLoop||t.runOnContext)?function(){i(v);}:d()}catch(t){return d()}}():d();var k=Math.random().toString(36).substring(2);function j(){}var M=void 0,O=1,A=2,x={error:null};function S(t){try{return t.then}catch(t){return x.error=t,x}}function E(e,n,r){n.constructor===e.constructor&&r===b&&n.constructor.resolve===T?function(t,e){e._state===O?C(t,e._result):e._state===A?L(t,e._result):W(e,void 0,function(e){return P(t,e)},function(e){return L(t,e)});}(e,n):r===x?(L(e,x.error),x.error=null):void 0===r?C(e,n):t(r)?function(t,e,n){u(function(t){var r=false,o=function(t,e,n,r){try{t.call(e,n,r);}catch(t){return t}}(n,e,function(n){r||(r=true,e!==n?P(t,n):C(t,n));},function(e){r||(r=true,L(t,e));},t._label);!r&&o&&(r=true,L(t,o));},t);}(e,n,r):C(e,n);}function P(t,e){var n,r;t===e?L(t,new TypeError("You cannot resolve a promise with itself")):(r=typeof(n=e),null===n||"object"!==r&&"function"!==r?C(t,e):E(t,e,S(e)));}function I(t){t._onerror&&t._onerror(t._result),q(t);}function C(t,e){t._state===M&&(t._result=e,t._state=O,0!==t._subscribers.length&&u(q,t));}function L(t,e){t._state===M&&(t._state=A,t._result=e,u(I,t));}function W(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+O]=n,o[i+A]=r,0===i&&t._state&&u(q,t);}function q(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?H(n,r,o,i):o(i);t._subscribers.length=0;}}function H(e,n,r,o){var i=t(r),s=void 0,u=void 0,a=void 0,c=void 0;if(i){if((s=function(t,e){try{return t(e)}catch(t){return x.error=t,x}}(r,o))===x?(c=true,u=s.error,s.error=null):a=true,n===s)return void L(n,new TypeError("A promises callback cannot return that same promise."))}else s=o,a=true;n._state!==M||(i&&a?P(n,s):c?L(n,u):e===O?C(n,s):e===A&&L(n,s));}var F=0;function N(t){t[k]=F++,t._state=void 0,t._result=void 0,t._subscribers=[];}var J=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(j),this.promise[k]||N(this.promise),r(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?C(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&C(this.promise,this._result))):L(this.promise,new Error("Array Methods must be provided an Array"));}return t.prototype._enumerate=function(t){for(var e=0;this._state===M&&e<t.length;e++)this._eachEntry(t[e],e);},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===T){var o=S(t);if(o===b&&t._state!==M)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===Q){var i=new n(j);E(i,t,o),this._willSettleAt(i,e);}else this._willSettleAt(new n(function(e){return e(t)}),e);}else this._willSettleAt(r(t),e);},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===M&&(this._remaining--,t===A?L(r,n):this._result[e]=n),0===this._remaining&&C(r,this._result);},t.prototype._willSettleAt=function(t,e){var n=this;W(t,void 0,function(t){return n._settledAt(O,e,t)},function(t){return n._settledAt(A,e,t)});},t}(),Q=function(){function t(e){this[k]=F++,this._result=this._state=void 0,this._subscribers=[],j!==e&&("function"!=typeof e&&function(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}(),this instanceof t?function(t,e){try{e(function(e){P(t,e);},function(e){L(t,e);});}catch(e){L(t,e);}}(this,e):function(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}());}return t.prototype.catch=function(t){return this.then(null,t)},t.prototype.finally=function(t){var e=this.constructor;return this.then(function(n){return e.resolve(t()).then(function(){return n})},function(n){return e.resolve(t()).then(function(){throw n})})},t}();return Q.prototype.then=b,Q.all=function(t){return new J(this,t).promise},Q.race=function(t){var e=this;return r(t)?new e(function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r);}):new e(function(t,e){return e(new TypeError("You must pass an array to race."))})},Q.resolve=T,Q.reject=function(t){var e=new this(j);return L(e,t),e},Q._setScheduler=function(t){s=t;},Q._setAsap=function(t){u=t;},Q._asap=u,Q.polyfill=function(){var t=void 0;if(void 0!==n)t=n;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")();}catch(t){throw new Error("polyfill failed because global object is unavailable in this environment")}var e=t.Promise;if(e){var r=null;try{r=Object.prototype.toString.call(e.resolve());}catch(t){}if("[object Promise]"===r&&!e.cast)return}t.Promise=Q;},Q.Promise=Q,Q},t.exports=r();}).call(this,n(1),n(2));},function(t,e){var n,r,o=t.exports={};function i(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function u(t){if(n===setTimeout)return setTimeout(t,0);if((n===i||!n)&&setTimeout)return n=setTimeout,setTimeout(t,0);try{return n(t,0)}catch(e){try{return n.call(null,t,0)}catch(e){return n.call(this,t,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:i;}catch(t){n=i;}try{r="function"==typeof clearTimeout?clearTimeout:s;}catch(t){r=s;}}();var a,c=[],f=false,h=-1;function l(){f&&a&&(f=false,a.length?c=a.concat(c):h=-1,c.length&&d());}function d(){if(!f){var t=u(l);f=true;for(var e=c.length;e;){for(a=c,c=[];++h<e;)a&&a[h].run();h=-1,e=c.length;}a=null,f=false,function(t){if(r===clearTimeout)return clearTimeout(t);if((r===s||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(t);try{r(t);}catch(e){try{return r.call(null,t)}catch(e){return r.call(this,t)}}}(t);}}function p(t,e){this.fun=t,this.array=e;}function v(){}o.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];c.push(new p(t,e)),1!==c.length||f||u(d);},p.prototype.run=function(){this.fun.apply(null,this.array);},o.title="browser",o.browser=true,o.env={},o.argv=[],o.version="",o.versions={},o.on=v,o.addListener=v,o.once=v,o.off=v,o.removeListener=v,o.removeAllListeners=v,o.emit=v,o.prependListener=v,o.prependOnceListener=v,o.listeners=function(t){return []},o.binding=function(t){throw new Error("process.binding is not supported")},o.cwd=function(){return "/"},o.chdir=function(t){throw new Error("process.chdir is not supported")},o.umask=function(){return 0};},function(t,e){var n;n=function(){return this}();try{n=n||new Function("return this")();}catch(t){"object"==typeof window&&(n=window);}t.exports=n;},function(t,e,n){n.r(e);var r,o=n(0),i=function(t,e,n){return delete t.__resolve__,delete t.__reject__,e(n),t},s=function(){var t,e,n=new o.Promise(function(n,r){t=n,e=r;});return n.__resolve__=function(e){return i(n,t,e)},n.__reject__=function(t){return i(n,e,t)},n},u="application/x-talkerjs-v1+json",a=(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);}),c=function(){return function(t,e,n,r){ void 0===r&&(r=null),this.talker=t,this.namespace=e,this.data=n,this.responseToId=r,this.type=u;}}(),f=function(t){function e(e,n,r,o){ void 0===o&&(o=null);var i=t.call(this,e,n,r,o)||this;return i.talker=e,i.namespace=n,i.data=r,i.responseToId=o,i.id=i.talker.nextId(),i}return a(e,t),e.prototype.toJSON=function(){var t=this;return {id:t.id,responseToId:t.responseToId||void 0,namespace:t.namespace,data:t.data,type:t.type}},e}(c),h=function(t){function e(e,n,r,o){ void 0===n&&(n=""),void 0===r&&(r={}),void 0===o&&(o=0);var i=t.call(this,e,n,r)||this;return i.talker=e,i.namespace=n,i.data=r,i.id=o,i}return a(e,t),e.prototype.respond=function(t){return this.talker.send(this.namespace,t,this.id)},e}(c);n.d(e,"IncomingMessage",function(){return h}),n.d(e,"OutgoingMessage",function(){return f});var l=function(){function t(t,e,n){ void 0===n&&(n=window);var r=this;return this.remoteWindow=t,this.remoteOrigin=e,this.localWindow=n,this.timeout=3e3,this.latestId=0,this.queue=[],this.sent={},this.handshaken=false,this.handshake=s(),this.localWindow.addEventListener("message",function(t){return r.receiveMessage(t)},false),this.sendHandshake(),this}return t.prototype.send=function(t,e,n){ void 0===n&&(n=null);var r=new f(this,t,e,n),o=s();return this.sent[r.id]=o,this.queue.push(r),this.flushQueue(),setTimeout(function(){return o.__reject__&&o.__reject__(new Error("Talker.js message timed out waiting for a response."))},this.timeout),o},t.prototype.nextId=function(){return this.latestId+=1},t.prototype.receiveMessage=function(t){var e;try{e=JSON.parse(t.data);}catch(t){e={namespace:"",data:{},id:this.nextId(),type:u};}if(this.isSafeMessage(t.source,t.origin,e.type))return e.handshake||e.handshakeConfirmation?this.handleHandshake(e):this.handleMessage(e)},t.prototype.isSafeMessage=function(t,e,n){var r=t===this.remoteWindow,o="*"===this.remoteOrigin||e===this.remoteOrigin;return r&&o&&n===u},t.prototype.handleHandshake=function(t){t.handshake&&this.sendHandshake(this.handshaken),this.handshaken||(this.handshaken=true,this.handshake.__resolve__&&this.handshake.__resolve__(this.handshaken),this.flushQueue());},t.prototype.handleMessage=function(t){var e=new h(this,t.namespace,t.data,t.id),n=t.responseToId;return n?this.respondToMessage(n,e):this.broadcastMessage(e)},t.prototype.respondToMessage=function(t,e){var n=this.sent[t];n&&n.__resolve__&&(n.__resolve__(e),delete this.sent[t]);},t.prototype.broadcastMessage=function(t){this.onMessage&&this.onMessage.call(this,t);},t.prototype.sendHandshake=function(t){var e;return void 0===t&&(t=false),this.postMessage(((e={type:u})[t?"handshakeConfirmation":"handshake"]=true,e))},t.prototype.postMessage=function(t){var e=JSON.stringify(t);if(this.remoteWindow&&this.remoteOrigin)try{this.remoteWindow.postMessage(e,this.remoteOrigin);}catch(t){}},t.prototype.flushQueue=function(){if(this.handshaken)for(;this.queue.length>0;){var t=this.queue.shift();t&&this.postMessage(t);}},t}();e.default=l;}])});
  		
  	} (talker_min));
  	return talker_min.exports;
  }

  var talker_minExports = requireTalker_min();
  var Talker = /*@__PURE__*/getDefaultExportFromCjs(talker_minExports);

  /**
   * wrapper for talkerapi to communicate ui <-> backend even in iframed setups
   *
   * @name TalkerAPI
   * @extends {Events}
   */
  class TalkerAPI extends Events {
    constructor(target) {
      super();

      this._talker = new Talker(target, "*");
      this._callbackCounter = 0;
      this._callbacks = {};

      this._talker.onMessage = (msg) => {
        if (msg.data && msg.data.cmd) {
          // other messages are not for talkerapi, i.e. anything that somehow is sent via .postMessage
          if (msg.data.cmd === "callback") {
            if (this._callbacks[msg.data.cb])
              this._callbacks[msg.data.cb](msg.data.error, msg.data.response);
          } else {
            if (!this.hasListenerForEventName(msg.data.cmd)) {
              console.error("TalkerAPI has no listener for", msg.data.cmd);
            }
            this.emitEvent(msg.data.cmd, msg.data.data, (error, r) => {
              this._talker.send("cables", {
                cmd: "callback",
                cb: msg.data.cb,
                response: r,
                error: error,
              });
            });
          }
        }
      };
    }

    /**
     * send message via cables-talkerapi
     * @param cmd name of the event
     * @param data payload
     * @param cb callback
     */
    send(cmd, data, cb) {
      const payload = { cmd: cmd, data: data };
      if (cb) {
        this._callbackCounter++;
        this._callbacks[this._callbackCounter] = cb;
        payload.cb = this._callbackCounter;
      }

      this._talker.send("cables", payload);
    }
  }

  class ModalBackground extends Events {
    constructor(options = {}) {
      super();
      this._eleBg = document.getElementById("modalbg");
      this.showing = false;

      this._eleBg.addEventListener("pointerdown", () => {
        this.hide();
      });
      this._eleBg.addEventListener("click", () => {
        this.hide();
      });

      if (options.listenToEsc)
        document.body.addEventListener("keydown", (event) => {
          if (this.showing && event.key === "Escape") this.hide();
        });
    }

    show(transparent) {
      if (!this.showing) {
        this.showing = true;
        this.emitEvent("show");
      }
      this._eleBg.style.display = "block";

      if (transparent) this._eleBg.classList.add("modalbgtransparent");
      else this._eleBg.classList.remove("modalbgtransparent");
    }

    hide() {
      if (this.showing) {
        this.showing = false;
        this.emitEvent("hide");
      }
      this._eleBg.style.display = "none";
    }
  }

  var DATE_FORMAT_LOGDATE = "YYYY-MM-DD HH:mm";
  var DATE_FORMAT_DISPLAYDATE_DATE = "YYYY-MM-DD HH:mm";
  var DATE_FORMAT_DISPLAYDATE_DISPLAY = "MMM D, YYYY [at] HH:mm";
  var DATE_FORMAT_TOOLTIPDATE = "MMM D, YYYY [at] HH:mm";
  var DATE_FORMAT_DISPLAYDATE_NO_TIME_DATE = "YYYY-MM-DD";
  var DATE_FORMAT_DISPLAYDATE_NO_TIME_DISPLAY = "MMM D, YYYY ";
  var DATE_FORMAT_RELATIVEDATE_CUTOFF_DAYS = 7;
  var DATE_FORMAT_RELATIVEDATE_FULL = "MMM D, YYYY [at] HH:mm";
  var IFRAME_OPTIONS_ALLOW = "clipboard-read;clipboard-write;geolocation;camera;microphone;midi;usb;serial;xr-spatial-tracking;web-share;ambient-light-sensor;window-management";
  var IFRAME_OPTIONS_SANDBOX = "allow-scripts allow-same-origin allow-forms allow-modals allow-orientation-lock allow-pointer-lock allow-presentation allow-downloads allow-popups allow-popups-to-escape-sandbox";
  var text$1 = {
  	en: {
  		leave_patch: "Leave Patch"
  	}
  };

  var CablesConstants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DATE_FORMAT_DISPLAYDATE_DATE: DATE_FORMAT_DISPLAYDATE_DATE,
    DATE_FORMAT_DISPLAYDATE_DISPLAY: DATE_FORMAT_DISPLAYDATE_DISPLAY,
    DATE_FORMAT_DISPLAYDATE_NO_TIME_DATE: DATE_FORMAT_DISPLAYDATE_NO_TIME_DATE,
    DATE_FORMAT_DISPLAYDATE_NO_TIME_DISPLAY: DATE_FORMAT_DISPLAYDATE_NO_TIME_DISPLAY,
    DATE_FORMAT_LOGDATE: DATE_FORMAT_LOGDATE,
    DATE_FORMAT_RELATIVEDATE_CUTOFF_DAYS: DATE_FORMAT_RELATIVEDATE_CUTOFF_DAYS,
    DATE_FORMAT_RELATIVEDATE_FULL: DATE_FORMAT_RELATIVEDATE_FULL,
    DATE_FORMAT_TOOLTIPDATE: DATE_FORMAT_TOOLTIPDATE,
    IFRAME_OPTIONS_ALLOW: IFRAME_OPTIONS_ALLOW,
    IFRAME_OPTIONS_SANDBOX: IFRAME_OPTIONS_SANDBOX,
    text: text$1
  });

  class HandlebarsHelper {
    initHandleBarsHelper() {
      if (window.Handlebars) {
        Handlebars.registerHelper("urlencode", (str) => {
          return new Handlebars.SafeString(encodeURIComponent(str));
        });

        Handlebars.registerHelper(
          "md",
          (str, setOpLinks = false, linkTarget = "") => {
            if (!str) return "";
            let escaped = Handlebars.escapeExpression(str);
            if (marked) escaped = marked.parse(escaped);
            if (setOpLinks) escaped = this._setOpLinks(escaped, linkTarget);
            return new Handlebars.SafeString(escaped);
          },
        );

        Handlebars.registerHelper("round", (str) => {
          if (helper.isNumeric(str)) {
            str = String(Math.round(parseFloat(str)));
          }
          return str;
        });

        Handlebars.registerHelper("twoDigits", (str) => {
          if (!str) return "0.00";
          let parsed = parseFloat(str);
          if (!parsed) return "0.00";
          return parsed.toFixed(2);
        });

        Handlebars.registerHelper("toInt", (str) => {
          if (!str) return "0";
          let parsed = parseInt(str);
          if (!parsed) return "0";
          return parsed;
        });

        Handlebars.registerHelper("json", (context) => {
          let str = "";
          try {
            str = JSON.stringify(context, true, 4);
          } catch (e) {
            console.error(e);
          }

          return str;
        });

        Handlebars.registerHelper("console", (context) => {
          return console.log(context);
        });

        Handlebars.registerHelper("opLayout", (opName) => {
          return new Handlebars.SafeString(gui.opDocs.getLayoutSvg(opName));
        });

        // don't change to arrow-function to keep the right `arguments` for context
        Handlebars.registerHelper(
          "compare",
          function (left_value, operator, right_value, options) {
            let operators, result;

            if (arguments.length < 4) {
              throw new Error(
                "Handlerbars Helper 'compare' needs 3 parameters, left value, operator and right value",
              );
            }

            operators = {
              "==": function (l, r) {
                return l == r;
              },
              "===": function (l, r) {
                return l === r;
              },
              "!=": function (l, r) {
                return l != r;
              },
              "<": function (l, r) {
                return l < r;
              },
              ">": function (l, r) {
                return l > r;
              },
              "<=": function (l, r) {
                return l <= r;
              },
              ">=": function (l, r) {
                return l >= r;
              },
              typeof: function (l, r) {
                return typeof l == r;
              },
            };

            if (!operators[operator]) {
              throw new Error(
                "Handlerbars Helper 'compare' doesn't know the operator " +
                  operator,
              );
            }

            result = operators[operator](left_value, right_value);

            if (result === true) {
              return options.fn(this);
            } else {
              return options.inverse(this);
            }
          },
        );

        Handlebars.registerHelper("toUpperCase", (str) => {
          if (str && typeof str === "string") {
            return str.charAt(0).toUpperCase() + str.slice(1);
          }
          return "";
        });

        // don't change to arrow-function to keep the right `this` for context
        Handlebars.registerHelper("paginationLoop", function (block) {
          let currentPage = Number(this.currentPage) || 0;
          let to = currentPage + 19;
          if (to > this.pages) {
            to = this.pages;
          }

          let from = currentPage - 10;
          if (from < 1) from = 1;

          const numTabs = 19;

          if (currentPage + numTabs > this.pages) {
            from = this.pages - numTabs;
          }

          if (from < 1) from = 1;

          let accum = "";
          let count = 0;
          for (let i = from; i <= to; i++) {
            if (count > numTabs) break;
            let last = i === to;
            if (count === numTabs) last = true;
            accum += block.fn({ page: i, last: last, first: i == from });
            count++;
          }

          return accum;
        });

        Handlebars.registerHelper("logdate", (str) => {
          if (helper.isNumeric(str) && String(str).length < 11) str *= 1000;
          let date;
          if (str && moment) {
            date = moment(str).format(DATE_FORMAT_LOGDATE);
          } else {
            date = "";
          }
          return new Handlebars.SafeString(
            '<span title="' + date + '">' + date + "</span>",
          );
        });

        Handlebars.registerHelper("displaydate", (str) => {
          if (helper.isNumeric(str) && String(str).length < 11) str *= 1000;
          let date = str;
          let displayDate;
          if (str && moment) {
            const m = moment(str);
            date = m.format(DATE_FORMAT_DISPLAYDATE_DATE);
            displayDate = m.format(
              DATE_FORMAT_DISPLAYDATE_DISPLAY,
            );
          } else {
            displayDate = "";
          }
          return new Handlebars.SafeString(
            '<span title="' + date + '">' + displayDate + "</span>",
          );
        });

        Handlebars.registerHelper("tooltipdate", (str) => {
          if (helper.isNumeric(str) && String(str).length < 11) str *= 1000;
          let displayDate;
          if (str && moment) {
            const m = moment(str);
            displayDate = m.format(DATE_FORMAT_TOOLTIPDATE);
          } else {
            displayDate = "";
          }
          return new Handlebars.SafeString(displayDate);
        });

        Handlebars.registerHelper("displaydateNoTime", (str) => {
          if (helper.isNumeric(str) && String(str).length < 11) str *= 1000;
          let date = str;
          let displayDate = str;
          if (moment) {
            const m = moment(str);
            date = m.format(DATE_FORMAT_DISPLAYDATE_NO_TIME_DATE);
            displayDate = m.format(
              DATE_FORMAT_DISPLAYDATE_NO_TIME_DISPLAY,
            );
          }
          return new Handlebars.SafeString(
            '<span title="' + date + '">' + displayDate + "</span>",
          );
        });

        Handlebars.registerHelper("relativedate", (str) => {
          if (helper.isNumeric(str) && String(str).length < 11) str *= 1000;
          let date = str;
          let displayDate;
          if (str && moment) {
            const m = moment(str);
            displayDate = m.fromNow();
            if (m.isBefore(moment().subtract(7, "days")))
              displayDate = moment(date).format(
                DATE_FORMAT_RELATIVEDATE_FULL,
              );
            date = m.format(DATE_FORMAT_RELATIVEDATE_FULL);
          } else {
            date = "";
            displayDate = "";
          }
          return new Handlebars.SafeString(
            '<span title="' + date + '">' + displayDate + "</span>",
          );
        });

        Handlebars.registerHelper("text", (str) => {
          const locale = "en";
          return text$1[locale][str];
        });

        Handlebars.registerHelper("constants", (path) => {
          if (!path) return "";
          const constant = helper.pathLookup(CablesConstants, path);
          if (constant) return constant;
          return path;
        });
      }
    }

    _setOpLinks(html, linkTarget = "") {
      html = html || "";
      let link = "/op/";
      if (CABLES && CABLES.platform) link = CABLES.platform.getCablesUrl() + link;

      const urlPattern =
        /\b(?:Ops\.)[a-z0-9-+&@#\/%?=~_|!:,.;]*[a-z0-9-+&@#\/%=~_|]/gim;
      let replaceValue = '<a href="' + link + '$&">$&</a>';
      if (linkTarget)
        replaceValue =
          '<a href="' + link + '$&" target="' + linkTarget + '">$&</a>';
      html = html.replace(urlPattern, replaceValue);
      return html;
    }
  }
  var HandlebarsHelper$1 = new HandlebarsHelper();

  const text = {
    save_screenshot:
      "## Save Screenshot\n\nDownload renderer output as an image file",
    toggle_sound: "## Toggle Sound\n\nTurn sound on or off",
    toggle_helper:
      "`o` Toggle the idsplay of overlays (helper outlines and bounding boxes)",
    canvas_lens:
      "## Pixel Magnifier\n\nMove over canvas to magnify pixels.\n\n[cmd_ctrl]`c` copy hovered color to clipboard",
    canvas_switch: "Switch between multiple canvasses",

    canvas_size:
      "## Canvas Size\n\nCanvas size in pixels\n\nclick to set the canvas manually",
    canvas_aspect: "## Canvas Aspect ratio\n\nclick to choose an aspect ratio",
    canvas_zoom:
      "## Website Zoom\n\nYour browser is zoomed in, use [cmd_ctrl] and +/- to change zoom",
    canvas_version: "## WebGl Version",
    canvas_fps: "## FPS\n\nCurrently number of rendered frames per second",
    canvas_ms:
      "## Miliseconds\n\nCurrent amount of time needed to render the mainloop",

    renderer_patchbg:
      "## Toggle Patch Background\n\n[cmd_ctrl][shift]`enter` Toggle patch nackground renderer",
    renderer_maximize: "## Maximize canvas\n\n[cmd_ctrl]`enter` Maximize canvas",
    renderer_setsize: "## Canvas Size \n\n* click to set canvas size",
    infoarea: "## Infoarea\n\nLook here for contextual information",

    nav_patch_new: "## New Patch\n\nCreates a new patch",
    nav_patch_open: "## Open Patch\n\nLoad an existing patch",

    linkAddCircle:
      "## Cable \n\n* [LMB] Insert op \n* [RMB] Remove cable \n* [DRAG_RMB] Move cable \n* [RMB]+`alt` Duplicate cable ",

    timeLineToggle: "Toggle timeline / keyframing panel",
    timeLineTime:
      "* Shows current frame/time in seconds\n\n * Click to enter frame to go to",
    tlplay: "`space` Play/Pause",
    tlzoomgraph: "Zoom graph",
    tlzoomtime: "Zoom time",
    tlnextkey: "`j` Next keyframe || `k` Previous keyframe",
    tltogglegraph: "Toggle graph view/dopesheet",
    tltoggle: "`ctrl space` Toggle timeline",
    tlactive:
      "[LMB] toggle editable || [RMB] deactivate all others || `dblclick` activate all",

    portFloatInput: "* Use mousewheel or up/down keys to inc/decrement by 0.1",
    portFloatDrag:
      "* Hold left mouse button and drag to change value. \n\n* hold shift to for smaller increase.",
    portUnlink: "Click to unlink port",
    portCreateOp: "Create and connect new texture op",
    portAnimKeep: "Keep in keyframing view",
    portAnimToggle: "Toggle parameter animation. enable to keyframe parameter",

    portDirIn: "## Input Port ",
    portDirOut: "## Output Port",
    portMouseUnlink:
      "|| [RMB] Unlink port || [DRAG_RMB] Move cable || `DEL` Delete link || [alt]+[DRAG_RMB] Copy link",
    portMouseCreate: "|| [DRAG_LMB] Create and link new op",
    portObjectSnapshot: "See an object data snapshot",

    patchSelectedMultiOps:
      "## Selected Multiple Ops\n\n* `d` disable ops and their children\n* `a` align ops left\n* `c` center ops\n* [shift]`a` reduce vertical spacing\n* `DEL` delete selected ops\n* [cmd_ctrl]`c` copy selected op ",
    patchSelectedOp:
      "## Selected Single Op\n\n* `T` set op title\n* `D` disable op and children\n* `X` unlink op \n* `DEL` delete op\n* `page up/down` snap to parent/child op",

    projectSettingsPublic: "Make patch public - Everyone can see it",
    projectSettingsTitle: "## Patch Name \n\nIf this is your op, click to edit",
    projectSettingsExample: "ADMIN: Patch will be listed as example",

    projectExportNotSaved: "Patch not saved - Save patch before exporting",
    projectBackupNotSaved:
      "Patch not saved - Save patch before creating a backup",
    projectNotSaved: "Patch not saved - Save patch and try again",

    editorTab: "## Editor \n\n* [LMB] Activate tab [MMB] Close tab ",
    searchResult: "|| [LMB] Focus op || [shift][LMB] Show op params",
    dragfile:
      "## File \n\n* [DRAG_LMB] Drag this File to the patchfield to create a fitting operator",

    editor:
      "## Code editor \n\nHere you can edit the code of your ops, write op descriptions, as well as edit objects / arrays.",
    patch:
      "## Patchfield \n\n|| `ESC` Add ops || [DRAG_RMB] Pan || [cmd_ctrl]`s` Save patch || `c` center all op || `f` flow visualization  || `+`/`-`[MW] Adjust zoom || [cmd_ctrl]`F` Search || [cmd_ctrl]`P` Command palette",
    canvas:
      "## Canvas\n\n|| Visual output of your patch || [cmd_ctrl][enter] || Maximize canvas",
    projectFiles: "## Project Files \n\nOverview over your uploaded files",
    undevLogo:
      "## UNDEV \n\ncables is made by **UNDEV**, come visit us in our office in Berlin and have a coffee with us! ",

    minimize_tabpanel: "## [cmd_ctrl]`ESC` - Toggle main tab panel",

    tab_files: "## Files \n\nUpload and manage your files",
    tab_code: "## Code\n\nOperator code",
    tab_doc: "## Documentation\n\nOperator documentation",
    tab_preview: "## Preview\n\nPreview you generated textures",
    tab_op: "## Op Parameters\n\n",
    tab_history: "## History\n\n",
    tab_keyframes: "## Keyframes\n\n",
    tab_variables: "## Variables\n\n",
    tab_patchconnection: "## Patch Connection\n\n",
    tab_profiler:
      "## Profiler \n\nFind out which ops require most processing time",
    tab_bookmarks:
      "## Bookmarks \n\nBookmark ops in a big patch to easily locate them",
    tab_debug: "## Debug \n\n",
    tab_screen: "## Screen \n\n",

    electron_openfolder: "## Open Folder\n[cmd_ctrl][LMB] Copy path to clipboard",

    download_screenshot:
      "## Download screenshot \n\nDownload a HD-image (1920 x 1080) of your patch",
    minimapContainer:
      "## Minimap \n\nShows an overview over your patch. Click inside the map to navigate.",
    timelineui:
      "## Timeline \n\nIn the timeline you can animate ports over time.",
    op_background: "## Op \n\n",
    op_title: "## Op Title \n\n* Click to edit title",

    bookmark_added: "Bookmark added!",
    bookmark_removed: "Bookmark removed!",

    timeline_overview:
      "## Timeline overview \n\nShows the current visible area\n\ndrag borders to resize\n\n* [DRAG_LMB] move area\n* [DRAG_RMB] move area and change time\n* `double click` toggle show full project length",
    timeline_frames: "## Timeline \n\n* [LMB] move cursor",
    timeline_time: "[LMB] Jump to frame",
    timeline_progress: "`click` Set project duration",
    timeline_keys:
      "## Timeline  \n\n* [DRAG_RMB] Move visible area\n* [DRAG_LMB] Select keys\n* `h` Center all keys\n* `j` / `k` Jump to next/previous key\n* `DEL` Delete selected keys",

    usersettings: "## User Settings\n\nChange editor settings ",
    texpreview:
      "## Texture Preview\n\nShows result of last clicked texture outputing operator.\n\nClick to see focus operator\n\nClick patch background to hide",

    valueChangerHover:
      "## Number Input \n\n* [DRAG_LMB] change value \n* [alt] + [DRAG_LMB] change value fast\n* [shift] + [DRAG_LMB] change value slow",
    valueChangerInput:
      "## Number Input Focussed \n\n* [updown][MW] change value +/- 0.1 \n* [shift][updown][MW] change value +/- 0.01\n* [alt][updown][MW] change value +/- 1",
    open_new_window: "## View Patch\n\nopen patch viewer in new window",
    settings:
      "## Patch Settings\n\nrename,publish your patch\n\ninvite users to collaborate",

    working_connected_to: "To work, this op needs to be a child of: ",
    working_connected_needs_connections_to: "These ports should be linked: ",
    working_connected_needs_connections_or_string:
      "Ports should have a string value (or be linked): ",
    working_shouldNotBeChildOf: "Should not be a child of ",

    notOptimizedBrowser_title: "oops!",
    notOptimizedBrowser_text:
      "Cables is optimized for firefox and chrome, you are using something else<br/>feel free to continue, but be warned, it might behave strange",

    filemanager_delete_file: "Delete file",
    filemanager_file_search: "Search for ops that use this file",
    filemanager_file_open: "Open file in new window",
    filemanager_file_download: "Download file",
    filemanager_file_refresh: "Reload file list",
    filemanager_file_upload: "Upload new file",
    filemanager_file_add: "Add new file",
    filemanager_file_create: "Create a file",
    filemanager_reupload: "Replace contents of this file",
    filemanager_copy_file_url: "Copy file URL",
    filemanager_edit_file: "Edit file",

    editorSaveButton: "Save",
    editorFormatButton: "Format",

    cmd_centerpatch: "`c` Center patch or selected ops",
    cmd_zoomin: "`+` Zoom In",
    cmd_zoomout: "`-` Zoom Out",
    cmd_savepatch: "[cmd_ctrl]`S` Save Patch",
    cmd_addop: "`esc` Add Operator",
    cmd_patchsettings: "## Open Patch settings",

    patch_hint_overlay_empty:
      "This patch is empty. press <code>escape</code> to add operators",
    patch_hint_overlay_outofbounds:
      "<i>got lost ?</i>&nbsp;&nbsp;press <code>[C]</code>to center the whole patch again",

    guestHint:
      "Cables is in Demo mode and has only limited functionality. Please register, it's free!",

    opselect_intro:
      '<br/><h2>&nbsp;Start typing!</h2><br/>You can search for multiple words at once, e.g.: "interpolate array"<br/><br/>Add spaces between words for better search results<br/><br/>Press <span class="icon icon-arrow-up"></span> and <span class="icon icon-arrow-down"></span> to navigate.<br/><br/>Finally press <span class="icon icon-corner-down-left"></span> to create the selected op',
    opselect_typemore: "<h2>&nbsp;Type some more!</h2>",
    opselect_notfound:
      '<h2>&nbsp;404 - Op not found</h2><br/><br/><a class="bluebutton" onclick="Gui.gui._opselect.close();Gui.gui.serverOps.createDialog(document.getElementById(\'opsearch\').value);">Code a new op</a>',
    opselect_addop: "Add",

    summary_settings: "Patch settings",
    summary_analyze: "Analyze patch",

    outline_filter_bookmarks: "Show/hide bookmarks ops in patch outline",
    outline_filter_subpatchops: "Show/hide subpatchops ops in patch outline",
    outline_filter_commented: "Show/hide commented ops in patch outline",
    outline_filter_comments: "Show/hide comments ops in patch outline",
    outline_filter_areas: "Show/hide areas ops in patch outline",
    outline_filter_colored: "Show/hide colored ops in patch outline",

    preferences: {
      title: "Preferences",

      subtitle_scroll_button: "Pan Button",
      subtitle_allow_cable_drag: "Allow dragging cables (right mouse button)",

      subtitle_glpatch_cursor: "use native cursor",
      subtitle_glpatch_showboundings: "draw patch bounding",
      subtitle_glpatch_linetype: "cables style",

      head_glpatch: "Patch Editor",

      title_snapToGrid: "Snap To Grid",
      subtitle_snapToGrid:
        "Ops snap to an invisible grid, makes patches look much cleaner",

      title_nobrowserWarning: "Hide Warning",
      subtitle_nobrowserWarning:
        'Hide that red "unsupported browser" warning notification',

      title_introCompleted: "Intro Tour",
      subtitle_introCompleted: "Show Intro tour again (needs reload)",

      title_randomizePatchName: "Random Patch Name",
      subtitle_randomizePatchName:
        "Pick a random name for new patches, instead of 'new project'",

      title_helperMode: "Show Helper Meshes",
      subtitle_helperMode:
        "Show helper, directions/boundaries etc, as in e.g. randomCluster",

      // "title_forceWebGl1": "Force WebGL v1",
      // "subtitle_forceWebGl1": "only if you know what you are doing!",

      title_devinfos: "Show developer information",
      subtitle_devinfos: "boring developer stuff",

      title_miniopselect: "Op Select Dialog Layout",
      subtitle_miniopselect: "",

      title_canvaspos: "Canvas Position",
      subtitle_canvaspos: "Patchfield Background Rendering or top-right corner",

      title_theme: "Theme",
      subtitle_theme: "Bright theme is better when you work outside.",

      title_hideCanvasUi: "Show Canvas Info Bar Ui",

      title_hideSizeBar: "Icon Side Bar",
      subtitle_hideSizeBar:
        "Shows a sidebar with icons of commands from command palette",

      title_texpreviewSize: "Texture Preview",
      subtitle_texpreviewSize:
        "After clicking an op that outputs an image/texture, it will be shown next to the canvas.",

      title_bgpattern: "Background Pattern",
      subtitle_bgpattern: "Background Pattern for transparent canvas/textures.",

      subtitle_wheelmultiplier: "Mouse scrollwheel speed",

      title_quickLinkLongPress: "Long Press Quick Link",
      subtitle_quickLinkLongPress:
        "Long press an op and drag a line to another, helps with pen inputs or touchpads",

      title_doubleClickAction: "Double click action",
      subtitle_doubleClickAction:
        "Click two times fast into an empty area of the patch field",

      title_quickLinkMiddleMouse: "Middle Mouse Quick Link",
      subtitle_quickLinkMiddleMouse:
        "Middle mouse click an op and drag a line to another",

      title_idlemode: "Idle Mode",
      subtitle_idlemode:
        "go into idle mode after some time (to save energy and less fan activity)",

      title_tipps: "Tips",
      subtitle_tipps: "Show tips when opening editor (needs reload)",

      title_presentationmode: "Presentation Mode",
      subtitle_presentationmode: "Show all key presses on the screen",

      title_fadeOutCables: "Fade Cables",
      subtitle_fadeOutCables: "Fade out long cables",

      title_fontsize: "Text Size",
      subtitle_fontsize: "Size Of Text and Icons in cables",
      subtitle_fontsize_ace: "Font size in Text editor",
      subtitle_wrapmode_ace: "Wrap Mode in Text editor",

      subtitle_formatcode: "Format code after saving",

      subtitle_notlocalizeNumberformat: "Localize output port number format",

      title_openlastproject: "Open the last saved patch on start",
      subtitle_openlastproject: "",

      title_openfullscreen: "Open in fullscreen on start",
      subtitle_openfullscreen: "",

      title_maximizerenderer: "Maximize renderer on start",
      subtitle_maximizerenderer: "",

      title_authorName: "Author name for created ops",
      subtitle_authorName: "",

      title_downloadPath: "Custom download folder",
      subtitle_downloadPath: "",

      subtitle_wheelmode:
        "How scrolling events are interpreted:<br/>- Zoom: mousewheel<br/>- pan: for tablets and touchpads",
      subtitle_panspeed: "Pan speed",
      subtitle_keybind_escape: "Hotkey for opening op select",
      subtitle_escape_closetabs: "Escape closes main tab panel",
      subtitle_ace_keymode: "keyboard mode",
    },
    tips: [
      {
        descr:
          " To **add an op** press the `Esc`-key. In the popup you can now enter any text which is part of the ops namespace (e.g. `MainLoop`). You can now navigate through the result-set using your arrow keys (`` and ``). \n\nWhen you press `Enter` the selected op will be added to the editor.descr:",
        img: "a_add_op_new.gif",
      },
      {
        descr:
          " To **add another op and connect it** to the one we just added you can now drag out a cable from one of the ports.  ",
        img: "b_add_op_and_connect_it_new.gif",
      },
      {
        descr:
          " To **add an op in between two ops** just press the circle in the middle of the cable (one of the existing ops must be highlighted for this).  ",
        img: "c_add_op_between_other_ops.gif",
      },
      {
        descr:
          " To **change one of the op-parameters** first select the op by clicking on it, then you will see the op-settings in the pane on the right. To change one of the number value inputs click and drag up or down.",
        img: "d_change_op_parameter.gif",
      },
      {
        descr:
          " To **access an ops example patch** first select the op, then click **view example patches**.",
        img: "e_view_example_patch.gif",
      },
      {
        title: "Delete Links",
        descr:
          " To **delete a cable** just press the `right mouse button` on one of the connected ports.",
        img: "f_delete_link.gif",
      },
      {
        descr:
          " To **reconnect a cable to another port** press and drag with the `right mouse button`.",
        img: "g_reconnect_link.gif",
      },
      {
        title: "Copy Paste",
        descr:
          " Ops can be duplicated by making a selection with your `left mouse button`, pressing `CMD + c` or `CTRL + c` to copy, followed by `CMD + v` or `CTRL + v` to paste.  ",
        img: "h_copy_paste_op.gif",
      },
      {
        title: "Align Ops",
        descr:
          " To bring some order into your patch you can align ops by making a selection with your `left mouse button` and pressing `a` to **horizontally align** or `SHIFT + a` to **vertically align**.   ",
        img: "i_align_ops.gif",
      },
      {
        descr:
          " To **unlink an op** hold it with the `left mouse button` and shake it.  ",
        img: "j_disconnect_by_shaking.gif",
      },
      {
        descr: " You can also **unlink ops** by selecting them and pressing `x`",
        img: "k_disconnect_with_x_key.gif",
      },
      {
        descr:
          "  Drag a cable to the center of an op to **see suggestions** of fitting ports. if there is only one the link will be connected automatically.",
        img: "l_connect_with_drag_to_center.gif",
      },
      {
        descr:
          " To **add an existing op between two other ops**, click and hold 'left mouse button' and drag the op to the middle of the cable and release.",
        img: "m_add_existing_op_between.gif",
      },
      {
        title: "Duplicating Links",
        descr:
          " You can **duplicate a link** by pressing [alt] and the `right mouse button` and dragging the cable to another port",
        img: "n_duplicate_link.gif",
      },
      {
        title: "Flow Mode",
        descr: " See data and function flow by pressing `f`",
        img: "o_op_flow_with_f_key.gif",
      },
      {
        descr: " Disable ops and its children by pressing `d`",
        img: "p_disable_ops_with_d_key.gif",
      },
      {
        descr: " You can **upload files** by dragging them into the window",
        img: "r_add_file_drag_and_drop.gif",
      },
      {
        descr:
          " access the **command palette** by pressing `CMD + p` or `CTRL + p`. ",
        img: "s_command_palette_ctrl_and_p.gif",
      },
      {
        descr:
          " You can **set a custom title to an op** by clicking the title in the parameter panel (you can also select an op and press `t`)",
        img: "t_change_op_title.gif",
      },
      {
        descr: " organize huge patches by putting ops into subpatches",
        img: "u_create_subpatch.gif",
      },
      {
        descr:
          " to find **documentation and examples for an op**, click on the op and then click the link",
        img: "v_op_documentation_link.gif",
      },
      {
        descr: " set colors for ops for easier identification",
        img: "colormarker.gif",
      },
      {
        descr: " create and link new op by clicking parameter",
        img: "linkparameter.gif",
      },
      {
        descr: " use snap to grid for cleaner looking patches",
        img: "snaptogrid.gif",
      },
      {
        descr:
          " `Right mouse button` click while holding [alt] key and drag a cable from a port or the cable itself, to **copy the connection**.",
        img: "rightclickdrag.gif",
      },

      {
        descr:
          " To move a cable connection to another port, hold `alt` keyboard keys and `right mouse button` while over either end of the cable.",
        img: "right_shift_alt.gif",
      },
      {
        descr:
          " You can drag a cable from an operator port directly to a parameter name in a parameter panel of another op.",
        img: "dragtoport.gif",
      },
      {
        descr:
          " Press `CTRL + f` or `CMD + f` on your keyboard to **find operators in your project by name or by tag** - for example, unconnected or bookmarked.",
        img: "ctrl_f.gif",
      },
      {
        descr:
          " Click `left mouse button` on the patch preview and select the gizmo icon to enable or disable helpers and transforms. **Show All transforms** will show all moveable objects in your scene, click `left mouse button` on the circle to enable the object's gizmo.",
        img: "gizmo.gif",
      },
      {
        descr:
          " To **select DIV elements directly from the patch preview**, hover over your DIV elements while holding `CTRL` or `CMD` on your keyboard and clicking `left mouse button` on the DIV element.",
        img: "inspecthtml.gif",
      },
      {
        descr:
          " You can **jump to a connected operator** in the parameter panel by clicking `left mouse button` on it's name next to the parameter it is connected to.",
        img: "jump_connected_op.gif",
      },
      {
        descr:
          " Quickly **find your sidebar operators** in a patch by clicking `left mouse button` on a sidebar element while holding the `CTRL` or `CMD` key on your keyboard.",
        img: "inspect_sidebar.gif",
      },
      {
        descr:
          " You can **organize** your operators into colorful Area groups by selecting multiple ops and clicking Create Area. Move operators out of an area to separate them, group groups into groups, hold down [alt]to drag Area without ops!",
        img: "area_create.gif",
      },
      {
        descr:
          " You can click `left mouse button` on an output field in any operator's parameter panel to **copy it to your clipboard**. Great for saving arrays or generated outputs.",
        img: "copyoutput.gif",
      },
    ],
  };

  let lastNotifyErr = "";
  let lastTextErr = "";

  let lastNotifyWarn = "";
  let lastTextWarn = "";

  /**
   * configuration object for loading a patch
   * @typedef {Object} NotificationDisplayOptions
   * @hideconstructor
   * @property {Number|Boolean} [timeout=2000] fade out notification after x ms, `false` to disable
   * @property {Boolean} [closeable=false] show closing button on notification
   * @property {Boolean} [force=false] force showing of notification even if last one was the same
   */

  /**
   * notifyError displays an error as a toast-notification
   *
   *
   * @param title
   * @param text
   * @param {NotificationDisplayOptions} options The option object.
   * @example
   * notifyError("error", "something broke",
   * {
   *     "timeout": false,
   *     "closeable": true,
   * });
   */
  function notifyError(title, text, options = {}) {
    const timeout = options.hasOwnProperty("timeout") ? options.timeout : 2000;
    const closeable = options.closeable || false;
    const force = options.force;

    if (!force) {
      if (title === lastNotifyErr && text === lastTextErr) {
        setTimeout(function () {
          lastNotifyErr = "";
          lastTextErr = "";
        }, 1000);
        return;
      }
    }

    lastNotifyErr = title;
    lastTextErr = text;

    const toastId = CABLES.uuid();

    iziToast.error({
      id: toastId,
      position: "bottomRight", // bottomRight, bottomLeft, topRight, topLeft, topCenter, bottomCenter, center
      theme: "dark",
      title: title,
      message: text || "",
      progressBar: false,
      animateInside: false,
      close: closeable,
      timeout: timeout,
    });

    return toastId;
  }

  function notifyWarn(title, text = "", options = {}) {
    const timeout = options.hasOwnProperty("timeout") ? options.timeout : 2000;
    const closeable = options.closeable || false;
    const force = options.hasOwnProperty("force") ? options.force : true;

    if (!force) {
      if (title === lastNotifyWarn && text === lastTextWarn) {
        setTimeout(function () {
          lastNotifyWarn = "";
          lastTextWarn = "";
        }, 1000);
        return;
      }
    }

    lastNotifyWarn = title;
    lastTextWarn = text;

    const toastId = CABLES.uuid();

    iziToast.warning({
      id: toastId,
      position: "bottomRight", // bottomRight, bottomLeft, topRight, topLeft, topCenter, bottomCenter, center
      theme: "dark",
      title: title,
      message: text || "",
      progressBar: false,
      animateInside: false,
      close: closeable,
      timeout: timeout,
    });

    return toastId;
  }

  /**
   * notify displays a toast-notification
   *
   *
   * @param title
   * @param text
   * @param {NotificationDisplayOptions} options The option object.
   * @example
   * notify("update", "cables has been updated",
   * {
   *     "timeout": 1000,
   *     "closeable": false
   * });
   */
  function notify(title, text = "", options = {}) {
    if (Gui$1.gui.Gui.gui.isRemoteClient) return;

    const timeout = options.timeout || 2000;
    const closeable = options.closeable || false;
    options.force || true;

    const toastId = CABLES.uuid();

    iziToast.show({
      id: toastId,
      position: "bottomRight", // bottomRight, bottomLeft, topRight, topLeft, topCenter, bottomCenter, center
      theme: "dark",
      title: title,
      message: text || "",
      progressBar: false,
      animateInside: false,
      close: closeable,
      timeout: timeout,
      buttons: options.buttons || [],
    });
    return toastId;
  }

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  var RANDOM = Math.random;
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * 2x2 Matrix
   * @module mat2
   */

  /**
   * Creates a new identity mat2
   *
   * @returns {mat2} a new 2x2 matrix
   */

  function create$8() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2 initialized with values from an existing matrix
   *
   * @param {mat2} a matrix to clone
   * @returns {mat2} a new 2x2 matrix
   */

  function clone$8(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Copy the values from one mat2 to another
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function copy$8(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set a mat2 to the identity matrix
   *
   * @param {mat2} out the receiving matrix
   * @returns {mat2} out
   */

  function identity$5(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Create a new mat2 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out A new 2x2 matrix
   */

  function fromValues$8(m00, m01, m10, m11) {
    var out = new ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Set the components of a mat2 to the given values
   *
   * @param {mat2} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out
   */

  function set$8(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Transpose the values of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function transpose$2(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
      var a1 = a[1];
      out[1] = a[2];
      out[2] = a1;
    } else {
      out[0] = a[0];
      out[1] = a[2];
      out[2] = a[1];
      out[3] = a[3];
    }

    return out;
  }
  /**
   * Inverts a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function invert$5(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3]; // Calculate the determinant

    var det = a0 * a3 - a2 * a1;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function adjoint$2(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
  }
  /**
   * Calculates the determinant of a mat2
   *
   * @param {mat2} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$3(a) {
    return a[0] * a[3] - a[2] * a[1];
  }
  /**
   * Multiplies two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function multiply$8(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
  }
  /**
   * Rotates a mat2 by the given angle
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function rotate$4(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
  }
  /**
   * Scales the mat2 by the dimensions in the given vec2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to rotate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat2} out
   **/

  function scale$8(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.rotate(dest, dest, rad);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function fromRotation$4(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.scale(dest, dest, vec);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat2} out
   */

  function fromScaling$3(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2
   *
   * @param {mat2} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$8(a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Returns Frobenius norm of a mat2
   *
   * @param {mat2} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$3(a) {
    return Math.hypot(a[0], a[1], a[2], a[3]);
  }
  /**
   * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
   * @param {mat2} L the lower triangular matrix
   * @param {mat2} D the diagonal matrix
   * @param {mat2} U the upper triangular matrix
   * @param {mat2} a the input matrix to factorize
   */

  function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [L, D, U];
  }
  /**
   * Adds two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function add$8(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function subtract$6(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat2} a The first matrix.
   * @param {mat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat2} a The first matrix.
   * @param {mat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$8(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2} out
   */

  function multiplyScalar$3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two mat2's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2} out the receiving vector
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2} out
   */

  function multiplyScalarAndAdd$3(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Alias for {@link mat2.multiply}
   * @function
   */

  var mul$8 = multiply$8;
  /**
   * Alias for {@link mat2.subtract}
   * @function
   */

  var sub$6 = subtract$6;

  var mat2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    LDU: LDU,
    add: add$8,
    adjoint: adjoint$2,
    clone: clone$8,
    copy: copy$8,
    create: create$8,
    determinant: determinant$3,
    equals: equals$8,
    exactEquals: exactEquals$8,
    frob: frob$3,
    fromRotation: fromRotation$4,
    fromScaling: fromScaling$3,
    fromValues: fromValues$8,
    identity: identity$5,
    invert: invert$5,
    mul: mul$8,
    multiply: multiply$8,
    multiplyScalar: multiplyScalar$3,
    multiplyScalarAndAdd: multiplyScalarAndAdd$3,
    rotate: rotate$4,
    scale: scale$8,
    set: set$8,
    str: str$8,
    sub: sub$6,
    subtract: subtract$6,
    transpose: transpose$2
  });

  /**
   * 2x3 Matrix
   * @module mat2d
   *
   * @description
   * A mat2d contains six elements defined as:
   * <pre>
   * [a, b, c,
   *  d, tx, ty]
   * </pre>
   * This is a short form for the 3x3 matrix:
   * <pre>
   * [a, b, 0,
   *  c, d, 0,
   *  tx, ty, 1]
   * </pre>
   * The last column is ignored so the array is shorter and operations are faster.
   */

  /**
   * Creates a new identity mat2d
   *
   * @returns {mat2d} a new 2x3 matrix
   */

  function create$7() {
    var out = new ARRAY_TYPE(6);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[4] = 0;
      out[5] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2d initialized with values from an existing matrix
   *
   * @param {mat2d} a matrix to clone
   * @returns {mat2d} a new 2x3 matrix
   */

  function clone$7(a) {
    var out = new ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Copy the values from one mat2d to another
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the source matrix
   * @returns {mat2d} out
   */

  function copy$7(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Set a mat2d to the identity matrix
   *
   * @param {mat2d} out the receiving matrix
   * @returns {mat2d} out
   */

  function identity$4(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Create a new mat2d with the given values
   *
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} A new mat2d
   */

  function fromValues$7(a, b, c, d, tx, ty) {
    var out = new ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Set the components of a mat2d to the given values
   *
   * @param {mat2d} out the receiving matrix
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} out
   */

  function set$7(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Inverts a mat2d
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the source matrix
   * @returns {mat2d} out
   */

  function invert$4(out, a) {
    var aa = a[0],
        ab = a[1],
        ac = a[2],
        ad = a[3];
    var atx = a[4],
        aty = a[5];
    var det = aa * ad - ab * ac;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
  }
  /**
   * Calculates the determinant of a mat2d
   *
   * @param {mat2d} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$2(a) {
    return a[0] * a[3] - a[1] * a[2];
  }
  /**
   * Multiplies two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function multiply$7(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
  }
  /**
   * Rotates a mat2d by the given angle
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function rotate$3(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Scales the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to translate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat2d} out
   **/

  function scale$7(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Translates the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to translate
   * @param {vec2} v the vec2 to translate the matrix by
   * @returns {mat2d} out
   **/

  function translate$3(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.rotate(dest, dest, rad);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function fromRotation$3(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.scale(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat2d} out
   */

  function fromScaling$2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.translate(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {vec2} v Translation vector
   * @returns {mat2d} out
   */

  function fromTranslation$3(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2d
   *
   * @param {mat2d} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$7(a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
  }
  /**
   * Returns Frobenius norm of a mat2d
   *
   * @param {mat2d} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$2(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
  }
  /**
   * Adds two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function add$7(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function subtract$5(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2d} out
   */

  function multiplyScalar$2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
  }
  /**
   * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2d} out the receiving vector
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2d} out
   */

  function multiplyScalarAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat2d} a The first matrix.
   * @param {mat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$7(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat2d} a The first matrix.
   * @param {mat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$7(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
  }
  /**
   * Alias for {@link mat2d.multiply}
   * @function
   */

  var mul$7 = multiply$7;
  /**
   * Alias for {@link mat2d.subtract}
   * @function
   */

  var sub$5 = subtract$5;

  var mat2d = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$7,
    clone: clone$7,
    copy: copy$7,
    create: create$7,
    determinant: determinant$2,
    equals: equals$7,
    exactEquals: exactEquals$7,
    frob: frob$2,
    fromRotation: fromRotation$3,
    fromScaling: fromScaling$2,
    fromTranslation: fromTranslation$3,
    fromValues: fromValues$7,
    identity: identity$4,
    invert: invert$4,
    mul: mul$7,
    multiply: multiply$7,
    multiplyScalar: multiplyScalar$2,
    multiplyScalarAndAdd: multiplyScalarAndAdd$2,
    rotate: rotate$3,
    scale: scale$7,
    set: set$7,
    str: str$7,
    sub: sub$5,
    subtract: subtract$5,
    translate: translate$3
  });

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create$6() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {mat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */

  function fromMat4$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  /**
   * Creates a new mat3 initialized with values from an existing matrix
   *
   * @param {mat3} a matrix to clone
   * @returns {mat3} a new 3x3 matrix
   */

  function clone$6(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Copy the values from one mat3 to another
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function copy$6(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Create a new mat3 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} A new mat3
   */

  function fromValues$6(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set the components of a mat3 to the given values
   *
   * @param {mat3} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} out
   */

  function set$6(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set a mat3 to the identity matrix
   *
   * @param {mat3} out the receiving matrix
   * @returns {mat3} out
   */

  function identity$3(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function transpose$1(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }

    return out;
  }
  /**
   * Inverts a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function invert$3(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function adjoint$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  /**
   * Calculates the determinant of a mat3
   *
   * @param {mat3} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$1(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function multiply$6(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  /**
   * Translate a mat3 by the given vector
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to translate
   * @param {vec2} v vector to translate by
   * @returns {mat3} out
   */

  function translate$2(out, a, v) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        x = v[0],
        y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  /**
   * Rotates a mat3 by the given angle
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function rotate$2(out, a, rad) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  /**
   * Scales the mat3 by the dimensions in the given vec2
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to rotate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat3} out
   **/

  function scale$6(out, a, v) {
    var x = v[0],
        y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {vec2} v Translation vector
   * @returns {mat3} out
   */

  function fromTranslation$2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function fromRotation$2(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat3} out
   */

  function fromScaling$1(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the values from a mat2d into a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat2d} a the matrix to copy
   * @returns {mat3} out
   **/

  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  /**
  * Calculates a 3x3 matrix from the given quaternion
  *
  * @param {mat3} out mat3 receiving operation result
  * @param {quat} q Quaternion to create matrix from
  *
  * @returns {mat3} out
  */

  function fromQuat$1(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  /**
  * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
  *
  * @param {mat3} out mat3 receiving operation result
  * @param {mat4} a Mat4 to derive the normal matrix from
  *
  * @returns {mat3} out
  */

  function normalFromMat4(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  /**
   * Generates a 2D projection matrix with the given bounds
   *
   * @param {mat3} out mat3 frustum matrix will be written into
   * @param {number} width Width of your gl context
   * @param {number} height Height of gl context
   * @returns {mat3} out
   */

  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat3
   *
   * @param {mat3} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$6(a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
  }
  /**
   * Returns Frobenius norm of a mat3
   *
   * @param {mat3} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$1(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  /**
   * Adds two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function add$6(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function subtract$4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat3} out
   */

  function multiplyScalar$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  /**
   * Adds two mat3's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat3} out the receiving vector
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat3} out
   */

  function multiplyScalarAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat3} a The first matrix.
   * @param {mat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$6(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat3} a The first matrix.
   * @param {mat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$6(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7],
        a8 = a[8];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
  }
  /**
   * Alias for {@link mat3.multiply}
   * @function
   */

  var mul$6 = multiply$6;
  /**
   * Alias for {@link mat3.subtract}
   * @function
   */

  var sub$4 = subtract$4;

  var mat3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$6,
    adjoint: adjoint$1,
    clone: clone$6,
    copy: copy$6,
    create: create$6,
    determinant: determinant$1,
    equals: equals$6,
    exactEquals: exactEquals$6,
    frob: frob$1,
    fromMat2d: fromMat2d,
    fromMat4: fromMat4$1,
    fromQuat: fromQuat$1,
    fromRotation: fromRotation$2,
    fromScaling: fromScaling$1,
    fromTranslation: fromTranslation$2,
    fromValues: fromValues$6,
    identity: identity$3,
    invert: invert$3,
    mul: mul$6,
    multiply: multiply$6,
    multiplyScalar: multiplyScalar$1,
    multiplyScalarAndAdd: multiplyScalarAndAdd$1,
    normalFromMat4: normalFromMat4,
    projection: projection,
    rotate: rotate$2,
    scale: scale$6,
    set: set$6,
    str: str$6,
    sub: sub$4,
    subtract: subtract$4,
    translate: translate$2,
    transpose: transpose$1
  });

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$5() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {mat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */

  function clone$5(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function copy$5(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */

  function fromValues$5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */

  function set$5(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity$2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function invert$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function adjoint(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  /**
   * Calculates the determinant of a mat4
   *
   * @param {mat4} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function multiply$5(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to translate
   * @param {vec3} v vector to translate by
   * @returns {mat4} out
   */

  function translate$1(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to scale
   * @param {vec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale$5(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function rotate$1(out, a, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX$3(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateY$3(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateZ$3(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation$1(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation$1(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */

  function fromRotationTranslation$1(out, q, v) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 from a dual quat.
   *
   * @param {mat4} out Matrix
   * @param {quat2} a Dual Quaternion
   * @returns {mat4} mat4 receiving operation result
   */

  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }

    fromRotationTranslation$1(out, a, translation);
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation$1(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {mat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @param {vec3} o The origin vector around which to scale and rotate
   * @returns {mat4} out
   */

  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */

  function fromQuat(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }

    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity$2(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function targetTo(out, eye, target, up) {
    var eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2];
    var z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }

    var x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat4
   *
   * @param {mat4} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$5(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
  }
  /**
   * Returns Frobenius norm of a mat4
   *
   * @param {mat4} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob(a) {
    return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
  }
  /**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function add$5(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function subtract$3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */

  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat4} out the receiving vector
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat4} out
   */

  function multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat4} a The first matrix.
   * @param {mat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$5(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat4} a The first matrix.
   * @param {mat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$5(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var a8 = a[8],
        a9 = a[9],
        a10 = a[10],
        a11 = a[11];
    var a12 = a[12],
        a13 = a[13],
        a14 = a[14],
        a15 = a[15];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    var b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    var b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11];
    var b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Alias for {@link mat4.multiply}
   * @function
   */

  var mul$5 = multiply$5;
  /**
   * Alias for {@link mat4.subtract}
   * @function
   */

  var sub$3 = subtract$3;

  var mat4$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$5,
    adjoint: adjoint,
    clone: clone$5,
    copy: copy$5,
    create: create$5,
    determinant: determinant,
    equals: equals$5,
    exactEquals: exactEquals$5,
    frob: frob,
    fromQuat: fromQuat,
    fromQuat2: fromQuat2,
    fromRotation: fromRotation$1,
    fromRotationTranslation: fromRotationTranslation$1,
    fromRotationTranslationScale: fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
    fromScaling: fromScaling,
    fromTranslation: fromTranslation$1,
    fromValues: fromValues$5,
    fromXRotation: fromXRotation,
    fromYRotation: fromYRotation,
    fromZRotation: fromZRotation,
    frustum: frustum,
    getRotation: getRotation,
    getScaling: getScaling,
    getTranslation: getTranslation$1,
    identity: identity$2,
    invert: invert$2,
    lookAt: lookAt,
    mul: mul$5,
    multiply: multiply$5,
    multiplyScalar: multiplyScalar,
    multiplyScalarAndAdd: multiplyScalarAndAdd,
    ortho: ortho,
    perspective: perspective,
    perspectiveFromFieldOfView: perspectiveFromFieldOfView,
    rotate: rotate$1,
    rotateX: rotateX$3,
    rotateY: rotateY$3,
    rotateZ: rotateZ$3,
    scale: scale$5,
    set: set$5,
    str: str$5,
    sub: sub$3,
    subtract: subtract$3,
    targetTo: targetTo,
    translate: translate$1,
    transpose: transpose
  });

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$4() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   *
   * @param {vec3} a vector to clone
   * @returns {vec3} a new 3D vector
   */

  function clone$4(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {vec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$4(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues$4(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Copy the values from one vec3 to another
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the source vector
   * @returns {vec3} out
   */

  function copy$4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set$4(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function add$4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function subtract$2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Multiplies two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function multiply$4(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Divides two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function divide$2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  /**
   * Math.ceil the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to ceil
   * @returns {vec3} out
   */

  function ceil$2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  /**
   * Math.floor the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to floor
   * @returns {vec3} out
   */

  function floor$2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  /**
   * Returns the minimum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function min$2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  /**
   * Returns the maximum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function max$2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  /**
   * Math.round the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to round
   * @returns {vec3} out
   */

  function round$2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale$4(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */

  function scaleAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Calculates the squared length of a vec3
   *
   * @param {vec3} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$4(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Negates the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to negate
   * @returns {vec3} out
   */

  function negate$2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to invert
   * @returns {vec3} out
   */

  function inverse$2(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize$4(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function cross$2(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function lerp$4(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Performs a hermite interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {vec3} c the third operand
   * @param {vec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Performs a bezier interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {vec3} c the third operand
   * @param {vec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec3} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec3} out
   */

  function random$3(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    var z = RANDOM() * 2.0 - 1.0;
    var zScale = Math.sqrt(1.0 - z * z) * scale;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4$2(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */

  function transformMat3$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {quat} q quaternion to transform with
   * @returns {vec3} out
   */

  function transformQuat$1(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3];
    var x = a[0],
        y = a[1],
        z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);

    var uvx = qy * z - qz * y,
        uvy = qz * x - qx * z,
        uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

    var uuvx = qy * uvz - qz * uvy,
        uuvy = qz * uvx - qx * uvz,
        uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);

    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateX$2(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateY$2(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateZ$2(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2]; //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Get the angle between two 3D vectors
   * @param {vec3} a The first operand
   * @param {vec3} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle$1(a, b) {
    var tempA = fromValues$4(a[0], a[1], a[2]);
    var tempB = fromValues$4(b[0], b[1], b[2]);
    normalize$4(tempA, tempA);
    normalize$4(tempB, tempB);
    var cosine = dot$4(tempA, tempB);

    if (cosine > 1.0) {
      return 0;
    } else if (cosine < -1) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  /**
   * Set the components of a vec3 to zero
   *
   * @param {vec3} out the receiving vector
   * @returns {vec3} out
   */

  function zero$2(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec3} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$4(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {vec3} a The first vector.
   * @param {vec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$4(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec3} a The first vector.
   * @param {vec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$4(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  }
  /**
   * Alias for {@link vec3.subtract}
   * @function
   */

  var sub$2 = subtract$2;
  /**
   * Alias for {@link vec3.multiply}
   * @function
   */

  var mul$4 = multiply$4;
  /**
   * Alias for {@link vec3.divide}
   * @function
   */

  var div$2 = divide$2;
  /**
   * Alias for {@link vec3.distance}
   * @function
   */

  var dist$2 = distance$2;
  /**
   * Alias for {@link vec3.squaredDistance}
   * @function
   */

  var sqrDist$2 = squaredDistance$2;
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len$4 = length$4;
  /**
   * Alias for {@link vec3.squaredLength}
   * @function
   */

  var sqrLen$4 = squaredLength$4;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$2 = function () {
    var vec = create$4();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  }();

  var vec3$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$4,
    angle: angle$1,
    bezier: bezier,
    ceil: ceil$2,
    clone: clone$4,
    copy: copy$4,
    create: create$4,
    cross: cross$2,
    dist: dist$2,
    distance: distance$2,
    div: div$2,
    divide: divide$2,
    dot: dot$4,
    equals: equals$4,
    exactEquals: exactEquals$4,
    floor: floor$2,
    forEach: forEach$2,
    fromValues: fromValues$4,
    hermite: hermite,
    inverse: inverse$2,
    len: len$4,
    length: length$4,
    lerp: lerp$4,
    max: max$2,
    min: min$2,
    mul: mul$4,
    multiply: multiply$4,
    negate: negate$2,
    normalize: normalize$4,
    random: random$3,
    rotateX: rotateX$2,
    rotateY: rotateY$2,
    rotateZ: rotateZ$2,
    round: round$2,
    scale: scale$4,
    scaleAndAdd: scaleAndAdd$2,
    set: set$4,
    sqrDist: sqrDist$2,
    sqrLen: sqrLen$4,
    squaredDistance: squaredDistance$2,
    squaredLength: squaredLength$4,
    str: str$4,
    sub: sub$2,
    subtract: subtract$2,
    transformMat3: transformMat3$1,
    transformMat4: transformMat4$2,
    transformQuat: transformQuat$1,
    zero: zero$2
  });

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$3() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec4 initialized with values from an existing vector
   *
   * @param {vec4} a vector to clone
   * @returns {vec4} a new 4D vector
   */

  function clone$3(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a new vec4 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} a new 4D vector
   */

  function fromValues$3(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Copy the values from one vec4 to another
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the source vector
   * @returns {vec4} out
   */

  function copy$3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to the given values
   *
   * @param {vec4} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} out
   */

  function set$3(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Adds two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function add$3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Multiplies two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function multiply$3(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  /**
   * Divides two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function divide$1(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  /**
   * Math.ceil the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to ceil
   * @returns {vec4} out
   */

  function ceil$1(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
  }
  /**
   * Math.floor the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to floor
   * @returns {vec4} out
   */

  function floor$1(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
  }
  /**
   * Returns the minimum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function min$1(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
  }
  /**
   * Returns the maximum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function max$1(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
  }
  /**
   * Math.round the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to round
   * @returns {vec4} out
   */

  function round$1(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
  }
  /**
   * Scales a vec4 by a scalar number
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec4} out
   */

  function scale$3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two vec4's after scaling the second operand by a scalar value
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec4} out
   */

  function scaleAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
  }
  /**
   * Calculates the squared euclidian distance between two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Calculates the length of a vec4
   *
   * @param {vec4} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$3(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
  }
  /**
   * Calculates the squared length of a vec4
   *
   * @param {vec4} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$3(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Negates the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to negate
   * @returns {vec4} out
   */

  function negate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to invert
   * @returns {vec4} out
   */

  function inverse$1(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$3(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$3(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  /**
   * Returns the cross-product of three vectors in a 4-dimensional space
   *
   * @param {vec4} result the receiving vector
   * @param {vec4} U the first vector
   * @param {vec4} V the second vector
   * @param {vec4} W the third vector
   * @returns {vec4} result
   */

  function cross$1(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0],
        B = v[0] * w[2] - v[2] * w[0],
        C = v[0] * w[3] - v[3] * w[0],
        D = v[1] * w[2] - v[2] * w[1],
        E = v[1] * w[3] - v[3] * w[1],
        F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec4} out
   */

  function lerp$3(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec4} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec4} out
   */

  function random$2(out, scale) {
    scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;

    var v1, v2, v3, v4;
    var s1, s2;

    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);

    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);

    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale * v1;
    out[1] = scale * v2;
    out[2] = scale * v3 * d;
    out[3] = scale * v4 * d;
    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Transforms the vec4 with a quat
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {quat} q quaternion to transform with
   * @returns {vec4} out
   */

  function transformQuat(out, a, q) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3]; // calculate quat * vec

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to zero
   *
   * @param {vec4} out the receiving vector
   * @returns {vec4} out
   */

  function zero$1(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec4} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$3(a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {vec4} a The first vector.
   * @param {vec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec4} a The first vector.
   * @param {vec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$3(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Alias for {@link vec4.subtract}
   * @function
   */

  var sub$1 = subtract$1;
  /**
   * Alias for {@link vec4.multiply}
   * @function
   */

  var mul$3 = multiply$3;
  /**
   * Alias for {@link vec4.divide}
   * @function
   */

  var div$1 = divide$1;
  /**
   * Alias for {@link vec4.distance}
   * @function
   */

  var dist$1 = distance$1;
  /**
   * Alias for {@link vec4.squaredDistance}
   * @function
   */

  var sqrDist$1 = squaredDistance$1;
  /**
   * Alias for {@link vec4.length}
   * @function
   */

  var len$3 = length$3;
  /**
   * Alias for {@link vec4.squaredLength}
   * @function
   */

  var sqrLen$3 = squaredLength$3;
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$3();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  var vec4$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$3,
    ceil: ceil$1,
    clone: clone$3,
    copy: copy$3,
    create: create$3,
    cross: cross$1,
    dist: dist$1,
    distance: distance$1,
    div: div$1,
    divide: divide$1,
    dot: dot$3,
    equals: equals$3,
    exactEquals: exactEquals$3,
    floor: floor$1,
    forEach: forEach$1,
    fromValues: fromValues$3,
    inverse: inverse$1,
    len: len$3,
    length: length$3,
    lerp: lerp$3,
    max: max$1,
    min: min$1,
    mul: mul$3,
    multiply: multiply$3,
    negate: negate$1,
    normalize: normalize$3,
    random: random$2,
    round: round$1,
    scale: scale$3,
    scaleAndAdd: scaleAndAdd$1,
    set: set$3,
    sqrDist: sqrDist$1,
    sqrLen: sqrLen$3,
    squaredDistance: squaredDistance$1,
    squaredLength: squaredLength$3,
    str: str$3,
    sub: sub$1,
    subtract: subtract$1,
    transformMat4: transformMat4$1,
    transformQuat: transformQuat,
    zero: zero$1
  });

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$2() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Set a quat to the identity quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function identity$1(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {vec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {vec3} out_axis  Vector receiving the axis of rotation
   * @param  {quat} q     Quaternion to be decomposed
   * @return {Number}     Angle, in radians, of the rotation
   */

  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);

    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      // If s is zero, return any axis (no rotation - axis does not matter)
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }

    return rad;
  }
  /**
   * Gets the angular distance between two unit quaternions
   *
   * @param  {quat} a     Origin unit quaternion 
   * @param  {quat} b     Destination unit quaternion
   * @return {Number}     Angle, in radians, between the two quaternions
   */

  function getAngle(a, b) {
    var dotproduct = dot$2(a, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  /**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {quat} out
   */

  function multiply$2(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the X axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateX$1(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Y axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateY$1(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var by = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Z axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateZ$1(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bz = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  /**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate W component of
   * @returns {quat} out
   */

  function calculateW(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
  }
  /**
   * Calculate the exponential of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate the exponential of
   * @returns {quat} out
   */

  function exp(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var et = Math.exp(w);
    var s = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x * s;
    out[1] = y * s;
    out[2] = z * s;
    out[3] = et * Math.cos(r);
    return out;
  }
  /**
   * Calculate the natural logarithm of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate the exponential of
   * @returns {quat} out
   */

  function ln(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x * t;
    out[1] = y * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
    return out;
  }
  /**
   * Calculate the scalar power of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate the exponential of
   * @param {Number} b amount to scale the quaternion by
   * @returns {quat} out
   */

  function pow(out, a, b) {
    ln(out, a);
    scale$2(out, out, b);
    exp(out, out);
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Generates a random unit quaternion
   * 
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function random$1(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
    return out;
  }
  /**
   * Calculates the inverse of a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate inverse of
   * @returns {quat} out
   */

  function invert$1(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate conjugate of
   * @returns {quat} out
   */

  function conjugate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {mat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */

  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  /**
   * Returns a string representation of a quatenion
   *
   * @param {quat} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$2(a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {quat} a quaternion to clone
   * @returns {quat} a new quaternion
   * @function
   */

  var clone$2 = clone$3;
  /**
   * Creates a new quat initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} a new quaternion
   * @function
   */

  var fromValues$2 = fromValues$3;
  /**
   * Copy the values from one quat to another
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the source quaternion
   * @returns {quat} out
   * @function
   */

  var copy$2 = copy$3;
  /**
   * Set the components of a quat to the given values
   *
   * @param {quat} out the receiving quaternion
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} out
   * @function
   */

  var set$2 = set$3;
  /**
   * Adds two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {quat} out
   * @function
   */

  var add$2 = add$3;
  /**
   * Alias for {@link quat.multiply}
   * @function
   */

  var mul$2 = multiply$2;
  /**
   * Scales a quat by a scalar number
   *
   * @param {quat} out the receiving vector
   * @param {quat} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {quat} out
   * @function
   */

  var scale$2 = scale$3;
  /**
   * Calculates the dot product of two quat's
   *
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$2 = dot$3;
  /**
   * Performs a linear interpolation between two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   * @function
   */

  var lerp$2 = lerp$3;
  /**
   * Calculates the length of a quat
   *
   * @param {quat} a vector to calculate length of
   * @returns {Number} length of a
   */

  var length$2 = length$3;
  /**
   * Alias for {@link quat.length}
   * @function
   */

  var len$2 = length$2;
  /**
   * Calculates the squared length of a quat
   *
   * @param {quat} a vector to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$2 = squaredLength$3;
  /**
   * Alias for {@link quat.squaredLength}
   * @function
   */

  var sqrLen$2 = squaredLength$2;
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$3;
  /**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {quat} a The first quaternion.
   * @param {quat} b The second quaternion.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var exactEquals$2 = exactEquals$3;
  /**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   *
   * @param {quat} a The first vector.
   * @param {quat} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var equals$2 = equals$3;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {vec3} a the initial vector
   * @param {vec3} b the destination vector
   * @returns {quat} out
   */

  var rotationTo = function () {
    var tmpvec3 = create$4();
    var xUnitVec3 = fromValues$4(1, 0, 0);
    var yUnitVec3 = fromValues$4(0, 1, 0);
    return function (out, a, b) {
      var dot = dot$4(a, b);

      if (dot < -0.999999) {
        cross$2(tmpvec3, xUnitVec3, a);
        if (len$4(tmpvec3) < 0.000001) cross$2(tmpvec3, yUnitVec3, a);
        normalize$4(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross$2(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot;
        return normalize$2(out, out);
      }
    };
  }();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {quat} c the third operand
   * @param {quat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  var sqlerp = function () {
    var temp1 = create$2();
    var temp2 = create$2();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {vec3} view  the vector representing the viewing direction
   * @param {vec3} right the vector representing the local "right" direction
   * @param {vec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  var setAxes = function () {
    var matr = create$6();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  }();

  var quat = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$2,
    calculateW: calculateW,
    clone: clone$2,
    conjugate: conjugate$1,
    copy: copy$2,
    create: create$2,
    dot: dot$2,
    equals: equals$2,
    exactEquals: exactEquals$2,
    exp: exp,
    fromEuler: fromEuler,
    fromMat3: fromMat3,
    fromValues: fromValues$2,
    getAngle: getAngle,
    getAxisAngle: getAxisAngle,
    identity: identity$1,
    invert: invert$1,
    len: len$2,
    length: length$2,
    lerp: lerp$2,
    ln: ln,
    mul: mul$2,
    multiply: multiply$2,
    normalize: normalize$2,
    pow: pow,
    random: random$1,
    rotateX: rotateX$1,
    rotateY: rotateY$1,
    rotateZ: rotateZ$1,
    rotationTo: rotationTo,
    scale: scale$2,
    set: set$2,
    setAxes: setAxes,
    setAxisAngle: setAxisAngle,
    slerp: slerp,
    sqlerp: sqlerp,
    sqrLen: sqrLen$2,
    squaredLength: squaredLength$2,
    str: str$2
  });

  /**
   * Dual Quaternion<br>
   * Format: [real, dual]<br>
   * Quaternion format: XYZW<br>
   * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
   * @module quat2
   */

  /**
   * Creates a new identity dual quat
   *
   * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
   */

  function create$1() {
    var dq = new ARRAY_TYPE(8);

    if (ARRAY_TYPE != Float32Array) {
      dq[0] = 0;
      dq[1] = 0;
      dq[2] = 0;
      dq[4] = 0;
      dq[5] = 0;
      dq[6] = 0;
      dq[7] = 0;
    }

    dq[3] = 1;
    return dq;
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {quat2} a dual quaternion to clone
   * @returns {quat2} new dual quaternion
   * @function
   */

  function clone$1(a) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
  }
  /**
   * Creates a new dual quat initialized with the given values
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromValues$1(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
  }
  /**
   * Creates a new dual quat from the given values (quat and translation)
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component (translation)
   * @param {Number} y2 Y component (translation)
   * @param {Number} z2 Z component (translation)
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5,
        ay = y2 * 0.5,
        az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
  }
  /**
   * Creates a dual quat from a quaternion and a translation
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {quat} q a normalized quaternion
   * @param {vec3} t tranlation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotationTranslation(out, q, t) {
    var ax = t[0] * 0.5,
        ay = t[1] * 0.5,
        az = t[2] * 0.5,
        bx = q[0],
        by = q[1],
        bz = q[2],
        bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Creates a dual quat from a translation
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {vec3} t translation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromTranslation(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a dual quat from a quaternion
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {quat} q the quaternion
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotation(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a new dual quat from a matrix (4x4)
   *
   * @param {quat2} out the dual quaternion
   * @param {mat4} a the matrix
   * @returns {quat2} dual quat receiving operation result
   * @function
   */

  function fromMat4(out, a) {
    //TODO Optimize this
    var outer = create$2();
    getRotation(outer, a);
    var t = new ARRAY_TYPE(3);
    getTranslation$1(t, a);
    fromRotationTranslation(out, outer, t);
    return out;
  }
  /**
   * Copy the values from one dual quat to another
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the source dual quaternion
   * @returns {quat2} out
   * @function
   */

  function copy$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Set a dual quat to the identity dual quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @returns {quat2} out
   */

  function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Set the components of a dual quat to the given values
   *
   * @param {quat2} out the receiving quaternion
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} out
   * @function
   */

  function set$1(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
  }
  /**
   * Gets the real part of a dual quat
   * @param  {quat} out real part
   * @param  {quat2} a Dual Quaternion
   * @return {quat} real part
   */

  var getReal = copy$2;
  /**
   * Gets the dual part of a dual quat
   * @param  {quat} out dual part
   * @param  {quat2} a Dual Quaternion
   * @return {quat} dual part
   */

  function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
  }
  /**
   * Set the real component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat} q a quaternion representing the real part
   * @returns {quat2} out
   * @function
   */

  var setReal = copy$2;
  /**
   * Set the dual component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat} q a quaternion representing the dual part
   * @returns {quat2} out
   * @function
   */

  function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
  }
  /**
   * Gets the translation of a normalized dual quat
   * @param  {vec3} out translation
   * @param  {quat2} a Dual Quaternion to be decomposed
   * @return {vec3} translation
   */

  function getTranslation(out, a) {
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
  }
  /**
   * Translates a dual quat by the given vector
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to translate
   * @param {vec3} v vector to translate by
   * @returns {quat2} out
   */

  function translate(out, a, v) {
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3],
        bx1 = v[0] * 0.5,
        by1 = v[1] * 0.5,
        bz1 = v[2] * 0.5,
        ax2 = a[4],
        ay2 = a[5],
        az2 = a[6],
        aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
  }
  /**
   * Rotates a dual quat around the X axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateX(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateX$1(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Y axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateY(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateY$1(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Z axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateZ(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateZ$1(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (a * q)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {quat} q quaternion to rotate by
   * @returns {quat2} out
   */

  function rotateByQuatAppend(out, a, q) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (q * a)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat} q quaternion to rotate by
   * @param {quat2} a the dual quaternion to rotate
   * @returns {quat2} out
   */

  function rotateByQuatPrepend(out, q, a) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        bx = a[0],
        by = a[1],
        bz = a[2],
        bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
  }
  /**
   * Rotates a dual quat around a given axis. Does the normalisation automatically
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {vec3} axis the axis to rotate around
   * @param {Number} rad how far the rotation should be
   * @returns {quat2} out
   */

  function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < EPSILON) {
      return copy$1(out, a);
    }

    var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Adds two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {quat2} out
   * @function
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
  }
  /**
   * Multiplies two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {quat2} out
   */

  function multiply$1(out, a, b) {
    var ax0 = a[0],
        ay0 = a[1],
        az0 = a[2],
        aw0 = a[3],
        bx1 = b[4],
        by1 = b[5],
        bz1 = b[6],
        bw1 = b[7],
        ax1 = a[4],
        ay1 = a[5],
        az1 = a[6],
        aw1 = a[7],
        bx0 = b[0],
        by0 = b[1],
        bz0 = b[2],
        bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
  }
  /**
   * Alias for {@link quat2.multiply}
   * @function
   */

  var mul$1 = multiply$1;
  /**
   * Scales a dual quat by a scalar number
   *
   * @param {quat2} out the receiving dual quat
   * @param {quat2} a the dual quat to scale
   * @param {Number} b amount to scale the dual quat by
   * @returns {quat2} out
   * @function
   */

  function scale$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
  }
  /**
   * Calculates the dot product of two dual quat's (The dot product of the real parts)
   *
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$1 = dot$2;
  /**
   * Performs a linear interpolation between two dual quats's
   * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
   *
   * @param {quat2} out the receiving dual quat
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat2} out
   */

  function lerp$1(out, a, b, t) {
    var mt = 1 - t;
    if (dot$1(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
  }
  /**
   * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a dual quat to calculate inverse of
   * @returns {quat2} out
   */

  function invert(out, a) {
    var sqlen = squaredLength$1(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
  }
  /**
   * Calculates the conjugate of a dual quat
   * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat2} a quat to calculate conjugate of
   * @returns {quat2} out
   */

  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Calculates the length of a dual quat
   *
   * @param {quat2} a dual quat to calculate length of
   * @returns {Number} length of a
   * @function
   */

  var length$1 = length$2;
  /**
   * Alias for {@link quat2.length}
   * @function
   */

  var len$1 = length$1;
  /**
   * Calculates the squared length of a dual quat
   *
   * @param {quat2} a dual quat to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$1 = squaredLength$2;
  /**
   * Alias for {@link quat2.squaredLength}
   * @function
   */

  var sqrLen$1 = squaredLength$1;
  /**
   * Normalize a dual quat
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a dual quaternion to normalize
   * @returns {quat2} out
   * @function
   */

  function normalize$1(out, a) {
    var magnitude = squaredLength$1(a);

    if (magnitude > 0) {
      magnitude = Math.sqrt(magnitude);
      var a0 = a[0] / magnitude;
      var a1 = a[1] / magnitude;
      var a2 = a[2] / magnitude;
      var a3 = a[3] / magnitude;
      var b0 = a[4];
      var b1 = a[5];
      var b2 = a[6];
      var b3 = a[7];
      var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
      out[0] = a0;
      out[1] = a1;
      out[2] = a2;
      out[3] = a3;
      out[4] = (b0 - a0 * a_dot_b) / magnitude;
      out[5] = (b1 - a1 * a_dot_b) / magnitude;
      out[6] = (b2 - a2 * a_dot_b) / magnitude;
      out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }

    return out;
  }
  /**
   * Returns a string representation of a dual quatenion
   *
   * @param {quat2} a dual quaternion to represent as a string
   * @returns {String} string representation of the dual quat
   */

  function str$1(a) {
    return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
  }
  /**
   * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {quat2} a the first dual quaternion.
   * @param {quat2} b the second dual quaternion.
   * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
   */

  function exactEquals$1(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
  }
  /**
   * Returns whether or not the dual quaternions have approximately the same elements in the same position.
   *
   * @param {quat2} a the first dual quat.
   * @param {quat2} b the second dual quat.
   * @returns {Boolean} true if the dual quats are equal, false otherwise.
   */

  function equals$1(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
  }

  var quat2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$1,
    clone: clone$1,
    conjugate: conjugate,
    copy: copy$1,
    create: create$1,
    dot: dot$1,
    equals: equals$1,
    exactEquals: exactEquals$1,
    fromMat4: fromMat4,
    fromRotation: fromRotation,
    fromRotationTranslation: fromRotationTranslation,
    fromRotationTranslationValues: fromRotationTranslationValues,
    fromTranslation: fromTranslation,
    fromValues: fromValues$1,
    getDual: getDual,
    getReal: getReal,
    getTranslation: getTranslation,
    identity: identity,
    invert: invert,
    len: len$1,
    length: length$1,
    lerp: lerp$1,
    mul: mul$1,
    multiply: multiply$1,
    normalize: normalize$1,
    rotateAroundAxis: rotateAroundAxis,
    rotateByQuatAppend: rotateByQuatAppend,
    rotateByQuatPrepend: rotateByQuatPrepend,
    rotateX: rotateX,
    rotateY: rotateY,
    rotateZ: rotateZ,
    scale: scale$1,
    set: set$1,
    setDual: setDual,
    setReal: setReal,
    sqrLen: sqrLen$1,
    squaredLength: squaredLength$1,
    str: str$1,
    translate: translate
  });

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec2 initialized with values from an existing vector
   *
   * @param {vec2} a vector to clone
   * @returns {vec2} a new 2D vector
   */

  function clone(a) {
    var out = new ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Creates a new vec2 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} a new 2D vector
   */

  function fromValues(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Copy the values from one vec2 to another
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the source vector
   * @returns {vec2} out
   */

  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Set the components of a vec2 to the given values
   *
   * @param {vec2} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} out
   */

  function set(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Adds two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  /**
   * Multiplies two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  /**
   * Divides two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  /**
   * Math.ceil the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to ceil
   * @returns {vec2} out
   */

  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
  }
  /**
   * Math.floor the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to floor
   * @returns {vec2} out
   */

  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
  }
  /**
   * Returns the minimum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  /**
   * Returns the maximum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  /**
   * Math.round the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to round
   * @returns {vec2} out
   */

  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
  }
  /**
   * Scales a vec2 by a scalar number
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec2} out
   */

  function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  /**
   * Adds two vec2's after scaling the second operand by a scalar value
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec2} out
   */

  function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  /**
   * Calculates the squared euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x * x + y * y;
  }
  /**
   * Calculates the length of a vec2
   *
   * @param {vec2} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0],
        y = a[1];
    return Math.hypot(x, y);
  }
  /**
   * Calculates the squared length of a vec2
   *
   * @param {vec2} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength(a) {
    var x = a[0],
        y = a[1];
    return x * x + y * y;
  }
  /**
   * Negates the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to negate
   * @returns {vec2} out
   */

  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to invert
   * @returns {vec2} out
   */

  function inverse(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
  }
  /**
   * Normalize a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to normalize
   * @returns {vec2} out
   */

  function normalize(out, a) {
    var x = a[0],
        y = a[1];
    var len = x * x + y * y;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  /**
   * Computes the cross product of two vec2's
   * Note that the cross product must by definition produce a 3D vector
   *
   * @param {vec3} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec3} out
   */

  function cross(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec2} out
   */

  function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec2} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec2} out
   */

  function random(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat2} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2d
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat2d} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2d(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  /**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat3} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  /**
   * Transforms the vec2 with a mat4
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  /**
   * Rotate a 2D vector
   * @param {vec2} out The receiving vec2
   * @param {vec2} a The vec2 point to rotate
   * @param {vec2} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec2} out
   */

  function rotate(out, a, b, c) {
    //Translate point to the origin
    var p0 = a[0] - b[0],
        p1 = a[1] - b[1],
        sinC = Math.sin(c),
        cosC = Math.cos(c); //perform rotation and translate to correct position

    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  /**
   * Get the angle between two 2D vectors
   * @param {vec2} a The first operand
   * @param {vec2} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle(a, b) {
    var x1 = a[0],
        y1 = a[1],
        x2 = b[0],
        y2 = b[1];
    var len1 = x1 * x1 + y1 * y1;

    if (len1 > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len1 = 1 / Math.sqrt(len1);
    }

    var len2 = x2 * x2 + y2 * y2;

    if (len2 > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len2 = 1 / Math.sqrt(len2);
    }

    var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

    if (cosine > 1.0) {
      return 0;
    } else if (cosine < -1) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  /**
   * Set the components of a vec2 to zero
   *
   * @param {vec2} out the receiving vector
   * @returns {vec2} out
   */

  function zero(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec2} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str(a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
  }
  /**
   * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
   *
   * @param {vec2} a The first vector.
   * @param {vec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec2} a The first vector.
   * @param {vec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals(a, b) {
    var a0 = a[0],
        a1 = a[1];
    var b0 = b[0],
        b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
  }
  /**
   * Alias for {@link vec2.length}
   * @function
   */

  var len = length;
  /**
   * Alias for {@link vec2.subtract}
   * @function
   */

  var sub = subtract;
  /**
   * Alias for {@link vec2.multiply}
   * @function
   */

  var mul = multiply;
  /**
   * Alias for {@link vec2.divide}
   * @function
   */

  var div = divide;
  /**
   * Alias for {@link vec2.distance}
   * @function
   */

  var dist = distance;
  /**
   * Alias for {@link vec2.squaredDistance}
   * @function
   */

  var sqrDist = squaredDistance;
  /**
   * Alias for {@link vec2.squaredLength}
   * @function
   */

  var sqrLen = squaredLength;
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  }();

  var vec2$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add,
    angle: angle,
    ceil: ceil,
    clone: clone,
    copy: copy,
    create: create,
    cross: cross,
    dist: dist,
    distance: distance,
    div: div,
    divide: divide,
    dot: dot,
    equals: equals,
    exactEquals: exactEquals,
    floor: floor,
    forEach: forEach,
    fromValues: fromValues,
    inverse: inverse,
    len: len,
    length: length,
    lerp: lerp,
    max: max,
    min: min,
    mul: mul,
    multiply: multiply,
    negate: negate,
    normalize: normalize,
    random: random,
    rotate: rotate,
    round: round,
    scale: scale,
    scaleAndAdd: scaleAndAdd,
    set: set,
    sqrDist: sqrDist,
    sqrLen: sqrLen,
    squaredDistance: squaredDistance,
    squaredLength: squaredLength,
    str: str,
    sub: sub,
    subtract: subtract,
    transformMat2: transformMat2,
    transformMat2d: transformMat2d,
    transformMat3: transformMat3,
    transformMat4: transformMat4,
    zero: zero
  });

  class AnimKey {
    constructor(obj, an) {
      this.id = CABLES.shortId();
      this.time = 0.0;
      this.value = 0.0;
      this.selected = false;

      /** @type {Anim} */
      this.anim = obj.anim || an || null;

      // this.ui = null;
      this.onChange = null;
      this._easing = 0;
      // this.bezTangIn = 0;
      // this.bezTangOut = 0;
      // this.bezTime = 0.5;
      // this.bezValue = 0;
      // this.bezTimeIn = -0.5;
      // this.bezValueIn = 0;

      this.cb = null;
      this.cbTriggered = false;

      // const bezierAnim = null;
      // this._updateBezier = false;

      this.setEasing(Anim.EASING_LINEAR);
      this.set(obj);
    }

    delete() {
      if (this.anim) this.anim.remove(this);
      else console.log("animkey without anim...");
    }

    /**
     * @param {Number} e
     */
    setEasing(e) {
      this._easing = e;

      if (this._easing == Anim.EASING_LINEAR) this.ease = AnimKey.easeLinear;
      else if (this._easing == Anim.EASING_ABSOLUTE)
        this.ease = AnimKey.easeAbsolute;
      else if (this._easing == Anim.EASING_SMOOTHSTEP)
        this.ease = AnimKey.easeSmoothStep;
      else if (this._easing == Anim.EASING_SMOOTHERSTEP)
        this.ease = AnimKey.easeSmootherStep;
      else if (this._easing == Anim.EASING_CUBIC_IN)
        this.ease = AnimKey.easeCubicIn;
      else if (this._easing == Anim.EASING_CUBIC_OUT)
        this.ease = AnimKey.easeCubicOut;
      else if (this._easing == Anim.EASING_CUBIC_INOUT)
        this.ease = AnimKey.easeCubicInOut;
      else if (this._easing == Anim.EASING_EXPO_IN)
        this.ease = AnimKey.easeExpoIn;
      else if (this._easing == Anim.EASING_EXPO_OUT)
        this.ease = AnimKey.easeExpoOut;
      else if (this._easing == Anim.EASING_EXPO_INOUT)
        this.ease = AnimKey.easeExpoInOut;
      else if (this._easing == Anim.EASING_SIN_IN) this.ease = AnimKey.easeSinIn;
      else if (this._easing == Anim.EASING_SIN_OUT)
        this.ease = AnimKey.easeSinOut;
      else if (this._easing == Anim.EASING_SIN_INOUT)
        this.ease = AnimKey.easeSinInOut;
      else if (this._easing == Anim.EASING_BACK_OUT)
        this.ease = AnimKey.easeOutBack;
      else if (this._easing == Anim.EASING_BACK_IN)
        this.ease = AnimKey.easeInBack;
      else if (this._easing == Anim.EASING_BACK_INOUT)
        this.ease = AnimKey.easeInOutBack;
      else if (this._easing == Anim.EASING_ELASTIC_IN)
        this.ease = AnimKey.easeInElastic;
      else if (this._easing == Anim.EASING_ELASTIC_OUT)
        this.ease = AnimKey.easeOutElastic;
      // else if (this._easing == Anim.EASING_ELASTIC_INOUT) this.ease = AnimKey.easeElasticInOut;
      else if (this._easing == Anim.EASING_BOUNCE_IN)
        this.ease = AnimKey.easeInBounce;
      else if (this._easing == Anim.EASING_BOUNCE_OUT)
        this.ease = AnimKey.easeOutBounce;
      else if (this._easing == Anim.EASING_QUART_OUT)
        this.ease = AnimKey.easeOutQuart;
      else if (this._easing == Anim.EASING_QUART_IN)
        this.ease = AnimKey.easeInQuart;
      else if (this._easing == Anim.EASING_QUART_INOUT)
        this.ease = AnimKey.easeInOutQuart;
      else if (this._easing == Anim.EASING_QUINT_OUT)
        this.ease = AnimKey.easeOutQuint;
      else if (this._easing == Anim.EASING_QUINT_IN)
        this.ease = AnimKey.easeInQuint;
      else if (this._easing == Anim.EASING_QUINT_INOUT)
        this.ease = AnimKey.easeInOutQuint;
      else if (this._easing == Anim.EASING_CUBICSPLINE) {
        // this._updateBezier = true;
        this.ease = AnimKey.easeCubicSpline;
      } else {
        this._easing = Anim.EASING_LINEAR;
        this.ease = AnimKey.easeLinear;
      }
    }

    trigger() {
      this.cb();
      this.cbTriggered = true;
    }

    setValue(v) {
      this.value = v;
      if (this.onChange !== null) this.onChange();
    }

    set(obj) {
      if (obj) {
        if (obj.hasOwnProperty("e")) this.setEasing(obj.e);
        if (obj.cb) {
          this.cb = obj.cb;
          this.cbTriggered = false;
        }

        if (obj.b) ;

        if (obj.hasOwnProperty("t")) this.time = obj.t;
        if (obj.hasOwnProperty("time")) this.time = obj.time;
        if (obj.hasOwnProperty("v")) this.value = obj.v;
        else if (obj.hasOwnProperty("value")) this.value = obj.value;
      }
      if (this.onChange !== null) this.onChange();
    }

    /**
     * @returns {Object}
     */
    getSerialized() {
      const obj = {};
      obj.t = this.time;
      obj.v = this.value;
      obj.e = this._easing;

      return obj;
    }

    getEasing() {
      return this._easing;
    }
  }

  AnimKey.cubicSpline = function (perc, key1, key2) {
    let previousPoint = key1.value,
      previousTangent = key1.bezTangOut,
      nextPoint = key2.value,
      nextTangent = key2.bezTangIn;
    let t = perc;
    let t2 = t * t;
    let t3 = t2 * t;

    return (
      (2 * t3 - 3 * t2 + 1) * previousPoint +
      (t3 - 2 * t2 + t) * previousTangent +
      (-2 * t3 + 3 * t2) * nextPoint +
      (t3 - t2) * nextTangent
    );
  };

  AnimKey.easeCubicSpline = function (perc, key2) {
    return AnimKey.cubicSpline(perc, this, key2);
  };

  AnimKey.linear = function (perc, key1, key2) {
    return parseFloat(key1.value) + parseFloat(key2.value - key1.value) * perc;
  };

  AnimKey.easeLinear = function (perc, key2) {
    return AnimKey.linear(perc, this, key2);
  };

  AnimKey.easeAbsolute = function (perc, key2) {
    return this.value;
  };

  const easeExpoIn = function (t) {
    return (t = 2 ** (10 * (t - 1)));
  };

  AnimKey.easeExpoIn = function (t, key2) {
    t = easeExpoIn(t);
    return AnimKey.linear(t, this, key2);
  };

  const easeExpoOut = function (t) {
    t = -(2 ** (-10 * t)) + 1;
    return t;
  };

  AnimKey.easeExpoOut = function (t, key2) {
    t = easeExpoOut(t);
    return AnimKey.linear(t, this, key2);
  };

  const easeExpoInOut = function (t) {
    t *= 2;
    if (t < 1) {
      t = 0.5 * 2 ** (10 * (t - 1));
    } else {
      t--;
      t = 0.5 * (-(2 ** (-10 * t)) + 2);
    }
    return t;
  };

  AnimKey.easeExpoInOut = function (t, key2) {
    t = easeExpoInOut(t);
    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeSinIn = function (t, key2) {
    t = -1 * Math.cos((t * Math.PI) / 2) + 1;
    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeSinOut = function (t, key2) {
    t = Math.sin((t * Math.PI) / 2);
    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeSinInOut = function (t, key2) {
    t = -0.5 * (Math.cos(Math.PI * t) - 1.0);
    return AnimKey.linear(t, this, key2);
  };

  const easeCubicIn = function (t) {
    t = t * t * t;
    return t;
  };

  AnimKey.easeCubicIn = function (t, key2) {
    t = easeCubicIn(t);
    return AnimKey.linear(t, this, key2);
  };

  // b 0
  // c 1/2 or 1
  // d always 1
  // easeOutCubic: function (x, t, b, c, d) {
  //     return c*((t=t/d-1)*t*t + 1) + b;

  AnimKey.easeInQuint = function (t, key2) {
    t = t * t * t * t * t;
    return AnimKey.linear(t, this, key2);
  };
  AnimKey.easeOutQuint = function (t, key2) {
    t = (t -= 1) * t * t * t * t + 1;
    return AnimKey.linear(t, this, key2);
  };
  AnimKey.easeInOutQuint = function (t, key2) {
    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t * t;
    else t = 0.5 * ((t -= 2) * t * t * t * t + 2);
    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeInQuart = function (t, key2) {
    t = t * t * t * t;
    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeOutQuart = function (t, key2) {
    // return -c * ((t=t/d-1)*t*t*t - 1) + b;
    t = -1 * ((t -= 1) * t * t * t - 1);
    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeInOutQuart = function (t, key2) {
    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t;
    else t = -0.5 * ((t -= 2) * t * t * t - 2);
    return AnimKey.linear(t, this, key2);
  };

  AnimKey.bounce = function (t) {
    if ((t /= 1) < 1 / 2.75) t = 7.5625 * t * t;
    else if (t < 2 / 2.75) t = 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
    else if (t < 2.5 / 2.75) t = 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
    else t = 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    return t;
  };

  AnimKey.easeInBounce = function (t, key2) {
    return AnimKey.linear(AnimKey.bounce(t), this, key2);
    // return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d);
  };

  AnimKey.easeOutBounce = function (t, key2) {
    return AnimKey.linear(AnimKey.bounce(t), this, key2);
  };

  AnimKey.easeInElastic = function (t, key2) {
    let s = 1.70158;
    let p = 0;
    let a = 1;

    const b = 0;
    const d = 1;
    const c = 1;

    if (t === 0) t = b;
    else if ((t /= d) == 1) t = b + c;
    else {
      if (!p) p = d * 0.3;
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else s = (p / (2 * Math.PI)) * Math.asin(c / a);
      t =
        -(
          a *
          2 ** (10 * (t -= 1)) *
          Math.sin(((t * d - s) * (2 * Math.PI)) / p)
        ) + b;
    }

    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeOutElastic = function (t, key2) {
    let s = 1.70158;
    let p = 0;
    let a = 1;

    const b = 0;
    const d = 1;
    const c = 1;

    if (t === 0) t = b;
    else if ((t /= d) == 1) t = b + c;
    else {
      if (!p) p = d * 0.3;
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else s = (p / (2 * Math.PI)) * Math.asin(c / a);
      t =
        a * 2 ** (-10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) + c + b;
    }

    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeInBack = function (t, key2) {
    const s = 1.70158;
    t = t * t * ((s + 1) * t - s);

    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeOutBack = function (t, key2) {
    const s = 1.70158;
    t = (t = t / 1 - 1) * t * ((s + 1) * t + s) + 1;

    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeInOutBack = function (t, key2) {
    let s = 1.70158;
    const c = 1 / 2;
    if ((t /= 1 / 2) < 1) t = c * (t * t * (((s *= 1.525) + 1) * t - s));
    else t = c * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);

    return AnimKey.linear(t, this, key2);
  };

  const easeCubicOut = function (t) {
    t--;
    t = t * t * t + 1;
    return t;
  };

  AnimKey.easeCubicOut = function (t, key2) {
    t = easeCubicOut(t);
    return AnimKey.linear(t, this, key2);
  };

  const easeCubicInOut = function (t) {
    t *= 2;
    if (t < 1) t = 0.5 * t * t * t;
    else {
      t -= 2;
      t = 0.5 * (t * t * t + 2);
    }
    return t;
  };

  AnimKey.easeCubicInOut = function (t, key2) {
    t = easeCubicInOut(t);
    return AnimKey.linear(t, this, key2);
  };

  AnimKey.easeSmoothStep = function (perc, key2) {
    // var x = Math.max(0, Math.min(1, (perc-0)/(1-0)));
    const x = Math.max(0, Math.min(1, perc));
    perc = x * x * (3 - 2 * x); // smoothstep
    return AnimKey.linear(perc, this, key2);
  };

  AnimKey.easeSmootherStep = function (perc, key2) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep
    return AnimKey.linear(perc, this, key2);
  };

  /**
   * LoadingStatus class, manages asynchronous loading jobs
   *
   * @namespace external:CABLES#LoadingStatus
   * @hideconstructor
   * @class
   * @param patch
   */

  class LoadingStatus extends Events {
    /**
     * @param {Patch} patch
     */
    constructor(patch) {
      super();
      this._log = new Logger("LoadingStatus");
      this._loadingAssets = {};
      this._cbFinished = [];
      this._assetTasks = [];
      this._percent = 0;
      this._count = 0;
      this._countFinished = 0;
      this._order = 0;
      this._startTime = 0;
      this._patch = patch;
      this._wasFinishedPrinted = false;
      this._loadingAssetTaskCb = false;
    }

    /**
     * @param {Function} cb
     */
    setOnFinishedLoading(cb) {
      this._cbFinished.push(cb);
    }

    getNumAssets() {
      return this._countFinished;
    }

    getProgress() {
      return this._percent;
    }

    checkStatus() {
      this._countFinished = 0;
      this._count = 0;

      for (const i in this._loadingAssets) {
        this._count++;
        if (!this._loadingAssets[i].finished) {
          this._countFinished++;
        }
      }

      this._percent = (this._count - this._countFinished) / this._count;

      if (this._countFinished === 0) {
        for (let j = 0; j < this._cbFinished.length; j++) {
          if (this._cbFinished[j]) {
            const cb = this._cbFinished[j];
            setTimeout(() => {
              cb(this._patch);
              this.emitEvent("finishedAll");
            }, 100);
          }
        }

        if (!this._wasFinishedPrinted) {
          this._wasFinishedPrinted = true;
          this.print();
        }
        this.emitEvent("finishedAll");
      }
    }

    getList() {
      let arr = [];
      for (const i in this._loadingAssets) {
        arr.push(this._loadingAssets[i]);
      }

      return arr;
    }

    getListJobs() {
      let arr = [];
      for (const i in this._loadingAssets) {
        if (!this._loadingAssets[i].finished)
          arr.push(this._loadingAssets[i].name);
      }

      return arr;
    }

    print() {
      if (this._patch.config.silent) return;

      const rows = [];

      for (const i in this._loadingAssets) {
        rows.push([
          this._loadingAssets[i].order,
          this._loadingAssets[i].type,
          this._loadingAssets[i].name,
          (this._loadingAssets[i].timeEnd - this._loadingAssets[i].timeStart) /
            1000 +
            "s",
        ]);
      }

      this._log.groupCollapsed(
        "finished loading " +
          this._order +
          " assets in " +
          (Date.now() - this._startTime) / 1000 +
          "s",
      );
      this._log.table(rows);
      this._log.groupEnd();
    }

    /**
     * @param {string} id
     */
    finished(id) {
      const l = this._loadingAssets[id];
      if (l) {
        if (l.finished) this._log.warn("loading job was already finished", l);

        if (l.op) l.op.setUiAttribs({ loading: false });
        l.finished = true;
        l.timeEnd = Date.now();
      }

      this.checkStatus();
      this.emitEvent("finishedTask");
      return null;
    }

    _startAssetTasks() {
      for (let i = 0; i < this._assetTasks.length; i++) this._assetTasks[i]();
      this._assetTasks.length = 0;
    }

    /**
     * delay an asset loading task, mainly to wait for ui to be finished loading and showing, and only then start loading assets
     * @function addAssetLoadingTask
     * @instance
     * @memberof LoadingStatus
     * @param {function} cb callback
     */
    addAssetLoadingTask(cb) {
      if (this._patch.isEditorMode() && !CABLES.UI.loaded) {
        this._assetTasks.push(cb);

        if (!this._loadingAssetTaskCb)
          window.gui.addEventListener(
            "uiloaded",
            this._startAssetTasks.bind(this),
          );
        this._loadingAssetTaskCb = true;
      } else {
        cb();
      }
      this.emitEvent("addAssetTask");
    }

    /**
     * @param {string} name
     */
    existByName(name) {
      for (let i in this._loadingAssets) {
        if (
          this._loadingAssets[i].name == name &&
          !this._loadingAssets[i].finished
        )
          return true;
      }
    }

    /**
     * @param {string} type
     * @param {string} name
     * @param {Op} [op]
     */
    start(type, name, op) {
      if (this._startTime == 0) this._startTime = Date.now();
      const id = generateUUID();

      name = name || "unknown";
      if (name.length > 100) name = name.substring(0, 100);

      if (op) op.setUiAttrib({ loading: true });

      this._loadingAssets[id] = {
        id: id,
        op: op,
        type: type,
        name: name,
        finished: false,
        timeStart: Date.now(),
        order: this._order,
      };
      this._order++;

      this.emitEvent("startTask");

      return id;
    }
  }

  /**
   * @namespace CABLES
   */

  const internalNow = function () {
    return window.performance.now();
  };

  /*
   * current time in milliseconds
   * @memberof CABLES
   * @function now
   * @static
   *
   */
  const now = function () {
    return internalNow();
  };

  /**
   * Measuring time
   * @namespace external:CABLES#Timer
   * @hideconstructor
   * @class
   */
  class Timer extends Events {
    constructor() {
      super();

      /**
       * @private
       */
      this._timeStart = internalNow();
      this._timeOffset = 0;
      this._currentTime = 0;
      this._lastTime = 0;
      this._paused = true;
      this._delay = 0;
      this.overwriteTime = -1;
    }

    _internalNow() {
      if (this._ts) return this._ts;
      return internalNow();
    }

    _getTime() {
      this._lastTime = (this._internalNow() - this._timeStart) / 1000;
      return this._lastTime + this._timeOffset;
    }

    setDelay(d) {
      this._delay = d;
      this.emitEvent("timeChange");
    }

    /**
     * @function
     * @memberof Timer
     * @instance
     * @description returns true if timer is playing
     * @return {Boolean} value
     */
    isPlaying() {
      return !this._paused;
    }

    /**
     * @function
     * @memberof Timer
     * @instance
     * @param ts
     * @description update timer
     * @return {Number} time
     */
    update(ts) {
      if (ts) this._ts = ts;
      if (this._paused) return;
      this._currentTime = this._getTime();

      return this._currentTime;
    }

    /**
     * @function
     * @memberof Timer
     * @instance
     * @return {Number} time in milliseconds
     */
    getMillis() {
      return this.get() * 1000;
    }

    /**
     * @function
     * @memberof Timer
     * @instance
     * @return {Number} value time in seconds
     */
    get() {
      return this.getTime();
    }

    getTime() {
      if (this.overwriteTime >= 0) return this.overwriteTime - this._delay;
      return this._currentTime - this._delay;
    }

    /**
     * toggle between play/pause state
     * @function
     * @memberof Timer
     * @instance
     */
    togglePlay() {
      if (this._paused) this.play();
      else this.pause();
    }

    /**
     * set current time
     * @function
     * @memberof Timer
     * @instance
     * @param {Number} t
     */
    setTime(t) {
      if (isNaN(t) || t < 0) t = 0;
      this._timeStart = this._internalNow();
      this._timeOffset = t;
      this._currentTime = t;
      this.emitEvent("timeChange");
    }

    setOffset(val) {
      if (this._currentTime + val < 0) {
        this._timeStart = this._internalNow();
        this._timeOffset = 0;
        this._currentTime = 0;
      } else {
        this._timeOffset += val;
        this._currentTime = this._lastTime + this._timeOffset;
      }
      this.emitEvent("timeChange");
    }

    /**
     * (re)starts the timer
     * @function
     * @memberof Timer
     * @instance
     */
    play() {
      this._timeStart = this._internalNow();
      this._paused = false;
      this.emitEvent("playPause");
    }

    /**
     * pauses the timer
     * @function
     * @memberof Timer
     * @instance
     */
    pause() {
      this._timeOffset = this._currentTime;
      this._paused = true;
      this.emitEvent("playPause");
    }
  }

  let Profiler$1 = class Profiler {
    /**
     * @param {Patch} patch
     */
    constructor(patch) {
      this.startFrame = patch.getFrameNum();
      this.items = {};
      this.currentId = null;
      this.currentStart = 0;
      this._patch = patch;
    }

    getItems() {
      return this.items;
    }

    clear() {
      if (this.paused) return;
      this.items = {};
    }

    togglePause() {
      this.paused = !this.paused;
      if (!this.paused) {
        this.items = {};
        this.currentStart = performance.now();
      }
    }

    add(type, object) {
      if (this.paused) return;

      if (this.currentId !== null) {
        if (!object || object.id != this.currentId) {
          if (this.items[this.currentId]) {
            this.items[this.currentId].timeUsed +=
              performance.now() - this.currentStart;

            if (
              !this.items[this.currentId].peakTime ||
              now() - this.items[this.currentId].peakTime > 5000
            ) {
              this.items[this.currentId].peak = 0;
              this.items[this.currentId].peakTime = now();
            }
            this.items[this.currentId].peak = Math.max(
              this.items[this.currentId].peak,
              performance.now() - this.currentStart,
            );
          }
        }
      }

      if (object !== null) {
        if (!this.items[object.id]) {
          this.items[object.id] = {
            numTriggers: 0,
            timeUsed: 0,
          };
        }

        if (this.items[object.id].lastFrame != this._patch.getFrameNum())
          this.items[object.id].numTriggers = 0;

        this.items[object.id].lastFrame = this._patch.getFrameNum();
        this.items[object.id].numTriggers++;
        this.items[object.id].opid = object.op.id;
        this.items[object.id].title = object.op.name + "." + object.name;
        this.items[object.id].subPatch = object.op.uiAttribs.subPatch;

        this.currentId = object.id;
        this.currentStart = performance.now();
      } else {
        this.currentId = null;
      }
    }

    print() {
      console.log("--------");
      for (const i in this.items) {
        console.log(
          this.items[i].title +
            ": " +
            this.items[i].numTriggers +
            " / " +
            this.items[i].timeUsed,
        );
      }
    }
  };

  class PatchVariable extends Events {
    /**
     * @param {String} name
     * @param {String|Number} val
     * @param {number} type
     */
    constructor(name, val, type) {
      super();
      this._name = name;
      this.type = type;
      this.setValue(val);
    }

    /**
     * keeping this for backwards compatibility in older
     * exports before using eventtarget
     *
     * @param cb
     */
    addListener(cb) {
      this.on("change", cb, "var");
    }

    /**
     * @function Variable.getValue
     * @memberof PatchVariable
     * @returns {String|Number|Boolean}
     */
    getValue() {
      return this._v;
    }

    /**
     * @function getName
     * @memberof PatchVariable
     * @instance
     * @returns {String|Number|Boolean}
     * @function
     */
    getName() {
      return this._name;
    }

    /**
     * @function setValue
     * @memberof PatchVariable
     * @instance
     * @param v
     * @returns {any}
     * @function
     */
    setValue(v) {
      this._v = v;
      this.emitEvent("change", v, this);
    }
  }

  const SHADER = {
    // default attributes
    SHADERVAR_VERTEX_POSITION: "vPosition",
    SHADERVAR_VERTEX_NUMBER: "attrVertIndex",
    SHADERVAR_VERTEX_NORMAL: "attrVertNormal",
    SHADERVAR_VERTEX_TEXCOORD: "attrTexCoord",
    SHADERVAR_INSTANCE_MMATRIX: "instMat",
    SHADERVAR_VERTEX_COLOR: "attrVertColor",

    SHADERVAR_INSTANCE_INDEX: "instanceIndex",

    // default uniforms
    SHADERVAR_UNI_PROJMAT: "projMatrix",
    SHADERVAR_UNI_VIEWMAT: "viewMatrix",
    SHADERVAR_UNI_MODELMAT: "modelMatrix",
    SHADERVAR_UNI_NORMALMAT: "normalMatrix",
    SHADERVAR_UNI_INVVIEWMAT: "inverseViewMatrix",
    SHADERVAR_UNI_INVPROJMAT: "invProjMatrix",
    SHADERVAR_UNI_MATERIALID: "materialId",
    SHADERVAR_UNI_OBJECTID: "objectId",

    SHADERVAR_UNI_VIEWPOS: "camPos",
  };

  const BLEND_MODES = {
    BLEND_NONE: 0,
    BLEND_NORMAL: 1,
    BLEND_ADD: 2,
    BLEND_SUB: 3,
    BLEND_MUL: 4,
  };

  const RAD2DEG = 180.0 / Math.PI;
  const DEG2RAD = Math.PI / 180.0;

  const CONSTANTS$1 = {
    MATH: {
      DEG2RAD: DEG2RAD,
      RAD2DEG: RAD2DEG,
    },
    SHADER: SHADER,
    BLEND_MODES: BLEND_MODES,
  };
  const nl = "\n"; // newline

  class CgUniform {
    /**
     * Description
     * @param {CgShader|CgpShader|Shader} __shader
     * @param {string} __type
     * @param {string} __name
     * @param {Number|Port} _value
     * @param {Port} _port2
     * @param {Port} _port3
     * @param {Port} _port4
     */
    constructor(
      __shader,
      __type,
      __name,
      _value,
      _port2,
      _port3,
      _port4,
      _structUniformName,
      _structName,
      _propertyName,
    ) {
      this._log = new Logger("cg_uniform");
      this._type = __type;
      this._name = __name;

      /** @type {CgShader} */
      this._shader = __shader;
      this._value = 0.00001;
      this._oldValue = null;
      this._port = null;

      this._structName = _structName;
      this._structUniformName = _structUniformName;
      this._propertyName = _propertyName;

      if (this._shader._addUniform) this._shader._addUniform(this);
      this.needsUpdate = true;
      this.shaderType = null;
      this.comment = null;

      if (__type == "f") {
        this.set = this.setValue = this.setValueF.bind(this);
        this.updateValue = this.updateValueF.bind(this);
      } else if (__type == "f[]") {
        this.set = this.setValue = this.setValueArrayF.bind(this);
        this.updateValue = this.updateValueArrayF.bind(this);
      } else if (__type == "2f[]") {
        this.set = this.setValue = this.setValueArray2F.bind(this);
        this.updateValue = this.updateValueArray2F.bind(this);
      } else if (__type == "3f[]") {
        this.set = this.setValue = this.setValueArray3F.bind(this);
        this.updateValue = this.updateValueArray3F.bind(this);
      } else if (__type == "4f[]") {
        this.set = this.setValue = this.setValueArray4F.bind(this);
        this.updateValue = this.updateValueArray4F.bind(this);
      } else if (__type == "i") {
        this.set = this.setValue = this.setValueI.bind(this);
        this.updateValue = this.updateValueI.bind(this);
      } else if (__type == "2i") {
        this.set = this.setValue = this.setValue2I.bind(this);
        this.updateValue = this.updateValue2I.bind(this);
      } else if (__type == "3i") {
        this.set = this.setValue = this.setValue3I.bind(this);
        this.updateValue = this.updateValue3I.bind(this);
      } else if (__type == "4i") {
        this.set = this.setValue = this.setValue4I.bind(this);
        this.updateValue = this.updateValue4I.bind(this);
      } else if (__type == "b") {
        this.set = this.setValue = this.setValueBool.bind(this);
        this.updateValue = this.updateValueBool.bind(this);
      } else if (__type == "4f") {
        this.set = this.setValue = this.setValue4F.bind(this);
        this.updateValue = this.updateValue4F.bind(this);
      } else if (__type == "3f") {
        this.set = this.setValue = this.setValue3F.bind(this);
        this.updateValue = this.updateValue3F.bind(this);
      } else if (__type == "2f") {
        this.set = this.setValue = this.setValue2F.bind(this);
        this.updateValue = this.updateValue2F.bind(this);
      } else if (__type == "t") {
        this.set = this.setValue = this.setValueT.bind(this);
        this.updateValue = this.updateValueT.bind(this);
      } else if (__type == "sampler") {
        if (this.setValueAny) {
          this.set = this.setValue = this.setValueAny.bind(this);
          this.updateValue = this.updateValueAny.bind(this);
        }
      } else if (__type == "tc") {
        this.set = this.setValue = this.setValueT.bind(this);
        this.updateValue = this.updateValueT.bind(this);
      } else if (__type == "t[]") {
        this.set = this.setValue = this.setValueArrayT.bind(this);
        this.updateValue = this.updateValueArrayT.bind(this);
      } else if (__type == "m4" || __type == "m4[]") {
        this.set = this.setValue = this.setValueM4.bind(this);
        this.updateValue = this.updateValueM4.bind(this);
      } else {
        // console.error("unknown");
        this._log.error(
          "Unknown uniform type " + __type,
          __name,
          typeof this._shader,
        );
      }

      if (typeof _value == "object" && _value instanceof CABLES.Port) {
        this._port = _value;
        this._value = this._port.get();

        if (_port2 && _port3 && _port4) {
          if (
            !(_port2 instanceof CABLES.Port) ||
            !(_port3 instanceof CABLES.Port) ||
            !(_port4 instanceof CABLES.Port)
          ) {
            this._log.error(
              "[cgl_uniform] mixed port/value parameter for vec4 ",
              this._name,
            );
          }

          this._value = [0, 0, 0, 0];
          this._port2 = _port2;
          this._port3 = _port3;
          this._port4 = _port4;

          this._port.on("change", this.updateFromPort4f.bind(this));
          this._port2.on("change", this.updateFromPort4f.bind(this));
          this._port3.on("change", this.updateFromPort4f.bind(this));
          this._port4.on("change", this.updateFromPort4f.bind(this));

          // this._port.onChange = this._port2.onChange = this._port3.onChange = this._port4.onChange = this.updateFromPort4f.bind(this);
          this.updateFromPort4f();
        } else if (_port2 && _port3) {
          if (
            !(_port2 instanceof CABLES.Port) ||
            !(_port3 instanceof CABLES.Port)
          ) {
            this._log.error(
              "[cgl_uniform] mixed port/value parameter for vec4 ",
              this._name,
            );
          }

          this._value = [0, 0, 0];
          this._port2 = _port2;
          this._port3 = _port3;
          // this._port.onChange = this._port2.onChange = this._port3.onChange = this.updateFromPort3f.bind(this);
          this._port.on("change", this.updateFromPort3f.bind(this));
          this._port2.on("change", this.updateFromPort3f.bind(this));
          this._port3.on("change", this.updateFromPort3f.bind(this));

          this.updateFromPort3f();
        } else if (_port2) {
          if (!(_port2 instanceof CABLES.Port)) {
            this._log.error(
              "[cgl_uniform] mixed port/value parameter for vec4 ",
              this._name,
            );
          }

          this._value = [0, 0];
          this._port2 = _port2;
          // this._port.onChange = this._port2.onChange = this.updateFromPort2f.bind(this);
          this._port.on("change", this.updateFromPort2f.bind(this));
          this._port2.on("change", this.updateFromPort2f.bind(this));

          this.updateFromPort2f();
        } else {
          // this._port.on = this.updateFromPort.bind(this);
          this._port.on("change", this.updateFromPort.bind(this));
        }
      } else this._value = _value;

      if (this._value == undefined) {
        this._value = 0;
      }

      this.setValue(this._value);

      this.needsUpdate = true;
    }

    getType() {
      return this._type;
    }

    get type() {
      return this._type;
    }

    get name() {
      return this._name;
    }

    getName() {
      return this._name;
    }

    getValue() {
      return this._value;
    }

    getShaderType() {
      return this.shaderType;
    }

    isStructMember() {
      return !!this._structName;
    }

    updateFromPort4f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this._value[3] = this._port4.get();
      this.setValue(this._value);
    }

    updateFromPort3f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this.setValue(this._value);
    }

    updateFromPort2f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this.setValue(this._value);
    }

    updateFromPort() {
      this.setValue(this._port.get());
    }

    get port() {
      return this._port;
    }
  }

  /**
   * @typedef ShaderModule
   * @property {String} title
   * @property {String} name
   * @property {Number} id
   * @property {Number} numId
   * @property {String} group
   * @property {String} prefix
   * @property {Number} priority
   * @property {Number} num
   * @property {String} attributes
   * @property {String} srcBodyFrag
   * @property {String} srcBodyVert
   * @property {String} srcHeadFrag
   * @property {String} srcHeadVert
   */

  class CgShader extends Events {
    id = simpleId();
    _isValid = true;

    /** @type {Array<Array<String>>} */
    _defines = [];

    /** @type {Array<String>} */
    _moduleNames = [];

    _moduleNumId = 0;
    _needsRecompile = true;
    _compileReason = "initial";

    /** @type {Array<ShaderModule>} */
    _modules = [];

    _compileCount = 0;

    logError = true;
    num = -1;
    lastCompile = 0;

    constructor() {
      super();
    }

    /**
     * @param {string} reason
     */
    setWhyCompile(reason) {
      this._compileReason = reason;
      this._needsRecompile = true;
    }

    getWhyCompile() {
      return this._compileReason;
    }

    needsRecompile() {
      return this._needsRecompile;
    }

    /**
     * @param {string} name
     */
    removeUniform(name) {
      for (let i = 0; i < this._uniforms.length; i++) {
        if (this._uniforms[i].getName() == name) {
          this._uniforms.splice(i, 1);
        }
      }
      this.setWhyCompile("remove uniform " + name);
    }

    /**
     * @param {String} name
     * @param {number} stage
     */
    hasUniformInStage(name, stage) {
      this.defaultUniBindingFrag;
      if (stage == GPUShaderStage.VERTEX) this.defaultUniBindingVert;
      if (stage == GPUShaderStage.COMPUTE)
        this.defaultUniBindingCompute;

      for (let i = 0; i < this._uniforms.length; i++) {
        console.log("hasuniiiiiiiiiiiiiii", this._uniforms[i].getName(), name);
        if (this._uniforms[i].getName() == name) return true;
      }
      return false;
    }

    /**
     * @param {String} name
     */
    hasUniform(name) {}

    /**
     * easily enable/disable a define without a value
     * @param {String} name
     * @param {Port} enabled value or port
     */
    toggleDefine(name, enabled) {
      if (enabled && typeof enabled == "object" && enabled.addEventListener) {
        // port
        if (enabled.changeListener) enabled.off(enabled.changeListener);

        enabled.onToggleDefine = (v) => {
          this.toggleDefine(name, v);
        };

        enabled.changeListener = enabled.on("change", enabled.onToggleDefine);
        enabled = enabled.get();
      }

      if (enabled) this.define(name);
      else this.removeDefine(name);
    }

    /**
     * add a define to a shader, e.g.  #define DO_THIS_THAT 1
     * @param {String} name
     * @param {any} value (can be empty)
     */
    define(name, value = "") {
      if (value === null || value === undefined) value = "";

      if (typeof value == "object") {
        // port
        value.removeEventListener("change", value.onDefineChange);
        value.onDefineChange = (v) => {
          this.define(name, v);
        };
        value.on("change", value.onDefineChange);

        value = value.get();
      }

      for (let i = 0; i < this._defines.length; i++) {
        if (this._defines[i][0] == name && this._defines[i][1] == value) return;
        if (this._defines[i][0] == name) {
          this._defines[i][1] = value;
          this.setWhyCompile("define " + name + " " + value);
          return;
        }
      }
      this.setWhyCompile("define " + name + " " + value);

      this._defines.push([name, value]);
    }

    getDefines() {
      return this._defines;
    }

    /**
     * @param {string} name
     */
    getDefine(name) {
      for (let i = 0; i < this._defines.length; i++)
        if (this._defines[i][0] == name) return this._defines[i][1];
      return null;
    }

    /**
     * return true if shader has define
     * @function hasDefine
     * @memberof Shader
     * @instance
     * @param {String} name
     * @return {Boolean}
     */
    hasDefine(name) {
      for (let i = 0; i < this._defines.length; i++)
        if (this._defines[i][0] == name) return true;
    }

    /**
     * remove a define from a shader
     * @param {string} name
     */
    removeDefine(name) {
      for (let i = 0; i < this._defines.length; i++) {
        if (this._defines[i][0] == name) {
          this._defines.splice(i, 1);

          this.setWhyCompile("define removed:" + name);

          return;
        }
      }
    }

    /**
     * @param {any} modId
     */
    hasModule(modId) {
      for (let i = 0; i < this._modules.length; i++)
        if (this._modules[i].id == modId) return true;

      return false;
    }

    /**
     *
     * @param {Array<String>} names
     */
    setModules(names) {
      this._moduleNames = names;
    }

    /**
     * remove a module from shader
     * @param {ShaderModule} mod the module to be removed
     */
    removeModule(mod) {
      for (let i = 0; i < this._modules.length; i++) {
        if (mod && mod.id) {
          if (this._modules[i].id == mod.id || !this._modules[i]) {
            let found = true;
            while (found) {
              found = false;
              for (let j = 0; j < this._uniforms.length; j++) {
                if (this._uniforms[j].getName().startsWith(mod.prefix)) {
                  this._uniforms.splice(j, 1);
                  found = true;
                  continue;
                }
              }
            }

            this.setWhyCompile("remove module " + mod.title);
            this._modules.splice(i, 1);
            break;
          }
        }
      }
    }

    getNumModules() {
      return this._modules.length;
    }

    getCurrentModules() {
      return this._modules;
    }

    /**
     * add a module
     * @param {ShaderModule} mod the module to be added
     * @param {ShaderModule} [sibling] sibling module, new module will share the same group
     */
    addModule(mod, sibling) {
      if (this.hasModule(mod.id)) return;
      if (!mod.id) mod.id = CABLES.simpleId();
      if (!mod.numId) mod.numId = this._moduleNumId;
      if (!mod.num) mod.num = this._modules.length;
      if (sibling && !sibling.group) sibling.group = simpleId();

      if (!mod.group)
        if (sibling) mod.group = sibling.group;
        else mod.group = simpleId();

      mod.prefix = "mod" + mod.group + "_";
      this._modules.push(mod);

      this.setWhyCompile("add module " + mod.title);
      this._moduleNumId++;

      return mod;
    }

    isValid() {
      return this._isValid;
    }
  }

  /**
   * Shader uniforms
   *
   * types:
   * <pre>
   * f    - float
   * 2f   - vec2
   * 3f   - vec3
   * 4f   - vec4
   * i    - integer
   * t    - texture
   * m4   - mat4, 4x4 float matrix
   * f[]  - array of floats
   * 2f[] - array of float vec2
   * 3f[] - array of float vec3
   * 4f[] - array of float vec4
   * </pre>
   *
   * @namespace external:CGL
   * @class
   * @param {CgShader} shader
   * @param {String} [type=f]
   * @param {String} name
   * @param {Number|Port} value  can be a Number,Matrix or Port
   * @example
   * // bind float uniform called myfloat and initialize with value 1.0
   * const unir=new CGL.Uniform(shader,'f','myfloat',1.0);
   * unir.setValue(1.0);
   *
   * // bind float uniform called myfloat and automatically set it to input port value
   * const myPort=op.inFloat("input");
   * const pv=new CGL.Uniform(shader,'f','myfloat',myPort);
   *
   */

  // export const Uniform(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)

  class Uniform extends CgUniform {
    constructor(
      __shader,
      __type,
      __name,
      _value,
      _port2,
      _port3,
      _port4,
      _structUniformName,
      _structName,
      _propertyName,
    ) {
      super(
        __shader,
        __type,
        __name,
        _value,
        _port2,
        _port3,
        _port4,
        _structUniformName,
        _structName,
        _propertyName,
      );
      this._loc = -1;
      this._cgl = __shader._cgl;
    }

    get name() {
      return this._name;
    }

    copy(newShader) {
      const uni = new Uniform(
        newShader,
        this._type,
        this._name,
        this._value,
        this._port2,
        this._port3,
        this._port4,
        this._structUniformName,
        this._structName,
        this._propertyName,
      );
      uni.shaderType = this.shaderType;
      return uni;
    }

    /**
     * returns type as glsl type string. e.g. 'f' returns 'float'
     * @function getGlslTypeString
     * @memberof Uniform
     * @instance
     * @return {string} type as string
     */
    getGlslTypeString() {
      return Uniform.glslTypeString(this._type);
    }

    _isValidLoc() {
      return this._loc != -1; // && this._loc != null;
    }

    resetLoc() {
      this._loc = -1;
      this.needsUpdate = true;
    }

    bindTextures() {}

    getLoc() {
      return this._loc;
    }

    updateFromPort4f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this._value[3] = this._port4.get();
      this.setValue(this._value);
    }

    updateFromPort3f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this.setValue(this._value);
    }

    updateFromPort2f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this.setValue(this._value);
    }

    updateFromPort() {
      this.setValue(this._port.get());
    }

    updateValueF() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      this._shader.getCgl().gl.uniform1f(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueF(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }

    updateValueI() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      this._shader.getCgl().gl.uniform1i(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    updateValue2I() {
      if (!this._value) return;

      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._shader
        .getCgl()
        .gl.uniform2i(this._loc, this._value[0], this._value[1]);

      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }

    updateValue3I() {
      if (!this._value) return;
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._shader
        .getCgl()
        .gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }

    updateValue4I() {
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader
        .getCgl()
        .gl.uniform4i(
          this._loc,
          this._value[0],
          this._value[1],
          this._value[2],
          this._value[3],
        );
      this._cgl.profileData.profileUniformCount++;
    }

    setValueI(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }

    setValue2I(v) {
      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this.needsUpdate = true;
      }

      this._value = v;
    }

    setValue3I(v) {
      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2];
        this.needsUpdate = true;
      } else if (
        v[0] != this._oldValue[0] ||
        v[1] != this._oldValue[1] ||
        v[2] != this._oldValue[2]
      ) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }

      this._value = v;
    }

    setValue4I(v) {
      this.needsUpdate = true;
      this._value = v || vec4.create();
    }

    updateValueBool() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);

      this._cgl.profileData.profileUniformCount++;
    }

    setValueBool(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }

    setValueArray4F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueArray4F() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform4fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueArray3F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueArray3F() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform3fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueArray2F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueArray2F() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform2fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayF(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueArrayF() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform1fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayT(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValue3F() {
      if (!this._value) return;
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._shader
        .getCgl()
        .gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }

    setValue3F(v) {
      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2];
        this.needsUpdate = true;
      } else if (
        v[0] != this._oldValue[0] ||
        v[1] != this._oldValue[1] ||
        v[2] != this._oldValue[2]
      ) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }

      this._value = v;
    }

    updateValue2F() {
      if (!this._value) return;

      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._shader
        .getCgl()
        .gl.uniform2f(this._loc, this._value[0], this._value[1]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }

    setValue2F(v) {
      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this.needsUpdate = true;
      }
      this._value = v;
    }

    updateValue4F() {
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      if (!this._value) {
        this._log.warn("no value for uniform", this._name, this);
        this._value = [0, 0, 0, 0];
      }

      this.needsUpdate = false;
      this._shader
        .getCgl()
        .gl.uniform4f(
          this._loc,
          this._value[0],
          this._value[1],
          this._value[2],
          this._value[3],
        );
      this._cgl.profileData.profileUniformCount++;
    }

    setValue4F(v) {
      if (typeof this.value == "number") this.value = vec4.create(); // this should not be needed, but somehow it crashes with some shadermods

      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2, 3];
        this.needsUpdate = true;
      } else if (
        v[0] != this._oldValue[0] ||
        v[1] != this._oldValue[1] ||
        v[2] != this._oldValue[2] ||
        v[3] != this._oldValue[3]
      ) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }

      this._value = v;
    }

    updateValueM4() {
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      if (!this._value || this._value.length % 16 != 0)
        return console.log("this.name", this._name, this._value);

      this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueM4(v) {
      this.needsUpdate = true;
      this._value = v || mat4.create();
    }

    updateValueArrayT() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform1iv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    updateValueT() {
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._cgl.profileData.profileUniformCount++;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value);
      this.needsUpdate = false;
    }

    setValueT(v) {
      this.needsUpdate = true;
      this._value = v;
    }
  }

  Uniform.glslTypeString = (t) => {
    if (t == "f") return "float";
    if (t == "b") return "bool";
    if (t == "i") return "int";
    if (t == "2i") return "ivec2";
    if (t == "2f") return "vec2";
    if (t == "3f") return "vec3";
    if (t == "4f") return "vec4";
    if (t == "m4") return "mat4";

    if (t == "t") return "sampler2D";
    if (t == "tc") return "samplerCube";

    if (t == "3f[]") return null; // ignore this for now...
    if (t == "m4[]") return null; // ignore this for now...
    if (t == "f[]") return null; // ignore this for now...

    console.warn("[CGL UNIFORM] unknown glsl type string ", t);
  };

  /**
   * @function setValue
   * @memberof Uniform
   * @instance
   * @param {Number|Array|Matrix|Texture} value
   */

  const DEFAULT_TEXTURE_SIZE$1 = 8;

  /**
   * @typedef {Object} CglTextureOptions
   * @property {number} [width]
   * @property {number} [height]
   * @property {string} [pixelformat]
   */
  class CgTexture {
    /**
     * @param {CglTextureOptions} options={}
     */
    constructor(options = {}) {
      this.id = CABLES.uuid();
      this.width = 0;
      this.height = 0;
      this.name = "unknown";

      options = options || {};
      this.pixelFormat = options.pixelFormat || CgTexture.PFORMATSTR_RGBA8UB;

      this.name = options.name || "unknown";

      if (!options.width) options.width = DEFAULT_TEXTURE_SIZE$1;
      if (!options.height) options.height = DEFAULT_TEXTURE_SIZE$1;
    }
  }

  CgTexture.getDefaultTextureData = (name, size, options = {}) => {
    if (name == "empty") {
      return new Uint8Array(size * size * 4).fill(0);
    } else if (name == "color") {
      const data = new Uint8Array(size * size * 4);
      let r = options.r || 1;
      let g = options.g || 1;
      let b = options.b || 1;

      for (let x = 0; x < size * size; x++) {
        data[x * 4 + 0] = r;
        data[x * 4 + 1] = g;
        data[x * 4 + 2] = b;
        data[x * 4 + 3] = 255;
      }
      return data;
    } else if (name == "randomUInt") {
      const data = new Uint8Array(size * size * 4);

      for (let x = 0; x < size * size; x++) {
        data[x * 4 + 0] = Math.random() * 255;
        data[x * 4 + 1] = Math.random() * 255;
        data[x * 4 + 2] = Math.random() * 255;
        data[x * 4 + 3] = 255;
      }
      return data;
    } else if (name == "random" || name == "randomFloat") {
      const data = new Float32Array(size * size * 4);

      for (let x = 0; x < size * size; x++) {
        data[x * 4 + 0] = (Math.random() - 0.5) * 2.0;
        data[x * 4 + 1] = (Math.random() - 0.5) * 2.0;
        data[x * 4 + 2] = (Math.random() - 0.5) * 2.0;
        data[x * 4 + 3] = 1;
      }
      return data;
    } else if (name == "stripes") {
      const arr = [];

      let r = options.r;
      let g = options.g;
      let b = options.b;

      if (r === undefined) r = 1;
      if (g === undefined) g = 1;
      if (b === undefined) b = 1;

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if ((x + y) % 64 < 32) {
            arr.push((200 + (y / size) * 25 + (x / size) * 25) * r);
            arr.push((200 + (y / size) * 25 + (x / size) * 25) * g);
            arr.push((200 + (y / size) * 25 + (x / size) * 25) * b);
          } else {
            arr.push((40 + (y / size) * 25 + (x / size) * 25) * r);
            arr.push((40 + (y / size) * 25 + (x / size) * 25) * g);
            arr.push((40 + (y / size) * 25 + (x / size) * 25) * b);
          }
          arr.push(255);
        }
      }

      return new Uint8Array(arr);
    } else {
      console.warn("unknown default texture", name);
      return CgTexture.getDefaultTextureData("stripes", size, {
        r: 1,
        g: 0,
        b: 0,
      });
    }
  };

  CgTexture.FILTER_NEAREST = 0;
  CgTexture.FILTER_LINEAR = 1;
  CgTexture.FILTER_MIPMAP = 2;

  CgTexture.WRAP_REPEAT = 0;
  CgTexture.WRAP_MIRRORED_REPEAT = 1;
  CgTexture.WRAP_CLAMP_TO_EDGE = 2;

  CgTexture.TYPE_DEFAULT = 0;
  CgTexture.TYPE_DEPTH = 1;
  CgTexture.TYPE_FLOAT = 2;

  CgTexture.PFORMATSTR_RGB565 = "RGB 5/6/5bit ubyte";

  CgTexture.PFORMATSTR_R8UB = "R 8bit ubyte";
  CgTexture.PFORMATSTR_RG8UB = "RG 8bit ubyte";
  CgTexture.PFORMATSTR_RGB8UB = "RGB 8bit ubyte";
  CgTexture.PFORMATSTR_RGBA8UB = "RGBA 8bit ubyte";

  CgTexture.PFORMATSTR_SRGBA8 = "SRGBA 8bit ubyte";

  CgTexture.PFORMATSTR_R11FG11FB10F = "RGB 11/11/10bit float";

  CgTexture.PFORMATSTR_R16F = "R 16bit float";
  CgTexture.PFORMATSTR_RG16F = "RG 16bit float";
  CgTexture.PFORMATSTR_RGB16F = "RGB 16bit float";
  CgTexture.PFORMATSTR_RGBA16F = "RGBA 16bit float";

  CgTexture.PFORMATSTR_R32F = "R 32bit float";
  CgTexture.PFORMATSTR_RG32F = "RG 32bit float";
  CgTexture.PFORMATSTR_RGB32F = "RGB 32bit float";
  CgTexture.PFORMATSTR_RGBA32F = "RGBA 32bit float";

  CgTexture.PFORMATSTR_DEPTH = "DEPTH";

  CgTexture.PIXELFORMATS = [
    CgTexture.PFORMATSTR_RGB565,

    CgTexture.PFORMATSTR_R8UB,
    CgTexture.PFORMATSTR_RG8UB,
    CgTexture.PFORMATSTR_RGB8UB,
    CgTexture.PFORMATSTR_RGBA8UB,

    CgTexture.PFORMATSTR_SRGBA8,

    CgTexture.PFORMATSTR_R11FG11FB10F,
    CgTexture.PFORMATSTR_R16F,
    CgTexture.PFORMATSTR_RG16F,
    CgTexture.PFORMATSTR_RGBA16F,

    CgTexture.PFORMATSTR_R32F,
    CgTexture.PFORMATSTR_RGBA32F,
  ];

  const DEFAULT_TEXTURE_SIZE = 8;

  const log$4 = new Logger("cgl_texture");

  /**
   * A Texture
   * @namespace external:CGL
   * @class
   * @param {CglContext} __cgl cgl
   * @param {Object} options
   * @hideconstructor
   * @example
   * // generate a 256x256 pixel texture of random colors
   * const size=256;
   * const data = new Uint8Array(size*size*4);
   *
   * for(var x=0;x<size*size*4;x++) data[ x*4+3]=255;
   *
   * const tex=new CGL.Texture(cgl);
   * tex.initFromData(data,size,size,CGL.Texture.FILTER_NEAREST,CGL.Texture.WRAP_REPEAT);
   */
  let Texture$1 = class Texture extends CgTexture {
    /**
     * @param {CglContext} __cgl
     */
    constructor(__cgl, options = {}) {
      super(options);
      if (!__cgl) throw new Error("no cgl");

      this._cgl = __cgl;
      this._log = new Logger("tex");
      this.tex = this._cgl.gl.createTexture();
      this.loading = false;
      this.flip = true;
      this.flipped = false;
      this.shadowMap = false;
      this.deleted = false;
      this.image = null;
      this.anisotropic = 0;
      this.filter = Texture.FILTER_NEAREST;
      this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
      this.texTarget = this._cgl.gl.TEXTURE_2D;
      if (options && options.type) this.texTarget = options.type;
      this.textureType = Texture.TYPE_DEFAULT;
      this.unpackAlpha = true;
      this._fromData = true;

      this._glDataType = -1;
      this._glInternalFormat = -1;
      this._glDataFormat = -1;

      if (options) {
        if (options.isDepthTexture) this.textureType = Texture.TYPE_DEPTH;
        if (options.isFloatingPointTexture === true)
          this.textureType = Texture.TYPE_FLOAT;

        if ("textureType" in options) this.textureType = options.textureType;
        if ("filter" in options) this.filter = options.filter;
        if ("wrap" in options) this.wrap = options.wrap;
        if ("unpackAlpha" in options) this.unpackAlpha = options.unpackAlpha;
        if ("flip" in options) this.flip = options.flip;
        if ("shadowMap" in options) this.shadowMap = options.shadowMap;
        if ("anisotropic" in options) this.anisotropic = options.anisotropic;
      } else {
        options = {};
      }

      if (!options.pixelFormat && options.isFloatingPointTexture)
        this.pixelFormat = Texture.PFORMATSTR_RGBA32F;

      if (this.textureType == Texture.TYPE_DEPTH)
        this.pixelFormat = Texture.PFORMATSTR_DEPTH;

      this._cgl.profileData.profileTextureNew++;

      this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
      this._cgl.profileData.addHeavyEvent(
        "texture created",
        this.name,
        options.width + "x" + options.height,
      );

      this.setSize(options.width, options.height);
      this.getInfoOneLine();
    }

    isFloatingPoint() {
      return Texture.isPixelFormatFloat(this.pixelFormat);
    }

    /**
     * returns true if otherTexture has same options (width/height/filter/wrap etc)
     * @function compareSettings
     * @memberof Texture
     * @instance
     * @param {Texture} tex otherTexture
     * @returns {Boolean}
     */
    compareSettings(tex) {
      // if (!tex) { this._log.warn("compare: no tex"); return false; }
      // if (tex.width != this.width) this._log.warn("tex.width not equal", tex.width, this.width);
      // if (tex.height != this.height) this._log.warn("tex.height not equal", tex.height, this.height);
      // if (tex.filter != this.filter) this._log.warn("tex.filter not equal");
      // if (tex.wrap != this.wrap) this._log.warn("tex.wrap not equal");
      // if (tex.textureType != this.textureType) this._log.warn("tex.textureType not equal");
      // if (tex.unpackAlpha != this.unpackAlpha) this._log.warn("tex.unpackAlpha not equal");
      // if (tex.anisotropic != this.anisotropic) this._log.warn("tex.anisotropic not equal");
      // if (tex.shadowMap != this.shadowMap) this._log.warn("tex.shadowMap not equal");
      // if (tex.texTarget != this.texTarget) this._log.warn("tex.texTarget not equal");
      // if (tex.flip != this.flip) this._log.warn("tex.flip not equal");

      if (!tex) return false;
      return (
        tex.width == this.width &&
        tex.height == this.height &&
        tex.filter == this.filter &&
        tex.wrap == this.wrap &&
        tex.textureType == this.textureType &&
        tex.unpackAlpha == this.unpackAlpha &&
        tex.anisotropic == this.anisotropic &&
        tex.shadowMap == this.shadowMap &&
        tex.texTarget == this.texTarget &&
        tex.flip == this.flip
      );
    }

    /**
     * returns a new texture with the same settings (does not copy texture itself)
     * @function clone
     * @memberof Texture
     * @instance
     * @returns {Texture}
     */
    clone() {
      const newTex = new Texture(this._cgl, {
        name: this.name,
        filter: this.filter,
        anisotropic: this.anisotropic,
        wrap: this.wrap,
        textureType: this.textureType,
        pixelFormat: this.pixelFormat,
        unpackAlpha: this.unpackAlpha,
        flip: this.flip,
        width: this.width,
        height: this.height,
      });

      this._cgl.profileData.addHeavyEvent(
        "texture created",
        this.name,
        this.width + "x" + this.height,
      );

      if (!this.compareSettings(newTex)) {
        this._log.error("Cloned texture settings do not compare!");
        this._log.error(this);
        this._log.error(newTex);
      }

      return newTex;
    }

    /**
     * @param {object} o
     */
    setFormat(o) {
      this.pixelFormat = o.pixelFormat;
      this._glDataFormat = o.glDataFormat;
      this._glInternalFormat = o.glInternalFormat;
      this._glDataType = o.glDataType;
    }

    /**
     * set pixel size of texture
     * @function setSize
     * @memberof Texture
     * @instance
     * @param {Number} w width
     * @param {Number} h height
     */
    setSize(w, h) {
      if (this._cgl.aborted) return;
      if (w != w || w <= 0 || !w) w = DEFAULT_TEXTURE_SIZE;
      if (h != h || h <= 0 || !h) h = DEFAULT_TEXTURE_SIZE;

      if (w > this._cgl.maxTexSize || h > this._cgl.maxTexSize)
        this._log.error(
          "texture size too big! " +
            w +
            "x" +
            h +
            " / max: " +
            this._cgl.maxTexSize,
        );

      w = Math.min(w, this._cgl.maxTexSize);
      h = Math.min(h, this._cgl.maxTexSize);

      w = Math.floor(w);
      h = Math.floor(h);
      if (this.width == w && this.height == h) return;

      w = this._cgl.checkTextureSize(w);
      h = this._cgl.checkTextureSize(h);

      this.width = w;
      this.height = h;
      this.deleted = false;

      this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

      this.shortInfoString = this.getInfoOneLine(); // w + "x" + h + "";

      this._cgl.gl.bindTexture(this.texTarget, this.tex);
      this._cgl.profileData.profileTextureResize++;

      const uarr = null;

      this._cgl.gl.texImage2D(
        this.texTarget,
        0,
        this._glInternalFormat,
        w,
        h,
        0,
        this._glDataFormat,
        this._glDataType,
        uarr,
      );

      this._setFilter();

      this.updateMipMap();

      this._cgl.gl.bindTexture(this.texTarget, null);
    }

    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap) {
      this.filter = filter;
      this.wrap = wrap;
      if (filter == undefined) this.filter = Texture.FILTER_LINEAR;
      if (wrap == undefined) this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
      this.width = w;
      this.height = h;
      this._fromData = true;
      this.deleted = false;

      if (
        this.height > this._cgl.maxTexSize ||
        this.width > this._cgl.maxTexSize
      ) {
        const t = CGL.Texture.getTempTexture(this._cgl);
        this.width = t.width;
        this.height = t.height;
        this.tex = t.tex;
        this._log.warn(
          "[cgl_texture] texture size too big!",
          this.width,
          this.height,
          this._cgl.maxTexSize,
        );
        return;
      }

      if (this.flip)
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip);

      this._cgl.gl.bindTexture(this.texTarget, this.tex);

      this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

      this._cgl.gl.texImage2D(
        this.texTarget,
        0,
        this._glInternalFormat,
        w,
        h,
        0,
        this._glDataFormat,
        this._glDataType,
        data,
      );

      this._setFilter();
      this.updateMipMap();

      if (this.flip)
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);
      this._cgl.gl.bindTexture(this.texTarget, null);
    }

    updateMipMap() {
      if (
        (this._cgl.glVersion == 2 || this.isPowerOfTwo()) &&
        this.filter == Texture.FILTER_MIPMAP
      ) {
        this._cgl.gl.generateMipmap(this.texTarget);
        this._cgl.profileData.profileGenMipMap++;
      }
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter = null) {
      this._cgl.printError("before initTexture");
      this._cgl.checkFrameStarted("texture inittexture");
      this._fromData = false;

      this._cgl.gl.pixelStorei(
        this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        this.unpackAlpha,
      );
      if (img.width || img.videoWidth) this.width = img.videoWidth || img.width;
      if (img.height || img.videoHeight)
        this.height = img.videoHeight || img.height;

      if (filter !== null) this.filter = filter; // todo: can we remove this filter param?

      if (img.height > this._cgl.maxTexSize || img.width > this._cgl.maxTexSize) {
        const t = CGL.Texture.getTempTexture(this._cgl);
        this.width = t.width;
        this.height = t.height;
        this.tex = t.tex;
        this._log.warn(
          "[cgl_texture] texture size too big!",
          img.width,
          img.height,
          this._cgl.maxTexSize,
        );
        return;
      }

      this._cgl.gl.bindTexture(this.texTarget, this.tex);

      this.deleted = false;
      this.flipped = !this.flip;
      if (this.flipped)
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flipped);

      this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

      this._cgl.gl.texImage2D(
        this.texTarget,
        0,
        this._glInternalFormat,
        this._glDataFormat,
        this._glDataType,
        img,
      );

      this._setFilter();
      this.updateMipMap();

      this._cgl.gl.bindTexture(this.texTarget, null);
      this._cgl.gl.pixelStorei(
        this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        false,
      );
      if (this.flipped)
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);

      this.getInfoOneLine();
      this._cgl.printError("initTexture");
    }

    /**
     * delete texture. use this when texture is no longer needed
     * @function delete
     * @memberof Texture
     * @instance
     */
    dispose() {
      this.delete();
    }

    delete() {
      if (this.loading) {
        // cant delete texture when still loading
        // setTimeout(this.delete.bind(this), 50);
        return;
      }

      this.deleted = true;
      this.width = 0;
      this.height = 0;
      this._cgl.profileData.profileTextureDelete++;
      this._cgl.gl.deleteTexture(this.tex);
      this.image = null;

      this.tex = null;
    }

    /**
     * @function isPowerOfTwo
     * @memberof Texture
     * @instance
     * @description return true if texture width and height are both power of two
     * @return {Boolean}
     */
    isPowerOfTwo() {
      return (
        Texture.isPowerOfTwo(this.width) && Texture.isPowerOfTwo(this.height)
      );
    }

    printInfo() {
      log$4.log(this.getInfo());
    }

    getInfoReadable() {
      const info = this.getInfo();
      let html = "";

      info.name = info.name.substr(0, info.name.indexOf("?rnd="));

      for (const i in info) {
        html += "* " + i + ":  **" + info[i] + "**\n";
      }

      return html;
    }

    getInfoOneLine() {
      let txt = "" + this.width + "x" + this.height;
      txt += " ";
      // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
      // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
      txt += this.pixelFormat;

      if (this.filter === Texture.FILTER_NEAREST) txt += " nearest";
      if (this.filter === Texture.FILTER_LINEAR) txt += " linear";
      if (this.filter === Texture.FILTER_MIPMAP) txt += " mipmap";

      if (this.wrap === Texture.WRAP_CLAMP_TO_EDGE) txt += " clamp";
      if (this.wrap === Texture.WRAP_REPEAT) txt += " repeat";
      if (this.wrap === Texture.WRAP_MIRRORED_REPEAT) txt += " repeatmir";

      this.shortInfoString = txt;

      return txt;
    }

    getInfoOneLineShort() {
      let txt = "" + this.width + "x" + this.height;
      // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
      txt += " ";
      txt += this.pixelFormat;

      this.shortInfoString = txt;

      return txt;
    }

    getInfo() {
      return Texture.getTexInfo(this);
    }

    _setFilter() {
      this._cgl.printError("before _setFilter");

      if (!this._fromData) {
        this._cgl.gl.pixelStorei(
          this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
          this.unpackAlpha,
        );
      }

      if (this.shadowMap) {
        this._cgl.gl.texParameteri(
          this._cgl.gl.TEXTURE_2D,
          this._cgl.gl.TEXTURE_COMPARE_MODE,
          this._cgl.gl.COMPARE_REF_TO_TEXTURE,
        );
        this._cgl.gl.texParameteri(
          this._cgl.gl.TEXTURE_2D,
          this._cgl.gl.TEXTURE_COMPARE_FUNC,
          this._cgl.gl.LEQUAL,
        );
      }

      if (
        this.textureType == Texture.TYPE_FLOAT &&
        this.filter == Texture.FILTER_MIPMAP
      ) {
        this.filter = Texture.FILTER_LINEAR;
        this._log.stack(
          "texture: HDR and mipmap filtering at the same time is not possible",
        );
      }

      if (this._cgl.glVersion == 1 && !this.isPowerOfTwo()) {
        this._cgl.gl.texParameteri(
          this.texTarget,
          this._cgl.gl.TEXTURE_MAG_FILTER,
          this._cgl.gl.NEAREST,
        );
        this._cgl.gl.texParameteri(
          this.texTarget,
          this._cgl.gl.TEXTURE_MIN_FILTER,
          this._cgl.gl.NEAREST,
        );

        this._cgl.gl.texParameteri(
          this.texTarget,
          this._cgl.gl.TEXTURE_WRAP_S,
          this._cgl.gl.CLAMP_TO_EDGE,
        );
        this._cgl.gl.texParameteri(
          this.texTarget,
          this._cgl.gl.TEXTURE_WRAP_T,
          this._cgl.gl.CLAMP_TO_EDGE,
        );

        this.filter = Texture.FILTER_NEAREST;
        this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
      } else {
        if (this.wrap == Texture.WRAP_CLAMP_TO_EDGE) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_S,
            this._cgl.gl.CLAMP_TO_EDGE,
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_T,
            this._cgl.gl.CLAMP_TO_EDGE,
          );
        } else if (this.wrap == Texture.WRAP_REPEAT) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_S,
            this._cgl.gl.REPEAT,
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_T,
            this._cgl.gl.REPEAT,
          );
        } else if (this.wrap == Texture.WRAP_MIRRORED_REPEAT) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_S,
            this._cgl.gl.MIRRORED_REPEAT,
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_T,
            this._cgl.gl.MIRRORED_REPEAT,
          );
        }

        if (this.filter == Texture.FILTER_NEAREST) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MAG_FILTER,
            this._cgl.gl.NEAREST,
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MIN_FILTER,
            this._cgl.gl.NEAREST,
          );
        } else if (this.filter == Texture.FILTER_LINEAR) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MIN_FILTER,
            this._cgl.gl.LINEAR,
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MAG_FILTER,
            this._cgl.gl.LINEAR,
          );
        } else if (this.filter == Texture.FILTER_MIPMAP) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MAG_FILTER,
            this._cgl.gl.LINEAR,
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MIN_FILTER,
            this._cgl.gl.LINEAR_MIPMAP_LINEAR,
          );
        } else {
          this._log.log("unknown texture filter!", this.filter);
          throw new Error("unknown texture filter!" + this.filter);
        }

        if (this.anisotropic) {
          const ext = this._cgl.enableExtension("EXT_texture_filter_anisotropic");

          if (this._cgl.maxAnisotropic) {
            const aniso = Math.min(this._cgl.maxAnisotropic, this.anisotropic);
            this._cgl.gl.texParameterf(
              this._cgl.gl.TEXTURE_2D,
              ext.TEXTURE_MAX_ANISOTROPY_EXT,
              aniso,
            );
          }
        }
      }
      this.getInfoOneLine();
      this._cgl.printError("_setFilter");
    }
  };

  /**
   * @function load
   * @static
   * @memberof Texture
   * @description load an image from an url
   * @param {CglContext} cgl
   * @param {String} url
   * @param {Function} finishedCallback
   * @param {Object} settings
   * @return {Texture}
   */
  Texture$1.load = function (cgl, url, finishedCallback, settings) {
    if (!url) return finishedCallback({ error: true });
    let loadingId = null;
    if (!cgl.patch.loading.existByName(url))
      loadingId = cgl.patch.loading.start("cgl.texture", url);

    const texture = new Texture$1(cgl);
    texture.name = url;

    texture.image = new Image();
    texture.image.crossOrigin = "anonymous";
    texture.loading = true;

    if (settings && settings.hasOwnProperty("filter"))
      texture.filter = settings.filter;
    if (settings && settings.hasOwnProperty("flip")) texture.flip = settings.flip;
    if (settings && settings.hasOwnProperty("wrap")) texture.wrap = settings.wrap;
    if (settings && settings.hasOwnProperty("anisotropic"))
      texture.anisotropic = settings.anisotropic;
    if (settings && settings.hasOwnProperty("unpackAlpha"))
      texture.unpackAlpha = settings.unpackAlpha;
    if (settings && settings.hasOwnProperty("pixelFormat"))
      texture.pixelFormat = settings.pixelFormat;

    texture.image.onabort = texture.image.onerror = (e) => {
      console.warn("[cgl.texture.load] error loading texture", url, e);
      texture.loading = false;
      if (loadingId) cgl.patch.loading.finished(loadingId);
      const error = { error: true };
      if (finishedCallback) finishedCallback(error, texture);
    };

    texture.image.onload = function (e) {
      cgl.addNextFrameOnceCallback(() => {
        texture.initTexture(texture.image);
        if (loadingId) cgl.patch.loading.finished(loadingId);
        texture.loading = false;

        if (finishedCallback) finishedCallback(null, texture);
      });
    };
    texture.image.src = url;

    return texture;
  };

  /**
   * @static
   * @function getTempTexture
   * @memberof Texture
   * @description returns the default temporary texture (grey diagonal stipes)
   // * @param {CglContext} cgl
   * @return {Texture}
   */
  Texture$1.getTempTexture = function (cgl) {
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.tempTexture)
      cgl.tempTexture = Texture$1.getTemporaryTexture(
        cgl,
        256,
        Texture$1.FILTER_LINEAR,
        Texture$1.REPEAT,
      );
    return cgl.tempTexture;
  };

  /**
   * @static
   * @function getErrorTexture
   * @memberof Texture
   * @description returns the default temporary texture (grey diagonal stipes)
   * @param {CglContext} cgl
   * @return {Texture}
   */
  Texture$1.getErrorTexture = function (cgl) {
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.errorTexture)
      cgl.errorTexture = Texture$1.getTemporaryTexture(
        cgl,
        256,
        Texture$1.FILTER_LINEAR,
        Texture$1.REPEAT,
        1,
        0.2,
        0.2,
      );
    return cgl.errorTexture;
  };

  /**
   * @function getEmptyTexture
   * @memberof Texture
   * @instance
   * @param cgl
   * @param fp
   * @description returns a reference to a small empty (transparent) texture
   * @return {Texture}
   */
  Texture$1.getEmptyTexture = function (cgl, fp) {
    if (fp) return Texture$1.getEmptyTextureFloat(cgl);
    if (!cgl) console.error("[getEmptyTexture] no cgl!");
    if (cgl.tempTextureEmpty) return cgl.tempTextureEmpty;

    let size = 8;

    cgl.tempTextureEmpty = new Texture$1(cgl, { name: "emptyTexture" });
    const data = Texture$1.getDefaultTextureData("empty", size);

    cgl.tempTextureEmpty.initFromData(
      data,
      size,
      size,
      Texture$1.FILTER_NEAREST,
      Texture$1.WRAP_REPEAT,
    );

    return cgl.tempTextureEmpty;
  };

  /**
   * @function getEmptyTextureFloat
   * @memberof Texture
   * @instance
   * @param cgl
   * @description returns a reference to a small empty (transparent) 32bit texture
   * @return {Texture}
   */
  Texture$1.getEmptyTextureFloat = function (cgl) {
    if (!cgl) console.error("[getEmptyTextureFloat] no cgl!");
    if (cgl.tempTextureEmptyFloat) return cgl.tempTextureEmptyFloat;

    cgl.tempTextureEmptyFloat = new Texture$1(cgl, {
      name: "emptyTexture",
      isFloatingPointTexture: true,
    });
    const data = new Float32Array(8 * 8 * 4).fill(1);
    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;

    cgl.tempTextureEmptyFloat.initFromData(
      data,
      8,
      8,
      Texture$1.FILTER_NEAREST,
      Texture$1.WRAP_REPEAT,
    );

    return cgl.tempTextureEmptyFloat;
  };

  /**
   * @function getRandomTexture
   * @memberof Texture
   * @static
   * @param cgl
   * @description returns a reference to a random texture
   * @return {Texture}
   */
  Texture$1.getRandomTexture = function (cgl) {
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.randomTexture) return cgl.randomTexture;

    const size = 256;
    const data = Texture$1.getDefaultTextureData("randomUInt", size);

    cgl.randomTexture = new Texture$1(cgl);
    cgl.randomTexture.initFromData(
      data,
      size,
      size,
      Texture$1.FILTER_NEAREST,
      Texture$1.WRAP_REPEAT,
    );

    return cgl.randomTexture;
  };

  /**
   * @function getRandomFloatTexture
   * @memberof Texture
   * @static
   * @param cgl
   * @description returns a reference to a texture containing random numbers between -1 and 1
   * @return {Texture}
   */
  Texture$1.getRandomFloatTexture = function (cgl) {
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.getRandomFloatTexture) return cgl.getRandomFloatTexture;

    const size = 256;
    const data = Texture$1.getDefaultTextureData("randomFloat", size);

    cgl.getRandomFloatTexture = new Texture$1(cgl, {
      isFloatingPointTexture: true,
    });
    cgl.getRandomFloatTexture.initFromData(
      data,
      size,
      size,
      Texture$1.FILTER_NEAREST,
      Texture$1.WRAP_REPEAT,
    );

    return cgl.getRandomFloatTexture;
  };

  /**
   * @function getBlackTexture
   * @memberof Texture
   * @static
   * @param {CglContext} cgl
   * @description returns a reference to a black texture
   * @return {Texture}
   */
  Texture$1.getBlackTexture = function (cgl) {
    if (cgl.blackTexture) return cgl.blackTexture;

    const size = 8;
    const data = Texture$1.getDefaultTextureData("color", size, {
      r: 0,
      g: 0,
      b: 0,
    });

    cgl.blackTexture = new Texture$1(cgl);
    cgl.blackTexture.initFromData(
      data,
      size,
      size,
      Texture$1.FILTER_NEAREST,
      Texture$1.WRAP_REPEAT,
    );

    return cgl.blackTexture;
  };

  /**
   * @function getEmptyCubemapTexture
   * @memberof Texture
   * @static
   * @param cgl
   * @description returns an empty cubemap texture with rgba = [0, 0, 0, 0]
   * @return {Texture}
   */
  Texture$1.getEmptyCubemapTexture = function (cgl) {
    const faces = [
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
    ];

    const tex = cgl.gl.createTexture();
    const target = cgl.gl.TEXTURE_CUBE_MAP;
    const filter = Texture$1.FILTER_NEAREST;
    const wrap = Texture$1.WRAP_CLAMP_TO_EDGE;
    const width = 8;
    const height = 8;

    cgl.profileData.profileTextureNew++;

    cgl.gl.bindTexture(target, tex);
    cgl.profileData.profileTextureResize++;

    for (let i = 0; i < 6; i += 1) {
      const data = new Uint8Array(8 * 8 * 4);

      cgl.gl.texImage2D(
        faces[i],
        0,
        cgl.gl.RGBA,
        8,
        8,
        0,
        cgl.gl.RGBA,
        cgl.gl.UNSIGNED_BYTE,
        data,
      );
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.NEAREST);
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.NEAREST);

      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);
    }

    cgl.gl.bindTexture(target, null);

    return {
      id: CABLES.uuid(),
      tex: tex,
      cubemap: tex,
      width: width,
      height: height,
      filter: filter,
      wrap: wrap,
      unpackAlpha: true,
      flip: true,
      _fromData: true,
      name: "emptyCubemapTexture",
      anisotropic: 0,
    };
  };

  Texture$1.getTempGradientTexture = function (cgl) {
    // deprecated...
    if (!cgl) console.error("[getTempGradientTexture] no cgl!");
    return Texture$1.getTempTexture(cgl);
  };

  Texture$1.getTemporaryTexture = function (cgl, size, filter, wrap, r, g, b) {
    const data = Texture$1.getDefaultTextureData("stripes", 256, {
      r: r,
      g: g,
      b: b,
    });
    const temptex = new Texture$1(cgl);
    temptex.initFromData(data, size, size, filter, wrap);
    return temptex;
  };

  /**
   * @static
   * @function createFromImage
   * @memberof Texture
   * @description create texturem from image data (e.g. image or canvas)
   * @param {CglContext} cgl
   * @param {Object} img image
   * @param {Object} options
   */
  Texture$1.createFromImage = function (cgl, img, options) {
    options = options || {};
    const texture = new Texture$1(cgl, options);
    texture.flip = false;
    texture.image = img;
    texture.width = img.videoWidth || img.width || 8;
    texture.height = img.videoHeight || img.height || 8;
    if (options.hasOwnProperty("wrap")) texture.wrap = options.wrap;

    texture.initTexture(img, options.filter);

    return texture;
  };

  // deprecated!
  Texture$1.fromImage = function (cgl, img, filter, wrap) {
    console.error("deprecated texture from image...");

    const texture = new Texture$1(cgl);
    texture.flip = false;
    if (filter) texture.filter = filter;
    if (wrap) texture.wrap = wrap;
    texture.image = img;
    texture.initTexture(img);
    return texture;
  };

  /**
   * @static
   * @function isPowerOfTwo
   * @memberof Texture
   * @description returns true if x is power of two
   * @param {Number} x
   * @return {Boolean}
   */
  Texture$1.isPowerOfTwo = function (x) {
    return (
      x == 1 ||
      x == 2 ||
      x == 4 ||
      x == 8 ||
      x == 16 ||
      x == 32 ||
      x == 64 ||
      x == 128 ||
      x == 256 ||
      x == 512 ||
      x == 1024 ||
      x == 2048 ||
      x == 4096 ||
      x == 8192 ||
      x == 16384
    );
  };

  Texture$1.getTexInfo = function (tex) {
    const obj = {};

    obj.name = tex.name;
    obj["power of two"] = tex.isPowerOfTwo();
    obj.size = tex.width + " x " + tex.height;

    let targetString = tex.texTarget;
    if (tex.texTarget == tex._cgl.gl.TEXTURE_2D) targetString = "TEXTURE_2D";
    obj.target = targetString;

    obj.unpackAlpha = tex.unpackAlpha;

    if (tex.cubemap) obj.cubemap = true;

    if (tex.textureType == Texture$1.TYPE_FLOAT) obj.textureType = "TYPE_FLOAT";
    if (tex.textureType == Texture$1.TYPE_HALF_FLOAT)
      obj.textureType = "TYPE_HALF_FLOAT";
    else if (tex.textureType == Texture$1.TYPE_DEPTH)
      obj.textureType = "TYPE_DEPTH";
    else if (tex.textureType == Texture$1.TYPE_DEFAULT)
      obj.textureType = "TYPE_DEFAULT";
    else obj.textureType = "UNKNOWN " + this.textureType;

    if (tex.wrap == Texture$1.WRAP_CLAMP_TO_EDGE) obj.wrap = "CLAMP_TO_EDGE";
    else if (tex.wrap == Texture$1.WRAP_REPEAT) obj.wrap = "WRAP_REPEAT";
    else if (tex.wrap == Texture$1.WRAP_MIRRORED_REPEAT)
      obj.wrap = "WRAP_MIRRORED_REPEAT";
    else obj.wrap = "UNKNOWN";

    if (tex.filter == Texture$1.FILTER_NEAREST) obj.filter = "FILTER_NEAREST";
    else if (tex.filter == Texture$1.FILTER_LINEAR) obj.filter = "FILTER_LINEAR";
    else if (tex.filter == Texture$1.FILTER_MIPMAP) obj.filter = "FILTER_MIPMAP";
    else obj.filter = "UNKNOWN";

    obj.pixelFormat = tex.pixelFormat || "unknown";

    return obj;
  };

  Texture$1.setUpGlPixelFormat = function (cgl, pixelFormatStr) {
    const o = {};

    if (!pixelFormatStr) {
      cgl._log.error("no pixelformatstr!");
      cgl._log.log(new Error());
      pixelFormatStr = Texture$1.PFORMATSTR_RGBA8UB;
    }

    o.pixelFormatBase = pixelFormatStr;
    o.pixelFormat = pixelFormatStr;
    o.glDataType = cgl.gl.UNSIGNED_BYTE;
    o.glInternalFormat = cgl.gl.RGBA8;
    o.glDataFormat = cgl.gl.RGBA;

    let floatDatatype = cgl.gl.FLOAT;

    if (cgl.glUseHalfFloatTex) {
      if (pixelFormatStr == Texture$1.PFORMATSTR_RGBA32F)
        pixelFormatStr = Texture$1.PFORMATSTR_RGBA16F;
      if (pixelFormatStr == Texture$1.PFORMATSTR_RG32F)
        pixelFormatStr = Texture$1.PFORMATSTR_RG16F;
      if (pixelFormatStr == Texture$1.PFORMATSTR_R32F)
        pixelFormatStr = Texture$1.PFORMATSTR_R16F;
    }

    if (pixelFormatStr.includes("16bit")) {
      if (cgl.glVersion == 2) {
        // cgl.enableExtension("OES_texture_half_float");
        const hasExt = cgl.enableExtension("EXT_color_buffer_half_float");

        if (!hasExt) {
          console.warn("no 16bit extension, fallback to 32bit", pixelFormatStr);
          // fallback to 32 bit?
          if (pixelFormatStr == Texture$1.PFORMATSTR_RGBA16F)
            pixelFormatStr = Texture$1.PFORMATSTR_RGBA32F;
          if (pixelFormatStr == Texture$1.PFORMATSTR_RGB16F)
            pixelFormatStr = Texture$1.PFORMATSTR_RGB32F;
          if (pixelFormatStr == Texture$1.PFORMATSTR_RG16F)
            pixelFormatStr = Texture$1.PFORMATSTR_RG32F;
          if (pixelFormatStr == Texture$1.PFORMATSTR_R16F)
            pixelFormatStr = Texture$1.PFORMATSTR_R32F;
        } else {
          floatDatatype = cgl.gl.HALF_FLOAT;
        }
      }
    }

    if (cgl.glVersion == 1) {
      o.glInternalFormat = cgl.gl.RGBA;

      if (
        pixelFormatStr == Texture$1.PFORMATSTR_RGBA16F ||
        pixelFormatStr == Texture$1.PFORMATSTR_RG16F ||
        pixelFormatStr == Texture$1.PFORMATSTR_R16F
      ) {
        const ext = cgl.enableExtension("OES_texture_half_float");
        if (!ext) throw new Error("no half float texture extension");

        floatDatatype = ext.HALF_FLOAT_OES;
      }
    }

    if (pixelFormatStr == Texture$1.PFORMATSTR_RGBA8UB) ; else if (pixelFormatStr == Texture$1.PFORMATSTR_RGB565) {
      o.glInternalFormat = cgl.gl.RGB565;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_R8UB) {
      o.glInternalFormat = cgl.gl.R8;
      o.glDataFormat = cgl.gl.RED;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_RG8UB) {
      o.glInternalFormat = cgl.gl.RG8;
      o.glDataFormat = cgl.gl.RG;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_RGB8UB) {
      o.glInternalFormat = cgl.gl.RGB8;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_SRGBA8) {
      o.glInternalFormat = cgl.gl.SRGB8_ALPHA8;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_R32F) {
      o.glInternalFormat = cgl.gl.R32F;
      o.glDataFormat = cgl.gl.RED;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_R16F) {
      o.glInternalFormat = cgl.gl.R16F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RED;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_RG16F) {
      o.glInternalFormat = cgl.gl.RG16F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RG;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_RGBA16F) {
      if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
      else o.glInternalFormat = cgl.gl.RGBA16F;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_R11FG11FB10F) {
      o.glInternalFormat = cgl.gl.R11F_G11F_B10F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_RGBA32F) {
      if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
      else o.glInternalFormat = cgl.gl.RGBA32F;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture$1.PFORMATSTR_DEPTH) {
      if (cgl.glVersion == 1) {
        o.glInternalFormat = cgl.gl.DEPTH_COMPONENT;
        o.glDataType = cgl.gl.UNSIGNED_SHORT;
        o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
      } else {
        o.glInternalFormat = cgl.gl.DEPTH_COMPONENT32F;
        o.glDataType = cgl.gl.FLOAT;
        o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
      }
    } else {
      log$4.log("unknown pixelformat ", pixelFormatStr);
    }

    /// //////

    if (
      pixelFormatStr.includes("32bit") ||
      pixelFormatStr == Texture$1.PFORMATSTR_R11FG11FB10F
    ) {
      if (cgl.glVersion == 2) cgl.enableExtension("EXT_color_buffer_float");
      if (cgl.glVersion == 2) cgl.enableExtension("EXT_float_blend");

      cgl.enableExtension("OES_texture_float_linear"); // yes, i am sure, this is a webgl 1 and 2 ext
    }

    o.numColorChannels = Texture$1.getPixelFormatNumChannels(pixelFormatStr);

    if (!o.glDataType || !o.glInternalFormat || !o.glDataFormat)
      log$4.log(
        "pixelformat wrong ?!",
        pixelFormatStr,
        o.glDataType,
        o.glInternalFormat,
        o.glDataFormat,
        this,
      );

    return o;
  };

  Texture$1.getPixelFormatNumChannels = (pxlFrmtStr) => {
    if (pxlFrmtStr.startsWith("RGBA")) return 4;
    if (pxlFrmtStr.startsWith("RGB")) return 3;
    if (pxlFrmtStr.startsWith("RG")) return 2;
    return 1;
  };

  Texture$1.isPixelFormatFloat = (pxlFrmtStr) => {
    return (pxlFrmtStr || "").includes("float");
  };

  Texture$1.isPixelFormatHalfFloat = (pxlFrmtStr) => {
    return (
      (pxlFrmtStr || "").includes("float") && (pxlFrmtStr || "").includes("16bit")
    );
  };

  /**
   * bounding box
   *
   * @namespace external:CGL
   * @param {Geometry} geometry or bounding box
   */
  class BoundingBox {
    /**
     * @param {Geometry} geom
     */
    constructor(geom) {
      this._init();
      this._first = true;
      this._wireMesh = null;

      if (geom) this.apply(geom);
    }

    _init() {
      this._max = [-0, -0, -0];
      this._min = [0, 0, 0];
      this._center = [0, 0, 0];
      this._size = [0, 0, 0];
      this._maxAxis = 0.0;
      this._first = true;
    }

    /**
     * get biggest number of maxX,maxY,maxZ
     * @type {Number}
     */
    get maxAxis() {
      return this._maxAxis || 1;
    }

    /**
     * size of bounding box
     * @type {vec3}
     */
    get size() {
      return this._size;
    }

    /**
     * center of bounding box
     * @type {vec3}
     */
    get center() {
      return this._center;
    }

    /**
     * center x
     * @type {Number}
     */
    get x() {
      return this._center[0];
    }

    /**
     * center y
     * @type {Number}
     */
    get y() {
      return this._center[1];
    }

    /**
     * center z
     * @type {Number}
     */
    get z() {
      return this._center[2];
    }

    /**
     * minimum x
     * @type {Number}
     */
    get minX() {
      return this._min[0];
    }

    /**
     * minimum y
     * @type {Number}
     */
    get minY() {
      return this._min[1];
    }

    /**
     * minimum z
     * @type {Number}
     */
    get minZ() {
      return this._min[2];
    }

    /**
     * maximum x
     * @type {Number}
     */
    get maxX() {
      return this._max[0];
    }

    /**
     * maximum y
     * @type {Number}
     */
    get maxY() {
      return this._max[1];
    }

    /**
     * maximum z
     * @type {Number}
     */
    get maxZ() {
      return this._max[2];
    }

    /**
     * @param {Geometry} geom
     */
    apply(geom) {
      if (!geom) return;

      if (geom instanceof BoundingBox) {
        const bb = geom;

        this.applyPos(bb.maxX, bb.maxY, bb.maxZ);
        this.applyPos(bb.minX, bb.minY, bb.minZ);
      } else {
        for (let i = 0; i < geom.vertices.length; i += 3)
          this.applyPos(
            geom.vertices[i],
            geom.vertices[i + 1],
            geom.vertices[i + 2],
          );
      }
      this.calcCenterSize();
    }

    /**
     * returns a copy of the bounding box
     * @function copy
     * @memberof BoundingBox
     * @instance
     */
    copy() {
      return new BoundingBox(this);
    }

    get changed() {
      return !(
        this._max[0] == -Number.MAX_VALUE &&
        this._max[1] == -Number.MAX_VALUE &&
        this._max[2] == -Number.MAX_VALUE
      );
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    applyPos(x, y, z) {
      if (
        x == Number.MAX_VALUE ||
        x == -Number.MAX_VALUE ||
        y == Number.MAX_VALUE ||
        y == -Number.MAX_VALUE ||
        z == Number.MAX_VALUE ||
        z == -Number.MAX_VALUE
      )
        return;

      if (!CABLES.isNumeric(x) || !CABLES.isNumeric(y) || !CABLES.isNumeric(z))
        return;

      if (this._first) {
        this._max[0] = x;
        this._max[1] = y;
        this._max[2] = z;

        this._min[0] = x;
        this._min[1] = y;
        this._min[2] = z;
        this._first = false;
        return;
      }

      this._max[0] = Math.max(this._max[0], x);
      this._max[1] = Math.max(this._max[1], y);
      this._max[2] = Math.max(this._max[2], z);

      this._min[0] = Math.min(this._min[0], x);
      this._min[1] = Math.min(this._min[1], y);
      this._min[2] = Math.min(this._min[2], z);
    }

    calcCenterSize() {
      if (this._first) return;

      this._size[0] = this._max[0] - this._min[0];
      this._size[1] = this._max[1] - this._min[1];
      this._size[2] = this._max[2] - this._min[2];

      this._center[0] = (this._min[0] + this._max[0]) / 2;
      this._center[1] = (this._min[1] + this._max[1]) / 2;
      this._center[2] = (this._min[2] + this._max[2]) / 2;

      this._maxAxis = Math.max(
        this._size[2],
        Math.max(this._size[0], this._size[1]),
      );
    }

    /**
     * @param {mat4} m
     */
    mulMat4(m) {
      if (this._first) {
        this._max[0] = 0;
        this._max[1] = 0;
        this._max[2] = 0;

        this._min[0] = 0;
        this._min[1] = 0;
        this._min[2] = 0;
        this._first = false;
      }
      transformMat4$2(this._max, this._max, m);
      transformMat4$2(this._min, this._min, m);
      this.calcCenterSize();
    }

    /**
     * @param {CglContext} cgl
     * @param {Shader} _shader
     * @param {Op} op
     */
    render(cgl, _shader, op) {
      if (!this._wireMesh) this._wireMesh = new CGL.WireCube(cgl);

      cgl.pushModelMatrix();
      translate$1(cgl.mMatrix, cgl.mMatrix, this._center);

      if (CABLES.UI && op) {
        CABLES.UI.OverlayMeshes.drawCube(
          op,
          this._size[0] / 2,
          this._size[1] / 2,
          this._size[2] / 2,
        );
      }

      cgl.popModelMatrix();
    }
  }

  /**
   * a geometry contains all information about a mesh, vertices, texturecoordinates etc. etc.
   * @param {String} name
   * @example
   * // create a triangle with all attributes
   * const geom=new Geometry("triangle"),
   *
   * geom.vertices = [
   *      0.0,           sizeH.get(),  0.0,
   *     -sizeW.get(),  -sizeH.get(),  0.0,
   *      sizeW.get(),  -sizeH.get(),  0.0 ];
   *
   * geom.vertexNormals = [
   *      0.0,  0.0,  1.0,
   *      0.0,  0.0,  1.0,
   *      0.0,  0.0,  1.0 ];
   *
   * geom.tangents = [
   *     1,0,0,
   *     1,0,0,
   *     1,0,0 ];
   *
   * geom.biTangents = [
   *     0,1,0,
   *     0,1,0,
   *     0,1,0 ];
   *
   * geom.texCoords = [
   *      0.5,  0.0,
   *      1.0,  1.0,
   *      0.0,  1.0, ];
   *
   * geom.verticesIndices = [
   *     0, 1, 2 ];
   *
   */

  class Geometry {
    /**
     * @param {String} name
     */
    constructor(name) {
      this.name = name || "unknown";
      this._log = new Logger("cgl_geometry");

      this.faceVertCount = 3;
      this.glPrimitive = null;
      this._attributes = {};

      /** @type {Array|Float32Array} */
      this._vertices = [];
      this.verticesIndices = [];

      this.isGeometry = true;

      this.morphTargets = [];
    }

    get vertices() {
      return this._vertices;
    }

    set vertices(v) {
      this.setVertices(v);
    }

    get texCoords() {
      const att = this.getAttribute("texCoords");
      if (!att) return [];
      return att.data;
    }

    set texCoords(v) {
      this.setAttribute("texCoords", v, 2);
    }

    get vertexNormals() {
      const att = this.getAttribute("vertexNormals");
      if (!att) return [];
      return att.data;
    }

    set vertexNormals(v) {
      this.setAttribute("vertexNormals", v, 3);
    }

    get tangents() {
      const att = this.getAttribute("tangents");
      if (!att) return [];
      return att.data;
    }

    set tangents(v) {
      this.setAttribute("tangents", v, 3);
    }

    get biTangents() {
      const att = this.getAttribute("biTangents");
      if (!att) return [];
      return att.data;
    }

    set biTangents(v) {
      this.setAttribute("biTangents", v, 3);
    }

    get vertexColors() {
      const att = this.getAttribute("vertexColors");
      if (!att) return [];
      return att.data;
    }

    set vertexColors(v) {
      this.setAttribute("vertexColors", v, 4);
    }

    /**
     * @description clear all buffers/set them to length 0
     */
    clear() {
      this._vertices = new Float32Array([]);
      this.verticesIndices = [];
      this.texCoords = new Float32Array([]);
      this.vertexNormals = new Float32Array([]);
      this.tangents = [];
      this.biTangents = [];
      this._attributes = {};
    }

    /**
     * @return {Object} returns array of attribute objects
     */
    getAttributes() {
      return this._attributes;
    }

    /**
     * @function getAttribute
     * @memberof Geometry
     * @instance
     * @param {String} name
     * @return {Object}
     */
    getAttribute(name) {
      for (const i in this._attributes) {
        if (this._attributes[i].name == name) return this._attributes[i];
      }
      return null;
    }

    /**
     * @function setAttribute
     * @description create an attribute
     * @memberof Geometry
     * @instance
     * @param {String} name
     * @param {Array} arr
     * @param {Number} itemSize
     */
    setAttribute(name, arr, itemSize) {
      let attrType = "";
      if (!itemSize || itemSize > 4) {
        this._log.warn("itemsize wrong?", itemSize, name);
        this._log.stack("itemsize");

        itemSize = 3;
      }

      if (itemSize == 1) attrType = "float";
      else if (itemSize == 2) attrType = "vec2";
      else if (itemSize == 3) attrType = "vec3";
      else if (itemSize == 4) attrType = "vec4";

      const attr = {
        name: name,
        data: arr,
        itemSize: itemSize,
        type: attrType,
      };

      this._attributes[name] = attr;
    }

    /**
     * @param {string} name
     * @param {Geometry} newgeom
     */
    copyAttribute(name, newgeom) {
      const attr = this.getAttribute(name);
      newgeom.setAttribute(name, new Float32Array(attr.data), attr.itemSize);
    }

    /**
     * @function setVertices
     * @memberof Geometry
     * @instance
     * @description set vertices
     * @param {Array|Float32Array} arr [x,y,z,x,y,z,...]
     */
    setVertices(arr) {
      if (arr instanceof Float32Array) this._vertices = arr;
      else this._vertices = new Float32Array(arr);
    }

    /**
     * set texcoords
     * @param {Array|Float32Array} arr [u,v,u,v,...]
     */
    setTexCoords(arr) {
      if (arr instanceof Float32Array) this.texCoords = arr;
      else this.texCoords = new Float32Array(arr);
    }

    // deprecated
    calcNormals(smooth) {
      const options = { smooth: smooth };
      this.calculateNormals(options);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    flipNormals(x, y, z) {
      let vec = create$4();

      if (x == undefined) x = 1;
      if (y == undefined) y = 1;
      if (z == undefined) z = 1;

      for (let i = 0; i < this.vertexNormals.length; i += 3) {
        set$4(
          vec,
          this.vertexNormals[i + 0],
          this.vertexNormals[i + 1],
          this.vertexNormals[i + 2],
        );

        vec[0] *= -x;
        vec[1] *= -y;
        vec[2] *= -z;

        normalize$4(vec, vec);

        this.vertexNormals[i + 0] = vec[0];
        this.vertexNormals[i + 1] = vec[1];
        this.vertexNormals[i + 2] = vec[2];
      }
    }

    getNumTriangles() {
      if (this.verticesIndices && this.verticesIndices.length)
        return this.verticesIndices.length / 3;
      return this.vertices.length / 3;
    }

    /**
     * flip order of vertices in geom faces
     */
    flipVertDir() {
      const newInd = [];
      newInd.length = this.verticesIndices.length;
      for (let i = 0; i < this.verticesIndices.length; i += 3) {
        newInd[i] = this.verticesIndices[i + 2];
        newInd[i + 1] = this.verticesIndices[i + 1];
        newInd[i + 2] = this.verticesIndices[i];
      }
      this.verticesIndices = newInd;
    }

    /**
     * @param {Array} verts
     */
    setPointVertices(verts) {
      if (verts.length % 3 !== 0) {
        this._log.error("SetPointVertices: Array must be multiple of three.");
        return;
      }

      if (!(verts instanceof Float32Array))
        this.vertices = new Float32Array(verts);
      else this.vertices = verts;

      if (!(this.texCoords instanceof Float32Array))
        this.texCoords = new Float32Array((verts.length / 3) * 2);

      // this.texCoords.length=verts.length/3*2;
      this.verticesIndices.length = verts.length / 3;
      // this.verticesIndices=[];

      for (let i = 0; i < verts.length / 3; i++) {
        this.verticesIndices[i] = i;
        this.texCoords[i * 2] = 0;
        this.texCoords[i * 2 + 1] = 0;
      }
    }

    /**
     * merge a different geometry into the this geometry
     * @param {Geometry} geom
     */
    merge(geom) {
      if (!geom) return;

      if (this.isIndexed() != geom.isIndexed()) {
        if (this.isIndexed()) {
          this.unIndex(false, true);
        }
        if (geom.isIndexed()) {
          const g = geom.copy();
          g.unIndex(false, true);
          geom = g;
        }
      }

      const oldIndizesLength = this.verticesIndices.length;
      const vertLength = this._vertices.length / 3;

      this.verticesIndices.length += geom.verticesIndices.length;
      for (let i = 0; i < geom.verticesIndices.length; i++)
        this.verticesIndices[oldIndizesLength + i] =
          geom.verticesIndices[i] + vertLength;

      this.vertices = CABLES.float32Concat(this._vertices, geom.vertices);
      this.texCoords = CABLES.float32Concat(this.texCoords, geom.texCoords);
      this.vertexNormals = CABLES.float32Concat(
        this.vertexNormals,
        geom.vertexNormals,
      );
      this.tangents = CABLES.float32Concat(this.tangents, geom.tangents);
      this.biTangents = CABLES.float32Concat(this.biTangents, geom.biTangents);
    }

    /**
     *   a copy of the geometry
     * @function copy
     * @memberof Geometry
     * @instance
     */
    copy() {
      const geom = new Geometry(this.name + " copy");
      geom.faceVertCount = this.faceVertCount;
      geom.glPrimitive = this.glPrimitive;

      geom.setVertices(this._vertices.slice(0));

      if (this.verticesIndices) {
        geom.verticesIndices.length = this.verticesIndices.length;
        for (let i = 0; i < this.verticesIndices.length; i++)
          geom.verticesIndices[i] = this.verticesIndices[i];
      }

      for (let i in this._attributes) this.copyAttribute(i, geom);

      geom.morphTargets.length = this.morphTargets.length;
      for (let i = 0; i < this.morphTargets.length; i++)
        geom.morphTargets[i] = this.morphTargets[i];

      return geom;
    }

    /**
     * Calculaten normals
     * @function calculateNormals
     * @param {{ smooth?: any; forceZUp?: any; }} options
     */
    calculateNormals(options = null) {
      // todo: should check angle of normals to get edges    https://community.khronos.org/t/calculating-accurate-vertex-normals/28152
      options = options || {};
      if (options.smooth === false) this.unIndex();

      const u = create$4();
      const v = create$4();
      const n = create$4();

      function calcNormal(triangle) {
        subtract$2(u, triangle[0], triangle[1]);
        subtract$2(v, triangle[0], triangle[2]);
        cross$2(n, u, v);
        normalize$4(n, n);

        if (options && options.forceZUp) {
          if (n[2] < 0) {
            n[0] *= -1;
            n[1] *= -1;
            n[2] *= -1;
          }
        }
        return n;
      }

      this.getVertexVec = function (which) {
        const vec = [0, 0, 0];
        vec[0] = this.vertices[which * 3 + 0];
        vec[1] = this.vertices[which * 3 + 1];
        vec[2] = this.vertices[which * 3 + 2];
        return vec;
      };

      if (
        !(this.vertexNormals instanceof Float32Array) ||
        this.vertexNormals.length != this.vertices.length
      )
        this.vertexNormals = new Float32Array(this.vertices.length);

      for (let i = 0; i < this.vertices.length; i++) {
        this.vertexNormals[i] = 0;
      }

      if (!this.isIndexed()) {
        const norms = [];
        for (let i = 0; i < this.vertices.length; i += 9) {
          const triangle = [
            [this.vertices[i + 0], this.vertices[i + 1], this.vertices[i + 2]],
            [this.vertices[i + 3], this.vertices[i + 4], this.vertices[i + 5]],
            [this.vertices[i + 6], this.vertices[i + 7], this.vertices[i + 8]],
          ];
          const nn = calcNormal(triangle);
          norms.push(
            nn[0],
            nn[1],
            nn[2],
            nn[0],
            nn[1],
            nn[2],
            nn[0],
            nn[1],
            nn[2],
          );
        }
        this.vertexNormals = norms;
      } else {
        const faceNormals = [];

        faceNormals.length = Math.floor(this.verticesIndices.length / 3);

        for (let i = 0; i < this.verticesIndices.length; i += 3) {
          const triangle = [
            this.getVertexVec(this.verticesIndices[i + 0]),
            this.getVertexVec(this.verticesIndices[i + 1]),
            this.getVertexVec(this.verticesIndices[i + 2]),
          ];

          faceNormals[i / 3] = calcNormal(triangle);

          this.vertexNormals[this.verticesIndices[i + 0] * 3 + 0] +=
            faceNormals[i / 3][0];
          this.vertexNormals[this.verticesIndices[i + 0] * 3 + 1] +=
            faceNormals[i / 3][1];
          this.vertexNormals[this.verticesIndices[i + 0] * 3 + 2] +=
            faceNormals[i / 3][2];

          this.vertexNormals[this.verticesIndices[i + 1] * 3 + 0] +=
            faceNormals[i / 3][0];
          this.vertexNormals[this.verticesIndices[i + 1] * 3 + 1] +=
            faceNormals[i / 3][1];
          this.vertexNormals[this.verticesIndices[i + 1] * 3 + 2] +=
            faceNormals[i / 3][2];

          this.vertexNormals[this.verticesIndices[i + 2] * 3 + 0] +=
            faceNormals[i / 3][0];
          this.vertexNormals[this.verticesIndices[i + 2] * 3 + 1] +=
            faceNormals[i / 3][1];
          this.vertexNormals[this.verticesIndices[i + 2] * 3 + 2] +=
            faceNormals[i / 3][2];
        }

        for (
          let i = 0;
          i < this.verticesIndices.length;
          i += 3 // faces
        ) {
          for (
            let k = 0;
            k < 3;
            k++ // triangles
          ) {
            const vv = [
              this.vertexNormals[this.verticesIndices[i + k] * 3 + 0],
              this.vertexNormals[this.verticesIndices[i + k] * 3 + 1],
              this.vertexNormals[this.verticesIndices[i + k] * 3 + 2],
            ];
            normalize$4(vv, vv);
            this.vertexNormals[this.verticesIndices[i + k] * 3 + 0] = vv[0];
            this.vertexNormals[this.verticesIndices[i + k] * 3 + 1] = vv[1];
            this.vertexNormals[this.verticesIndices[i + k] * 3 + 2] = vv[2];
          }
        }
      }
    }

    /**
     * Calculates tangents & bitangents with the help of uv-coordinates. Adapted from
     * Lengyel, Eric. Computing Tangent Space Basis Vectors for an Arbitrary Mesh.
     * Terathon Software 3D Graphics Library.
     * https://fenix.tecnico.ulisboa.pt/downloadFile/845043405449073/Tangent%20Space%20Calculation.pdf
     *
     * @function calcTangentsBitangents
     */
    calcTangentsBitangents() {
      if (!this.vertices.length) {
        // this._log.error("Cannot calculate tangents/bitangents without vertices.");
        return;
      }
      if (!this.vertexNormals.length) {
        // this._log.error("Cannot calculate tangents/bitangents without normals.");
        return;
      }
      if (!this.texCoords.length) {
        const texCoordLength = (this.vertices.length / 3) * 2;
        this.texCoords = new Float32Array(texCoordLength);
        for (let i = 0; i < texCoordLength; i += 1) this.texCoords[i] = 0;
      }
      if (!this.verticesIndices || !this.verticesIndices.length) {
        // this._log.error("Cannot calculate tangents/bitangents without vertex indices.");
        return;
      }
      // this code assumes that we have three indices per triangle
      if (this.verticesIndices.length % 3 !== 0) {
        this._log.error("Vertex indices mismatch!");
        return;
      }

      const triangleCount = this.verticesIndices.length / 3;
      const vertexCount = this.vertices.length / 3;

      this.tangents = new Float32Array(this.vertexNormals.length);
      this.biTangents = new Float32Array(this.vertexNormals.length);

      // temporary buffers
      const tempVertices = [];
      tempVertices.length = vertexCount * 2;
      const v1 = create$4();
      const v2 = create$4();
      const v3 = create$4();

      const w1 = create();
      const w2 = create();
      const w3 = create();

      const sdir = create$4();
      const tdir = create$4();

      // for details on calculation, see article referenced above
      for (let tri = 0; tri < triangleCount; tri += 1) {
        // indices of the three vertices for a triangle
        const i1 = this.verticesIndices[tri * 3];
        const i2 = this.verticesIndices[tri * 3 + 1];
        const i3 = this.verticesIndices[tri * 3 + 2];

        // vertex position as vec3
        set$4(
          v1,
          this.vertices[i1 * 3],
          this.vertices[i1 * 3 + 1],
          this.vertices[i1 * 3 + 2],
        );
        set$4(
          v2,
          this.vertices[i2 * 3],
          this.vertices[i2 * 3 + 1],
          this.vertices[i2 * 3 + 2],
        );
        set$4(
          v3,
          this.vertices[i3 * 3],
          this.vertices[i3 * 3 + 1],
          this.vertices[i3 * 3 + 2],
        );

        // texture coordinate as vec2
        set(w1, this.texCoords[i1 * 2], this.texCoords[i1 * 2 + 1]);
        set(w2, this.texCoords[i2 * 2], this.texCoords[i2 * 2 + 1]);
        set(w3, this.texCoords[i3 * 2], this.texCoords[i3 * 2 + 1]);

        const x1 = v2[0] - v1[0];
        const x2 = v3[0] - v1[0];
        const y1 = v2[1] - v1[1];
        const y2 = v3[1] - v1[1];
        const z1 = v2[2] - v1[2];
        const z2 = v3[2] - v1[2];

        const s1 = w2[0] - w1[0];
        const s2 = w3[0] - w1[0];
        const t1 = w2[1] - w1[1];
        const t2 = w3[1] - w1[1];

        const r = 1.0 / (s1 * t2 - s2 * t1);

        set$4(
          sdir,
          (t2 * x1 - t1 * x2) * r,
          (t2 * y1 - t1 * y2) * r,
          (t2 * z1 - t1 * z2) * r,
        );
        set$4(
          tdir,
          (s1 * x2 - s2 * x1) * r,
          (s1 * y2 - s2 * y1) * r,
          (s1 * z2 - s2 * z1) * r,
        );

        tempVertices[i1] = sdir;
        tempVertices[i2] = sdir;
        tempVertices[i3] = sdir;

        tempVertices[i1 + vertexCount] = tdir;
        tempVertices[i2 + vertexCount] = tdir;
        tempVertices[i3 + vertexCount] = tdir;
      }

      const normal = create$4();
      const tempVert = create$4();
      const tan = create$4();
      const bitan = create$4();
      const temp1 = create$4();
      const temp2 = create$4();
      const crossPd = create$4();
      const normalized = create$4();

      for (let vert = 0; vert < vertexCount; vert += 1) {
        // NOTE: some meshes don't have index 0 - n in their indexbuffer, if this is the case, skip calculation of this vertex
        if (!tempVertices[vert]) continue;

        set$4(
          normal,
          this.vertexNormals[vert * 3],
          this.vertexNormals[vert * 3 + 1],
          this.vertexNormals[vert * 3 + 2],
        );
        set$4(
          tempVert,
          tempVertices[vert][0],
          tempVertices[vert][1],
          tempVertices[vert][2],
        );

        // Gram-Schmidt orthagonalize
        const _dp = dot$4(normal, tempVert);
        scale$4(temp1, normal, _dp);
        subtract$2(temp2, tempVert, temp1);

        normalize$4(normalized, temp2);
        cross$2(crossPd, normal, tempVert);

        // const intermDot = vec3.dot(crossPd, tempVertices[vert + vertexCount]);
        const w = 1.0; // intermDot < 0.0 ? -1.0 : 1.0;

        scale$4(tan, normalized, 1 / w);
        cross$2(bitan, normal, tan);

        this.tangents[vert * 3 + 0] = tan[0];
        this.tangents[vert * 3 + 1] = tan[1];
        this.tangents[vert * 3 + 2] = tan[2];
        this.biTangents[vert * 3 + 0] = bitan[0];
        this.biTangents[vert * 3 + 1] = bitan[1];
        this.biTangents[vert * 3 + 2] = bitan[2];
      }
    }

    isIndexed() {
      if (this._vertices.length == 0) return true;
      return this.verticesIndices.length != 0;
    }

    /**
     * @function unIndex
     * @memberof Geometry
     * @instance
     * @description remove all vertex indizes, vertices array will contain 3*XYZ for every triangle
     * @param {boolean} reIndex
     * @param {boolean} dontCalcNormals
     */
    unIndex(reIndex = false, dontCalcNormals = false) {
      const newVerts = [];
      const newIndizes = [];
      let count = 0;

      for (let j in this._attributes) {
        const attr = this._attributes[j];
        let na = [];

        for (let i = 0; i < this.verticesIndices.length; i += 3) {
          for (let s = 0; s < 3; s++) {
            if (attr.itemSize == 3)
              na.push(
                attr.data[this.verticesIndices[i + s] * 3 + 0],
                attr.data[this.verticesIndices[i + s] * 3 + 1],
                attr.data[this.verticesIndices[i + s] * 3 + 2],
              );
            else if (attr.itemSize == 4)
              na.push(
                attr.data[this.verticesIndices[i + s] * 4 + 0],
                attr.data[this.verticesIndices[i + s] * 4 + 1],
                attr.data[this.verticesIndices[i + s] * 4 + 2],
                attr.data[this.verticesIndices[i + s] * 4 + 3],
              );
            else if (attr.itemSize == 2)
              na.push(
                attr.data[this.verticesIndices[i + s] * 2 + 0],
                attr.data[this.verticesIndices[i + s] * 2 + 1],
              );
            else if (attr.itemSize == 1)
              na.push(attr.data[this.verticesIndices[i + s]]);
            else this._log.warn("unknown attr", attr);
          }
        }
        this.setAttribute(attr.name, na, attr.itemSize);
      }

      for (let i = 0; i < this.verticesIndices.length; i += 3) {
        newVerts.push(
          this.vertices[this.verticesIndices[i + 0] * 3 + 0],
          this.vertices[this.verticesIndices[i + 0] * 3 + 1],
          this.vertices[this.verticesIndices[i + 0] * 3 + 2],
        );

        newIndizes.push(count);
        count++;

        newVerts.push(
          this.vertices[this.verticesIndices[i + 1] * 3 + 0],
          this.vertices[this.verticesIndices[i + 1] * 3 + 1],
          this.vertices[this.verticesIndices[i + 1] * 3 + 2],
        );

        newIndizes.push(count);
        count++;

        newVerts.push(
          this.vertices[this.verticesIndices[i + 2] * 3 + 0],
          this.vertices[this.verticesIndices[i + 2] * 3 + 1],
          this.vertices[this.verticesIndices[i + 2] * 3 + 2],
        );

        newIndizes.push(count);
        count++;
      }

      this.vertices = newVerts;

      this.verticesIndices = [];
      if (reIndex) this.verticesIndices = newIndizes;

      if (!dontCalcNormals) this.calculateNormals();
    }

    calcBarycentric() {
      let barycentrics = [];
      barycentrics.length = this.vertices.length;
      for (let i = 0; i < this.vertices.length; i++) barycentrics[i] = 0;

      let count = 0;
      for (let i = 0; i < this.vertices.length; i += 3) {
        barycentrics[i + count] = 1;
        count++;
        if (count == 3) count = 0;
      }

      this.setAttribute("attrBarycentric", barycentrics, 3);
    }

    getBounds() {
      return new BoundingBox(this);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Array} offset
     */
    center(x, y, z) {
      if (x === undefined) {
        x = true;
        y = true;
        z = true;
      }

      let i = 0;
      const bounds = this.getBounds();
      const offset = [
        bounds.minX + (bounds.maxX - bounds.minX) / 2,
        bounds.minY + (bounds.maxY - bounds.minY) / 2,
        bounds.minZ + (bounds.maxZ - bounds.minZ) / 2,
      ];

      for (i = 0; i < this.vertices.length; i += 3) {
        if (this.vertices[i + 0] == this.vertices[i + 0]) {
          if (x) this.vertices[i + 0] -= offset[0];
          if (y) this.vertices[i + 1] -= offset[1];
          if (z) this.vertices[i + 2] -= offset[2];
        }
      }

      return offset;
    }

    mapTexCoords2d() {
      const bounds = this.getBounds();
      const num = this.vertices.length / 3;

      this.texCoords = new Float32Array(num * 2);

      for (let i = 0; i < num; i++) {
        const vertX = this.vertices[i * 3 + 0];
        const vertY = this.vertices[i * 3 + 1];
        this.texCoords[i * 2 + 0] = vertX / (bounds.maxX - bounds.minX) + 0.5;
        this.texCoords[i * 2 + 1] =
          1.0 - vertY / (bounds.maxY - bounds.minY) + 0.5;
      }
    }

    getInfoOneLine() {
      let txt = "";
      if (this.faceVertCount == 3 && this.verticesIndices)
        txt += this.verticesIndices.length / 3;
      else txt += 0;

      txt += " tris ";

      if (this.vertices) txt += this.vertices.length / 3;
      else txt += 0;

      txt += " verts";

      return txt;
    }

    getInfo() {
      const info = {};

      info.name = this.name;
      info.class = this.constructor.name;

      if (this.faceVertCount == 3 && this.verticesIndices)
        info.numFaces = this.verticesIndices.length / 3;
      else info.numFaces = 0;

      if (this.verticesIndices && this.verticesIndices.length)
        info.indices = this.verticesIndices.length;

      if (this.vertices) info.numVerts = this.vertices.length / 3;
      else info.numVerts = 0;

      if (this.vertexNormals) info.numNormals = this.vertexNormals.length / 3;
      else info.numNormals = 0;

      if (this.texCoords) info.numTexCoords = this.texCoords.length / 2;
      else info.numTexCoords = 0;

      if (this.tangents) info.numTangents = this.tangents.length / 3;
      else info.numTangents = 0;

      if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
      else info.numBiTangents = 0;

      if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
      else info.numBiTangents = 0;

      if (this.vertexColors) info.numVertexColors = this.vertexColors.length / 4;
      else info.numVertexColors = 0;

      if (this.getAttributes())
        info.numAttribs = Object.keys(this.getAttributes()).length;
      else info.numAttribs = 0;

      info.isIndexed = this.isIndexed();

      return info;
    }

    // -----------------
  }

  // TODO : rewritwe circle op 1
  /** @deprecated */
  Geometry.buildFromFaces = function (arr, name, optimize) {
    const vertices = [];
    const verticesIndices = [];

    for (let i = 0; i < arr.length; i += 3) {
      const a = arr[i + 0];
      const b = arr[i + 1];
      const c = arr[i + 2];
      const face = [-1, -1, -1];

      if (optimize)
        for (let iv = 0; iv < vertices.length; iv += 3) {
          if (
            vertices[iv + 0] == a[0] &&
            vertices[iv + 1] == a[1] &&
            vertices[iv + 2] == a[2]
          )
            face[0] = iv / 3;
          if (
            vertices[iv + 0] == b[0] &&
            vertices[iv + 1] == b[1] &&
            vertices[iv + 2] == b[2]
          )
            face[1] = iv / 3;
          if (
            vertices[iv + 0] == c[0] &&
            vertices[iv + 1] == c[1] &&
            vertices[iv + 2] == c[2]
          )
            face[2] = iv / 3;
        }

      if (face[0] == -1) {
        vertices.push(a[0], a[1], a[2]);
        face[0] = (vertices.length - 1) / 3;
      }

      if (face[1] == -1) {
        vertices.push(b[0], b[1], b[2]);
        face[1] = (vertices.length - 1) / 3;
      }

      if (face[2] == -1) {
        vertices.push(c[0], c[1], c[2]);
        face[2] = (vertices.length - 1) / 3;
      }

      verticesIndices.push(face[0]);
      verticesIndices.push(face[1]);
      verticesIndices.push(face[2]);
    }

    const geom = new Geometry(name);
    geom.name = name;
    geom.vertices = vertices;
    geom.verticesIndices = verticesIndices;

    return geom;
  };

  class CgMesh {
    _name = "unknown";

    constructor() {}
  }

  class CgCanvas {
    constructor(options) {
      this._log = new Logger("CgCanvas");
      if (!options) {
        this._log.error("CgCanvas no options");
      } else {
        this._canvasEle = options.canvasEle;
      }

      if (!options.cg) this._log.error("CgCanvas options has no cg");
      if (!options.canvasEle)
        this._log.error("CgCanvas options has no canvasEle");

      this._cg = options.cg;
      this.pixelDensity = 1;
      this.canvasWidth = this.canvasEle.clientWidth;
      this.canvasHeight = this.canvasEle.clientHeight;

      this._oldWidthRp = -1;
      this._oldHeightRp = -1;

      this.setSize(this.canvasWidth, this.canvasHeight);
    }

    get canvasEle() {
      return this._canvasEle;
    }

    setWhyCompile(why) {
      this._compileReason = why;
    }

    /**
     * @param {Number} w
     * @param {Number} h
     * @param {any} ignorestyle
     * @returns {any}
     */
    setSize(w, h, ignorestyle = false) {
      if (
        this._oldWidthRp != w * this.pixelDensity ||
        this._oldHeightRp != h * this.pixelDensity
      ) {
        this._oldWidthRp = this.canvasEle.width = w * this.pixelDensity;
        this._oldHeightRp = this.canvasEle.height = h * this.pixelDensity;

        if (!ignorestyle) {
          this.canvasEle.style.width = w + "px";
          this.canvasEle.style.height = h + "px";
        }

        this.updateSize();

        this._cg.emitEvent("resize");
      }
    }

    updateSize() {
      this.canvasEle.width = this.canvasWidth =
        this.canvasEle.clientWidth * this.pixelDensity;
      this.canvasEle.height = this.canvasHeight =
        this.canvasEle.clientHeight * this.pixelDensity;
    }

    dispose() {
      if (this._canvasEle) this._canvasEle.remove();
      this._canvasEle = null;
    }
  }

  class MatrixStack {
    constructor() {
      this._arr = [create$5()];
      this._index = 0;
      this.stateCounter = 0;
    }

    /**
     * @param {mat4} m
     */
    push(m) {
      this._index++;
      this.stateCounter++;

      if (this._index == this._arr.length) {
        const copy = create$5();
        this._arr.push(copy);
      }

      copy$5(this._arr[this._index], m || this._arr[this._index - 1]);

      return this._arr[this._index];
    }

    pop() {
      this.stateCounter++;

      this._index--;
      if (this._index < 0) this._index = 0;

      return this._arr[this._index];
    }

    length() {
      return this._index;
    }
  }

  class ProfileData {
    constructor(cgl) {
      this._cgl = cgl;
      this._lastTime = 0;
      this.pause = false;
      this.profileUniformCount = 0;
      this.profileShaderBinds = 0;
      this.profileUniformCount = 0;
      this.profileShaderCompiles = 0;
      this.profileVideosPlaying = 0;
      this.profileMVPMatrixCount = 0;
      this.profileEffectBuffercreate = 0;
      this.profileShaderGetUniform = 0;
      this.profileFrameBuffercreate = 0;
      this.profileMeshSetGeom = 0;
      this.profileTextureNew = 0;
      this.profileGenMipMap = 0;
      this.profileOnAnimFrameOps = 0;

      this.profileFencedPixelRead = 0;
      this.profileMainloopMs = 0;
      this.profileMeshDraw = 0;
      this.profileTextureEffect = 0;
      this.profileTexPreviews = 0;
      this.shaderCompileTime = 0;
      this.profileMeshNumElements = 0;
      this.profileMeshAttributes = 0;
      this.profileSingleMeshAttribute = [];
      this.heavyEvents = [];

      this.doProfileGlQuery = false;
      this.glQueryData = {};
      this.counts = {};
    }

    clear() {
      this.counts = {};
      this.profileSingleMeshAttribute = {};
      this.profileMeshAttributes = 0;
      this.profileUniformCount = 0;
      this.profileShaderGetUniform = 0;
      this.profileShaderCompiles = 0;
      this.profileShaderBinds = 0;
      this.profileTextureResize = 0;
      this.profileFrameBuffercreate = 0;
      this.profileEffectBuffercreate = 0;
      this.profileTextureDelete = 0;
      this.profileMeshSetGeom = 0;
      this.profileVideosPlaying = 0;
      this.profileMVPMatrixCount = 0;
      this.profileNonTypedAttrib = 0;
      this.profileNonTypedAttribNames = "";
      this.profileTextureNew = 0;
      this.profileGenMipMap = 0;
      this.profileFramebuffer = 0;
      this.profileMeshDraw = 0;
      this.profileTextureEffect = 0;
      this.profileTexPreviews = 0;
      this.profileMeshNumElements = 0;
      this.profileFencedPixelRead = 0;
    }

    clearGlQuery() {
      for (let i in this.glQueryData) {
        if (
          !this.glQueryData[i].lastClear ||
          performance.now() - this.glQueryData[i].lastClear > 1000
        ) {
          this.glQueryData[i].time =
            this.glQueryData[i]._times / this.glQueryData[i]._numcount;
          this.glQueryData[i].num = this.glQueryData[i]._numcount;

          this.glQueryData[i]._times = 0;
          this.glQueryData[i]._numcount = 0;
          this.glQueryData[i].lastClear = performance.now();
        }
      }
    }

    /**
     * @param {string} event
     * @param {string} name
     */
    count(event, name) {
      this.counts[event] = this.counts[event] || [];
      this.counts[event].push(name);
    }

    /**
     * @param {string} event
     * @param {string} name
     * @param {string} [info]
     */
    addHeavyEvent(event, name, info) {
      const e = { event: event, name: name, info: info, date: performance.now() };
      this.heavyEvents.push(e);
      this._cgl.emitEvent("heavyEvent", e);
    }
  }

  class CgContext extends Events {
    static API_WEBGL = 0;
    static API_WEBGPU = 1;

    gApi = "unknown";

    /**
     * Description
     * @param {Patch} _patch
     */
    constructor(_patch) {
      super();

      this._log = new Logger("cg_context", { onError: _patch.config.onError });

      /** @type {object} */
      this.tempData = this.frameStore = this.frameStore || {};
      this.fpsCounter = new CABLES.CG.FpsCounter();
      this._identView = create$4();
      this._ident = create$4();
      set$4(this._identView, 0, 0, -2);
      set$4(this._ident, 0, 0, 0);
      this._onetimeCallbacks = [];
      this.maxTexSize = 2048;
      this._viewPort = [0, 0, 1, 1];
      this._viewPortStack = [];
      this.patch = _patch;
      this.autoReSize = true;

      this.DEPTH_COMPARE_FUNC_NEVER = 0;
      this.DEPTH_COMPARE_FUNC_LESS = 1;
      this.DEPTH_COMPARE_FUNC_EQUAL = 2;
      this.DEPTH_COMPARE_FUNC_LESSEQUAL = 3;
      this.DEPTH_COMPARE_FUNC_GREATER = 4;
      this.DEPTH_COMPARE_FUNC_NOTEQUAL = 5;
      this.DEPTH_COMPARE_FUNC_GREATEREQUAL = 6;
      this.DEPTH_COMPARE_FUNC_ALWAYS = 7;

      this.profileData = new ProfileData(this);

      /**
       * Current projection matrix
       * @memberof Context
       * @instance
       * @type {mat4}
       */
      this.pMatrix = create$5();

      /**
       * Current model matrix
       * @memberof Context
       * @instance
       * @type {mat4}
       */
      this.mMatrix = create$5();

      /**
       * Current view matrix
       * @memberof Context
       * @instance
       * @type {mat4}
       */
      this.vMatrix = create$5();
      this._textureslots = [];

      this._pMatrixStack = new MatrixStack();
      this._mMatrixStack = new MatrixStack();
      this._vMatrixStack = new MatrixStack();

      this.canvasScale = 1;

      identity$2(this.mMatrix);
      identity$2(this.vMatrix);

      window
        .matchMedia("screen and (min-resolution: 2dppx)")
        .addEventListener("change", () => {
          this.emitEvent("resize");
        });
    }

    get canvasWidth() {
      return this.cgCanvas.canvasWidth;
    }

    get canvasHeight() {
      return this.cgCanvas.canvasHeight;
    }

    set pixelDensity(p) {
      if (this.cgCanvas.pixelDensity != p) {
        this.cgCanvas.pixelDensity = p;
        this.cgCanvas.updateSize();
        this.emitEvent("resize");
      }
    }

    get pixelDensity() {
      return this.cgCanvas.pixelDensity;
    }

    getGApiName() {
      return ["WebGL", "WebGPU"][this.gApi];
    }

    get canvas() {
      return this.cgCanva?.canvasEle;
    }

    get viewPort() {
      // TODO: add stack...
      return [0, 0, this.canvasWidth, this.canvasHeight];
    }

    /**
     * @param {HTMLElement} canvEle
     */
    setCanvas(canvEle) {
      if (this.cgCanvas && canvEle === this.cgCanvas.canvasEle) return;
      if (typeof canvEle === "string") canvEle = document.getElementById(canvEle);

      this.cgCanvas = new CgCanvas({ canvasEle: canvEle, cg: this });

      canvEle.parentElement.classList.add("cablesContainer");
      if (this._setCanvas) this._setCanvas(canvEle);

      this.updateSize();
    }

    /**
     * @param {HTMLElement} _canvEle
     */
    _setCanvas(_canvEle) {}

    updateSize() {
      this.cgCanvas.updateSize();
    }

    /**
     * @param {number} w
     * @param {number} h
     * @param {boolean} ignorestyle
     */
    setSize(w, h, ignorestyle = false) {
      this.cgCanvas.setSize(w, h, ignorestyle);
    }

    _resizeToWindowSize() {
      if (this.autoReSize) {
        this.setSize(window.innerWidth, window.innerHeight);
        this.updateSize();
      }
    }

    _resizeToParentSize() {
      if (this.autoReSize) {
        const p = this.canvas.parentElement;
        if (!p) {
          this._log.error("cables: can not resize to container element");
          return;
        }

        this.setSize(p.clientWidth, p.clientHeight);
        this.updateSize();
      }
    }

    setAutoResize(parent) {
      window.removeEventListener("resize", this._resizeToWindowSize.bind(this));
      window.removeEventListener("resize", this._resizeToParentSize.bind(this));

      if (parent == "window") {
        window.addEventListener("resize", this._resizeToWindowSize.bind(this));
        window.addEventListener(
          "orientationchange",
          this._resizeToWindowSize.bind(this),
        );
        this._resizeToWindowSize();
      }
      if (parent == "parent") {
        window.addEventListener("resize", this._resizeToParentSize.bind(this));
        this._resizeToParentSize();
      }
    }

    /**
     * push a matrix to the projection matrix stack
     * @function pushPMatrix
     * @memberof Context
     * @instance
     */
    pushPMatrix() {
      this.pMatrix = this._pMatrixStack.push(this.pMatrix);
    }

    /**
     * pop projection matrix stack
     * @function popPMatrix
     * @memberof Context
     * @instance
     * @returns {mat4} current projectionmatrix
     */
    popPMatrix() {
      this.pMatrix = this._pMatrixStack.pop();
      return this.pMatrix;
    }

    getProjectionMatrixStateCount() {
      return this._pMatrixStack.stateCounter;
    }

    /**
     * push a matrix to the model matrix stack
     * @function pushModelMatrix
     * @memberof Context
     * @instance
     * @example
     * // see source code of translate op:
     * cgl.pushModelMatrix();
     * mat4.translate(cgl.mMatrix,cgl.mMatrix, vec);
     * trigger.trigger();
     * cgl.popModelMatrix();
     */
    pushModelMatrix() {
      this.mMatrix = this._mMatrixStack.push(this.mMatrix);
    }

    /**
     * pop model matrix stack
     * @function popModelMatrix
     * @memberof Context
     * @instance
     * @returns {mat4} current modelmatrix
     */
    popModelMatrix() {
      // todo: DEPRECATE
      // if (this._mMatrixStack.length === 0) throw "Invalid modelview popMatrix!";
      this.mMatrix = this._mMatrixStack.pop();
      return this.mMatrix;
    }

    /**
     * get model matrix
     * @function modelMatrix
     * @memberof Context
     * @instance
     * @returns {mat4} current modelmatrix
     */
    modelMatrix() {
      return this.mMatrix;
    }

    /**
     * push a matrix to the view matrix stack
     * @function pushviewMatrix
     * @memberof Context
     * @instance
     */
    pushViewMatrix() {
      this.vMatrix = this._vMatrixStack.push(this.vMatrix);
    }

    /**
     * pop view matrix stack
     * @function popViewMatrix
     * @memberof Context
     * @instance
     * @returns {mat4} current viewmatrix
     * @function
     */
    popViewMatrix() {
      this.vMatrix = this._vMatrixStack.pop();
    }

    getViewMatrixStateCount() {
      return this._vMatrixStack.stateCounter;
    }

    /**
     * @param {vec3} identTranslate
     * @param {vec3} identTranslateView
     */
    _startMatrixStacks(identTranslate, identTranslateView) {
      identTranslate = identTranslate || this._ident;
      identTranslateView = identTranslateView || this._identView;

      perspective(
        this.pMatrix,
        45,
        this.canvasWidth / this.canvasHeight,
        0.1,
        1000.0,
      );

      identity$2(this.mMatrix);
      identity$2(this.vMatrix);
      translate$1(this.mMatrix, this.mMatrix, identTranslate);
      translate$1(this.vMatrix, this.vMatrix, identTranslateView);

      this.pushPMatrix();
      this.pushModelMatrix();
      this.pushViewMatrix();
    }

    _endMatrixStacks() {
      this.popViewMatrix();
      this.popModelMatrix();
      this.popPMatrix();
    }

    dispose() {
      this.aborted = true;
      if (this.cgCanvas) this.cgCanvas.dispose();
      if (this._dispose) this._dispose();
    }

    _dispose() {}

    /**
     * @param {any} _op
     */
    shouldDrawHelpers(_op) {
      return false;
    }

    /**
     * execute the callback next frame, once
     * @param {function} cb
     */
    addNextFrameOnceCallback(cb) {
      if (cb && this._onetimeCallbacks.indexOf(cb) == -1)
        this._onetimeCallbacks.push(cb);
    }

    _execOneTimeCallbacks() {
      if (this._onetimeCallbacks.length > 0) {
        for (let i = 0; i < this._onetimeCallbacks.length; i++)
          this._onetimeCallbacks[i]();
        this._onetimeCallbacks.length = 0;
      }
    }

    /**
     * @param {number} x
     */
    checkTextureSize(x) {
      x = x || 1;
      x = Math.floor(x);
      x = Math.min(x, this.maxTexSize);
      x = Math.max(x, 1);
      return x;
    }

    // should be overwritten...
    screenShot(cb, doScreenshotClearAlpha, mimeType, quality) {
      console.log("no screenshot function implemented");
    }

    /**
     * @param {string} [filename]
     * @param {function} [cb]
     * @param {number} [pw]
     * @param {number} [ph]
     * @param {boolean} [noclearalpha]
     */
    saveScreenshot(filename, cb, pw, ph, noclearalpha) {
      this.patch.renderOneFrame();

      let w = this.canvas.clientWidth * this.pixelDensity;
      let h = this.canvas.clientHeight * this.pixelDensity;

      if (pw) {
        this.canvas.width = pw;
        w = pw;
      }
      if (ph) {
        this.canvas.height = ph;
        h = ph;
      }

      function padLeft(nr, n, str) {
        return Array(n - String(nr).length + 1).join("0") + nr;
      }

      const d = new Date();
      const dateStr = ""
        .concat(
          String(d.getFullYear()) +
            String(d.getMonth() + 1) +
            String(d.getDate()),
          "_",
        )
        .concat(padLeft(d.getHours(), 2))
        .concat(padLeft(d.getMinutes(), 2))
        .concat(padLeft(d.getSeconds(), 2));

      if (!filename) filename = "cables_" + dateStr + ".png";
      else filename += ".png";

      this.screenShot((blob) => {
        this.canvas.width = w;
        this.canvas.height = h;

        if (blob) {
          const anchor = document.createElement("a");

          anchor.download = filename;
          anchor.href = URL.createObjectURL(blob);

          console.log("scrrenshot");
          setTimeout(function () {
            anchor.click();
            if (cb) cb(blob);
          }, 100);
        } else {
          this._log.log("screenshot: no blob");
        }
      });
    }
  }

  const MESH = {};
  MESH.lastMesh = null;

  /**
   * @typedef {Object} CglMeshAttributeOptions
   * @property {Number} [instanced]
   * @property {Function} [cb]
   * @property {Function} [type]
   */

  /**
   * @type Object
   * @typedef CglMeshOptions
   * @property {Number} [glPrimitive]
   * @property {String} [opId]
   */

  /**
   * webgl renderable 3d object
   * @class
   * @namespace external:CGL
   * @hideconstructor
   * @example
   * const cgl=this._cgl
   * const mesh=new CGL.Mesh(cgl, geometry);
   *
   * function render()
   * {
   *   mesh.render(cgl.getShader());
   * }
   *
   */
  class Mesh extends CgMesh {
    /** @type {CglContext} */
    #cgl = null;

    /** @type {Geometry} */
    #geom = null;

    /** @type {WebGLBuffer} */
    #bufVerticesIndizes = null;

    /**
     * @param {CglContext} _cgl cgl
     * @param {Geometry} __geom geometry
     * @param {CglMeshOptions} _options
     */
    constructor(_cgl, __geom, _options = {}) {
      super();
      this.#cgl = _cgl;

      let options = _options || {};
      if (CABLES.isNumeric(options)) options = { glPrimitive: _options }; // old constructor fallback...
      this._log = new Logger("cgl_mesh");
      this._bufVertexAttrib = null;
      this.#bufVerticesIndizes = this.#cgl.gl.createBuffer();
      this._indexType = this.#cgl.gl.UNSIGNED_SHORT;
      this._attributes = [];
      this._attribLocs = {};

      this._lastShader = null;
      this._numInstances = 0;
      this._glPrimitive = options.glPrimitive;

      this.opId = options.opId || "";
      this._preWireframeGeom = null;
      this.addVertexNumbers = false;

      this.feedBackAttributes = [];
      this.setGeom(__geom);

      this._feedBacks = [];
      this._feedBacksChanged = false;
      this._transformFeedBackLoc = -1;
      this._lastAttrUpdate = 0;

      this.memFreed = false;

      this.#cgl.profileData.addHeavyEvent("mesh constructed", this._name);

      this._queryExt = null;
    }

    get geom() {
      return this.#geom;
    }

    get numInstances() {
      return this._numInstances;
    }

    set numInstances(v) {
      this.setNumInstances(v);
    }

    freeMem() {
      this.memFreed = true;

      for (let i = 0; i < this._attributes.length; i++)
        this._attributes[i].floatArray = null;
    }

    /**
     * @function updateVertices
     * @memberof Mesh
     * @instance
     * @description update vertices only from a geometry
     * @param {Geometry} geom
     */
    updateVertices(geom) {
      this.setAttribute(
        CONSTANTS$1.SHADER.SHADERVAR_VERTEX_POSITION,
        geom.vertices,
        3,
      );
      this._numVerts = geom.vertices.length / 3;
    }

    /**
     * @param {String} attrName
     * @param {String} name
     * @param {Number} stride
     * @param {Number} offset
     */
    setAttributePointer(attrName, name, stride, offset) {
      for (let i = 0; i < this._attributes.length; i++) {
        if (this._attributes[i].name == attrName) {
          if (!this._attributes[i].pointer) this._attributes[i].pointer = [];

          this._attributes[i].pointer.push({
            loc: -1,
            name: name,
            stride: stride,
            offset: offset,
            instanced: attrName == CONSTANTS$1.SHADER.SHADERVAR_INSTANCE_MMATRIX,
          });
        }
      }
    }

    /**
     * @param {String} name
     * @returns {AttributeObject}
     */
    getAttribute(name) {
      for (let i = 0; i < this._attributes.length; i++)
        if (this._attributes[i].name == name) return this._attributes[i];
    }

    setAttributeRange(attr, array, start, end) {
      if (!attr) return;
      if (!start && !end) return;

      if (!attr.name) this._log.stack("no attrname?!");

      const gl = this.#cgl.gl;

      gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
      this.#cgl.profileData.profileMeshAttributes += end - start || 0;

      this.#cgl.profileData.profileSingleMeshAttribute[this._name] =
        this.#cgl.profileData.profileSingleMeshAttribute[this._name] || 0;
      this.#cgl.profileData.profileSingleMeshAttribute[this._name] +=
        end - start || 0;

      if (attr.numItems < array.length / attr.itemSize) {
        this._resizeAttr(array, attr);
      }

      if (end > array.length && !this.warned) {
        this.warned = true;
        this._log.warn(
          this.#cgl.canvas.id +
            " " +
            attr.name +
            " buffersubdata out of bounds ?",
          array.length,
          end,
          start,
          attr,
        );
        return;
      }

      // if (glVersion == 1) gl.bufferSubData(gl.ARRAY_BUFFER, 0, array); // probably slow/ maybe create and array with only changed size ??
      // else
      gl.bufferSubData(gl.ARRAY_BUFFER, start * 4, array, start, end - start);
    }

    _resizeAttr(array, attr) {
      const gl = this.#cgl.gl;

      if (attr.buffer) gl.deleteBuffer(attr.buffer);

      attr.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
      this._bufferArray(array, attr);
      attr.numItems = array.length / attr.itemSize; // numItems;
    }

    _bufferArray(array, attr) {
      let floatArray = attr.floatArray || null;
      if (!array) return;

      if (this.#cgl.debugOneFrame) {
        console.log("_bufferArray", array.length, attr.name);
      }

      if (!(array instanceof Float32Array)) {
        if (attr && floatArray && floatArray.length == array.length) {
          floatArray.set(array);
        } else {
          floatArray = new Float32Array(array);

          if (this.#cgl.debugOneFrame) {
            console.log(
              "_bufferArray create new float32array",
              array.length,
              attr.name,
            );
          }

          if (array.length > 10000) {
            this.#cgl.profileData.profileNonTypedAttrib++;
            this.#cgl.profileData.profileNonTypedAttribNames =
              "(" + this._name + ":" + attr.name + ")";
          }
        }
      } else floatArray = array;

      attr.arrayLength = floatArray.length;
      attr.floatArray = null; // floatArray;

      this.#cgl.gl.bufferData(
        this.#cgl.gl.ARRAY_BUFFER,
        floatArray,
        this.#cgl.gl.DYNAMIC_DRAW,
      );
    }

    /**
     * @function setAttribute
     * @description update attribute
     * @memberof Mesh
     * @instance
     * @param {String} name
     * @param {Array} array
     * @param {Number} itemSize
     * @param {Object} options
     */
    addAttribute(name, array, itemSize, options) {
      this.setAttribute(name, array, itemSize, options);
    }

    /**
     * @param {String} name
     * @param {Array} array
     * @param {Number} itemSize Integer
     * @param {CglMeshAttributeOptions} options
     */
    setAttribute(name, array, itemSize, options = {}) {
      if (!array) {
        this._log.error("mesh addAttribute - no array given! " + name);
        throw new Error();
      }
      let cb = null;
      let instanced = false;
      let i = 0;
      const numItems = array.length / itemSize;

      this.#cgl.profileData.profileMeshAttributes += numItems || 0;

      if (typeof options == "function") {
        cb = options;
      }

      if (typeof options == "object") {
        if (options.cb) cb = options.cb;
        if (options.instanced) instanced = options.instanced;
      }

      if (name == CONSTANTS$1.SHADER.SHADERVAR_INSTANCE_MMATRIX) instanced = true;

      for (i = 0; i < this._attributes.length; i++) {
        const attr = this._attributes[i];
        if (attr.name == name) {
          if (attr.numItems === numItems) ; else {
            this._resizeAttr(array, attr);
          }

          this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, attr.buffer);
          this._bufferArray(array, attr);

          return attr;
        }
      }

      // create new buffer...

      const buffer = this.#cgl.gl.createBuffer();

      this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, buffer);
      // this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);

      let type = this.#cgl.gl.FLOAT;
      if (options && options.type) type = options.type;
      const attr = {
        buffer: buffer,
        name: name,
        cb: cb,
        itemSize: itemSize,
        numItems: numItems,
        startItem: 0,
        instanced: instanced,
        type: type,
      };

      this._bufferArray(array, attr);

      if (name == CONSTANTS$1.SHADER.SHADERVAR_VERTEX_POSITION)
        this._bufVertexAttrib = attr;
      this._attributes.push(attr);
      this._attribLocs = {};

      return attr;
    }

    getAttributes() {
      return this._attributes;
    }

    /**
     * @function updateTexCoords
     * @description update texture coordinates only from a geometry
     * @memberof Mesh
     * @instance
     * @param {Geometry} geom
     */
    updateTexCoords(geom) {
      if (geom.texCoords && geom.texCoords.length > 0) {
        this.setAttribute(
          CONSTANTS$1.SHADER.SHADERVAR_VERTEX_TEXCOORD,
          geom.texCoords,
          2,
        );
      } else {
        const tcBuff = new Float32Array(
          Math.round((geom.vertices.length / 3) * 2),
        );
        this.setAttribute(CONSTANTS$1.SHADER.SHADERVAR_VERTEX_TEXCOORD, tcBuff, 2);
      }
    }

    /**
     * @function updateNormals
     * @description update normals only from a geometry
     * @memberof Mesh
     * @instance
     * @param {Geometry} geom
     */
    updateNormals(geom) {
      if (geom.vertexNormals && geom.vertexNormals.length > 0) {
        this.setAttribute(
          CONSTANTS$1.SHADER.SHADERVAR_VERTEX_NORMAL,
          geom.vertexNormals,
          3,
        );
      } else {
        const tcBuff = new Float32Array(Math.round(geom.vertices.length));
        this.setAttribute(CONSTANTS$1.SHADER.SHADERVAR_VERTEX_NORMAL, tcBuff, 3);
      }
    }

    /**
     * @param {Array} arr
     */
    _setVertexNumbers(arr) {
      if (
        !this._verticesNumbers ||
        this._verticesNumbers.length != this._numVerts ||
        arr
      ) {
        if (arr) this._verticesNumbers = arr;
        else {
          this._verticesNumbers = new Float32Array(this._numVerts);
          for (let i = 0; i < this._numVerts; i++) this._verticesNumbers[i] = i;
        }

        this.setAttribute(
          CONSTANTS$1.SHADER.SHADERVAR_VERTEX_NUMBER,
          this._verticesNumbers,
          1,
          (attr, geom, shader) => {
            if (!shader.uniformNumVertices)
              shader.uniformNumVertices = new Uniform(
                shader,
                "f",
                "numVertices",
                this._numVerts,
              );
            shader.uniformNumVertices.setValue(this._numVerts);
          },
        );
      }
    }

    /**
     * @function setVertexIndices
     * @description update vertex indices / faces
     * @memberof Mesh
     * @instance
     * @param {array} vertIndices
     */
    setVertexIndices(vertIndices) {
      if (!this.#bufVerticesIndizes) {
        this._log.warn("no bufVerticesIndizes: " + this._name);
        return;
      }
      if (vertIndices.length > 0) {
        if (vertIndices instanceof Float32Array)
          this._log.warn("vertIndices float32Array: " + this._name);

        for (let i = 0; i < vertIndices.length; i++) {
          if (vertIndices[i] >= this._numVerts) {
            this._log.warn("invalid index in " + this._name, i, vertIndices[i]);
            return;
          }
        }

        this.#cgl.gl.bindBuffer(
          this.#cgl.gl.ELEMENT_ARRAY_BUFFER,
          this.#bufVerticesIndizes,
        );

        /*
         * todo cache this ?
         * if(!this.vertIndicesTyped || this.vertIndicesTyped.length!=this._geom.verticesIndices.length)
         */

        if (vertIndices.length > 65535) {
          this.vertIndicesTyped = new Uint32Array(vertIndices);
          this._indexType = this.#cgl.gl.UNSIGNED_INT;
        } else if (vertIndices instanceof Uint32Array) {
          this.vertIndicesTyped = vertIndices;
          this._indexType = this.#cgl.gl.UNSIGNED_INT;
        } else if (!(vertIndices instanceof Uint16Array)) {
          this.vertIndicesTyped = new Uint16Array(vertIndices);
          this._indexType = this.#cgl.gl.UNSIGNED_SHORT;
        } else this.vertIndicesTyped = vertIndices;

        this.#cgl.gl.bufferData(
          this.#cgl.gl.ELEMENT_ARRAY_BUFFER,
          this.vertIndicesTyped,
          this.#cgl.gl.DYNAMIC_DRAW,
        );
        this.#bufVerticesIndizes.itemSize = 1;
        this.#bufVerticesIndizes.numItems = vertIndices.length;
      } else this.#bufVerticesIndizes.numItems = 0;
    }

    /**
     * @function setGeom
     * @memberof Mesh
     * @instance
     * @description set geometry for mesh
     * @param {Geometry} geom
     * @param {boolean} removeRef
     */
    setGeom(geom, removeRef = false) {
      this.#geom = geom;
      if (geom.glPrimitive != null) this._glPrimitive = geom.glPrimitive;
      if (this.#geom && this.#geom.name) this._name = "mesh " + this.#geom.name;

      MESH.lastMesh = null;
      this.#cgl.profileData.profileMeshSetGeom++;

      this._disposeAttributes();

      this.updateVertices(this.#geom);
      this.setVertexIndices(this.#geom.verticesIndices);

      if (this.addVertexNumbers) this._setVertexNumbers();

      const geomAttribs = this.#geom.getAttributes();

      const attribAssoc = {
        texCoords: CONSTANTS$1.SHADER.SHADERVAR_VERTEX_TEXCOORD,
        vertexNormals: CONSTANTS$1.SHADER.SHADERVAR_VERTEX_NORMAL,
        vertexColors: CONSTANTS$1.SHADER.SHADERVAR_VERTEX_COLOR,
        tangents: "attrTangent",
        biTangents: "attrBiTangent",
      };

      for (const index in geomAttribs)
        if (geomAttribs[index].data && geomAttribs[index].data.length)
          this.setAttribute(
            attribAssoc[index] || index,
            geomAttribs[index].data,
            geomAttribs[index].itemSize,
          );

      if (removeRef) {
        this.#geom = null;
      }
    }

    _preBind(shader) {
      for (let i = 0; i < this._attributes.length; i++)
        if (this._attributes[i].cb)
          this._attributes[i].cb(this._attributes[i], this.#geom, shader);
    }

    _checkAttrLengths() {
      if (this.memFreed) return;
      // check length
      for (let i = 0; i < this._attributes.length; i++) {
        if (
          this._attributes[i].arrayLength / this._attributes[i].itemSize <
          this._attributes[0].arrayLength / this._attributes[0].itemSize
        ) {
          if (this.#geom) this.#geom.name;

          /*
           * this._log.warn(
           *     name + ": " + this._attributes[i].name +
           *     " wrong attr length. is:", this._attributes[i].arrayLength / this._attributes[i].itemSize,
           *     " should be:", this._attributes[0].arrayLength / this._attributes[0].itemSize,
           * );
           */
        }
      }
    }

    _bind(shader) {
      if (!shader) return;
      if (!shader.isValid()) return;

      let attrLocs = [];
      if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
      else this._attribLocs[shader.id] = attrLocs;

      this._lastShader = shader;
      if (
        shader.lastCompile > this._lastAttrUpdate ||
        attrLocs.length != this._attributes.length
      ) {
        this._lastAttrUpdate = shader.lastCompile;
        for (let i = 0; i < this._attributes.length; i++) attrLocs[i] = -1;
      }

      for (let i = 0; i < this._attributes.length; i++) {
        const attribute = this._attributes[i];
        if (attrLocs[i] == -1) {
          if (attribute._attrLocationLastShaderTime != shader.lastCompile) {
            attribute._attrLocationLastShaderTime = shader.lastCompile;
            attrLocs[i] = this.#cgl.glGetAttribLocation(
              shader.getProgram(),
              attribute.name,
            );
            // this._log.log('attribloc',attribute.name,attrLocs[i]);
            this.#cgl.profileData.profileAttrLoc++;
          }
        }

        if (attrLocs[i] != -1) {
          this.#cgl.gl.enableVertexAttribArray(attrLocs[i]);
          this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, attribute.buffer);

          if (attribute.instanced) {
            // todo: easier way to fill mat4 attribs...
            if (attribute.itemSize <= 4) {
              if (!attribute.itemSize || attribute.itemSize == 0)
                this._log.warn(
                  "instanced attrib itemsize error",
                  this.#geom.name,
                  attribute,
                );

              this.#cgl.gl.vertexAttribPointer(
                attrLocs[i],
                attribute.itemSize,
                attribute.type,
                false,
                attribute.itemSize * 4,
                0,
              );
              this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
            } else if (attribute.itemSize == 16) {
              const stride = 16 * 4;

              this.#cgl.gl.vertexAttribPointer(
                attrLocs[i],
                4,
                attribute.type,
                false,
                stride,
                0,
              );
              this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 1);
              this.#cgl.gl.vertexAttribPointer(
                attrLocs[i] + 1,
                4,
                attribute.type,
                false,
                stride,
                4 * 4 * 1,
              );
              this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 2);
              this.#cgl.gl.vertexAttribPointer(
                attrLocs[i] + 2,
                4,
                attribute.type,
                false,
                stride,
                4 * 4 * 2,
              );
              this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 3);
              this.#cgl.gl.vertexAttribPointer(
                attrLocs[i] + 3,
                4,
                attribute.type,
                false,
                stride,
                4 * 4 * 3,
              );

              this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
              this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 1);
              this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 1);
              this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 1);
            } else {
              this._log.warn("unknown instance attrib size", attribute.name);
            }
          } else {
            if (!attribute.itemSize || attribute.itemSize == 0)
              this._log.warn("attrib itemsize error", this._name, attribute);
            this.#cgl.gl.vertexAttribPointer(
              attrLocs[i],
              attribute.itemSize,
              attribute.type,
              false,
              attribute.itemSize * 4,
              0,
            );

            if (attribute.pointer) {
              for (let ip = 0; ip < attribute.pointer.length; ip++) {
                const pointer = attribute.pointer[ip];

                if (pointer.loc == -1)
                  pointer.loc = this.#cgl.glGetAttribLocation(
                    shader.getProgram(),
                    pointer.name,
                  );

                this.#cgl.profileData.profileAttrLoc++;

                this.#cgl.gl.enableVertexAttribArray(pointer.loc);
                this.#cgl.gl.vertexAttribPointer(
                  pointer.loc,
                  attribute.itemSize,
                  attribute.type,
                  false,
                  pointer.stride,
                  pointer.offset,
                );
              }
            }
            if (this.bindFeedback) this.bindFeedback(attribute);
          }
        }
      }

      if (this.#bufVerticesIndizes && this.#bufVerticesIndizes.numItems !== 0)
        this.#cgl.gl.bindBuffer(
          this.#cgl.gl.ELEMENT_ARRAY_BUFFER,
          this.#bufVerticesIndizes,
        );
    }

    unBind() {
      const shader = this._lastShader;
      this._lastShader = null;
      if (!shader) return;

      let attrLocs = [];
      if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
      else this._attribLocs[shader.id] = attrLocs;

      MESH.lastMesh = null;

      for (let i = 0; i < this._attributes.length; i++) {
        if (this._attributes[i].instanced) {
          // todo: easier way to fill mat4 attribs...
          if (this._attributes[i].itemSize <= 4) {
            if (attrLocs[i] != -1)
              this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
            if (attrLocs[i] >= 0)
              this.#cgl.gl.disableVertexAttribArray(attrLocs[i]);
          } else {
            this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
            this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 0);
            this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 0);
            this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 0);
            this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 1);
            this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 2);
            this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 3);
          }
        }

        if (attrLocs[i] != -1) this.#cgl.gl.disableVertexAttribArray(attrLocs[i]);
      }
    }

    meshChanged() {
      return this.#cgl.lastMesh && this.#cgl.lastMesh != this;
    }

    printDebug(shader) {
      console.log("--attributes");
      for (let i = 0; i < this._attributes.length; i++) {
        console.log("attribute " + i + " " + this._attributes[i].name);
      }
    }

    /**
     * @param {Number} num
     */
    setNumVertices(num) {
      // this._bufVerticesIndizes.numItems = num;
      this._bufVertexAttrib.numItems = num;
    }

    /**
     * @returns {Number}
     */
    getNumVertices() {
      // return this._bufVerticesIndizes.numItems;
      return this._bufVertexAttrib.numItems;
    }

    /**
     * @param {Number} num
     */
    setNumIndices(num) {
      this.#bufVerticesIndizes.numItems = num;
    }

    /**
     * @returns {Number}
     */
    getNumIndices() {
      return this.#bufVerticesIndizes.numItems;
    }

    /**
     * @function render
     * @memberof Mesh
     * @instance
     * @description draw mesh to screen
     * @param {CgShader} shader
     */
    render(shader) {
      // TODO: enable/disablevertex only if the mesh has changed... think drawing 10000x the same mesh

      if (this.#cgl.aborted) return;
      shader = shader || this.#cgl.getShader();

      if (!shader) {
        return console.log("shadern not valid");
      }

      if (!shader.isValid()) {
        shader = this.#cgl.getErrorShader();
      }

      this._checkAttrLengths();

      if (this.#geom) {
        if (
          this._preWireframeGeom &&
          !shader.wireframe &&
          !this.#geom.isIndexed()
        ) {
          this.setGeom(this._preWireframeGeom);
          this._preWireframeGeom = null;
        }

        if (shader.wireframe) {
          let changed = false;

          if (this.#geom.isIndexed()) {
            if (!this._preWireframeGeom) {
              this._preWireframeGeom = this.#geom;
              this.#geom = this.#geom.copy();
            }

            this.#geom.unIndex();
            changed = true;
          }

          if (!this.#geom.getAttribute("attrBarycentric")) {
            if (!this._preWireframeGeom) {
              this._preWireframeGeom = this.#geom;
              this.#geom = this.#geom.copy();
            }
            changed = true;

            this.#geom.calcBarycentric();
          }
          if (changed) this.setGeom(this.#geom);
        }
      }

      let needsBind = false;
      if (MESH.lastMesh != this) {
        if (MESH.lastMesh) MESH.lastMesh.unBind();
        needsBind = true;
      }

      if (needsBind) this._preBind(shader);

      if (!shader.bind()) return;

      this._bind(shader);
      if (this.addVertexNumbers) this._setVertexNumbers();

      MESH.lastMesh = this;

      let prim = this.#cgl.gl.TRIANGLES;
      if (this._glPrimitive !== undefined) prim = this._glPrimitive;
      if (shader.glPrimitive !== null) prim = shader.glPrimitive;

      let elementDiv = 1;
      let doQuery = this.#cgl.profileData.doProfileGlQuery;
      let queryStarted = false;
      if (doQuery) {
        let id = this._name + " - " + shader.getName() + " #" + shader.id;
        if (this._numInstances) id += " instanced " + this._numInstances + "x";

        let queryProfilerData = this.#cgl.profileData.glQueryData[id];

        if (!queryProfilerData) queryProfilerData = { id: id, num: 0 };

        if (shader.opId) queryProfilerData.shaderOp = shader.opId;
        if (this.opId) queryProfilerData.meshOp = this.opId;

        this.#cgl.profileData.glQueryData[id] = queryProfilerData;

        if (!this._queryExt && this._queryExt !== false)
          this._queryExt =
            this.#cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || false;
        if (this._queryExt) {
          if (queryProfilerData._drawQuery) {
            const available = this.#cgl.gl.getQueryParameter(
              queryProfilerData._drawQuery,
              this.#cgl.gl.QUERY_RESULT_AVAILABLE,
            );
            if (available) {
              const elapsedNanos = this.#cgl.gl.getQueryParameter(
                queryProfilerData._drawQuery,
                this.#cgl.gl.QUERY_RESULT,
              );
              const currentTimeGPU = elapsedNanos / 1000000;

              queryProfilerData._times = queryProfilerData._times || 0;
              queryProfilerData._times += currentTimeGPU;
              queryProfilerData._numcount++;
              queryProfilerData.when = performance.now();
              queryProfilerData._drawQuery = null;
              queryProfilerData.queryStarted = false;
            }
          }

          if (!queryProfilerData.queryStarted) {
            queryProfilerData._drawQuery = this.#cgl.gl.createQuery();
            this.#cgl.gl.beginQuery(
              this._queryExt.TIME_ELAPSED_EXT,
              queryProfilerData._drawQuery,
            );
            queryStarted = queryProfilerData.queryStarted = true;
          }
        }
      }

      if (this.hasFeedbacks && this.hasFeedbacks())
        this.drawFeedbacks(shader, prim);
      else if (
        !this.#bufVerticesIndizes ||
        this.#bufVerticesIndizes.numItems === 0
      ) {
        /*
         * for (let i = 0; i < this._attributes.length; i++)
         * {
         *     if (this._attributes[i].arrayLength / this._attributes[i].itemSize != this._bufVertexAttrib.floatArray.length / 3)
         *     {
         *         this._log.warn("attrib buffer length wrong! ", this._attributes[i].name, this._attributes[i].arrayLength / this._attributes[i].itemSize, this._bufVertexAttrib.floatArray.length / 3, this._attributes[i].itemSize);
         *         // this._log.log(this);
         *         // debugger;
         *         return;
         *     }
         * }
         */

        if (prim == this.#cgl.gl.TRIANGLES) elementDiv = 3;

        if (this._numInstances === 0)
          this.#cgl.gl.drawArrays(
            prim,
            this._bufVertexAttrib.startItem,
            this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem,
          );
        else
          this.#cgl.gl.drawArraysInstanced(
            prim,
            this._bufVertexAttrib.startItem,
            this._bufVertexAttrib.numItems,
            this._numInstances,
          );
      } else {
        if (prim == this.#cgl.gl.TRIANGLES) elementDiv = 3;
        if (this._numInstances === 0) {
          this.#cgl.gl.drawElements(
            prim,
            this.#bufVerticesIndizes.numItems,
            this._indexType,
            0,
          );
        } else {
          this.#cgl.gl.drawElementsInstanced(
            prim,
            this.#bufVerticesIndizes.numItems,
            this._indexType,
            0,
            this._numInstances,
          );
        }
      }

      if (
        this.#cgl.debugOneFrame &&
        this.#cgl.gl.getError() != this.#cgl.gl.NO_ERROR
      ) {
        this._log.error("mesh draw gl error");
        this._log.error("mesh", this);
        this._log.error("shader", shader);
        for (
          let i = 0;
          i <
          this.#cgl.gl.getProgramParameter(
            shader.getProgram(),
            this.#cgl.gl.ACTIVE_ATTRIBUTES,
          );
          i++
        ) {
          const name = this.#cgl.gl.getActiveAttrib(shader.getProgram(), i).name;
          this._log.error("attrib ", name);
        }
      }

      this.#cgl.profileData.profileMeshNumElements +=
        (this._bufVertexAttrib.numItems / elementDiv) * (this._numInstances || 1);
      this.#cgl.profileData.profileMeshDraw++;

      if (doQuery && queryStarted) {
        this.#cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);
      }

      this.#cgl.printError("mesh render " + this._name);

      this.unBind();
    }

    setNumInstances(n) {
      n = Math.max(0, n);
      if (this._numInstances != n) {
        this._numInstances = n;
        const indexArr = new Float32Array(n);
        for (let i = 0; i < n; i++) indexArr[i] = i;
        this.setAttribute(
          CONSTANTS$1.SHADER.SHADERVAR_INSTANCE_INDEX,
          indexArr,
          1,
          { instanced: true },
        );
      }
    }

    _disposeAttributes() {
      if (!this._attributes) return;

      for (let i = 0; i < this._attributes.length; i++) {
        if (this._attributes[i].buffer) {
          this.#cgl.gl.deleteBuffer(this._attributes[i].buffer);
          this._attributes[i].buffer = null;
        }
      }
      this._attributes.length = 0;
    }

    dispose() {
      if (this.#cgl.aborted) return;
      if (this._bufVertexAttrib && this._bufVertexAttrib.buffer)
        this.#cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);
      if (this.#bufVerticesIndizes)
        this.#cgl.gl.deleteBuffer(this.#bufVerticesIndizes);
      this.#bufVerticesIndizes = null;

      this._disposeAttributes();
    }
  }

  const MESHES = {};

  MESHES.getSimpleRect = function (cgl, name, size = 1.0) {
    const geom = new Geometry(name);

    geom.vertices = [
      1.0 * size,
      1.0 * size,
      0.0,
      -1 * size,
      1.0 * size,
      0.0,
      1.0 * size,
      -1 * size,
      0.0,
      -1 * size,
      -1 * size,
      0.0,
    ];
    geom.texCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];
    geom.verticesIndices = [0, 1, 2, 2, 1, 3];
    geom.vertexNormals = [
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    ];

    return cgl.createMesh(geom);
  };

  MESHES.getSimpleCube = function (cgl, name) {
    const geom = new Geometry(name);
    geom.vertices = [
      -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1,
      1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1,
      1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1,
      -1, 1, 1, -1, 1, -1,
    ];
    geom.setTexCoords([
      0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1,
      0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0,
    ]);
    geom.verticesIndices = [
      0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14,
      15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23,
    ];
    geom.vertexNormals = new Float32Array([
      0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1,
      0.0, 0.0, -1, 0.0, 0.0, -1, 0.0, 0.0, -1, 0.0, 1.0, 0.0, 0.0, 1.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1, 0.0, 0.0, -1, 0.0, 0.0,
      -1, 0.0, 0.0, -1, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
      0.0, 0.0, -1, 0.0, 0.0, -1, 0.0, 0.0, -1, 0.0, 0.0, -1, 0.0, 0.0,
    ]);
    geom.tangents = new Float32Array([
      0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1,
      0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0,
      0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
    ]);
    geom.biTangents = new Float32Array([
      -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
      0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
      0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
    ]);

    return new Mesh(cgl, geom);
  };

  class TextureEffect {
    constructor(cgl, options) {
      this._cgl = cgl;
      this._log = new Logger("cgl_TextureEffect");

      if (!cgl.TextureEffectMesh) this.createMesh();

      this._textureSource = null;
      this._options = options;
      this.name = options.name || "unknown";

      this.imgCompVer = 0;
      this.aspectRatio = 1;
      this._textureTarget = null; // new CGL.Texture(this._cgl,opts);
      this._frameBuf = this._cgl.gl.createFramebuffer();
      this._frameBuf2 = this._cgl.gl.createFramebuffer();
      this._renderbuffer = this._cgl.gl.createRenderbuffer();
      this._renderbuffer2 = this._cgl.gl.createRenderbuffer();
      this.switched = false;
      this.depth = false;
    }

    dispose() {
      if (this._renderbuffer) this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
      if (this._frameBuf) this._cgl.gl.deleteFramebuffer(this._frameBuf);
      if (this._renderbuffer2)
        this._cgl.gl.deleteRenderbuffer(this._renderbuffer2);
      if (this._frameBuf2) this._cgl.gl.deleteFramebuffer(this._frameBuf2);
    }

    getWidth() {
      return this._textureSource.width;
    }

    getHeight() {
      return this._textureSource.height;
    }

    setSourceTexture(tex) {
      if (tex === null) {
        this._textureSource = new Texture$1(this._cgl);
        this._textureSource.setSize(16, 16);
      } else {
        this._textureSource = tex;
      }

      if (!this._textureSource.compareSettings(this._textureTarget)) {
        if (this._textureTarget) this._textureTarget.delete();

        this._textureTarget = this._textureSource.clone();

        this._cgl.profileData.profileEffectBuffercreate++;

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);

        this._cgl.gl.bindRenderbuffer(
          this._cgl.gl.RENDERBUFFER,
          this._renderbuffer,
        );

        // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
        // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

        if (this.depth)
          this._cgl.gl.renderbufferStorage(
            this._cgl.gl.RENDERBUFFER,
            this._cgl.gl.DEPTH_COMPONENT16,
            this._textureSource.width,
            this._textureSource.height,
          );
        this._cgl.gl.framebufferTexture2D(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.COLOR_ATTACHMENT0,
          this._cgl.gl.TEXTURE_2D,
          this._textureTarget.tex,
          0,
        );
        if (this.depth)
          this._cgl.gl.framebufferRenderbuffer(
            this._cgl.gl.FRAMEBUFFER,
            this._cgl.gl.DEPTH_ATTACHMENT,
            this._cgl.gl.RENDERBUFFER,
            this._renderbuffer,
          );

        // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);

        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);

        this._cgl.gl.bindRenderbuffer(
          this._cgl.gl.RENDERBUFFER,
          this._renderbuffer2,
        );

        // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
        // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

        if (this.depth)
          this._cgl.gl.renderbufferStorage(
            this._cgl.gl.RENDERBUFFER,
            this._cgl.gl.DEPTH_COMPONENT16,
            this._textureSource.width,
            this._textureSource.height,
          );
        this._cgl.gl.framebufferTexture2D(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.COLOR_ATTACHMENT0,
          this._cgl.gl.TEXTURE_2D,
          this._textureSource.tex,
          0,
        );

        if (this.depth)
          this._cgl.gl.framebufferRenderbuffer(
            this._cgl.gl.FRAMEBUFFER,
            this._cgl.gl.DEPTH_ATTACHMENT,
            this._cgl.gl.RENDERBUFFER,
            this._renderbuffer2,
          );

        // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);

        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
      }

      this.aspectRatio = this._textureSource.width / this._textureSource.height;
    }

    continueEffect() {
      this._cgl.pushDepthTest(false);
      this._cgl.pushModelMatrix();
      this._cgl.pushPMatrix();
      // todo why two pushs?

      this._cgl.pushViewPort(
        0,
        0,
        this.getCurrentTargetTexture().width,
        this.getCurrentTargetTexture().height,
      );

      mat4.perspective(
        this._cgl.pMatrix,
        45,
        this.getCurrentTargetTexture().width /
          this.getCurrentTargetTexture().height,
        0.1,
        1100.0,
      ); // todo: why?

      this._cgl.pushPMatrix();
      mat4.identity(this._cgl.pMatrix);

      this._cgl.pushViewMatrix();
      mat4.identity(this._cgl.vMatrix);

      this._cgl.pushModelMatrix();
      mat4.identity(this._cgl.mMatrix);
    }

    startEffect(bgTex) {
      if (!this._textureTarget) {
        this._log.warn("effect has no target");
        return;
      }

      this.switched = false;

      this.continueEffect();

      if (bgTex) {
        this._bgTex = bgTex;
      }
      this._countEffects = 0;
    }

    endEffect() {
      this._cgl.popDepthTest();
      this._cgl.popModelMatrix();

      this._cgl.popPMatrix();
      this._cgl.popModelMatrix();
      this._cgl.popViewMatrix();

      this._cgl.popPMatrix();
      this._cgl.popViewPort();
    }

    bind() {
      if (this._textureSource === null) {
        this._log.warn("no base texture set!");
        return;
      }

      if (!this.switched) {
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);
        this._cgl.pushGlFrameBuffer(this._frameBuf);
      } else {
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);
        this._cgl.pushGlFrameBuffer(this._frameBuf2);
      }
    }

    finish() {
      if (this._textureSource === null) {
        this._log.warn("no base texture set!");
        return;
      }

      this._cgl.TextureEffectMesh.render(this._cgl.getShader());

      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.popGlFrameBuffer(),
      );

      this._cgl.profileData.profileTextureEffect++;

      if (this._textureTarget.filter == Texture$1.FILTER_MIPMAP) {
        if (!this.switched) {
          this._cgl.gl.bindTexture(
            this._cgl.gl.TEXTURE_2D,
            this._textureTarget.tex,
          );
          this._textureTarget.updateMipMap();
        } else {
          this._cgl.gl.bindTexture(
            this._cgl.gl.TEXTURE_2D,
            this._textureSource.tex,
          );
          this._textureSource.updateMipMap();
        }

        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
      }

      this.switched = !this.switched;
      this._countEffects++;
    }

    getCurrentTargetTexture() {
      if (this.switched) return this._textureSource;
      return this._textureTarget;
    }

    getCurrentSourceTexture() {
      if (this._countEffects == 0 && this._bgTex) return this._bgTex;

      if (this.switched) return this._textureTarget;
      return this._textureSource;
    }

    delete() {
      if (this._textureTarget) this._textureTarget.delete();
      if (this._textureSource) this._textureSource.delete();
      this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
      this._cgl.gl.deleteFramebuffer(this._frameBuf);
    }

    createMesh() {
      this._cgl.TextureEffectMesh = CABLES.CGL.MESHES.getSimpleRect(
        this._cgl,
        "texEffectRect",
      );
    }

    // ---------------------------------------------------------------------------------
  }

  TextureEffect.checkOpNotInTextureEffect = function (op) {
    if (!op.patch.cgl) return true;
    if (op.uiAttribs.error && !op.patch.cgl.currentTextureEffect) {
      op.setUiError("textureeffect", null);
      return true;
    }
    if (!op.patch.cgl.currentTextureEffect) return true;

    if (op.patch.cgl.currentTextureEffect && !op.uiAttribs.error) {
      op.setUiError(
        "textureeffect",
        "This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.",
        0,
      );
      return false;
    }

    if (op.patch.cgl.currentTextureEffect) return false;
    return true;
  };

  TextureEffect.checkOpInEffect = function (op, minver) {
    minver = minver || 0;

    if (op.patch.cgl.currentTextureEffect) {
      if (
        op.uiAttribs.uierrors &&
        op.patch.cgl.currentTextureEffect.imgCompVer >= minver
      ) {
        op.setUiError("texeffect", null);
        return true;
      }

      if (minver && op.patch.cgl.currentTextureEffect.imgCompVer < minver) {
        op.setUiError(
          "texeffect",
          "This op must be a child of an ImageCompose op with version >=" +
            minver +
            ' <span class="button-small" onclick="gui.patchView.downGradeOp(\'' +
            op.id +
            "','" +
            op.name +
            "')\">Downgrade</span> to previous version",
          1,
        );
      }
    }

    if (op.patch.cgl.currentTextureEffect) return true;

    if (
      !op.patch.cgl.currentTextureEffect &&
      (!op.uiAttribs.uierrors || op.uiAttribs.uierrors.length == 0)
    ) {
      op.setUiError(
        "texeffect",
        'This op must be a child of an ImageCompose op! More infos <a href="https://cables.gl/docs/image_composition/image_composition.html" target="_blank">here</a>. ',
        1,
      );
      return false;
    }

    if (!op.patch.cgl.currentTextureEffect) return false;
    return true;
  };

  TextureEffect.getBlendCode = function (ver) {
    let src =
      "".endl() +
      "vec3 _blend(vec3 base,vec3 blend)".endl() +
      "{".endl() +
      "   vec3 colNew=blend;".endl() +
      "   #ifdef BM_MULTIPLY".endl() +
      "       colNew=base*blend;".endl() +
      "   #endif".endl() +
      "   #ifdef BM_MULTIPLY_INV".endl() +
      "       colNew=base* vec3(1.0)-blend;".endl() +
      "   #endif".endl() +
      "   #ifdef BM_AVERAGE".endl() +
      "       colNew=((base + blend) / 2.0);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_ADD".endl() +
      "       colNew=min(base + blend, vec3(1.0));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_SUBTRACT_ONE".endl() +
      "       colNew=max(base + blend - vec3(1.0), vec3(0.0));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_SUBTRACT".endl() +
      "       colNew=base - blend;".endl() +
      "   #endif".endl() +
      "   #ifdef BM_DIFFERENCE".endl() +
      "       colNew=abs(base - blend);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_NEGATION".endl() +
      "       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_EXCLUSION".endl() +
      "       colNew=(base + blend - 2.0 * base * blend);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_LIGHTEN".endl() +
      "       colNew=max(blend, base);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_DARKEN".endl() +
      "       colNew=min(blend, base);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_OVERLAY".endl() +
      "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
        // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
        //    .endl()+'      colNew=Blend(base, blend, BlendOverlayf);'
        .endl() +
      "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_SCREEN".endl() +
      "      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))"
        // .endl()+'       #define BlendScreen(base, blend)        Blend(base, blend, BlendScreenf)'
        // .endl()+'      colNew=Blend(base, blend, BlendScreenf);'
        .endl() +
      "      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_SOFTLIGHT".endl() +
      "      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))"
        // .endl()+'       #define BlendSoftLight(base, blend)     Blend(base, blend, BlendSoftLightf)'
        //    .endl()+'      colNew=Blend(base, blend, BlendSoftLightf);'
        .endl() +
      "      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_HARDLIGHT".endl() +
      "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
        // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
        // .endl()+'      colNew=Blend(blend, base, BlendOverlayf);'
        .endl() +
      "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_COLORDODGE".endl() +
      "      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))"
        // .endl()+'      colNew=Blend(base, blend, BlendColorDodgef);'
        .endl() +
      "      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_COLORBURN".endl() +
      "      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))"
        // .endl()+'      colNew=Blend(base, blend, BlendColorBurnf);'
        .endl() +
      "      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   return colNew;".endl() +
      "}".endl();

    if (!ver)
      src +=
        "vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)".endl() +
        "{".endl() +
        "vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);".endl() +
        "col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);".endl() +
        "return col;".endl() +
        "}".endl();

    if (ver >= 3)
      src +=
        "vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)".endl() +
        "{".endl() +
        "#ifdef BM_MATH_ADD".endl() +
        "   return vec4(base.rgb+col.rgb*amount,1.0);".endl() +
        "#endif".endl() +
        "#ifdef BM_MATH_SUB".endl() +
        "   return vec4(base.rgb-col.rgb*amount,1.0);".endl() +
        "#endif".endl() +
        "#ifdef BM_MATH_MUL".endl() +
        "   return vec4(base.rgb*col.rgb*amount,1.0);".endl() +
        "#endif".endl() +
        "#ifdef BM_MATH_DIV".endl() +
        "   return vec4(base.rgb/col.rgb*amount,1.0);".endl() +
        "#endif".endl() +
        "#ifndef BM_MATH".endl() +
        "vec3 colNew=_blend(base.rgb,col.rgb);".endl() +
        "float newA=clamp(base.a+(col.a*amount),0.,1.);".endl() +
        "#ifdef BM_ALPHAMASKED".endl() +
        "newA=base.a;".endl() +
        "#endif".endl() +
        "return vec4(".endl() +
        "mix(colNew,base.rgb,1.0-(amount*col.a)),".endl() +
        "newA);".endl() +
        "#endif".endl() +
        "}".endl();

    return src;
  };

  TextureEffect.onChangeBlendSelect = function (
    shader,
    blendName,
    maskAlpha = false,
  ) {
    blendName = String(blendName);
    shader.toggleDefine("BM_NORMAL", blendName == "normal");
    shader.toggleDefine("BM_MULTIPLY", blendName == "multiply");
    shader.toggleDefine("BM_MULTIPLY_INV", blendName == "multiply invert");
    shader.toggleDefine("BM_AVERAGE", blendName == "average");
    shader.toggleDefine("BM_ADD", blendName == "add");
    shader.toggleDefine("BM_SUBTRACT_ONE", blendName == "subtract one");
    shader.toggleDefine("BM_SUBTRACT", blendName == "subtract");
    shader.toggleDefine("BM_DIFFERENCE", blendName == "difference");
    shader.toggleDefine("BM_NEGATION", blendName == "negation");
    shader.toggleDefine("BM_EXCLUSION", blendName == "exclusion");
    shader.toggleDefine("BM_LIGHTEN", blendName == "lighten");
    shader.toggleDefine("BM_DARKEN", blendName == "darken");
    shader.toggleDefine("BM_OVERLAY", blendName == "overlay");
    shader.toggleDefine("BM_SCREEN", blendName == "screen");
    shader.toggleDefine("BM_SOFTLIGHT", blendName == "softlight");
    shader.toggleDefine("BM_HARDLIGHT", blendName == "hardlight");
    shader.toggleDefine("BM_COLORDODGE", blendName == "color dodge");
    shader.toggleDefine("BM_COLORBURN", blendName == "color burn");

    shader.toggleDefine("BM_MATH_ADD", blendName == "Math Add");
    shader.toggleDefine("BM_MATH_SUB", blendName == "Math Subtract");
    shader.toggleDefine("BM_MATH_MUL", blendName == "Math Multiply");
    shader.toggleDefine("BM_MATH_DIV", blendName == "Math Divide");

    shader.toggleDefine("BM_MATH", blendName.indexOf("Math ") == 0);

    shader.toggleDefine("BM_ALPHAMASKED", maskAlpha);
  };

  TextureEffect.AddBlendSelect = function (op, name, defaultMode) {
    const p = op.inValueSelect(
      name || "Blend Mode",
      [
        "normal",
        "lighten",
        "darken",
        "multiply",
        "multiply invert",
        "average",
        "add",
        "subtract",
        "difference",
        "negation",
        "exclusion",
        "overlay",
        "screen",
        "color dodge",
        "color burn",
        "softlight",
        "hardlight",
        "subtract one",
        "Math Add",
        "Math Subtract",
        "Math Multiply",
        "Math Divide",
      ],
      defaultMode || "normal",
    );
    return p;
  };

  TextureEffect.AddBlendAlphaMask = function (op, name, defaultMode) {
    const p = op.inSwitch(
      name || "Alpha Mask",
      ["Off", "On"],
      defaultMode || "Off",
    );
    return p;
  };

  TextureEffect.setupBlending = function (
    op,
    shader,
    blendPort,
    amountPort,
    alphaMaskPort,
  ) {
    const onChange = () => {
      let maskAlpha = false;
      if (alphaMaskPort) maskAlpha = alphaMaskPort.get() == "On";
      TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);

      let str = blendPort.get();
      if (str == "normal") str = null;
      else if (str == "multiply") str = "mul";
      else if (str == "multiply invert") str = "mulinv";
      else if (str == "lighten") str = "light";
      else if (str == "darken") str = "darken";
      else if (str == "average") str = "avg";
      else if (str == "subtract one") str = "sub one";
      else if (str == "subtract") str = "sub";
      else if (str == "difference") str = "diff";
      else if (str == "negation") str = "neg";
      else if (str == "exclusion") str = "exc";
      else if (str == "overlay") str = "ovl";
      else if (str == "color dodge") str = "dodge";
      else if (str == "color burn") str = "burn";
      else if (str == "softlight") str = "soft";
      else if (str == "hardlight") str = "hard";
      else if (str == "Math Add") str = "+";
      else if (str == "Math Subtract") str = "-";
      else if (str == "Math Multiply") str = "*";
      else if (str == "Math Divide") str = "/";

      op.setUiAttrib({ extendTitle: str });
    };
    op.setPortGroup("Blending", [blendPort, amountPort, alphaMaskPort]);

    let maskAlpha = false;

    blendPort.onChange = onChange;
    if (alphaMaskPort) {
      alphaMaskPort.onChange = onChange;
      maskAlpha = alphaMaskPort.get() == "On";
    }

    TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);
  };

  /** @type {Object} */
  const ShaderLibMods = {
    "CGL.BLENDMODES": function () {
      this.name = "blendmodes";
      this.srcHeadFrag = TextureEffect.getBlendCode();
    },

    "CGL.BLENDMODES3": function () {
      this.name = "blendmodes3";
      this.srcHeadFrag = TextureEffect.getBlendCode(3);
    },

    "CGL.LUMINANCE": function () {
      this.name = "luminance";
      this.srcHeadFrag =
        "".endl() +
        "float cgl_luminance(vec3 c)".endl() +
        "{".endl() +
        "    return dot(vec3(0.2126,0.7152,0.0722),c);".endl() +
        "}".endl();
    },

    // quite good random numbers, but somehow don't work in ANGLE
    "CGL.RANDOM_OLD": function () {
      this.name = "randomNumber";
      this.srcHeadFrag =
        "".endl() +
        "float cgl_random(vec2 co)".endl() +
        "{".endl() +
        "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);".endl() +
        "}".endl() +
        "vec3 cgl_random3(vec2 co)".endl() +
        "{".endl() +
        "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl() +
        "}";
    },

    // low quality generative ranodm numbers
    "CGL.RANDOM_LOW": function () {
      this.name = "randomNumber";
      this.srcHeadFrag =
        "".endl() +
        "float cgl_random(vec2 co)".endl() +
        "{".endl() +
        "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);".endl() +
        "}".endl() +
        "vec3 cgl_random3(vec2 co)".endl() +
        "{".endl() +
        "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl() +
        "}";
    },

    "CGL.RANDOM_TEX": function () {
      this.name = "randomNumbertex";

      this.srcHeadFrag =
        "".endl() +
        "UNI sampler2D CGLRNDTEX;".endl() +
        "float cgl_random(vec2 co)".endl() +
        "{".endl() +
        "    return texture(CGLRNDTEX,co*5711.0).r;".endl() +
        "}".endl() +
        "vec3 cgl_random3(vec2 co)".endl() +
        "{".endl() +
        "    return texture(CGLRNDTEX,co*5711.0).rgb;".endl() +
        "}";

      this.initUniforms = function (shader) {
        return [new Uniform(shader, "t", "CGLRNDTEX", 7)];
      };

      this.onBind = function (cgl, shader) {
        CABLES.CGL.Texture.getRandomTexture(cgl);
        cgl.setTexture(7, CABLES.CGL.Texture.getRandomTexture(cgl).tex);
      };
    },
  };

  /**
   * @namespace CGL
   */


  const onLoadingAssetsFinished = null; // deprecated / remove later

  /**
   * get normalized mouse wheel delta (including browser specific adjustment)
   * @function getWheelDelta
   * @static
   * @memberof CGL
   * @param {MouseEvent} event
   * @return {Number} normalized delta
   */
  const isWindows = window.navigator?.userAgent.includes("Windows");
  const getWheelDelta_ = function (event) {
    let normalized;
    if (event.wheelDelta) {
      // chrome
      normalized =
        (event.wheelDelta % 120) - 0 == -0
          ? event.wheelDelta / 120
          : event.wheelDelta / 30;
      normalized *= -1.5;
      if (isWindows) normalized *= 2;
    } else {
      // firefox
      let d = event.deltaY;
      if (event.shiftKey) d = event.deltaX;
      const rawAmmount = d || event.detail;
      normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);
      normalized *= -3;
    }

    if (normalized > 20) normalized = 20;
    if (normalized < -20) normalized = -20;

    return normalized;
  };

  const getWheelSpeed = getWheelDelta_;
  const getWheelDelta = getWheelDelta_;

  var defaultShaderSrcVert$1 = `{{MODULES_HEAD}}
IN vec3 vPosition; //!@
IN vec2 attrTexCoord;
IN vec3 attrVertNormal;
IN vec3 attrTangent,attrBiTangent;

IN float attrVertIndex;

OUT vec2 texCoord;
OUT vec3 norm;
UNI mat4 projMatrix;
UNI mat4 viewMatrix;
UNI mat4 modelMatrix;

void main()
{
    texCoord=attrTexCoord;
    norm=attrVertNormal;
    vec4 pos=vec4(vPosition,  1.0);
    vec3 tangent=attrTangent;
    vec3 bitangent=attrBiTangent;
    mat4 mMatrix=modelMatrix;
    gl_PointSize=10.0;

    {{MODULE_VERTEX_POSITION}}

    mat4 modelViewMatrix=viewMatrix*mMatrix;
    {{MODULE_VERTEX_MODELVIEW}}

    gl_Position = projMatrix * modelViewMatrix * pos;
}
`;

  // ---------------------------------------------------------------------------

  /*

  proposal default shader variable names:

  attrVertex - currently: vPosition
  attrVertexIndex - currently: attrVertIndex
  attrTexCoord
  attrInstMat - currently: instMat
  attrVertColor
  attrTangent
  attrBiTangent

  uProjMatrix - currently: projMatrix
  uModelMatrix - currently: modelMatrix
  uNormalMatrix - currently: normalMatrix
  uCamPosition - currently: camPos

  */

  // ---------------------------------------------------------------------------

  let materialIdCounter = 0;

  function getDefaultVertexShader() {
    return defaultShaderSrcVert$1;
  }

  /**
   * @param {number} [r]
   * @param {number} [g]
   * @param {number} [b]
   */
  function getDefaultFragmentShader(r, g, b) {
    if (r == undefined) {
      r = 0.5;
      g = 0.5;
      b = 0.5;
    }
    return (
      "" +
      nl +
      "IN vec2 texCoord;" +
      nl +
      "{{MODULES_HEAD}}" +
      nl +
      "void main()" +
      nl +
      "{" +
      nl +
      "    vec4 col=vec4(" +
      r +
      "," +
      g +
      "," +
      b +
      ",1.0);" +
      nl +
      "    {{MODULE_COLOR}}" +
      nl +
      "    outColor = col;" +
      nl +
      "}"
    );
  }

  /**
   * @class
   * @namespace external:CGL
   * @hideconstructor
   * @param _cgl
   * @param _name
   * @param _op
   * @example
   * var shader=new CGL.Shader(cgl,'MinimalMaterial');
   * shader.setSource(attachments.shader_vert,attachments.shader_frag);
   */
  class CglShader extends CgShader {
    /** @type {Uniform[]} */
    _uniforms = [];

    /**
     * @param {CglContext} _cgl
     * @param {string} _name
     * @param {Op} [_op]
     */
    constructor(_cgl, _name, _op) {
      super();
      if (!_cgl) throw new Error("shader constructed without cgl " + _name);

      this._log = new Logger("cgl_shader");
      this._cgl = _cgl;

      if (!_name) this._log.stack("no shader name given");
      this._name = _name || "unknown";

      if (_op) this.opId = _op.id;
      this.glslVersion = 0;
      if (_cgl.glVersion > 1) this.glslVersion = 300;

      this._materialId = ++materialIdCounter;

      this._program = null;
      this._drawBuffers = [true];
      this.error = null;

      this.ignoreMissingUniforms = false;
      this._projMatrixUniform = null;
      this._mvMatrixUniform = null;
      this._mMatrixUniform = null;
      this._vMatrixUniform = null;
      this._camPosUniform = null;
      this._normalMatrixUniform = null;
      this._inverseViewMatrixUniform = null;
      this._fromUserInteraction = false;

      this._attrVertexPos = -1;
      this.precision = _cgl.patch.config.glslPrecision || "highp";

      this._pMatrixState = -1;
      this._vMatrixState = -1;

      this._countMissingUniforms = 0;
      this._modGroupCount = 0; // not needed anymore...
      this._feedBackNames = [];
      this._attributes = [];

      this.glPrimitive = null;
      this.offScreenPass = false;
      this._extensions = [];
      this.srcVert = getDefaultVertexShader();
      this.srcFrag = getDefaultFragmentShader();
      this.lastCompile = 0;

      this._libs = [];
      this._structNames = [];
      this._structUniformNames = [];
      this._textureStackUni = [];
      this._textureStackTex = [];
      this._textureStackType = [];
      this._textureStackTexCgl = [];

      this._tempNormalMatrix = create$5();
      this._tempCamPosMatrix = create$5();
      this._tempInverseViewMatrix = create$5();
      this._tempInverseProjMatrix = create$5();

      this.setModules([
        "MODULE_VERTEX_POSITION",
        "MODULE_COLOR",
        "MODULE_NORMAL",
        "MODULE_BEGIN_FRAG",
        "MODULE_VERTEX_MODELVIEW",
      ]);
    }

    isValid() {
      return this._isValid;
    }

    getCgl() {
      return this._cgl;
    }

    getName() {
      return this._name;
    }

    /**
     * @param {string} name
     */
    enableExtension(name) {
      this.setWhyCompile("enable extension " + name);

      this._extensions.push(name);
    }

    getAttrVertexPos() {
      return this._attrVertexPos;
    }

    hasTextureUniforms() {
      for (let i = 0; i < this._uniforms.length; i++)
        if (this._uniforms[i].getType() == "t") return true;
      return false;
    }

    /**
     * copy all uniform values from another shader
     * @param {CglShader} origShader uniform values will be copied from this shader
     */
    copyUniformValues(origShader) {
      for (let i = 0; i < origShader._uniforms.length; i++) {
        if (!this._uniforms[i]) {
          this._log.log("unknown uniform?!");
          continue;
        }

        this.getUniform(origShader._uniforms[i].getName()).set(
          origShader._uniforms[i].getValue(),
        );
      }

      this.popTextures();
      for (let i = 0; i < origShader._textureStackUni.length; i++) {
        this._textureStackUni[i] = origShader._textureStackUni[i];
        this._textureStackTex[i] = origShader._textureStackTex[i];
        this._textureStackType[i] = origShader._textureStackType[i];
        this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];
      }
    }

    /**
     * copy current shader
     * @returns {CglShader} newShader
     */
    copy() {
      const shader = new CglShader(this._cgl, this._name + " copy");
      shader.setSource(this.srcVert, this.srcFrag);

      shader._modules = JSON.parse(JSON.stringify(this._modules));
      shader._defines = JSON.parse(JSON.stringify(this._defines));

      shader._modGroupCount = this._modGroupCount;
      shader._moduleNames = this._moduleNames;
      shader.glPrimitive = this.glPrimitive;
      shader.offScreenPass = this.offScreenPass;
      shader._extensions = this._extensions;
      shader.wireframe = this.wireframe;
      shader._attributes = this._attributes;

      for (let i = 0; i < this._uniforms.length; i++) {
        const u = this._uniforms[i].copy(shader);
        u.resetLoc();
      }

      shader.setWhyCompile("copy");
      return shader;
    }

    /**
     * set shader source code
     * @param {String} srcVert
     * @param {String} srcFrag
     * @param {Boolean} fromUserInteraction
     */
    setSource(srcVert, srcFrag, fromUserInteraction = false) {
      this._fromUserInteraction = fromUserInteraction;
      this.srcVert = srcVert;
      this.srcFrag = srcFrag;
      this.setWhyCompile("Source changed");
      this._isValid = true;
    }

    _addLibs(src) {
      for (const id in ShaderLibMods) {
        if (src.includes(id)) {
          const lib = new ShaderLibMods[id]();
          src = src.replace("{{" + id + "}}", lib.srcHeadFrag);
          this._libs.push(lib);
          if (lib.initUniforms) lib.initUniforms(this);
        }
      }

      return src;
    }

    createStructUniforms() {
      // * create structs
      let structStrFrag = "";
      let structStrVert = ""; // TODO: not used yet

      this._structNames = [];
      // * reset the arrays holding the value each recompile so we don't skip structs
      // * key value mapping so the same struct can be added twice (two times the same modifier)
      this._injectedStringsFrag = {};
      this._injectedStringsVert = {};

      this._structUniformNamesIndicesFrag = [];
      this._structUniformNamesIndicesVert = [];

      for (let i = 0; i < this._uniforms.length; i++) {
        // * only add uniforms to struct that are a member of a struct
        if (this._uniforms[i].isStructMember()) {
          const injectionString =
            "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";

          // * check if struct is not already part of shader
          if (!this._structNames.includes(this._uniforms[i]._structName)) {
            // * create struct definition with placeholder string to inject
            const structDefinition =
              "struct " +
              this._uniforms[i]._structName +
              " {" +
              nl +
              injectionString +
              "};" +
              nl +
              nl;

            if (
              this._uniforms[i].getShaderType() === "both" ||
              this._uniforms[i].getShaderType() === "frag"
            )
              structStrFrag = structStrFrag.concat(structDefinition);

            if (
              this._uniforms[i].getShaderType() === "both" ||
              this._uniforms[i].getShaderType() === "vert"
            )
              structStrVert = structStrVert.concat(structDefinition);

            this._structNames.push(this._uniforms[i]._structName);
            this._injectedStringsFrag[this._uniforms[i]._structName] = [];
            this._injectedStringsVert[this._uniforms[i]._structName] = [];
          }

          // * create member & comment
          let comment = "";
          if (this._uniforms[i].comment)
            comment = " // " + this._uniforms[i].comment;

          let stringToInsert = "";
          if (this._uniforms[i].getGlslTypeString() == undefined)
            stringToInsert += "//";
          stringToInsert +=
            "  " +
            this._uniforms[i].getGlslTypeString() +
            " " +
            this._uniforms[i]._propertyName +
            ";" +
            comment;

          if (this._uniforms[i].getShaderType() === "both") {
            // * inject member before {injectionString}
            if (
              !this._injectedStringsFrag[this._uniforms[i]._structName].includes(
                stringToInsert,
              ) &&
              !this._injectedStringsVert[this._uniforms[i]._structName].includes(
                stringToInsert,
              )
            ) {
              const insertionIndexFrag =
                structStrFrag.lastIndexOf(injectionString);
              const insertionIndexVert =
                structStrVert.lastIndexOf(injectionString);

              structStrFrag =
                structStrFrag.slice(0, insertionIndexFrag) +
                stringToInsert +
                structStrFrag.slice(insertionIndexFrag - 1);

              structStrVert =
                structStrVert.slice(0, insertionIndexVert) +
                stringToInsert +
                structStrVert.slice(insertionIndexVert - 1);

              this._injectedStringsFrag[this._uniforms[i]._structName].push(
                stringToInsert,
              );
              this._injectedStringsVert[this._uniforms[i]._structName].push(
                stringToInsert,
              );
            }

            if (!this._structUniformNamesIndicesFrag.includes(i))
              this._structUniformNamesIndicesFrag.push(i);
            if (!this._structUniformNamesIndicesVert.includes(i))
              this._structUniformNamesIndicesVert.push(i);
          } else if (this._uniforms[i].getShaderType() === "frag") {
            // * inject member before {injectionString}
            if (
              !this._injectedStringsFrag[this._uniforms[i]._structName].includes(
                stringToInsert,
              )
            ) {
              //
              const insertionIndexFrag =
                structStrFrag.lastIndexOf(injectionString);

              structStrFrag =
                structStrFrag.slice(0, insertionIndexFrag) +
                stringToInsert +
                structStrFrag.slice(insertionIndexFrag - 1);

              this._injectedStringsFrag[this._uniforms[i]._structName].push(
                stringToInsert,
              );
            }

            if (!this._structUniformNamesIndicesFrag.includes(i))
              this._structUniformNamesIndicesFrag.push(i);
          } else if (this._uniforms[i].getShaderType() === "vert") {
            // * inject member before {injectionString}
            if (
              !this._injectedStringsVert[this._uniforms[i]._structName].includes(
                stringToInsert,
              )
            ) {
              const insertionIndexVert =
                structStrVert.lastIndexOf(injectionString);

              structStrVert =
                structStrVert.slice(0, insertionIndexVert) +
                stringToInsert +
                structStrVert.slice(insertionIndexVert - 1);

              this._injectedStringsVert[this._uniforms[i]._structName].push(
                stringToInsert,
              );
            }

            if (!this._structUniformNamesIndicesVert.includes(i))
              this._structUniformNamesIndicesVert.push(i);
          }
        }
      }

      // * dedupe injected uni declarations
      this._uniDeclarationsFrag = [];
      this._uniDeclarationsVert = [];

      // * remove struct injection points and add uniform in fragment
      for (let i = 0; i < this._structUniformNamesIndicesFrag.length; i += 1) {
        const index = this._structUniformNamesIndicesFrag[i];
        const uniDeclarationString =
          "UNI " +
          this._uniforms[index]._structName +
          " " +
          this._uniforms[index]._structUniformName +
          ";" +
          nl;

        if (!this._uniDeclarationsFrag.includes(uniDeclarationString)) {
          const injectionString =
            "{{INJECTION_POINT_STRUCT_" +
            this._uniforms[index]._structName +
            "}}";

          structStrFrag = structStrFrag.replace(injectionString, "");
          structStrFrag += uniDeclarationString;

          this._uniDeclarationsFrag.push(uniDeclarationString);
        }
      }

      // * remove struct injection points and add uniform in vertex
      for (let i = 0; i < this._structUniformNamesIndicesVert.length; i += 1) {
        const index = this._structUniformNamesIndicesVert[i];
        const uniDeclarationString =
          "UNI " +
          this._uniforms[index]._structName +
          " " +
          this._uniforms[index]._structUniformName +
          ";" +
          nl;

        if (!this._uniDeclarationsVert.includes(uniDeclarationString)) {
          const injectionString =
            "{{INJECTION_POINT_STRUCT_" +
            this._uniforms[index]._structName +
            "}}";

          structStrVert = structStrVert.replace(injectionString, "");
          structStrVert += uniDeclarationString;
          this._uniDeclarationsVert.push(uniDeclarationString);
        }
      }

      return [structStrVert, structStrFrag];
    }

    _getAttrSrc(attr, firstLevel) {
      const r = {};
      if (attr.name && attr.type) {
        r.srcHeadVert = "";
        if (!firstLevel) r.srcHeadVert += "#ifndef ATTRIB_" + attr.name + nl;
        r.srcHeadVert += "#define ATTRIB_" + attr.name + nl;
        r.srcHeadVert += "IN " + attr.type + " " + attr.name + ";" + nl;
        if (!firstLevel) r.srcHeadVert += "#endif" + nl;

        if (attr.nameFrag) {
          r.srcHeadVert += "";
          if (!firstLevel)
            r.srcHeadVert += "#ifndef ATTRIB_" + attr.nameFrag + nl;
          r.srcHeadVert += "#define ATTRIB_" + attr.nameFrag + nl;
          r.srcHeadVert += "OUT " + attr.type + " " + attr.nameFrag + ";" + nl;
          if (!firstLevel) r.srcHeadVert += "#endif" + nl;

          r.srcVert = "" + nl + attr.nameFrag + "=" + attr.name + ";";

          r.srcHeadFrag = "";
          if (!firstLevel)
            r.srcHeadFrag += "#ifndef ATTRIB_" + attr.nameFrag + nl;
          r.srcHeadFrag += "#define ATTRIB_" + attr.nameFrag + nl;
          r.srcHeadFrag += "IN " + attr.type + " " + attr.nameFrag + ";" + nl;
          if (!firstLevel) r.srcHeadFrag += "#endif" + nl;
        }
      }
      return r;
    }

    compile() {
      if (this._cgl.aborted) return;
      const startTime = performance.now();

      this._cgl.profileData.profileShaderCompiles++;
      this._cgl.profileData.profileShaderCompileName =
        this._name + " [" + this._compileReason + "]";

      let extensionString = "";
      if (this._extensions)
        for (let i = 0; i < this._extensions.length; i++)
          extensionString +=
            "#extension " + this._extensions[i] + " : enable" + nl;

      let definesStr = "";
      if (this._defines.length) definesStr = "\n// cgl generated" + nl;
      for (let i = 0; i < this._defines.length; i++)
        definesStr +=
          "#define " + this._defines[i][0] + " " + this._defines[i][1] + "" + nl;

      const structStrings = this.createStructUniforms();
      this._cgl.profileData.addHeavyEvent(
        "shader compile",
        this._name + " [" + this._compileReason + "]",
      );
      this._compileReason = "";

      if (this._uniforms) {
        // * we create an array of the uniform names to check our indices & an array to save them
        const uniNames = this._uniforms.map((uni) => {
          return uni._name;
        });
        const indicesToRemove = [];

        // * we go through our uniforms and check if the same name is contained somewhere further in the array
        // * if so, we add the current index to be removed later
        for (let i = 0; i < this._uniforms.length; i++) {
          const uni = this._uniforms[i];
          const nextIndex = uniNames.indexOf(uni._name, i + 1);
          if (nextIndex > -1) indicesToRemove.push(i);
        }

        // * after that, we go through the uniforms backwards (so we keep the order) and remove the indices
        // * also, we reset the locations of all the other valid uniforms
        for (let j = this._uniforms.length - 1; j >= 0; j -= 1) {
          if (indicesToRemove.includes(j)) this._uniforms.splice(j, 1);
          else this._uniforms[j].resetLoc();
        }
      }

      this._cgl.printError("uniform resets");

      this._compileCount++;
      if (this.hasTextureUniforms()) definesStr += "#define HAS_TEXTURES" + nl;

      let vs = "";
      let fs = "";

      if (!this.srcFrag) {
        this._log.warn("[cgl shader] has no fragment source!", this._name, this);
        this.srcVert = getDefaultVertexShader();
        this.srcFrag = getDefaultFragmentShader();
      }

      vs =
        "#version 300 es" +
        nl +
        "// " +
        nl +
        "// vertex shader " +
        this._name +
        nl +
        "// " +
        nl +
        "precision " +
        this.precision +
        " float;" +
        nl +
        "precision " +
        this.precision +
        " sampler2D;" +
        nl +
        "" +
        nl +
        "#define WEBGL2" +
        nl +
        "#define texture2D texture" +
        nl +
        "#define UNI uniform" +
        nl +
        "#define IN in" +
        nl +
        "#define OUT out" +
        nl;

      fs =
        "#version 300 es" +
        nl +
        "// " +
        nl +
        "// fragment shader " +
        this._name +
        nl +
        "// " +
        nl +
        "precision " +
        this.precision +
        " float;" +
        nl +
        "precision " +
        this.precision +
        " sampler2D;" +
        nl +
        "" +
        nl +
        "#define WEBGL2" +
        nl +
        "#define texture2D texture" +
        nl +
        "#define IN in" +
        nl +
        "#define OUT out" +
        nl +
        "#define UNI uniform" +
        nl +
        "{{DRAWBUFFER}}" +
        nl;

      let uniformsStrVert = "\n// cgl generated" + nl;
      let uniformsStrFrag = "\n// cgl generated" + nl;

      fs += "\n// active mods: --------------- ";
      vs += "\n// active mods: --------------- ";

      let foundModsFrag = false;
      let foundModsVert = false;
      for (let i = 0; i < this._moduleNames.length; i++) {
        for (let j = 0; j < this._modules.length; j++) {
          if (this._modules[j].name == this._moduleNames[i]) {
            if (this._modules[j].srcBodyFrag || this._modules[j].srcHeadFrag) {
              foundModsFrag = true;
              fs +=
                "\n// " +
                i +
                "." +
                j +
                ". " +
                this._modules[j].title +
                " (" +
                this._modules[j].name +
                ")";
            }
            if (this._modules[j].srcBodyVert || this._modules[j].srcHeadVert) {
              vs +=
                "\n// " +
                i +
                "." +
                j +
                ". " +
                this._modules[j].title +
                " (" +
                this._modules[j].name +
                ")";
              foundModsVert = true;
            }
          }
        }
      }
      if (!foundModsVert) fs += "\n// no mods used...";
      if (!foundModsFrag) fs += "\n// no mods used...";
      fs += "\n";
      vs += "\n";

      for (let i = 0; i < this._uniforms.length; i++) {
        if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember()) {
          let uniStr = "";
          if (!this._uniforms[i].getGlslTypeString()) uniStr += "// ";
          uniStr +=
            "UNI " +
            this._uniforms[i].getGlslTypeString() +
            " " +
            this._uniforms[i].getName();
          let comment = "";
          if (this._uniforms[i].comment)
            comment = " // " + this._uniforms[i].comment;

          if (
            this._uniforms[i].shaderType == "vert" ||
            this._uniforms[i].shaderType == "both"
          )
            if (
              !this.srcVert.includes(uniStr) &&
              !this.srcVert.includes(
                "uniform " +
                  this._uniforms[i].getGlslTypeString() +
                  " " +
                  this._uniforms[i].getName(),
              )
            )
              uniformsStrVert += uniStr + ";" + comment + nl;

          if (
            this._uniforms[i].shaderType == "frag" ||
            this._uniforms[i].shaderType == "both"
          )
            if (
              !this.srcFrag.includes(uniStr) &&
              !this.srcFrag.includes(
                "uniform " +
                  this._uniforms[i].getGlslTypeString() +
                  " " +
                  this._uniforms[i].getName(),
              )
            )
              uniformsStrFrag += uniStr + ";" + comment + nl;
        }
      }

      let countUniFrag = 0;
      let countUniVert = 0;
      for (let i = 0; i < this._uniforms.length; i++) {
        if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember()) {
          if (
            this._uniforms[i].shaderType == "vert" ||
            this._uniforms[i].shaderType == "both"
          )
            countUniVert++;
          if (
            this._uniforms[i].shaderType == "frag" ||
            this._uniforms[i].shaderType == "both"
          )
            countUniFrag++;
        }
      }
      if (countUniFrag >= this._cgl.maxUniformsFrag)
        this._log.warn(
          "[cgl_shader] num uniforms frag: " +
            countUniFrag +
            " / " +
            this._cgl.maxUniformsFrag,
        );
      if (countUniVert >= this._cgl.maxUniformsVert)
        this._log.warn(
          "[cgl_shader] num uniforms vert: " +
            countUniVert +
            " / " +
            this._cgl.maxUniformsVert,
        );

      if (!fs.includes("precision"))
        fs = "precision " + this.precision + " float;" + nl + fs;
      if (!vs.includes("precision"))
        vs = "precision " + this.precision + " float;" + nl + vs;
      if (
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent,
        )
      ) {
        fs += "#define MOBILE" + nl;
        vs += "#define MOBILE" + nl;
      }
      vs =
        extensionString +
        vs +
        definesStr +
        structStrings[0] +
        uniformsStrVert +
        "\n// -- \n" +
        this.srcVert;
      fs =
        extensionString +
        fs +
        definesStr +
        structStrings[1] +
        uniformsStrFrag +
        "\n// -- \n" +
        this.srcFrag;

      let srcHeadVert = "";
      let srcHeadFrag = "";

      this._modules.sort(function (a, b) {
        return a.priority || 0 - b.priority || 0;
      });

      let addedAttribs = false;

      for (let i = 0; i < this._moduleNames.length; i++) {
        let srcVert = "";
        let srcFrag = "";

        if (!addedAttribs) {
          addedAttribs = true;

          for (let k = 0; k < this._attributes.length; k++) {
            const r = this._getAttrSrc(this._attributes[k], true);
            if (r.srcHeadVert) srcHeadVert += r.srcHeadVert;
            if (r.srcVert) srcVert += r.srcVert;
            if (r.srcHeadFrag) srcHeadFrag += r.srcHeadFrag;
          }
        }

        for (let j = 0; j < this._modules.length; j++) {
          const mod = this._modules[j];
          if (mod.name == this._moduleNames[i]) {
            srcHeadVert +=
              "\n//---- MOD: group:" +
              mod.group +
              ": idx:" +
              j +
              " - prfx:" +
              mod.prefix +
              " - " +
              mod.title +
              " ------\n";
            srcHeadFrag +=
              "\n//---- MOD: group:" +
              mod.group +
              ": idx:" +
              j +
              " - prfx:" +
              mod.prefix +
              " - " +
              mod.title +
              " ------\n";

            srcVert +=
              "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";
            srcFrag +=
              "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";

            if (mod.attributes)
              for (let k = 0; k < mod.attributes.length; k++) {
                const r = this._getAttrSrc(mod.attributes[k], false);
                if (r.srcHeadVert) srcHeadVert += r.srcHeadVert;
                if (r.srcVert) srcVert += r.srcVert;
                if (r.srcHeadFrag) srcHeadFrag += r.srcHeadFrag;
              }

            srcHeadVert += mod.srcHeadVert || "";
            srcHeadFrag += mod.srcHeadFrag || "";
            srcVert += mod.srcBodyVert || "";
            srcFrag += mod.srcBodyFrag || "";

            srcHeadVert += "\n//---- end mod ------\n";
            srcHeadFrag += "\n//---- end mod ------\n";

            srcVert += "\n//---- end mod ------\n";
            srcFrag += "\n//---- end mod ------\n";

            srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
            srcFrag = srcFrag.replace(/{{mod}}/g, mod.prefix);
            srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);
            srcHeadFrag = srcHeadFrag.replace(/{{mod}}/g, mod.prefix);

            srcVert = srcVert.replace(/MOD_/g, mod.prefix);
            srcFrag = srcFrag.replace(/MOD_/g, mod.prefix);
            srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
            srcHeadFrag = srcHeadFrag.replace(/MOD_/g, mod.prefix);
          }
        }

        vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
        fs = fs.replace("{{" + this._moduleNames[i] + "}}", srcFrag);
      }

      vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
      fs = fs.replace("{{MODULES_HEAD}}", srcHeadFrag);

      vs = this._addLibs(vs);
      fs = this._addLibs(fs);

      // SETUP draw buffers / multi texture render targets

      let drawBufferStr = "";
      for (let i = 0; i < 16; i++)
        if (fs.includes("outColor" + i)) this._drawBuffers[i] = true;

      if (this._drawBuffers.length == 1) {
        drawBufferStr = "out vec4 outColor;" + nl;
        drawBufferStr += "#define gl_FragColor outColor" + nl;
      } else {
        drawBufferStr += "#define MULTI_COLORTARGETS" + nl;
        drawBufferStr += "vec4 outColor;" + nl;

        let count = 0;
        for (let i = 0; i < this._drawBuffers.length; i++) {
          if (count == 0)
            drawBufferStr += "#define gl_FragColor outColor" + i + "" + nl;
          drawBufferStr +=
            "layout(location = " + i + ") out vec4 outColor" + i + ";" + nl;
          count++;
        }
      }

      fs = fs.replace("{{DRAWBUFFER}}", drawBufferStr);
      // //////

      if (!this._program) {
        this._program = this._createProgram(vs, fs);
      } else {
        // this.vshader=createShader(vs, gl.VERTEX_SHADER, this.vshader );
        // this.fshader=createShader(fs, gl.FRAGMENT_SHADER, this.fshader );
        // linkProgram(program);
        this._program = this._createProgram(vs, fs);

        this._projMatrixUniform = null;

        for (let i = 0; i < this._uniforms.length; i++)
          this._uniforms[i].resetLoc();
      }

      this.finalShaderFrag = fs;
      this.finalShaderVert = vs;

      MESH.lastMesh = null;
      MESH.lastShader = null;

      this._countMissingUniforms = 0;
      this._needsRecompile = false;
      this.lastCompile = now();

      this._cgl.profileData.shaderCompileTime += performance.now() - startTime;
    }

    bind() {
      if (!this._isValid || this._cgl.aborted) return;

      MESH.lastShader = this;

      if (!this._program || this.needsRecompile()) this.compile();
      if (!this._isValid) return;

      if (!this._projMatrixUniform && !this.ignoreMissingUniforms) {
        this._countMissingUniforms++;
        // if (this._countMissingUniforms == 10)this._log.log("stopping getlocation of missing uniforms...", this._name);
        if (this._countMissingUniforms < 10) {
          this._projMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_PROJMAT,
          );
          this._attrVertexPos = this._cgl.glGetAttribLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_VERTEX_POSITION,
          );
          this._mvMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            "mvMatrix",
          );
          this._vMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_VIEWMAT,
          );
          this._mMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_MODELMAT,
          );
          this._camPosUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_VIEWPOS,
          );
          this._normalMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_NORMALMAT,
          );
          this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_INVVIEWMAT,
          );
          this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_INVPROJMAT,
          );
          this._materialIdUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_MATERIALID,
          );
          this._objectIdUniform = this._cgl.gl.getUniformLocation(
            this._program,
            CONSTANTS$1.SHADER.SHADERVAR_UNI_OBJECTID,
          );

          for (let i = 0; i < this._uniforms.length; i++)
            this._uniforms[i].needsUpdate = true;
        }
      }

      if (this._cgl.currentProgram != this._program) {
        this._cgl.profileData.profileShaderBinds++;
        this._cgl.gl.useProgram(this._program);
        this._cgl.currentProgram = this._program;
      }

      for (let i = 0; i < this._uniforms.length; i++)
        if (this._uniforms[i].needsUpdate) this._uniforms[i].updateValue();

      if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount()) {
        this._pMatrixState = this._cgl.getProjectionMatrixStateCount();
        this._cgl.gl.uniformMatrix4fv(
          this._projMatrixUniform,
          false,
          this._cgl.pMatrix,
        );
        this._cgl.profileData.profileMVPMatrixCount++;
      }

      if (this._objectIdUniform)
        this._cgl.gl.uniform1f(
          this._objectIdUniform,
          ++this._cgl.tempData.objectIdCounter,
        );

      if (this._materialIdUniform)
        this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId);

      if (this._vMatrixUniform) {
        if (this._vMatrixState != this._cgl.getViewMatrixStateCount()) {
          this._cgl.gl.uniformMatrix4fv(
            this._vMatrixUniform,
            false,
            this._cgl.vMatrix,
          );
          this._cgl.profileData.profileMVPMatrixCount++;
          this._vMatrixState = this._cgl.getViewMatrixStateCount();

          if (this._inverseViewMatrixUniform) {
            invert$2(this._tempInverseViewMatrix, this._cgl.vMatrix);
            this._cgl.gl.uniformMatrix4fv(
              this._inverseViewMatrixUniform,
              false,
              this._tempInverseViewMatrix,
            );
            this._cgl.profileData.profileMVPMatrixCount++;
          }
          if (this._inverseProjMatrixUniform) {
            invert$2(this._tempInverseProjMatrix, this._cgl.pMatrix);
            this._cgl.gl.uniformMatrix4fv(
              this._inverseProjMatrixUniform,
              false,
              this._tempInverseProjMatrix,
            );
            this._cgl.profileData.profileMVPMatrixCount++;
          }
        }
        this._cgl.gl.uniformMatrix4fv(
          this._mMatrixUniform,
          false,
          this._cgl.mMatrix,
        );
        this._cgl.profileData.profileMVPMatrixCount++;

        if (this._camPosUniform) {
          invert$2(this._tempCamPosMatrix, this._cgl.vMatrix);
          this._cgl.gl.uniform3f(
            this._camPosUniform,
            this._tempCamPosMatrix[12],
            this._tempCamPosMatrix[13],
            this._tempCamPosMatrix[14],
          );
          this._cgl.profileData.profileMVPMatrixCount++;
        }
      } else {
        // mvmatrix deprecated....
        const tempmv = create$5();

        mul$5(tempmv, this._cgl.vMatrix, this._cgl.mMatrix);
        this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, false, tempmv);
        this._cgl.profileData.profileMVPMatrixCount++;
      }

      if (this._normalMatrixUniform) {
        // mat4.mul(this._tempNormalMatrix, this._cgl.vMatrix, this._cgl.mMatrix);
        invert$2(this._tempNormalMatrix, this._cgl.mMatrix);
        transpose(this._tempNormalMatrix, this._tempNormalMatrix);

        this._cgl.gl.uniformMatrix4fv(
          this._normalMatrixUniform,
          false,
          this._tempNormalMatrix,
        );
        this._cgl.profileData.profileMVPMatrixCount++;
      }

      for (let i = 0; i < this._libs.length; i++) {
        if (this._libs[i].onBind)
          this._libs[i].onBind.bind(this._libs[i])(this._cgl, this);
      }

      this._bindTextures();

      return this._isValid;
    }

    unBind() {}

    dispose() {
      if (this._program && this._cgl && this._cgl.gl)
        this._cgl.gl.deleteProgram(this._program);
      this._program = null;
    }

    setDrawBuffers(arr) {
      this._log.warn("useless drawbuffers...?!");
    }

    getUniforms() {
      return this._uniforms;
    }

    getUniform(name) {
      for (let i = 0; i < this._uniforms.length; i++)
        if (this._uniforms[i].getName() == name) return this._uniforms[i];
      return null;
    }

    removeAllUniforms() {
      this._uniforms = [];
      // for (let i = 0; i < this._uniforms.length; i++)
      //     this.removeUniform(this._uniforms[i].name);
    }

    _addUniform(uni) {
      this._uniforms.push(uni);
      this.setWhyCompile("add uniform " + name);
    }

    /**
     * add a uniform to the fragment shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformFrag(type, name, valueOrPort, p2, p3, p4) {
      const uni = new Uniform(this, type, name, valueOrPort, p2, p3, p4);
      uni.shaderType = "frag";
      return uni;
    }

    /**
     * add a uniform to the vertex shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformVert(type, name, valueOrPort, p2, p3, p4) {
      const uni = new Uniform(this, type, name, valueOrPort, p2, p3, p4);
      uni.shaderType = "vert";
      return uni;
    }

    /**
     * add a uniform to both shaders
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformBoth(type, name, valueOrPort, p2, p3, p4) {
      const uni = new Uniform(this, type, name, valueOrPort, p2, p3, p4);
      uni.shaderType = "both";
      return uni;
    }

    /**
       * add a struct & its uniforms to the fragment shader
       * @param {String} structName name of the struct, i.e.: LightStruct
       * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
       * @param {Array} members array of objects containing the struct members. see example for structure

       * @returns {Object}
       * @example
       * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
       * shader.setSource(attachments.shader_vert, attachments.shader_frag);
       * shader.addUniformStructFrag("Light", "uniformLight", [
       * { "type": "3f", "name": "position", "v1": null },
       * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
       * ]);
       */
    addUniformStructFrag(structName, uniformName, members) {
      const uniforms = {};

      if (!members) return uniforms;

      for (let i = 0; i < members.length; i += 1) {
        const member = members[i];
        if (!this.hasUniform(uniformName + "." + member.name)) {
          const uni = new Uniform(
            this,
            member.type,
            uniformName + "." + member.name,
            member.v1,
            member.v2,
            member.v3,
            member.v4,
            uniformName,
            structName,
            member.name,
          );
          uni.shaderType = "frag";
          uniforms[uniformName + "." + member.name] = uni;
        }
      }

      return uniforms;
    }

    /**
     * add a struct & its uniforms to the vertex shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure
     * @returns {object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructVert("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructVert(structName, uniformName, members) {
      const uniforms = {};

      if (!members) return uniforms;

      for (let i = 0; i < members.length; i += 1) {
        const member = members[i];
        if (!this.hasUniform(uniformName + "." + member.name)) {
          const uni = new Uniform(
            this,
            member.type,
            uniformName + "." + member.name,
            member.v1,
            member.v2,
            member.v3,
            member.v4,
            uniformName,
            structName,
            member.name,
          );
          uni.shaderType = "vert";
          uniforms[uniformName + "." + member.name] = uni;
        }
      }

      return uniforms;
    }

    /**
       * add a struct & its uniforms to the both shaders. PLEASE NOTE: it is not possible to add the same struct to both shaders when it contains ANY integer members.
       * @param {String} structName name of the struct, i.e.: LightStruct
       * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
       * @param {Array} members array of objects containing the struct members. see example for structure

       * @returns {Object}
       * @example
       * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
       * shader.setSource(attachments.shader_vert, attachments.shader_frag);
       * shader.addUniformStructBoth("Light", "uniformLight", [
       * { "type": "3f", "name": "position", "v1": null },
       * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
       * ]);
       */
    addUniformStructBoth(structName, uniformName, members) {
      const uniforms = {};

      if (!members) return uniforms;

      for (let i = 0; i < members.length; i += 1) {
        const member = members[i];
        if (member.type === "2i" || member.type === "i" || member.type === "3i")
          this._log.error(
            "Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:",
            structName,
            " with member:",
            member.name,
            " of type:",
            member.type,
            ".",
          );
        if (!this.hasUniform(uniformName + "." + member.name)) {
          const uni = new Uniform(
            this,
            member.type,
            uniformName + "." + member.name,
            member.v1,
            member.v2,
            member.v3,
            member.v4,
            uniformName,
            structName,
            member.name,
          );
          uni.shaderType = "both";
          uniforms[uniformName + "." + member.name] = uni;
        }
      }

      return uniforms;
    }

    /**
     * @param {String} vstr
     * @param {String} fstr
     */
    _createProgram(vstr, fstr) {
      this._cgl.printError("before _createprogram");

      const program = this._cgl.gl.createProgram();

      this.vshader = CglShader.createShader(
        this._cgl,
        vstr,
        this._cgl.gl.VERTEX_SHADER,
        this,
      );
      this.fshader = CglShader.createShader(
        this._cgl,
        fstr,
        this._cgl.gl.FRAGMENT_SHADER,
        this,
      );

      if (this.vshader && this.fshader) {
        this._cgl.gl.attachShader(program, this.vshader);
        this._cgl.gl.attachShader(program, this.fshader);

        this._linkProgram(program, vstr, fstr);
      } else {
        this._isValid = false;
        this._cgl.printError("shader _createProgram");
        this._log.error("could not link shaderprogram");
        return null;
      }

      this._cgl.printError("shader _createProgram");
      return program;
    }

    hasErrors() {
      return this._hasErrors;
    }

    /**
     * @param {any} program
     * @param {string} vstr
     * @param {string} fstr
     */
    _linkProgram(program, vstr, fstr) {
      this._cgl.printError("before _linkprogram");

      if (this._feedBackNames.length > 0) {
        this._cgl.gl.transformFeedbackVaryings(
          program,
          this._feedBackNames,
          this._cgl.gl.SEPARATE_ATTRIBS,
        );
        // INTERLEAVED_ATTRIBS
        // SEPARATE_ATTRIBS
      }

      this._cgl.gl.linkProgram(program);
      this._cgl.printError("gl.linkprogram");
      this._isValid = true;
      this._hasErrors = false;

      if (this._cgl.patch.config.glValidateShader !== false) {
        this._cgl.gl.validateProgram(program);

        if (
          !this._cgl.gl.getProgramParameter(program, this._cgl.gl.VALIDATE_STATUS)
        ) {
          // validation failed
          this._log.log("shaderprogram validation failed...");

          this._cgl.gl.getProgramInfoLog(program);
        }

        if (
          !this._cgl.gl.getProgramParameter(program, this._cgl.gl.LINK_STATUS)
        ) {
          this._hasErrors = true;

          const infoLogFrag = this._cgl.gl.getShaderInfoLog(this.fshader);
          const infoLogVert = this._cgl.gl.getShaderInfoLog(this.vshader);

          if (this.logError)
            this._log.error(this._name + " shader linking fail...");
          else this._log.warn(this._name + " shader linking fail...");

          if (infoLogFrag)
            this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader));
          if (infoLogVert)
            this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader));

          this._cgl.gl.getProgramInfoLog(program);
          if (!CABLES.UI) this._log.log(this);
          this._isValid = false;

          this._cgl.printError("shader link err");
        }
      }
    }

    getProgram() {
      return this._program;
    }

    /**
     * @param {any[]} names
     */
    setFeedbackNames(names) {
      this.setWhyCompile("setFeedbackNames");
      this._feedBackNames = names;
    }

    /**
     * adds attribute definition to shader header without colliding with other shader modules...
     * when attrFrag is defined, vertex shader will output this attribute to the fragment shader
     * @param {Object} attr {type:x,name:x,[nameFrag:x]}
     * @return {Object}
     */
    addAttribute(attr) {
      for (let i = 0; i < this._attributes.length; i++) {
        if (
          this._attributes[i].name == attr.name &&
          this._attributes[i].nameFrag == attr.nameFrag
        )
          return;
      }
      this._attributes.push(attr);

      this.setWhyCompile("addAttribute");
    }

    bindTextures() {
      this._bindTextures();
    }

    _bindTextures() {
      if (this._textureStackTex.length > this._cgl.maxTextureUnits) {
        this._log.warn(
          "[shader._bindTextures] too many textures bound",
          this._textureStackTex.length + "/" + this._cgl.maxTextureUnits,
        );
      }

      // for (let i = this._textureStackTex.length + 1; i < this._cgl.maxTextureUnits; i++) this._cgl.setTexture(i, null);

      for (let i = 0; i < this._textureStackTex.length; i++) {
        // this._log.log(this._textureStackTex.length, i);
        if (!this._textureStackTex[i] && !this._textureStackTexCgl[i]) {
          this._log.warn("no texture for pushtexture", this._name);
        } else {
          let t = this._textureStackTex[i];
          if (this._textureStackTexCgl[i]) {
            t =
              this._textureStackTexCgl[i].tex ||
              CGL.Texture.getEmptyTexture(this._cgl).tex;
          }

          let bindOk = true;

          if (!this._textureStackUni[i]) {
            // throw(new Error('no uniform given to texturestack'));
            this._log.warn("no uniform for pushtexture", this._name);
            bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);
          } else {
            this._textureStackUni[i].setValue(i);
            bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);

            // this._log.log(bindOk, i, t, this._textureStackType[i]);
          }
          if (!bindOk)
            this._log.warn(
              "tex bind failed",
              this.getName(),
              this._textureStackUni[i],
            );
        }
      }
    }

    /**
     * @param {Uniform} uni
     * @param {Texture} tex
     */
    setUniformTexture(uni, tex) {
      tex = tex || Texture$1.getTempTexture(this._cgl);
      for (let i = 0; i < this._textureStackUni.length; i++)
        if (this._textureStackUni[i] == uni) {
          const old = this._textureStackTex[i] || this._textureStackTexCgl[i];
          if (tex.hasOwnProperty("tex")) {
            this._textureStackTexCgl[i] = tex;
            this._textureStackTex[i] = null;
          } else {
            this._textureStackTexCgl[i] = null;
            this._textureStackTex[i] = tex;
          }

          // this._textureStackTex[i] = tex;
          // this._cgl.setTexture(i, tex, this._textureStackType[i]);
          return old;
        }
      return null;
    }

    /**
     * push a texture on the stack. those textures will be bound when binding the shader. texture slots are automatically set
     * @param {Uniform} uniform texture uniform
     * @param {Texture} t texture
     * @param {number} type texture type, can be ignored when TEXTURE_2D
     */
    pushTexture(uniform, t, type) {
      if (!uniform) {
        // this._log.log("pushtexture: no uniform given to texturestack", "shader:"+this._name,uniform,t,type);
        return;
      }
      if (!t) {
        // if(uniform)this._log.warn("pushtexture: no tex","shader:"+this._name," uniform:"+uniform.name);
        return;
      }
      if (!t.hasOwnProperty("tex") && !(t instanceof WebGLTexture)) {
        this._log.warn(new Error("invalid texture").stack);

        this._log.warn("[cgl_shader] invalid texture...", t);
        return;
      }

      this._textureStackUni.push(uniform);

      if (t.hasOwnProperty("tex")) {
        this._textureStackTexCgl.push(t);
        this._textureStackTex.push(null);
      } else {
        this._textureStackTexCgl.push(null);
        this._textureStackTex.push(t);
      }

      this._textureStackType.push(type);
    }

    /**
     * pop last texture
     */
    popTexture() {
      this._textureStackUni.pop();
      this._textureStackTex.pop();
      this._textureStackTexCgl.pop();
      this._textureStackType.pop();
    }

    /**
     * pop all textures
     */
    popTextures() {
      this._textureStackTex.length =
        this._textureStackTexCgl.length =
        this._textureStackType.length =
        this._textureStackUni.length =
          0;
    }

    getMaterialId() {
      return this._materialId;
    }

    getInfo() {
      const info = {};
      info.name = this._name;
      // info.modules = JSON.parse(JSON.stringify(this._modules));
      // info.defines = JSON.parse(JSON.stringify(this._defines));
      info.defines = this.getDefines();
      info.hasErrors = this.hasErrors();

      return info;
    }

    getDefaultFragmentShader(r, g, b, a) {
      return getDefaultFragmentShader(r, g, b);
    }

    getDefaultVertexShader() {
      return getDefaultVertexShader();
    }
  }

  // --------------------------

  CglShader.getDefaultVertexShader = getDefaultVertexShader;
  CglShader.getDefaultFragmentShader = getDefaultFragmentShader;

  CglShader.getErrorFragmentShader = function () {
    return (
      "" +
      nl +
      "void main()" +
      nl +
      "{" +
      nl +
      "   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;" +
      nl +
      "   g= step(0.1,g);" +
      nl +
      "   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);" +
      nl +
      "}"
    );
  };

  /**
   * @param {CglContext} cgl
   * @param {String} str
   * @param {number} type
   * @param {CglShader} cglShader
   * @returns {CglShader}
   */
  CglShader.createShader = function (cgl, str, type, cglShader) {
    if (cgl.aborted) return;

    const shader = cgl.gl.createShader(type);
    cgl.gl.shaderSource(shader, str);
    cgl.gl.compileShader(shader);

    if (!cgl.gl.getShaderParameter(shader, cgl.gl.COMPILE_STATUS)) {
      cglShader.error = { str: str, infoLog: cgl.gl.getShaderInfoLog(shader) };

      if (CABLES.UI) gui.emitEvent("ShaderError", cglShader);

      if (!cglShader.error.infoLog) {
        cglShader._log.warn("empty shader info log", this._name);
        return;
      }

      cglShader.setSource(
        CglShader.getDefaultVertexShader(),
        CglShader.getErrorFragmentShader(),
      );

      // CABLES.UI.showShaderError(shader);
    }
    return shader;
  };

  class FpsCounter extends Events {
    constructor() {
      super();
      this._timeStartFrame = 0;
      this._timeStartSecond = 0;
      this._fpsCounter = 0;
      this._msCounter = 0;
      this._frameCount = 0;

      this.stats = { ms: 0, fps: 0 };
    }

    get frameCount() {
      return this._frameCount;
    }

    startFrame() {
      this._timeStartFrame = CABLES.now();
    }

    endFrame() {
      this._frameCount++;
      this._fpsCounter++;

      const timeFrame = CABLES.now() - this._timeStartFrame;
      this._msCounter += timeFrame;

      if (CABLES.now() - this._timeStartSecond > 1000) this.endSecond();
    }

    endSecond() {
      this.stats.fps = this._fpsCounter;
      this.stats.ms =
        Math.round((this._msCounter / this._fpsCounter) * 100) / 100;

      this.emitEvent("performance", this.stats);

      // reset
      this._fpsCounter = 0;
      this._msCounter = 0;
      this._timeStartSecond = CABLES.now();
    }
  }

  const CG = {
    DEPTH_COMPARE_NEVER: 0,
    DEPTH_COMPARE_LESS: 1,
    DEPTH_COMPARE_EQUAL: 2,
    DEPTH_COMPARE_LESSEQUAL: 3,
    DEPTH_COMPARE_GREATER: 4,
    DEPTH_COMPARE_NOTEQUAL: 5,
    DEPTH_COMPARE_GREATEREQUAL: 6,
    DEPTH_COMPARE_ALWAYS: 7,

    CULL_NONE: 0,
    CULL_BACK: 1,
    CULL_FRONT: 2,
    CULL_BOTH: 3,

    Geometry: Geometry,
    BoundingBox: BoundingBox,
    FpsCounter: FpsCounter,

    CgCanvas: CgCanvas,
  };

  class Framebuffer2 {
    /**
     * @param {CglContext} cgl
     * @param {number} w
     * @param {number} h
     * @param {object} options
     */
    constructor(cgl, w, h, options) {
      this._log = new Logger("cgl_framebuffer2");
      if (cgl.glVersion == 1) this._log.error("framebuffer2 used on webgl1");
      this.Framebuffer2DrawTargetsDefault = null;
      this.Framebuffer2BlittingFramebuffer = null;
      this.Framebuffer2FinalFramebuffer = null;
      this._cgl = cgl;

      this._cgl.printError("before framebuffer2 constructor");

      this._width = 0;
      this._height = 0;
      this.valid = true;

      this._depthRenderbuffer = null;
      this._frameBuffer = null;
      this._textureFrameBuffer = null;
      this._colorRenderbuffers = [];
      this._drawTargetArray = [];
      this._disposed = false;

      if (!this.Framebuffer2BlittingFramebuffer)
        this.Framebuffer2BlittingFramebuffer = cgl.gl.createFramebuffer();
      if (!this.Framebuffer2FinalFramebuffer)
        this.Framebuffer2FinalFramebuffer = cgl.gl.createFramebuffer();

      if (!this.Framebuffer2DrawTargetsDefault)
        this.Framebuffer2DrawTargetsDefault = [cgl.gl.COLOR_ATTACHMENT0];

      this._options = options || {
        isFloatingPointTexture: false,
      };

      this.name = this._options.name || "unknown";

      this._cgl.profileData.addHeavyEvent("framebuffer create", this.name);

      if (!this._options.hasOwnProperty("numRenderBuffers"))
        this._options.numRenderBuffers = 1;
      if (!this._options.hasOwnProperty("depth")) this._options.depth = true;
      if (!this._options.hasOwnProperty("clear")) this._options.clear = true;
      if (!this._options.hasOwnProperty("multisampling")) {
        this._options.multisampling = false;
        this._options.multisamplingSamples = 0;
      }

      if (this._options.multisamplingSamples) {
        if (this._cgl.glSlowRenderer) this._options.multisamplingSamples = 0;
        if (!this._cgl.gl.MAX_SAMPLES) this._options.multisamplingSamples = 0;
        else
          this._options.multisamplingSamples = Math.min(
            this._cgl.maxSamples,
            this._options.multisamplingSamples,
          );
      }

      if (!this._options.hasOwnProperty("filter"))
        this._options.filter = Texture$1.FILTER_LINEAR;
      if (!this._options.hasOwnProperty("wrap"))
        this._options.wrap = Texture$1.WRAP_REPEAT;

      this._numRenderBuffers = this._options.numRenderBuffers;
      this._colorTextures = [];

      this.clearColors = [];
      for (let i = 0; i < this._numRenderBuffers; i++)
        this.clearColors.push([0, 0, 0, 1]);

      if (!options.pixelFormat) {
        if (options.isFloatingPointTexture)
          this._options.pixelFormat = Texture$1.PFORMATSTR_RGBA32F;
        else this._options.pixelFormat = Texture$1.PFORMATSTR_RGBA8UB;
      }

      for (let i = 0; i < this._numRenderBuffers; i++) {
        this._colorTextures[i] = new Texture$1(cgl, {
          name: "fb2 " + this.name + " " + i,
          isFloatingPointTexture: this._options.isFloatingPointTexture,
          anisotropic: this._options.anisotropic || 0,
          pixelFormat: this._options.pixelFormat,
          filter: this._options.filter,
          wrap: this._options.wrap,
        });
      }

      let fil = Texture$1.FILTER_NEAREST;
      if (this._options.shadowMap) fil = Texture$1.FILTER_LINEAR;

      const defaultTexSize = 512;

      if (this._options.depth) {
        this._textureDepth = new Texture$1(cgl, {
          name: "fb2 depth " + this.name,
          isDepthTexture: true,
          filter: fil,
          shadowMap: this._options.shadowMap || false,
          width: w || defaultTexSize,
          height: h || defaultTexSize,
        });
      }

      if (cgl.aborted) return;

      this.setSize(w || defaultTexSize, h || defaultTexSize);

      this._cgl.printError("framebuffer2 constructor");
    }

    getWidth() {
      return this._width;
    }

    getHeight() {
      return this._height;
    }

    getGlFrameBuffer() {
      return this._frameBuffer;
    }

    getDepthRenderBuffer() {
      return this._depthRenderbuffer;
    }

    getTextureColor() {
      return this._colorTextures[0];
    }

    getTextureColorNum(i) {
      return this._colorTextures[i];
    }

    getTextureDepth() {
      return this._textureDepth;
    }

    setFilter(f) {
      for (let i = 0; i < this._numRenderBuffers; i++) {
        this._colorTextures[i].filter = f;
        this._colorTextures[i].setSize(this._width, this._height);
      }
    }

    delete() {
      this.dispose();
    }

    dispose() {
      this._disposed = true;
      let i = 0;
      for (i = 0; i < this._numRenderBuffers; i++)
        this._colorTextures[i].delete();
      // this._texture.delete();
      if (this._textureDepth) this._textureDepth.delete();
      for (i = 0; i < this._numRenderBuffers; i++)
        this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
      this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
      this._cgl.gl.deleteFramebuffer(this._frameBuffer);
      this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
    }

    /**
     * @param {number} w
     * @param {number} h
     */
    setSize(w, h) {
      if (this._disposed)
        return this._log.warn("disposed framebuffer setsize...");
      this._cgl.profileData.addHeavyEvent("framebuffer resize", this.name);

      let i = 0;

      this._width = this._cgl.checkTextureSize(w);
      this._height = this._cgl.checkTextureSize(h);

      this._cgl.profileData.profileFrameBuffercreate++;

      if (this._frameBuffer) {
        for (i = 0; i < this._numRenderBuffers; i++)
          this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
        // this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffer);
        this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
        this._cgl.gl.deleteFramebuffer(this._frameBuffer);
        this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
      }

      this._frameBuffer = this._cgl.gl.createFramebuffer();
      this._textureFrameBuffer = this._cgl.gl.createFramebuffer();

      const depth = this._options.depth;

      for (i = 0; i < this._numRenderBuffers; i++) {
        this._colorTextures[i].setSize(this._width, this._height);
      }

      for (i = 0; i < this._numRenderBuffers; i++) {
        const renderBuffer = this._cgl.gl.createRenderbuffer();

        // color renderbuffer

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, renderBuffer);

        const info = Texture$1.setUpGlPixelFormat(
          this._cgl,
          this._options.pixelFormat,
        );
        let internFormat = info.glInternalFormat;

        // if (this._options.isFloatingPointTexture)
        // {
        if (CGL.Texture.isPixelFormatHalfFloat(info.pixelFormat)) {
          if (!this._cgl.enableExtension("OES_texture_float_linear")) {
            this._options.filter = Texture$1.FILTER_NEAREST;
            this.setFilter(this._options.filter);
          }
        } else if (CGL.Texture.isPixelFormatFloat(info.pixelFormat)) {
          if (!this._cgl.enableExtension("OES_texture_float_linear")) {
            this._log.warn("no linear pixelformat,using nearest");
            this._options.filter = Texture$1.FILTER_NEAREST;
            this.setFilter(this._options.filter);
          }
        }
        // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
        // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
        // else if (info.pixelFormat == Texture.PFORMATSTR_RG16F)
        // {
        //     const extcb = this._cgl.enableExtension("EXT_color_buffer_float");

        //     if (!this._cgl.enableExtension("OES_texture_float_linear"))
        //     {
        //         console.log("no linear pixelformat,switching to nearest");
        //         this._options.filter = Texture.FILTER_NEAREST;
        //         this.setFilter(this._options.filter);
        //     }
        // }
        // }

        if (this._options.multisampling && this._options.multisamplingSamples) {
          this._cgl.gl.renderbufferStorageMultisample(
            this._cgl.gl.RENDERBUFFER,
            this._options.multisamplingSamples,
            internFormat,
            this._width,
            this._height,
          );
        } else {
          this._cgl.gl.renderbufferStorage(
            this._cgl.gl.RENDERBUFFER,
            internFormat,
            this._width,
            this._height,
          );
        }

        this._cgl.gl.framebufferRenderbuffer(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.COLOR_ATTACHMENT0 + i,
          this._cgl.gl.RENDERBUFFER,
          renderBuffer,
        );
        this._colorRenderbuffers[i] = renderBuffer;
      }

      // this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.FRAMEBUFFER,
        this._textureFrameBuffer,
      );

      for (i = 0; i < this._numRenderBuffers; i++) {
        this._cgl.gl.framebufferTexture2D(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.COLOR_ATTACHMENT0 + i,
          this._cgl.gl.TEXTURE_2D,
          this._colorTextures[i].tex,
          0,
        );
      }

      if (this._options.depth) {
        this._cgl.gl.framebufferTexture2D(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.DEPTH_ATTACHMENT,
          this._cgl.gl.TEXTURE_2D,
          this._textureDepth.tex,
          0,
        );
      }

      // depth renderbuffer

      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

      let depthType = this._cgl.gl.DEPTH_COMPONENT32F;

      if (this._cgl.glSlowRenderer) depthType = this._cgl.gl.DEPTH_COMPONENT16;
      if (depth) {
        this._textureDepth.setSize(this._width, this._height);
        this._depthRenderbuffer = this._cgl.gl.createRenderbuffer();

        this._cgl.gl.bindRenderbuffer(
          this._cgl.gl.RENDERBUFFER,
          this._depthRenderbuffer,
        );
        if (this._options.isFloatingPointTexture) {
          if (this._options.multisampling)
            this._cgl.gl.renderbufferStorageMultisample(
              this._cgl.gl.RENDERBUFFER,
              this._options.multisamplingSamples,
              depthType,
              this._width,
              this._height,
            );
          else
            this._cgl.gl.renderbufferStorage(
              this._cgl.gl.RENDERBUFFER,
              depthType,
              this._width,
              this._height,
            );
        } else if (this._options.multisampling) {
          this._cgl.gl.renderbufferStorageMultisample(
            this._cgl.gl.RENDERBUFFER,
            this._options.multisamplingSamples,
            depthType,
            this._width,
            this._height,
          );
          // this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,depthType, this._width, this._height);
        } else {
          this._cgl.gl.renderbufferStorage(
            this._cgl.gl.RENDERBUFFER,
            depthType,
            this._width,
            this._height,
          );
        }

        this._cgl.gl.framebufferRenderbuffer(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.DEPTH_ATTACHMENT,
          this._cgl.gl.RENDERBUFFER,
          this._depthRenderbuffer,
        );
      }

      // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
      // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);

      this._drawTargetArray.length = 0;
      for (i = 0; i < this._numRenderBuffers; i++)
        this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);

      // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

      if (!this._cgl.gl.isFramebuffer(this._textureFrameBuffer))
        this._log.warn("invalid framebuffer"); // throw new Error("Invalid framebuffer");
      const status = this._cgl.gl.checkFramebufferStatus(
        this._cgl.gl.FRAMEBUFFER,
      );

      if (status != this._cgl.gl.FRAMEBUFFER_COMPLETE) {
        this._log.error("framebuffer incomplete: " + this.name, this);
        this._log.log("options", this._options);
        this._log.log("options pixelformat", this._options.pixelFormat);

        switch (status) {
          case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", this);
            throw new Error(
              "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
            );
          case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
            throw new Error(
              "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
            );
          case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
            throw new Error(
              "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
            );
          case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:
            this._log.warn("FRAMEBUFFER_UNSUPPORTED");
            throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
          default:
            this.valid = false;
            this._log.error("incomplete framebuffer", status, this._frameBuffer);
            this._cgl.printError();

            this._frameBuffer = null;
            // debugger;
            throw new Error("Incomplete framebuffer: " + status);

          // throw("Incomplete framebuffer: " + status);
        }
      }

      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);

      // this._cgl.printError("fb setsize");
    }

    renderStart() {
      if (this._disposed)
        return this._log.warn("disposed framebuffer renderStart...");
      this._cgl.checkFrameStarted("fb2 renderstart");
      this._cgl.pushModelMatrix(); // needed ??

      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
      this._cgl.pushGlFrameBuffer(this._frameBuffer);
      this._cgl.pushFrameBuffer(this);

      this._cgl.pushPMatrix();
      this._cgl.pushViewPort(0, 0, this._width, this._height);

      this._cgl.gl.drawBuffers(this._drawTargetArray);

      if (this._options.clear) {
        this._cgl.gl.clearColor(0, 0, 0, 0);
        this._cgl.gl.clear(
          this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT,
        );
      }
    }

    clear() {
      if (this._numRenderBuffers <= 1) {
        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.READ_FRAMEBUFFER,
          this._frameBuffer,
        );
        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.DRAW_FRAMEBUFFER,
          this._textureFrameBuffer,
        );
      } else
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

      this._cgl.gl.drawBuffers(this._drawTargetArray);

      for (let i = 0; i < this._numRenderBuffers; i++) {
        this._cgl.gl.framebufferTexture2D(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.COLOR_ATTACHMENT0 + i,
          this._cgl.gl.TEXTURE_2D,
          this._colorTextures[i].tex,
          0,
        );
        this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, this.clearColors[i]);
      }
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    }

    renderEnd() {
      if (this._disposed)
        return this._log.warn("disposed framebuffer renderEnd...");
      this._cgl.popPMatrix();

      this._cgl.profileData.profileFramebuffer++;

      if (this._numRenderBuffers <= 1) {
        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.READ_FRAMEBUFFER,
          this._frameBuffer,
        );
        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.DRAW_FRAMEBUFFER,
          this._textureFrameBuffer,
        );

        this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
        this._cgl.gl.blitFramebuffer(
          0,
          0,
          this._width,
          this._height,
          0,
          0,
          this._width,
          this._height,
          this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT,
          this._cgl.gl.NEAREST,
        );
      } else {
        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.FRAMEBUFFER,
          this.Framebuffer2BlittingFramebuffer,
        );
        this._cgl.gl.framebufferRenderbuffer(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.DEPTH_ATTACHMENT,
          this._cgl.gl.RENDERBUFFER,
          this._depthRenderbuffer,
        );

        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.FRAMEBUFFER,
          this.Framebuffer2FinalFramebuffer,
        );
        this._cgl.gl.framebufferTexture2D(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.DEPTH_ATTACHMENT,
          this._cgl.gl.TEXTURE_2D,
          this._textureDepth.tex,
          0,
        );

        for (let i = 0; i < this._numRenderBuffers; i++) {
          this._cgl.gl.bindFramebuffer(
            this._cgl.gl.FRAMEBUFFER,
            this.Framebuffer2BlittingFramebuffer,
          );
          this._cgl.gl.framebufferRenderbuffer(
            this._cgl.gl.FRAMEBUFFER,
            this._cgl.gl.COLOR_ATTACHMENT0,
            this._cgl.gl.RENDERBUFFER,
            this._colorRenderbuffers[i],
          );

          this._cgl.gl.bindFramebuffer(
            this._cgl.gl.FRAMEBUFFER,
            this.Framebuffer2FinalFramebuffer,
          );
          this._cgl.gl.framebufferTexture2D(
            this._cgl.gl.FRAMEBUFFER,
            this._cgl.gl.COLOR_ATTACHMENT0,
            this._cgl.gl.TEXTURE_2D,
            this._colorTextures[i].tex,
            0,
          );

          this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

          this._cgl.gl.bindFramebuffer(
            this._cgl.gl.READ_FRAMEBUFFER,
            this.Framebuffer2BlittingFramebuffer,
          );
          this._cgl.gl.bindFramebuffer(
            this._cgl.gl.DRAW_FRAMEBUFFER,
            this.Framebuffer2FinalFramebuffer,
          );

          // this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [0.0, 0.0, 0.0, 1.0]);

          let flags = this._cgl.gl.COLOR_BUFFER_BIT;
          if (i == 0) flags |= this._cgl.gl.DEPTH_BUFFER_BIT;

          this._cgl.gl.blitFramebuffer(
            0,
            0,
            this._width,
            this._height,
            0,
            0,
            this._width,
            this._height,
            flags,
            this._cgl.gl.NEAREST,
          );
        }
      }

      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.popGlFrameBuffer(),
      );
      this._cgl.popFrameBuffer();

      this._cgl.popModelMatrix();
      this._cgl.popViewPort();

      if (this._colorTextures[0].filter == Texture$1.FILTER_MIPMAP) {
        for (let i = 0; i < this._numRenderBuffers; i++) {
          this._cgl.gl.bindTexture(
            this._cgl.gl.TEXTURE_2D,
            this._colorTextures[i].tex,
          );
          this._colorTextures[i].updateMipMap();
          this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
        }
      }
    }
  }

  /**
   * cables gl context/state manager
   * @class
   * @namespace external:CGL
   * @hideconstructor
   */
  // const Context(_patch)
  class CglContext extends CgContext {
    constructor(_patch) {
      super(_patch);

      this.gApi = CgContext.API_WEBGL;
      this.aborted = false;

      /** @deprecated */
      this.pushMvMatrix = this.pushModelMatrix; // deprecated and wrong... still used??
      /** @deprecated */
      this.popMvMatrix = this.popmMatrix = this.popModelMatrix; // deprecated and wrong... still used??

      this._log = new Logger("cgl_context", { onError: _patch.config.onError });

      this.glVersion = 0;
      this.glUseHalfFloatTex = false;
      this.clearCanvasTransparent = true;
      this.clearCanvasDepth = true;
      this.debugOneFrame = false;
      this.checkGlErrors = false; // true is slow // false should be default...
      this.maxTextureUnits = 0;
      this.maxVaryingVectors = 0;
      this.currentProgram = null;
      this._hadStackError = false;
      this.glSlowRenderer = false;
      this._isSafariCrap = false;

      this.temporaryTexture = null;
      this.gl = null;

      this._cursor = "auto";
      this._currentCursor = "";

      this._viewPortStack = [];
      this._glFrameBufferStack = [];
      this._frameBufferStack = [];
      this._shaderStack = [];
      this._stackDepthTest = [];
      this.mainloopOp = null;
      this._stackBlendMode = [];
      this._stackBlendModePremul = [];
      this._stackBlend = [];
      this._stackDepthFunc = [];
      this._stackCullFaceFacing = [];
      this._stackCullFace = [];
      this._stackDepthWrite = [];
      this._stackDepthTest = [];
      this._stackStencil = [];

      this._simpleShader = new CglShader(this, "simpleshader");
      this._simpleShader.setModules([
        "MODULE_VERTEX_POSITION",
        "MODULE_COLOR",
        "MODULE_BEGIN_FRAG",
        "MODULE_VERTEX_MODELVIEW",
      ]);
      this._simpleShader.setSource(
        CglShader.getDefaultVertexShader(),
        CglShader.getDefaultFragmentShader(),
      );

      this._currentShader = this._simpleShader;

      this._oldCanvasWidth = -1;
      this._oldCanvasHeight = -1;
      this._enabledExtensions = {};

      this.errorShader = null;
    }

    // set pixelDensity(p)
    // {
    //     this._pixelDensity = p;
    // }

    // get pixelDensity()
    // {
    //     return this._pixelDensity;
    // }

    get viewPort() {
      if (this._viewPortStack.length > 3) {
        const l = this._viewPortStack.length;

        return [
          this._viewPortStack[l - 4],
          this._viewPortStack[l - 3],
          this._viewPortStack[l - 2],
          this._viewPortStack[l - 1],
        ];
      } else {
        // workaround pre viewport stack times / or+and initial value...

        return this._viewPort;
      }
    }

    get mvMatrix() {
      // deprecate
      return this.mMatrix;
    }

    set mvMatrix(m) {
      this.mMatrix = m;
    }

    _setCanvas(canv) {
      if (!canv) this._log.stack("_setCanvas undef");

      if (!this.patch.config.canvas) this.patch.config.canvas = {};
      if (!this.patch.config.canvas.hasOwnProperty("preserveDrawingBuffer"))
        this.patch.config.canvas.preserveDrawingBuffer = true;
      if (!this.patch.config.canvas.hasOwnProperty("premultipliedAlpha"))
        this.patch.config.canvas.premultipliedAlpha = false;
      if (!this.patch.config.canvas.hasOwnProperty("alpha"))
        this.patch.config.canvas.alpha = false;

      this.patch.config.canvas.stencil = true;

      if (this.patch.config.hasOwnProperty("clearCanvasColor"))
        this.clearCanvasTransparent = this.patch.config.clearCanvasColor;
      if (this.patch.config.hasOwnProperty("clearCanvasDepth"))
        this.clearCanvasDepth = this.patch.config.clearCanvasDepth;

      // safari stuff..........
      if (
        /^((?!chrome|android).)*safari/i.test(navigator.userAgent) &&
        navigator.userAgent.match(/iPhone/i)
      ) {
        this._isSafariCrap = true;
        this.glUseHalfFloatTex = true;
      }

      if (!this.patch.config.canvas.forceWebGl1)
        this.gl = canv.getContext("webgl2", this.patch.config.canvas);

      if (!this.gl || this.gl.isContextLost()) {
        this.aborted = true;
        this._log.error(
          "NO_WEBGL",
          "sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser.",
        );
        return;
      }

      if (this.gl.getParameter(this.gl.VERSION) != "WebGL 1.0") {
        this.glVersion = 2;
      } else {
        this.gl =
          canv.getContext("webgl", this.patch.config.canvas) ||
          canv.getContext("experimental-webgl", this.patch.config.canvas);
        this.glVersion = 1;

        // safari
        // if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))
        // {
        //     this.glUseHalfFloatTex = true;
        // }

        // ios
        // @ts-ignore
        if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
          if (!this.patch.config.canvas.hasOwnProperty("powerPreference"))
            this.patch.config.canvas.powerPreference = "high-performance";
        }

        this.enableExtension("OES_standard_derivatives");
        // this.enableExtension("GL_OES_standard_derivatives");
        const instancingExt =
          this.enableExtension("ANGLE_instanced_arrays") || this.gl;
        if (instancingExt.vertexAttribDivisorANGLE) {
          this.gl.vertexAttribDivisor =
            instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
          this.gl.drawElementsInstanced =
            instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
        }
      }

      const dbgRenderInfo = this.enableExtension("WEBGL_debug_renderer_info");
      if (dbgRenderInfo) {
        this.glRenderer = this.gl.getParameter(
          dbgRenderInfo.UNMASKED_RENDERER_WEBGL,
        );
        if (this.glRenderer === "Google SwiftShader") this.glSlowRenderer = true;
      }

      this.canvas.addEventListener("webglcontextlost", (event) => {
        if (this.aborted)
          return this._log.warn(
            "[cgl_state] aborted context lost... can be ignored...",
          );
        this._log.error("canvas lost...", event);
        this.emitEvent("webglcontextlost");
        this.aborted = true;
      });

      this.maxAnisotropic = 0;
      if (this.enableExtension("EXT_texture_filter_anisotropic"))
        this.maxAnisotropic = this.gl.getParameter(
          this.enableExtension("EXT_texture_filter_anisotropic")
            .MAX_TEXTURE_MAX_ANISOTROPY_EXT,
        );

      this.maxVaryingVectors = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS);
      this.maxTextureUnits = this.gl.getParameter(
        this.gl.MAX_TEXTURE_IMAGE_UNITS,
      );
      this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
      this.maxUniformsFrag = this.gl.getParameter(
        this.gl.MAX_FRAGMENT_UNIFORM_VECTORS,
      );
      this.maxUniformsVert = this.gl.getParameter(
        this.gl.MAX_VERTEX_UNIFORM_VECTORS,
      );
      this.maxSamples = 0;
      if (this.gl.MAX_SAMPLES)
        this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES);

      if (this.glVersion == 1) {
        this.enableExtension("OES_standard_derivatives");
        const instancingExt =
          this.enableExtension("ANGLE_instanced_arrays") || this.gl;

        if (instancingExt.vertexAttribDivisorANGLE) {
          this.gl.vertexAttribDivisor =
            instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
          this.gl.drawElementsInstanced =
            instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
        }
      }

      this.DEPTH_FUNCS = [
        this.gl.NEVER,
        this.gl.ALWAYS,
        this.gl.LESS,
        this.gl.LEQUAL,
        this.gl.GREATER,
        this.gl.GEQUAL,
        this.gl.EQUAL,
        this.gl.NOTEQUAL,
      ];
      this.CULL_MODES = [
        null,
        this.gl.BACK,
        this.gl.FRONT,
        this.gl.FRONT_AND_BACK,
      ];
    }

    getInfo() {
      return {
        glVersion: this.glVersion,
        glRenderer: this.glRenderer,
        glUseHalfFloatTex: this.glUseHalfFloatTex,
        maxVaryingVectors: this.maxVaryingVectors,
        maxTextureUnits: this.maxTextureUnits,
        maxTexSize: this.maxTexSize,
        maxUniformsFrag: this.maxUniformsFrag,
        maxUniformsVert: this.maxUniformsVert,
        maxSamples: this.maxSamples,
      };
    }

    /**
     * @function popViewPort
     * @memberof Context
     * @instance
     * @description pop viewPort stack
     */
    popViewPort() {
      this._viewPortStack.pop();
      this._viewPortStack.pop();
      this._viewPortStack.pop();
      this._viewPortStack.pop();

      if (this._viewPortStack.length == 0)
        this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);
      else
        this.setViewPort(
          this._viewPortStack[this._viewPort.length - 4],
          this._viewPortStack[this._viewPort.length - 3],
          this._viewPortStack[this._viewPort.length - 2],
          this._viewPortStack[this._viewPort.length - 1],
        );
    }

    /**
     * @function pushViewPort
     * @memberof Context
     * @instance
     * @description push a new viewport onto stack
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */

    pushViewPort(x, y, w, h) {
      this._viewPortStack.push(x, y, w, h);
      this.setViewPort(x, y, w, h);
    }

    // old
    getViewPort() {
      return this._viewPort;
    }

    // old
    resetViewPort() {
      this.gl.viewport(
        this._viewPort[0],
        this._viewPort[1],
        this._viewPort[2],
        this._viewPort[3],
      );
    }

    // old
    setViewPort(x, y, w, h) {
      this._viewPort[0] = Math.round(x);
      this._viewPort[1] = Math.round(y);
      this._viewPort[2] = Math.round(w);
      this._viewPort[3] = Math.round(h);
      this.gl.viewport(
        this._viewPort[0],
        this._viewPort[1],
        this._viewPort[2],
        this._viewPort[3],
      );
    }

    /**
     * @param {function} cb
     * @param {boolean} doScreenshotClearAlpha
     * @param {string} mimeType
     * @param {number} quality
     */
    screenShot(cb, doScreenshotClearAlpha, mimeType, quality) {
      if (doScreenshotClearAlpha) {
        this.gl.clearColor(1, 1, 1, 1);
        this.gl.colorMask(false, false, false, true);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.colorMask(true, true, true, true);
      }

      if (this.canvas && this.canvas.toBlob) {
        this.canvas.toBlob(
          (blob) => {
            if (cb) cb(blob);
            else this._log.log("no screenshot callback...");
          },
          mimeType,
          quality,
        );
      }
    }

    endFrame() {
      if (this.patch.isEditorMode()) CABLES.GL_MARKER.drawMarkerLayer(this);

      this.setPreviousShader();

      if (this._vMatrixStack.length() > 0)
        this.logStackError("view matrix stack length !=0 at end of rendering...");
      if (this._mMatrixStack.length() > 0)
        this.logStackError("mvmatrix stack length !=0 at end of rendering...");
      if (this._pMatrixStack.length() > 0)
        this.logStackError("pmatrix stack length !=0 at end of rendering...");
      if (this._glFrameBufferStack.length > 0)
        this.logStackError(
          "glFrameBuffer stack length !=0 at end of rendering...",
        );
      if (this._stackDepthTest.length > 0)
        this.logStackError("depthtest stack length !=0 at end of rendering...");
      if (this._stackDepthWrite.length > 0)
        this.logStackError("depthwrite stack length !=0 at end of rendering...");
      if (this._stackDepthFunc.length > 0)
        this.logStackError("depthfunc stack length !=0 at end of rendering...");
      if (this._stackBlend.length > 0)
        this.logStackError("blend stack length !=0 at end of rendering...");
      if (this._stackBlendMode.length > 0)
        this.logStackError("blendMode stack length !=0 at end of rendering...");
      if (this._shaderStack.length > 0)
        this.logStackError("this._shaderStack length !=0 at end of rendering...");
      if (this._stackCullFace.length > 0)
        this.logStackError(
          "this._stackCullFace length !=0 at end of rendering...",
        );
      if (this._stackCullFaceFacing.length > 0)
        this.logStackError(
          "this._stackCullFaceFacing length !=0 at end of rendering...",
        );
      if (this._viewPortStack.length > 0)
        this.logStackError("viewport stack length !=0 at end of rendering...");

      this._frameStarted = false;

      if (
        this._oldCanvasWidth != this.canvasWidth ||
        this._oldCanvasHeight != this.canvasHeight
      ) {
        this._oldCanvasWidth = this.canvasWidth;
        this._oldCanvasHeight = this.canvasHeight;
        this.emitEvent("resize");
      }

      if (this._cursor != this._currentCursor) {
        this._currentCursor = this.canvas.style.cursor = this._cursor;
      }

      this.emitEvent("endframe");

      this.fpsCounter.endFrame();
    }

    logStackError(str) {
      if (!this._hadStackError) {
        this._hadStackError = true;
        this._log.warn("[" + this.canvas.id + "]: ", str);
      }
    }

    // shader stack
    getShader() {
      if (this._currentShader)
        if (
          !this.tempData ||
          ((this.tempData.renderOffscreen === true) ==
            this._currentShader.offScreenPass) ===
            true
        )
          return this._currentShader;

      for (let i = this._shaderStack.length - 1; i >= 0; i--)
        if (this._shaderStack[i])
          if (this.tempData.renderOffscreen == this._shaderStack[i].offScreenPass)
            return this._shaderStack[i];
    }

    getDefaultShader() {
      return this._simpleShader;
    }

    /**
     * @deprecated
     * @param {Shader} s
     */
    setShader(s) {
      this.pushShader(s);
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Shader} shader
     * @function
     */
    pushShader(shader) {
      if (this.tempData.forceShaderMods) {
        for (let i = 0; i < this.tempData.forceShaderMods.length; i++) {
          // if (!currentShader.forcedMod && currentShader != this.tempData.forceShaderMods[i])
          // {
          //     currentShader.forcedMod = this.tempData.forceShaderMods[i];
          shader = this.tempData.forceShaderMods[i].bind(shader, false);
          // }
          // return currentShader;
          // if (this.tempData.forceShaderMods[i].currentShader() && shader != this.tempData.forceShaderMods[i].currentShader().shader)
        }
      }

      this._shaderStack.push(shader);
      this._currentShader = shader;
    }

    popShader() {
      this.setPreviousShader();
    }

    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    setPreviousShader() {
      if (this.tempData.forceShaderMods) {
        for (let i = 0; i < this.tempData.forceShaderMods.length; i++) {
          // const a =
          this.tempData.forceShaderMods[i].unbind(false);
          // if (a) return;
          // this.popShader();
        }
      }

      if (this._shaderStack.length === 0)
        throw new Error("Invalid shader stack pop!");
      this._shaderStack.pop();
      this._currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Object} fb framebuffer
     * @function
     */
    pushGlFrameBuffer(fb) {
      this._glFrameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popGlFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    popGlFrameBuffer() {
      if (this._glFrameBufferStack.length == 0) return null;
      this._glFrameBufferStack.pop();
      return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    getCurrentGlFrameBuffer() {
      if (this._glFrameBufferStack.length === 0) return null;
      return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Framebuffer2} fb framebuffer
     */
    pushFrameBuffer(fb) {
      this._frameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer2} current framebuffer or null
     */
    popFrameBuffer() {
      if (this._frameBufferStack.length == 0) return null;
      this._frameBufferStack.pop();
      return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer2} current framebuffer or null
     */
    getCurrentFrameBuffer() {
      if (this._frameBufferStack.length === 0) return null;
      return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    renderStart(cgl, identTranslate, identTranslateView) {
      this.fpsCounter.startFrame();
      this.pushDepthTest(true);
      this.pushDepthWrite(true);
      this.pushDepthFunc(cgl.gl.LEQUAL);
      this.pushCullFaceFacing(cgl.gl.BACK);
      this.pushCullFace(false);

      // if (this.clearCanvasTransparent)
      // {
      //     cgl.gl.clearColor(0, 0, 0, 0);
      //     cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
      // }
      // if (this.clearCanvasDepth) cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

      cgl.setViewPort(0, 0, cgl.canvasWidth, cgl.canvasHeight);

      this._startMatrixStacks(identTranslate, identTranslateView);

      cgl.pushBlendMode(CONSTANTS$1.BLEND_MODES.BLEND_NORMAL, false);

      for (let i = 0; i < this._textureslots.length; i++)
        this._textureslots[i] = null;

      this.pushShader(this._simpleShader);

      this._frameStarted = true;

      this._execOneTimeCallbacks();

      for (let i = 0; i < this._textureslots.length; i++) {
        this.gl.activeTexture(this.gl.TEXTURE0 + i);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this._textureslots[i] = null;
      }

      this.emitEvent("beginFrame");
    }

    renderEnd(cgl) {
      this._endMatrixStacks();

      this.popDepthTest();
      this.popDepthWrite();
      this.popDepthFunc();
      this.popCullFaceFacing();
      this.popCullFace();
      this.popBlend();
      this.popBlendMode();

      cgl.endFrame();

      this.emitEvent("endFrame");
    }

    getTexture(slot) {
      return this._textureslots[slot];
    }

    hasFrameStarted() {
      return this._frameStarted;
    }

    /**
     * log warning to console if the rendering of one frame has not been started / handy to check for async problems
     * @function checkFrameStarted
     * @memberof Context
     * @param string
     * @instance
     */
    checkFrameStarted(string) {
      if (!this._frameStarted) {
        this._log.warn("frame not started " + string);
        this.patch.printTriggerStack();
      }
    }

    setTexture(slot, t, type) {
      this.checkFrameStarted("cgl setTexture");

      if (t === null) t = Texture$1.getEmptyTexture(this).tex;

      if (this._textureslots[slot] != t) {
        this.gl.activeTexture(this.gl.TEXTURE0 + slot);
        this.gl.bindTexture(type || this.gl.TEXTURE_2D, t);
        this._textureslots[slot] = t;
      }

      return true;
    }

    fullScreen() {
      if (this.canvas.requestFullscreen) this.canvas.requestFullscreen();
      else if (this.canvas.mozRequestFullScreen)
        this.canvas.mozRequestFullScreen();
      else if (this.canvas.webkitRequestFullscreen)
        this.canvas.webkitRequestFullscreen();
      else if (this.canvas.msRequestFullscreen) this.canvas.msRequestFullscreen();
    }

    /**
     * @param {string} [str]
     */
    printError(str) {
      if (!this.checkGlErrors) return;
      let found = false;
      let error = this.gl.getError();

      if (error != this.gl.NO_ERROR) {
        let errStr = "";
        if (error == this.gl.OUT_OF_MEMORY) errStr = "OUT_OF_MEMORY";
        if (error == this.gl.INVALID_ENUM) errStr = "INVALID_ENUM";
        if (error == this.gl.INVALID_OPERATION) errStr = "INVALID_OPERATION";
        if (error == this.gl.INVALID_FRAMEBUFFER_OPERATION)
          errStr = "INVALID_FRAMEBUFFER_OPERATION";
        if (error == this.gl.INVALID_VALUE) errStr = "INVALID_VALUE";
        if (error == this.gl.CONTEXT_LOST_WEBGL) {
          this.aborted = true;
          errStr = "CONTEXT_LOST_WEBGL";
        }
        if (error == this.gl.NO_ERROR) errStr = "NO_ERROR";

        found = true;

        this._log.warn("gl error [" + this.canvas.id + "]: ", str, error, errStr);

        if (this.canvas.id.includes("glGuiCanvas"))
          if (!this._loggedGlError) {
            this.patch.printTriggerStack();
            this._log.stack("glerror");
            this._loggedGlError = true;
          }
      }
      error = this.gl.getError();

      return found;
    }

    _dispose() {
      this._simpleShader.dispose();
      this.gl = null;
    }

    // state depthtest

    /**
     * push depth testing enabled state
     * @function pushDepthTest
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */

    pushDepthTest(enabled) {
      this._stackDepthTest.push(enabled);
      if (!enabled) this.gl.disable(this.gl.DEPTH_TEST);
      else this.gl.enable(this.gl.DEPTH_TEST);
    }

    /**
     * current state of depth testing
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthTest() {
      return this._stackDepthTest[this._stackDepthTest.length - 1];
    }

    /**
     * pop depth testing state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popDepthTest() {
      this._stackDepthTest.pop();

      if (!this._stackDepthTest[this._stackDepthTest.length - 1])
        this.gl.disable(this.gl.DEPTH_TEST);
      else this.gl.enable(this.gl.DEPTH_TEST);
    }

    // --------------------------------------
    // state depthwrite

    /**
     * push depth write enabled state
     * @function pushDepthTest
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */
    pushDepthWrite(enabled) {
      enabled = enabled || false;
      this._stackDepthWrite.push(enabled);
      this.gl.depthMask(enabled);
    }

    /**
     * current state of depth writing
     * @function stateDepthWrite
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthWrite() {
      return this._stackDepthWrite[this._stackDepthWrite.length - 1];
    }

    /**
     * pop depth writing state
     * @function popDepthWrite
     * @memberof Context
     * @instance
     */
    popDepthWrite() {
      this._stackDepthWrite.pop();
      this.gl.depthMask(
        this._stackDepthWrite[this._stackDepthWrite.length - 1] || false,
      );
    }

    // --------------------------------------
    // state CullFace

    /**
     * push face culling face enabled state
     * @function pushCullFace
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */
    pushCullFace(enabled) {
      this._stackCullFace.push(enabled);

      if (enabled) this.gl.enable(this.gl.CULL_FACE);
      else this.gl.disable(this.gl.CULL_FACE);
    }

    /**
     * current state of face culling
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFace() {
      return this._stackCullFace[this._stackCullFace.length - 1];
    }

    /**
     * pop face culling enabled state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popCullFace() {
      this._stackCullFace.pop();

      if (this._stackCullFace[this._stackCullFace.length - 1])
        this.gl.enable(this.gl.CULL_FACE);
      else this.gl.disable(this.gl.CULL_FACE);
    }

    // --------------------------------------
    // state CullFace Facing

    /**
     * push face culling face side
     * @function pushCullFaceFacing
     * @param {Number} face - cgl.gl.FRONT_AND_BACK, cgl.gl.BACK or cgl.gl.FRONT
     * @memberof Context
     * @instance
     */

    pushCullFaceFacing(face) {
      this._stackCullFaceFacing.push(face);
      this.gl.cullFace(
        this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1],
      );
    }

    /**
     * current state of face culling side
     * @function stateCullFaceFacing
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFaceFacing() {
      return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
    }

    /**
     * pop face culling face side
     * @function popCullFaceFacing
     * @memberof Context
     * @instance
     */
    popCullFaceFacing() {
      this._stackCullFaceFacing.pop();
      if (this._stackCullFaceFacing.length > 0)
        this.gl.cullFace(
          this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1],
        );
    }

    // --------------------------------------
    // state depthfunc

    /**
     * enable / disable depth testing
     * like `gl.depthFunc(boolean);`
     * @function pushDepthFunc
     * @memberof Context
     * @instance
     * @param {Boolean} f depthtesting
     */
    pushDepthFunc(f) {
      this._stackDepthFunc.push(f);
      this.gl.depthFunc(f);
    }

    /**
     * current state of blend
     * @function stateDepthFunc
     * @memberof Context
     * @instance
     * @returns {Boolean} depth testing enabled/disabled
     */
    stateDepthFunc() {
      if (this._stackDepthFunc.length > 0)
        return this._stackDepthFunc[this._stackDepthFunc.length - 1];
      return false;
    }

    /**
     * pop depth testing and set the previous state
     * @function popDepthFunc
     * @memberof Context
     * @instance
     */
    popDepthFunc() {
      this._stackDepthFunc.pop();
      if (this._stackDepthFunc.length > 0)
        this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1]);
    }

    // --------------------------------------
    // state blending

    /**
     * enable / disable blend
     * like gl.enable(gl.BLEND); / gl.disable(gl.BLEND);
     * @function pushBlend
     * @memberof Context
     * @instance
     * @param {boolean} b blending
     */
    pushBlend(b) {
      this._stackBlend.push(b);
      if (!b) this.gl.disable(this.gl.BLEND);
      else this.gl.enable(this.gl.BLEND);
    }

    /**
     * pop blend state and set the previous state
     * @function popBlend
     * @memberof Context
     * @instance
     */
    popBlend() {
      this._stackBlend.pop();

      if (!this._stackBlend[this._stackBlend.length - 1])
        this.gl.disable(this.gl.BLEND);
      else this.gl.enable(this.gl.BLEND);
    }

    /**
     * current state of blend
     * @function stateBlend
     * @returns {boolean} blending enabled/disabled
     * @memberof Context
     * @instance
     */
    stateBlend() {
      return this._stackBlend[this._stackBlend.length - 1];
    }

    /**
     * push and switch to predefined blendmode (CONSTANTS.BLEND_MODES.BLEND_NONE,CONSTANTS.BLEND_MODES.BLEND_NORMAL,CONSTANTS.BLEND_MODES.BLEND_ADD,CONSTANTS.BLEND_MODES.BLEND_SUB,CONSTANTS.BLEND_MODES.BLEND_MUL)
     * @function pushBlendMode
     * @memberof Context
     * @instance
     * @param {Number} blendMode
     * @param {Boolean} premul premultiplied mode
     */
    pushBlendMode(blendMode, premul) {
      this._stackBlendMode.push(blendMode);
      this._stackBlendModePremul.push(premul);

      const n = this._stackBlendMode.length - 1;

      this.pushBlend(
        this._stackBlendMode[n] !== CONSTANTS$1.BLEND_MODES.BLEND_NONE,
      );
      this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
    }

    /**
     * pop predefined blendmode / switch back to previous blendmode
     * @function popBlendMode
     * @memberof Context
     * @instance
     */
    popBlendMode() {
      this._stackBlendMode.pop();
      this._stackBlendModePremul.pop();

      const n = this._stackBlendMode.length - 1;

      this.popBlend();

      if (n >= 0)
        this._setBlendMode(
          this._stackBlendMode[n],
          this._stackBlendModePremul[n],
        );
    }

    // --------------------------------------
    // state stencil

    /**
       * enable / disable stencil testing

      * @function pushStencil
      * @memberof Context
      * @instance
      * @param {Boolean} b enable
      */
    pushStencil(b) {
      this._stackStencil.push(b);
      if (!b) this.gl.disable(this.gl.STENCIL_TEST);
      else this.gl.enable(this.gl.STENCIL_TEST);
    }

    /**
     * pop stencil test state and set the previous state
     * @function popStencil
     * @memberof Context
     * @instance
     */
    popStencil() {
      this._stackStencil.pop();

      if (!this._stackStencil[this._stackStencil.length - 1])
        this.gl.disable(this.gl.STENCIL_TEST);
      else this.gl.enable(this.gl.STENCIL_TEST);
    }

    // --------------------------------------

    glGetAttribLocation(prog, name) {
      const l = this.gl.getAttribLocation(prog, name);
      // if (l == -1)
      // {
      //     this._log.warn("get attr loc -1 ", name);
      // }
      return l;
    }

    /**
     * should an op now draw helpermeshes
     * @param {Op} op
     */
    shouldDrawHelpers(op) {
      if (this.tempData.shadowPass) return false;
      if (!op.patch.isEditorMode()) return false;

      // const fb = this.getCurrentFrameBuffer();
      // if (fb && fb.getWidth)
      // {
      //     const fbshould = this.canvasWidth / this.canvasHeight == fb.getWidth() / fb.getHeight();
      //     if (!fbshould) return false;
      // }

      return gui.shouldDrawOverlay; // || (CABLES.UI.renderHelperCurrent && op.isCurrentUiOp());
    }

    _setBlendMode(blendMode, premul) {
      const gl = this.gl;

      if (blendMode == CONSTANTS$1.BLEND_MODES.BLEND_NONE) ; else if (blendMode == CONSTANTS$1.BLEND_MODES.BLEND_ADD) {
        if (premul) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        }
      } else if (blendMode == CONSTANTS$1.BLEND_MODES.BLEND_SUB) {
        if (premul) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(
            gl.ZERO,
            gl.ZERO,
            gl.ONE_MINUS_SRC_COLOR,
            gl.ONE_MINUS_SRC_ALPHA,
          );
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
        }
      } else if (blendMode == CONSTANTS$1.BLEND_MODES.BLEND_MUL) {
        if (premul) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
        }
      } else if (blendMode == CONSTANTS$1.BLEND_MODES.BLEND_NORMAL) {
        if (premul) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(
            gl.ONE,
            gl.ONE_MINUS_SRC_ALPHA,
            gl.ONE,
            gl.ONE_MINUS_SRC_ALPHA,
          );
        } else {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(
            gl.SRC_ALPHA,
            gl.ONE_MINUS_SRC_ALPHA,
            gl.ONE,
            gl.ONE_MINUS_SRC_ALPHA,
          );
        }
      } else {
        this._log.log("setblendmode: unknown blendmode");
      }
    }

    /**
     * @param {Geometry} geom
     * @param {CglMeshOptions} options
     */
    createMesh(geom, options) {
      if (CABLES.isNumeric(options)) options = { glPrimitive: options }; // old constructor fallback...
      return new Mesh(this, geom, options);
    }

    /**
     * set cursor
     * @function setCursor
     * @memberof Context
     * @instance
     * @param {String} str css cursor string
     */
    setCursor(str) {
      this._cursor = str;
    }

    /**
     * enable a webgl extension
     * @function enableExtension
     * @memberof Context
     * @instance
     * @param {String} name extension name
     * @returns {Object} extension object or null
     */
    enableExtension(name) {
      if (!this.gl) return null;

      if (this._enabledExtensions.hasOwnProperty(name))
        return this._enabledExtensions[name];

      const o = this.gl.getExtension(name);
      this._enabledExtensions[name] = o;

      if (!o) this._log.warn("[cgl_state] extension not available " + name);

      return o;
    }

    getErrorShader() {
      if (this.errorShader) return this.errorShader;

      this.errorShader = new CglShader(this, "errormaterial");
      this.errorShader.setSource(
        CglShader.getDefaultVertexShader(),
        CglShader.getErrorFragmentShader(),
      );
      return this.errorShader;
    }
  }

  /** @global CABLES.OPS  */

  /**
   * @typedef {import("./core_op.js").OpUiAttribs} OpUiAttribs
   */

  /**
   * @typedef PatchConfig
   * @property {String} [prefixAssetPath=''] prefix for path to assets
   * @property {String} [assetPath=''] path to assets
   * @property {String} [jsPath=''] path to javascript files
   * @property {String} [glCanvasId='glcanvas'] dom element id of canvas element
   * @property {Function} [onError=null] called when an error occurs
   * @property {Function} [onFinishedLoading=null] called when patch finished loading all assets
   * @property {Function} [onFirstFrameRendered=null] called when patch rendered it's first frame
   * @property {Boolean} [glCanvasResizeToWindow=false] resize canvas automatically to window size
   * @property {Boolean} [glCanvasResizeToParent] resize canvas automatically to parent element
   * @property {Boolean} [doRequestAnimation=true] do requestAnimationFrame set to false if you want to trigger exec() from outside (only do if you know what you are doing)
   * @property {Boolean} [clearCanvasColor=true] clear canvas in transparent color every frame
   * @property {Boolean} [clearCanvasDepth=true] clear depth every frame
   * @property {Boolean} [glValidateShader=true] enable/disable validation of shaders *
   * @property {Boolean} [silent=false]
   * @property {Number} [fpsLimit=0] 0 for maximum possible frames per second
   * @property {String} [glslPrecision='mediump'] default precision for glsl shader
   * @property {String} [prefixJsPath]
   * @property {Function} [onPatchLoaded]
   * @property {Object} [canvas]
   * @property {Object} [patch]
   * @property {String} [patchFile]
   * @property {String} [subPatch] internal use
   * @property {Number} [masterVolume] 0 for maximum possible frames per second
   * @property {HTMLCanvasElement} [glCanvas]
   */

  /**
   * @typedef CoreOp
   * @type Op
   */

  /**
   * @template {CoreOp} Op
   *
   * Patch class, contains all operators,values,links etc. manages loading and running of the whole patch
   *
   * see {@link PatchConfig}
   *
   * @example
   * CABLES.patch=new CABLES.Patch(
   * {
   *     patch:pStr,
   *     glCanvasId:'glcanvas',
   *     glCanvasResizeToWindow:true,
   *     canvas:{powerPreference:"high-performance"},
   *     prefixAssetPath:'/assets/',
   *     prefixJsPath:'/js/',
   *     onError:function(e){console.log(e);}
   *     glslPrecision:'highp'
   * });
   */
  class Patch extends Events {
    static EVENT_OP_DELETED = "onOpDelete";
    static EVENT_OP_ADDED = "onOpAdd";
    static EVENT_PAUSE = "pause";
    static EVENT_RESUME = "resume";
    static EVENT_PATCHLOADEND = "patchLoadEnd";
    static EVENT_VARIABLES_CHANGED = "variablesChanged";

    #renderOneFrame = false;
    #initialDeserialize = true;

    /** @param {PatchConfig} cfg */
    constructor(cfg) {
      super();

      this._log = new Logger("core_patch", { onError: cfg.onError });

      /** @type {Array<Op>} */
      this.ops = [];
      this.settings = {};

      /** @type {PatchConfig} */
      this.config = cfg || {
        glCanvasResizeToWindow: false,
        prefixAssetPath: "",
        prefixJsPath: "",
        silent: true,
        onError: null,
        onFinishedLoading: null,
        onFirstFrameRendered: null,
        onPatchLoaded: null,
        fpsLimit: 0,
      };

      this.timer = new Timer();
      this.freeTimer = new Timer();
      this.animFrameOps = [];
      this.animFrameCallbacks = [];
      this.gui = false;
      CABLES.logSilent = this.silent = true;
      this.profiler = null;
      this.aborted = false;
      this._crashedOps = [];

      this._animReq = null;
      this._opIdCache = {};
      this._triggerStack = [];
      this.storeObjNames = false; // remove after may release

      /** @type {LoadingStatus} */
      this.loading = new LoadingStatus(this);

      this._volumeListeners = [];
      this._paused = false;
      this._frameNum = 0;
      this.onOneFrameRendered = null;
      this.namedTriggers = {};

      this._origData = null;
      this._frameNext = 0;
      this._frameInterval = 0;
      this._lastFrameTime = 0;
      this._frameWasdelayed = true;
      this.tempData = this.frameStore = {};
      this.reqAnimTimeStamp = 0;

      this.cgCanvas = null;

      if (
        !(function () {
          return !this;
        })()
      )
        console.log("not in strict mode: core patch");

      if (this.config.hasOwnProperty("silent"))
        this.silent = CABLES.logSilent = this.config.silent;
      if (!this.config.hasOwnProperty("doRequestAnimation"))
        this.config.doRequestAnimation = true;

      if (!this.config.prefixAssetPath) this.config.prefixAssetPath = "";
      if (!this.config.prefixJsPath) this.config.prefixJsPath = "";
      if (!this.config.masterVolume) this.config.masterVolume = 1.0;

      this._variables = {};

      this.vars = {};
      if (cfg && cfg.vars) this.vars = cfg.vars; // vars is old!

      this.cgl = new CglContext(this);
      this.cgp = null;

      this._subpatchOpCache = {};

      this.cgl.setCanvas(
        this.config.glCanvasId || this.config.glCanvas || "glcanvas",
      );
      if (this.config.glCanvasResizeToWindow === true)
        this.cgl.setAutoResize("window");
      if (this.config.glCanvasResizeToParent === true)
        this.cgl.setAutoResize("parent");
      this.loading.setOnFinishedLoading(this.config.onFinishedLoading);

      if (this.cgl.aborted) this.aborted = true;
      if (this.cgl.silent) this.silent = true;

      if (!CABLES.OPS) {
        this.aborted = true;
        throw new Error("no CABLES.OPS found");
      }
      this.freeTimer.play();
      this.exec();

      if (!this.aborted) {
        if (this.config.patch) {
          this.deSerialize(this.config.patch);
        } else if (this.config.patchFile) {
          ajax(this.config.patchFile, (err, _data) => {
            try {
              const data = JSON.parse(_data);
              if (err) {
                const txt = "";
                this._log.error("err", err);
                this._log.error("data", data);
                this._log.error("data", data.msg);
                return;
              }
              this.deSerialize(data);
            } catch (e) {
              this._log.error("could not load/parse patch ", e);
            }
          });
        }
        this.timer.play();
      }

      console.log("made with https://cables.gl");
    }

    isPlaying() {
      return !this._paused;
    }

    /** @deprecated */
    renderOneFrame() {
      this._paused = true;
      this._renderOneFrame = true;
      this.exec();
      this._renderOneFrame = false;
    }

    /**
     * returns true if patch is opened in editor/gui mode
     * @function isEditorMode
     * @memberof Patch
     * @instance
     * @return {Boolean} editor mode
     */
    isEditorMode() {
      return this.config.editorMode === true;
    }

    /**
     * pauses patch execution
     * @function pause
     * @memberof Patch
     * @instance
     */
    pause() {
      cancelAnimationFrame(this._animReq);
      this.emitEvent(Patch.EVENT_PAUSE);
      this._animReq = null;
      this._paused = true;
      this.freeTimer.pause();
    }

    /**
     * resumes patch execution
     * @function resume
     * @memberof Patch
     * @instance
     */
    resume() {
      if (this._paused) {
        cancelAnimationFrame(this._animReq);
        this._paused = false;
        this.freeTimer.play();
        this.emitEvent(Patch.EVENT_RESUME);
        this.exec();
      }
    }

    /**
     * set volume [0-1]
     * @function setVolume
     * @param {Number} v volume
     * @memberof Patch
     * @instance
     */
    setVolume(v) {
      this.config.masterVolume = v;
      for (let i = 0; i < this._volumeListeners.length; i++)
        this._volumeListeners[i].onMasterVolumeChanged(v);
    }

    /**
     * get asset path
     * @function getAssetPath
     * @memberof Patch
     * @param patchId
     * @instance
     */
    getAssetPath(patchId = null) {
      if (this.config.hasOwnProperty("assetPath")) {
        return this.config.assetPath;
      } else if (this.isEditorMode()) {
        let id = patchId || gui.project()._id;
        return "/assets/" + id + "/";
      } else if (
        document.location.href.indexOf("cables.gl") > 0 ||
        document.location.href.indexOf("cables.local") > 0
      ) {
        const parts = document.location.pathname.split("/");
        let id = patchId || parts[parts.length - 1];
        return "/assets/" + id + "/";
      } else {
        return "assets/";
      }
    }

    /**
     * get js path
     * @function getJsPath
     * @memberof Patch
     * @instance
     */
    getJsPath() {
      if (this.config.hasOwnProperty("jsPath")) {
        return this.config.jsPath;
      } else {
        return "js/";
      }
    }

    /**
     * get url/filepath for a filename
     * this uses prefixAssetpath in exported patches
     * @function getFilePath
     * @memberof Patch
     * @instance
     * @param {String} filename
     * @return {String} url
     */
    getFilePath(filename) {
      if (!filename) return filename;
      filename = String(filename);
      if (filename.indexOf("https:") === 0 || filename.indexOf("http:") === 0)
        return filename;
      if (filename.indexOf("data:") === 0) return filename;
      if (filename.indexOf("file:") === 0) return filename;
      filename = filename.replace("//", "/");
      if (filename.startsWith(this.config.prefixAssetPath))
        filename = filename.replace(this.config.prefixAssetPath, "");
      return (
        this.config.prefixAssetPath +
        filename +
        (this.config.suffixAssetPath || "")
      ); //
    }

    clear() {
      this.emitEvent("patchClearStart");
      this.cgl.TextureEffectMesh = null;
      this.animFrameOps.length = 0;
      this.timer = new Timer();
      while (this.ops.length > 0) this.deleteOp(this.ops[0].id);

      this._opIdCache = {};
      this.emitEvent("patchClearEnd");
    }

    /**
     * @param {string} identifier
     * @param {string} id
     * @param {string} [opName]
     * @returns {Op}
     */
    createOp(identifier, id, opName = null) {
      /**
       * @type {Op}
       */
      let op = null;
      let objName = "";

      try {
        if (!identifier) {
          console.error("createop identifier false", identifier);
          console.log(new Error().stack);
          return;
        }
        if (identifier.indexOf("Ops.") === -1) {
          /*
           * this should be a uuid, not a namespace
           * creating ops by id should be the default way from now on!
           */
          const opId = identifier;

          if (CABLES.OPS[opId]) {
            objName = CABLES.OPS[opId].objName;
            op = new CABLES.OPS[opId].f(this, objName, id, opId);
            op.opId = opId;
          } else {
            if (opName) {
              identifier = opName;
              this._log.warn("could not find op by id: " + opId);
            } else {
              throw new Error("could not find op by id: " + opId, {
                cause: "opId:" + opId,
              });
            }
          }
        }

        if (!op) {
          // fallback: create by objname!
          objName = identifier;
          const parts = identifier.split(".");
          const opObj = Patch.getOpClass(objName);

          if (!opObj) {
            this.emitEvent("criticalError", {
              title: "unknown op" + objName,
              text: "unknown op: " + objName,
            });

            this._log.error("unknown op: " + objName);
            throw new Error("unknown op: " + objName);
          } else {
            if (parts.length == 2)
              op = new window[parts[0]][parts[1]](this, objName, id);
            else if (parts.length == 3)
              op = new window[parts[0]][parts[1]][parts[2]](this, objName, id);
            else if (parts.length == 4)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]](
                this,
                objName,
                id,
              );
            else if (parts.length == 5)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]](
                this,
                objName,
                id,
              );
            else if (parts.length == 6)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ](this, objName, id);
            else if (parts.length == 7)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ][parts[6]](this, objName, id);
            else if (parts.length == 8)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ][parts[6]][parts[7]](this, objName, id);
            else if (parts.length == 9)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ][parts[6]][parts[7]][parts[8]](this, objName, id);
            else if (parts.length == 10)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ][parts[6]][parts[7]][parts[8]][parts[9]](this, objName, id);
            else console.log("parts.length", parts.length);
          }

          if (op) {
            op.opId = null;
            for (const i in CABLES.OPS) {
              if (CABLES.OPS[i].objName == objName) op.opId = i;
            }
          }
        }
      } catch (e) {
        this._crashedOps.push(objName);

        this._log.error("[instancing error] " + objName, e);

        if (!this.isEditorMode()) {
          this._log.error("INSTANCE_ERR", "Instancing Error: " + objName, e);
          // throw new Error("instancing error 1" + objName);
        }
      }

      if (op) {
        op._objName = objName;
        op.patch = this;
      } else {
        this._log.log("no op was created!?", identifier, id);
      }
      return op;
    }

    /**
     * create a new op in patch
     * @function addOp
     * @memberof Patch
     * @instance
     * @param {string} opIdentifier uuid or name, e.g. Ops.Math.Sum
     * @param {OpUiAttribs} uiAttribs Attributes
     * @param {string} id
     * @param {boolean} [fromDeserialize]
     * @param {string} [opName] e.g. Ops.Math.Sum
     * @example
     * // add invisible op
     * patch.addOp('Ops.Math.Sum', { showUiAttribs: false });
     */
    addOp(opIdentifier, uiAttribs, id, fromDeserialize = false, opName = null) {
      const op = this.createOp(opIdentifier, id, opName);

      if (op) {
        uiAttribs = uiAttribs || {};
        if (uiAttribs.hasOwnProperty("errors")) delete uiAttribs.errors;
        if (uiAttribs.hasOwnProperty("error")) delete uiAttribs.error;
        uiAttribs.subPatch = uiAttribs.subPatch || 0;
        op.setUiAttribs(uiAttribs);
        if (op.onCreate) op.onCreate();

        if (op.hasOwnProperty("onAnimFrame")) this.addOnAnimFrame(op);
        if (op.hasOwnProperty("onMasterVolumeChanged"))
          this._volumeListeners.push(op);

        if (this._opIdCache[op.id]) {
          this._log.warn("opid with id " + op.id + " already exists in patch!");
          this.deleteOp(op.id); // strange with subpatch ops: why is this needed, somehow ops get added twice ???.....
          // return;
        }

        this.ops.push(op);
        this._opIdCache[op.id] = op;

        if (this._subPatchCacheAdd)
          this._subPatchCacheAdd(uiAttribs.subPatch, op);
        this.emitEvent(Patch.EVENT_OP_ADDED, op, fromDeserialize);

        if (op.init) op.init();

        op.emitEvent("init", fromDeserialize);
      } else {
        this._log.error("addop: op could not be created: ", opIdentifier);
      }

      return op;
    }

    addOnAnimFrame(op) {
      for (let i = 0; i < this.animFrameOps.length; i++)
        if (this.animFrameOps[i] == op) {
          return;
        }

      this.animFrameOps.push(op);
    }

    removeOnAnimFrame(op) {
      for (let i = 0; i < this.animFrameOps.length; i++) {
        if (this.animFrameOps[i] == op) {
          this.animFrameOps.splice(i, 1);
          return;
        }
      }
    }

    addOnAnimFrameCallback(cb) {
      this.animFrameCallbacks.push(cb);
    }

    removeOnAnimCallback(cb) {
      for (let i = 0; i < this.animFrameCallbacks.length; i++) {
        if (this.animFrameCallbacks[i] == cb) {
          this.animFrameCallbacks.splice(i, 1);
          return;
        }
      }
    }

    deleteOp(opid, tryRelink, reloadingOp) {
      let found = false;
      for (const i in this.ops) {
        if (this.ops[i].id == opid) {
          const op = this.ops[i];

          /** @type {Port} */
          let reLinkP1 = null;

          /** @type {Port} */
          let reLinkP2 = null;

          if (op) {
            found = true;
            if (tryRelink) {
              if (
                op.portsIn.length > 0 &&
                op.portsIn[0].isLinked() &&
                op.portsOut.length > 0 &&
                op.portsOut[0].isLinked()
              ) {
                if (
                  op.portsIn[0].getType() == op.portsOut[0].getType() &&
                  op.portsIn[0].links[0]
                ) {
                  reLinkP1 = op.portsIn[0].links[0].getOtherPort(op.portsIn[0]);
                  reLinkP2 = op.portsOut[0].links[0].getOtherPort(op.portsOut[0]);
                }
              }
            }

            const opToDelete = this.ops[i];
            opToDelete.removeLinks();

            this.ops.splice(i, 1);
            opToDelete.emitEvent("delete", opToDelete);
            this.emitEvent(Patch.EVENT_OP_DELETED, opToDelete, reloadingOp);

            if (this.clearSubPatchCache)
              this.clearSubPatchCache(opToDelete.uiAttribs.subPatch);

            if (opToDelete.onDelete) opToDelete.onDelete(reloadingOp);
            opToDelete.cleanUp();

            if (reLinkP1 !== null && reLinkP2 !== null) {
              this.link(
                reLinkP1.op,
                reLinkP1.getName(),
                reLinkP2.op,
                reLinkP2.getName(),
              );
            }

            delete this._opIdCache[opid];
            break;
          }
        }
      }

      if (!found) this._log.warn("core patch deleteop: not found...", opid);
    }

    getFrameNum() {
      return this._frameNum;
    }

    emitOnAnimFrameEvent(time, delta) {
      time = time || this.timer.getTime();

      for (let i = 0; i < this.animFrameCallbacks.length; ++i)
        if (this.animFrameCallbacks[i])
          this.animFrameCallbacks[i](time, this._frameNum, delta);

      for (let i = 0; i < this.animFrameOps.length; ++i)
        if (this.animFrameOps[i].onAnimFrame)
          this.animFrameOps[i].onAnimFrame(time, this._frameNum, delta);
    }

    renderFrame(timestamp) {
      this.timer.update(this.reqAnimTimeStamp);
      this.freeTimer.update(this.reqAnimTimeStamp);
      const time = this.timer.getTime();
      const startTime = performance.now();
      this.cgl.frameStartTime = this.timer.getTime();

      const delta = timestamp - this.reqAnimTimeStamp || timestamp;

      this.emitOnAnimFrameEvent(null, delta);

      this.cgl.profileData.profileFrameDelta = delta;
      this.reqAnimTimeStamp = timestamp;
      this.cgl.profileData.profileOnAnimFrameOps = performance.now() - startTime;

      this.emitEvent("onRenderFrame", time);

      this._frameNum++;
      if (this._frameNum == 1) {
        if (this.config.onFirstFrameRendered) this.config.onFirstFrameRendered();
      }
    }

    /**
     * @param {number} [timestamp]
     */
    exec(timestamp) {
      if (!this.#renderOneFrame && (this._paused || this.aborted)) return;
      this.emitEvent("reqAnimFrame");
      cancelAnimationFrame(this._animReq);

      this.config.fpsLimit = this.config.fpsLimit || 0;
      if (this.config.fpsLimit) {
        this._frameInterval = 1000 / this.config.fpsLimit;
      }

      const now = CABLES.now();
      const frameDelta = now - this._frameNext;

      if (this.isEditorMode()) {
        if (!this.#renderOneFrame) {
          if (
            now - this._lastFrameTime >= 500 &&
            this._lastFrameTime !== 0 &&
            !this._frameWasdelayed
          ) {
            this._lastFrameTime = 0;
            setTimeout(this.exec.bind(this), 500);
            this.emitEvent("renderDelayStart");
            this._frameWasdelayed = true;
            return;
          }
        }
      }

      if (
        this.#renderOneFrame ||
        this.config.fpsLimit === 0 ||
        frameDelta > this._frameInterval ||
        this._frameWasdelayed
      ) {
        this.renderFrame(timestamp);

        if (this._frameInterval)
          this._frameNext = now - (frameDelta % this._frameInterval);
      }

      if (this._frameWasdelayed) {
        this.emitEvent("renderDelayEnd");
        this._frameWasdelayed = false;
      }

      if (this.#renderOneFrame) {
        if (this.onOneFrameRendered) this.onOneFrameRendered(); // todo remove everywhere and use propper event...
        this.emitEvent("renderedOneFrame");
        this._renderOneFrame = false;
      }

      if (this.config.doRequestAnimation)
        this._animReq =
          this.cgl.canvas?.ownerDocument.defaultView.requestAnimationFrame(
            this.exec.bind(this),
          );
    }

    /**
     * link two ops/ports
     * @function link
     * @memberof Patch
     * @instance
     * @param {Op} op1
     * @param {String} port1Name
     * @param {Op} op2
     * @param {String} port2Name
     * @param {boolean} lowerCase
     * @param {boolean} fromDeserialize
     */
    link(
      op1,
      port1Name,
      op2,
      port2Name,
      lowerCase = false,
      fromDeserialize = false,
    ) {
      if (!op1) return this._log.warn("link: op1 is null ");
      if (!op2) return this._log.warn("link: op2 is null");

      const port1 = op1.getPort(port1Name, lowerCase);
      const port2 = op2.getPort(port2Name, lowerCase);

      if (!port1)
        return this._log.warn(
          "port1 not found! " + port1Name + " (" + op1.objName + ")",
        );
      if (!port2)
        return this._log.warn(
          "port2 not found! " +
            port2Name +
            " of " +
            op2.name +
            "(" +
            op2.objName +
            ")",
          op2,
        );

      if (!port1.shouldLink(port1, port2) || !port2.shouldLink(port1, port2))
        return false;

      if (Link.canLink(port1, port2)) {
        const link = new Link(this);
        link.link(port1, port2);

        this.emitEvent("onLink", port1, port2, link, fromDeserialize);
        return link;
      }
    }

    /**
     * @param {Object} options
     * @returns {Object|String}
     */
    serialize(options) {
      const obj = {};

      options = options || {};
      obj.ops = [];
      obj.settings = this.settings;
      for (const i in this.ops) {
        const op = this.ops[i];
        if (op && op.getSerialized) obj.ops.push(op.getSerialized());
      }

      cleanJson(obj);

      if (options.asObject) return obj;
      return JSON.stringify(obj);
    }

    getOpsByRefId(
      refId, // needed for instancing ops ?
    ) {
      const perf = gui.uiProfiler.start("[corepatchetend] getOpsByRefId");
      const refOps = [];
      const ops = gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++)
        if (ops[i].storage && ops[i].storage.ref == refId) refOps.push(ops[i]);
      perf.finish();
      return refOps;
    }

    /**
     * @param {String} opid
     * @returns {Op}
     */
    getOpById(opid) {
      return this._opIdCache[opid];
    }

    /**
     * @param {String} name
     */
    getOpsByObjName(name) {
      const arr = [];
      for (const i in this.ops)
        if (this.ops[i].objName == name) arr.push(this.ops[i]);
      return arr;
    }

    /**
     * @param {String} opid
     */
    getOpsByOpId(opid) {
      const arr = [];
      for (const i in this.ops)
        if (this.ops[i].opId == opid) arr.push(this.ops[i]);
      return arr;
    }

    /**
     * @param {String} which
     */
    loadLib(which) {
      ajaxSync(
        "/ui/libs/" + which + ".js",
        (_err, res) => {
          const se = document.createElement("script");
          se.type = "text/javascript";
          se.text = res;
          document.getElementsByTagName("head")[0].appendChild(se);
        },
        "GET",
      );
    }

    getSubPatchOpsByName(patchId, objName) {
      const arr = [];
      for (const i in this.ops)
        if (
          this.ops[i].uiAttribs &&
          this.ops[i].uiAttribs.subPatch == patchId &&
          this.ops[i].objName == objName
        )
          arr.push(this.ops[i]);

      return arr;
    }

    getSubPatchOp(patchId, objName) {
      return this.getFirstSubPatchOpByName(patchId, objName);
    }

    /**
     * @param {string} patchId
     * @param {string} objName
     * @returns {Op}
     */
    getFirstSubPatchOpByName(patchId, objName) {
      for (const i in this.ops)
        if (
          this.ops[i].uiAttribs &&
          this.ops[i].uiAttribs.subPatch == patchId &&
          this.ops[i].objName == objName
        )
          return this.ops[i];

      return false;
    }

    _addLink(opinid, opoutid, inName, outName) {
      return this.link(
        this.getOpById(opinid),
        inName,
        this.getOpById(opoutid),
        outName,
        false,
        true,
      );
    }

    /**
     * @param {String} s
     */
    logStartup(s) {
      if (window.logStartup) window.logStartup(s);
    }

    /**
     * @typedef DeserializeOptions
     * @property {boolean} [genIds]
     * @property {boolean} [createRef]
     */

    /**
     * Description
     * @param {Object} obj
     * @param {DeserializeOptions} options
     * @returns {any}
     */
    deSerialize(obj, options = { genIds: false, createRef: false }) {
      if (this.aborted) return;
      const newOps = [];
      const loadingId = this.loading.start("core", "deserialize");

      if (typeof obj === "string") obj = JSON.parse(obj);

      if (this.#initialDeserialize) {
        this.#initialDeserialize = false;
        this.namespace = obj.namespace || "";
        this.name = obj.name || "";
        this.settings = obj.settings;
      }

      this.emitEvent("patchLoadStart");

      obj.ops = obj.ops || [];

      this.logStartup("add " + obj.ops.length + " ops... ");

      const addedOps = [];

      // add ops...
      for (let iop = 0; iop < obj.ops.length; iop++) {
        const start = CABLES.now();
        const opData = obj.ops[iop];
        let op = null;

        try {
          if (opData.opId)
            op = this.addOp(
              opData.opId,
              opData.uiAttribs,
              opData.id,
              true,
              opData.objName,
            );
          else op = this.addOp(opData.objName, opData.uiAttribs, opData.id, true);
        } catch (e) {
          this._log.error("[instancing error] op data:", opData, e);
          // throw new Error("could not create op by id: <b>" + (opData.objName || opData.opId) + "</b> (" + opData.id + ")");
        }

        if (op) {
          addedOps.push(op);
          if (options.genIds) op.id = shortId();
          op.portsInData = opData.portsIn;
          op._origData = JSON.parse(JSON.stringify(opData));
          op.storage = opData.storage;
          // if (opData.hasOwnProperty("disabled"))op.setEnabled(!opData.disabled);

          for (const ipi in opData.portsIn) {
            const objPort = opData.portsIn[ipi];
            if (objPort && objPort.hasOwnProperty("name")) {
              const port = op.getPort(objPort.name);

              if (
                port &&
                (port.uiAttribs.display == "bool" ||
                  port.uiAttribs.type == "bool") &&
                !isNaN(objPort.value)
              )
                objPort.value = objPort.value == true ? 1 : 0;
              if (
                port &&
                objPort.value !== undefined &&
                port.type != Port.TYPE_TEXTURE
              )
                port.set(objPort.value);

              if (port) {
                port.deSerializeSettings(objPort);
              } else {
                /*
                 * if (port.uiAttribs.hasOwnProperty("title"))
                 * {
                 *     op.preservedPortTitles = op.preservedPortTitles || {};
                 *     op.preservedPortTitles[port.name] = port.uiAttribs.title;
                 * }
                 */
                op.preservedPortValues = op.preservedPortValues || {};
                op.preservedPortValues[objPort.name] = objPort.value;
              }
            }
          }

          for (const ipo in opData.portsOut) {
            const objPort = opData.portsOut[ipo];
            if (objPort && objPort.hasOwnProperty("name")) {
              const port2 = op.getPort(objPort.name);

              if (port2) {
                port2.deSerializeSettings(objPort);

                if (port2.uiAttribs.hasOwnProperty("title")) {
                  op.preservedPortTitles = op.preservedPortTitles || {};
                  op.preservedPortTitles[port2.name] = port2.uiAttribs.title;
                }

                if (
                  port2.type != Port.TYPE_TEXTURE &&
                  objPort.hasOwnProperty("value")
                )
                  port2.set(obj.ops[iop].portsOut[ipo].value);

                if (objPort.expose) port2.setUiAttribs({ expose: true });
              }
            }
          }
          newOps.push(op);
        }

        const timeused = Math.round(100 * (CABLES.now() - start)) / 100;
        if (!this.silent && timeused > 5)
          console.log("long op init ", obj.ops[iop].objName, timeused);
      }
      this.logStartup("add ops done");

      for (const i in this.ops) {
        if (this.ops[i].onLoadedValueSet) {
          this.ops[i].onLoadedValueSet(this.ops[i]._origData);
          this.ops[i].onLoadedValueSet = null;
          this.ops[i]._origData = null;
        }
        this.ops[i].emitEvent("loadedValueSet");
      }

      this.logStartup("creating links");

      if (options.opsCreated) options.opsCreated(addedOps);
      // create links...
      if (obj.ops) {
        for (let iop = 0; iop < obj.ops.length; iop++) {
          if (obj.ops[iop].portsIn) {
            for (let ipi2 = 0; ipi2 < obj.ops[iop].portsIn.length; ipi2++) {
              if (
                obj.ops[iop].portsIn[ipi2] &&
                obj.ops[iop].portsIn[ipi2].links
              ) {
                for (
                  let ili = 0;
                  ili < obj.ops[iop].portsIn[ipi2].links.length;
                  ili++
                ) {
                  this._addLink(
                    obj.ops[iop].portsIn[ipi2].links[ili].objIn,
                    obj.ops[iop].portsIn[ipi2].links[ili].objOut,
                    obj.ops[iop].portsIn[ipi2].links[ili].portIn,
                    obj.ops[iop].portsIn[ipi2].links[ili].portOut,
                  );

                  /*
                   * const took = performance.now - startTime;
                   * if (took > 100)console.log(obj().ops[iop].portsIn[ipi2].links[ili].objIn, obj.ops[iop].portsIn[ipi2].links[ili].objOut, took);
                   */
                }
              }
            }
          }
          if (obj.ops[iop].portsOut)
            for (let ipi2 = 0; ipi2 < obj.ops[iop].portsOut.length; ipi2++)
              if (
                obj.ops[iop].portsOut[ipi2] &&
                obj.ops[iop].portsOut[ipi2].links
              ) {
                for (
                  let ili = 0;
                  ili < obj.ops[iop].portsOut[ipi2].links.length;
                  ili++
                ) {
                  if (obj.ops[iop].portsOut[ipi2].links[ili]) {
                    if (obj.ops[iop].portsOut[ipi2].links[ili].subOpRef) {
                      // lost link
                      const outOp = this.getOpById(
                        obj.ops[iop].portsOut[ipi2].links[ili].objOut,
                      );
                      let dstOp = null;
                      let theSubPatch = 0;

                      for (let i = 0; i < this.ops.length; i++) {
                        if (
                          this.ops[i].storage &&
                          this.ops[i].storage.ref ==
                            obj.ops[iop].portsOut[ipi2].links[ili].subOpRef &&
                          outOp.uiAttribs.subPatch ==
                            this.ops[i].uiAttribs.subPatch
                        ) {
                          theSubPatch = this.ops[i].patchId.get();
                          break;
                        }
                      }

                      for (let i = 0; i < this.ops.length; i++) {
                        if (
                          this.ops[i].storage &&
                          this.ops[i].storage.ref ==
                            obj.ops[iop].portsOut[ipi2].links[ili].refOp &&
                          this.ops[i].uiAttribs.subPatch == theSubPatch
                        ) {
                          dstOp = this.ops[i];
                          break;
                        }
                      }

                      if (!dstOp)
                        this._log.warn("could not find op for lost link");
                      else {
                        this._addLink(
                          dstOp.id,
                          obj.ops[iop].portsOut[ipi2].links[ili].objOut,

                          obj.ops[iop].portsOut[ipi2].links[ili].portIn,
                          obj.ops[iop].portsOut[ipi2].links[ili].portOut,
                        );
                      }
                    } else {
                      const l = this._addLink(
                        obj.ops[iop].portsOut[ipi2].links[ili].objIn,
                        obj.ops[iop].portsOut[ipi2].links[ili].objOut,
                        obj.ops[iop].portsOut[ipi2].links[ili].portIn,
                        obj.ops[iop].portsOut[ipi2].links[ili].portOut,
                      );

                      if (!l) {
                        const op1 = this.getOpById(
                          obj.ops[iop].portsOut[ipi2].links[ili].objIn,
                        );
                        const op2 = this.getOpById(
                          obj.ops[iop].portsOut[ipi2].links[ili].objOut,
                        );

                        if (!op1) console.log("could not find link op1");
                        if (!op2) console.log("could not find link op2");

                        const p1Name =
                          obj.ops[iop].portsOut[ipi2].links[ili].portIn;

                        if (op1 && !op1.getPort(p1Name)) {
                          // console.log("PRESERVE port 1 not found", p1Name);

                          op1.preservedPortLinks[p1Name] =
                            op1.preservedPortLinks[p1Name] || [];
                          op1.preservedPortLinks[p1Name].push(
                            obj.ops[iop].portsOut[ipi2].links[ili],
                          );
                        }

                        const p2Name =
                          obj.ops[iop].portsOut[ipi2].links[ili].portOut;
                        if (op2 && !op2.getPort(p2Name)) {
                          // console.log("PRESERVE port 2 not found", obj.ops[iop].portsOut[ipi2].links[ili].portOut);
                          op2.preservedPortLinks[p1Name] =
                            op2.preservedPortLinks[p1Name] || [];
                          op2.preservedPortLinks[p1Name].push(
                            obj.ops[iop].portsOut[ipi2].links[ili],
                          );
                        }
                      }
                    }
                  }
                }
              }
        }
      }

      this.logStartup("calling ops onloaded");

      for (const i in this.ops) {
        if (this.ops[i].onLoaded) {
          // TODO: deprecate!!!
          this.ops[i].onLoaded();
          this.ops[i].onLoaded = null;
        }
      }

      this.logStartup("initializing ops...");
      for (const i in this.ops) {
        if (this.ops[i].init) {
          try {
            this.ops[i].init();
            this.ops[i].init = null;
          } catch (e) {
            console.error("op.init crash", e);
          }
        }
      }

      this.logStartup("initializing vars...");

      if (this.config.variables)
        for (const varName in this.config.variables)
          this.setVarValue(varName, this.config.variables[varName]);

      this.logStartup("initializing var ports");

      for (const i in this.ops) {
        this.ops[i].initVarPorts();
        delete this.ops[i].uiAttribs.pasted;
      }

      setTimeout(() => {
        this.loading.finished(loadingId);
      }, 100);

      if (this.config.onPatchLoaded) this.config.onPatchLoaded(this);

      this.emitEvent(Patch.EVENT_PATCHLOADEND, newOps, obj, options.genIds);
    }

    profile(enable) {
      this.profiler = new Profiler$1(this);
      for (const i in this.ops) {
        this.ops[i].profile(enable);
      }
    }

    // ----------------------

    /**
     * set variable value
     * @function setVariable
     * @memberof Patch
     * @instance
     * @param {String} name of variable
     * @param {Number|String|Boolean} val value
     */
    setVariable(name, val) {
      if (this._variables[name] !== undefined) {
        this._variables[name].setValue(val);
      } else {
        this._log.warn("variable " + name + " not found!");
      }
    }

    _sortVars() {
      if (!this.isEditorMode()) return;
      const ordered = {};
      Object.keys(this._variables)
        .sort((a, b) => {
          return a.localeCompare(b, "en", { sensitivity: "base" });
        })
        .forEach((key) => {
          ordered[key] = this._variables[key];
        });
      this._variables = ordered;
    }

    /**
     * has variable
     * @function hasVariable
     * @memberof Patch
     * @instance
     * @param {String} name of variable
     */
    hasVar(name) {
      return this._variables[name] !== undefined;
    }

    // used internally
    setVarValue(name, val, type) {
      if (this.hasVar(name)) {
        this._variables[name].setValue(val);
      } else {
        this._variables[name] = new PatchVariable(name, val, type);
        this._sortVars();
        this.emitEvent(Patch.EVENT_VARIABLES_CHANGED);
      }
      return this._variables[name];
    }

    // old?
    getVarValue(name, val) {
      if (this._variables.hasOwnProperty(name))
        return this._variables[name].getValue();
    }

    /**
     * @function getVar
     * @memberof Patch
     * @instance
     * @param {String} name
     * @return {PatchVariable} variable
     */
    getVar(name) {
      if (this._variables.hasOwnProperty(name)) return this._variables[name];
    }

    deleteVar(name) {
      for (let i = 0; i < this.ops.length; i++)
        for (let j = 0; j < this.ops[i].portsIn.length; j++)
          if (this.ops[i].portsIn[j].getVariableName() == name)
            this.ops[i].portsIn[j].setVariable(null);

      delete this._variables[name];
      this.emitEvent("variableDeleted", name);
      this.emitEvent("variablesChanged");
    }

    /**
     * @param {number} t
     * @returns {Object}
     */
    getVars(t) {
      if (t === undefined) return this._variables;
      if (t === 1) return {};

      const perf = gui.uiProfiler.start("[corepatchetend] getVars");

      const vars = [];
      let tStr = "";
      if (t == Port.TYPE_STRING) tStr = "string";
      else if (t == Port.TYPE_VALUE) tStr = "number";
      else if (t == Port.TYPE_ARRAY) tStr = "array";
      else if (t == Port.TYPE_OBJECT) tStr = "object";
      else {
        console.log("unknown,,,", t);
        console.log(new Error().stack);
      }

      for (const i in this._variables) {
        if (
          !this._variables[i].type ||
          this._variables[i].type == tStr ||
          this._variables[i].type == t
        )
          vars.push(this._variables[i]);
      }

      perf.finish();

      return vars;
    }

    // getVars(t)
    // {
    //     if (t === undefined) return this._variables;

    //     const vars = [];
    //     let tStr = "";
    //     if (t == Port.TYPE_STRING) tStr = "string";
    //     if (t == Port.TYPE_VALUE) tStr = "number";
    //     if (t == Port.TYPE_ARRAY) tStr = "array";
    //     if (t == Port.TYPE_OBJECT) tStr = "object";

    //     for (const i in this._variables)
    //     {
    //         if (!this._variables[i].type || this._variables[i].type == tStr || this._variables[i].type == t) vars.push(this._variables[i]);
    //     }
    //     return vars;
    // }

    /**
     * @function preRenderOps
     * @memberof Patch
     * @instance
     * @description invoke pre rendering of ops
     * @function
     */
    preRenderOps() {
      this._log.log("prerendering...");

      for (let i = 0; i < this.ops.length; i++) {
        if (this.ops[i].preRender) {
          this.ops[i].preRender();
          this._log.log("prerender " + this.ops[i].objName);
        }
      }
    }

    /**
     * @function dispose
     * @memberof Patch
     * @instance
     * @description stop, dispose and cleanup patch
     */
    dispose() {
      this.pause();
      this.clear();
      this.cgl.dispose();
    }

    pushTriggerStack(p) {
      this._triggerStack.push(p);
    }

    popTriggerStack() {
      this._triggerStack.pop();
    }

    printTriggerStack() {
      if (this._triggerStack.length == 0) {
        // console.log("stack length", this._triggerStack.length); // eslint-disable-line
        return;
      }
      console.groupCollapsed(
        "trigger port stack " +
          this._triggerStack[this._triggerStack.length - 1].op.objName +
          "." +
          this._triggerStack[this._triggerStack.length - 1].name,
      );

      const rows = [];
      for (let i = 0; i < this._triggerStack.length; i++) {
        rows.push(
          i +
            ". " +
            this._triggerStack[i].op.objName +
            " " +
            this._triggerStack[i].name,
        );
      }

      console.table(rows);
      console.groupEnd();
    }

    /**
     * returns document object of the patch could be != global document object when opening canvas ina popout window
     * @function getDocument
     * @memberof Patch
     * @instance
     * @return {Object} document
     */
    getDocument() {
      return this.cgl.canvas.ownerDocument;
    }
  }

  Patch.getOpClass = function (objName) {
    const parts = objName.split(".");
    let opObj = null;

    try {
      if (parts.length == 2) opObj = window[parts[0]][parts[1]];
      else if (parts.length == 3) opObj = window[parts[0]][parts[1]][parts[2]];
      else if (parts.length == 4)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]];
      else if (parts.length == 5)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]];
      else if (parts.length == 6)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]];
      else if (parts.length == 7)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ];
      else if (parts.length == 8)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ][parts[7]];
      else if (parts.length == 9)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ][parts[7]][parts[8]];
      else if (parts.length == 10)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ][parts[7]][parts[8]][parts[9]];
      return opObj;
    } catch (e) {
      return null;
    }
  };

  Patch.replaceOpIds = function (json, options) {
    const opids = {};
    for (const i in json.ops) {
      opids[json.ops[i].id] = json.ops[i];
    }

    for (const j in json.ops) {
      for (const k in json.ops[j].portsOut) {
        const links = json.ops[j].portsOut[k].links;
        if (links) {
          let l = links.length;

          while (l--) {
            if (links[l] && (!opids[links[l].objIn] || !opids[links[l].objOut])) {
              if (!options.doNotUnlinkLostLinks) {
                links.splice(l, 1);
              } else {
                if (options.fixLostLinks) {
                  const op = gui.corePatch().getOpById(links[l].objIn);
                  if (!op) console.log("op not found!");
                  else {
                    const outerOp = gui.patchView.getSubPatchOuterOp(
                      op.uiAttribs.subPatch,
                    );
                    if (outerOp) {
                      op.storage = op.storage || {};
                      op.storage.ref = op.storage.ref || shortId();
                      links[l].refOp = op.storage.ref;
                      links[l].subOpRef = outerOp.storage.ref;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    for (const i in json.ops) {
      const op = json.ops[i];
      const oldId = op.id;
      let newId = shortId();

      if (options.prefixHash) newId = prefixedHash(options.prefixHash + oldId);
      else if (options.prefixId) newId = options.prefixId + oldId;
      else if (options.refAsId) {
        // when saving json
        if (op.storage && op.storage.ref) {
          newId = op.storage.ref;
          delete op.storage.ref;
        } else {
          op.storage = op.storage || {};
          op.storage.ref = newId = shortId();
        }
      }

      const newID = (op.id = newId);

      if (options.oldIdAsRef) {
        // when loading json
        op.storage = op.storage || {};
        op.storage.ref = oldId;
      }

      for (const j in json.ops) {
        if (json.ops[j].portsIn)
          for (const k in json.ops[j].portsIn) {
            if (json.ops[j].portsIn[k].links) {
              let l = json.ops[j].portsIn[k].links.length;

              while (l--)
                if (json.ops[j].portsIn[k].links[l] === null)
                  json.ops[j].portsIn[k].links.splice(l, 1);

              for (l in json.ops[j].portsIn[k].links) {
                if (json.ops[j].portsIn[k].links[l].objIn === oldId)
                  json.ops[j].portsIn[k].links[l].objIn = newID;
                if (json.ops[j].portsIn[k].links[l].objOut === oldId)
                  json.ops[j].portsIn[k].links[l].objOut = newID;
              }
            }
          }

        if (json.ops[j].portsOut)
          for (const k in json.ops[j].portsOut) {
            if (json.ops[j].portsOut[k].links) {
              let l = json.ops[j].portsOut[k].links.length;

              while (l--)
                if (json.ops[j].portsOut[k].links[l] === null)
                  json.ops[j].portsOut[k].links.splice(l, 1);

              for (l in json.ops[j].portsOut[k].links) {
                if (json.ops[j].portsOut[k].links[l].objIn === oldId)
                  json.ops[j].portsOut[k].links[l].objIn = newID;
                if (json.ops[j].portsOut[k].links[l].objOut === oldId)
                  json.ops[j].portsOut[k].links[l].objOut = newID;
              }
            }
          }
      }
    }
    const fixedSubPatches = [];

    for (let i = 0; i < json.ops.length; i++) {
      // if (CABLES.Op.isSubPatchOpName(json.ops[i].objName))
      if (json.ops[i].storage && json.ops[i].storage.subPatchVer) {
        for (const k in json.ops[i].portsIn) {
          if (json.ops[i].portsIn[k].name === "patchId") {
            let newId = shortId();

            if (options.prefixHash)
              newId = prefixedHash(
                options.prefixHash + json.ops[i].portsIn[k].value,
              );

            const oldSubPatchId = json.ops[i].portsIn[k].value;
            const newSubPatchId = (json.ops[i].portsIn[k].value = newId);

            for (let j = 0; j < json.ops.length; j++) {
              // op has no uiAttribs in export, we don't care about subpatches in export though
              if (json.ops[j].uiAttribs) {
                if (json.ops[j].uiAttribs.subPatch === oldSubPatchId) {
                  json.ops[j].uiAttribs.subPatch = newSubPatchId;
                  fixedSubPatches.push(json.ops[j].id);
                }
              }
            }
          }
        }
      }
    }

    for (const kk in json.ops) {
      let found = false;
      for (let j = 0; j < fixedSubPatches.length; j++) {
        if (json.ops[kk].id === fixedSubPatches[j]) {
          found = true;
          break;
        }
      }
      // op has no uiAttribs in export, we don't care about subpatches in export though
      if (!found && json.ops[kk].uiAttribs && options.parentSubPatchId != null)
        json.ops[kk].uiAttribs.subPatch = options.parentSubPatchId;
    }

    return json;
  };

  /**
   * remove an eventlistener
   * @instance
   * @function addEventListener
   * @param {String} name of event
   * @param {function} callback
   */

  /**
   * remove an eventlistener
   * @instance
   * @function removeEventListener
   * @param {String} name of event
   * @param {function} callback
   */

  /**
   * op added to patch event
   * @event onOpAdd
   *
   * @memberof Patch
   * @type {Object}
   * @property {Op} op new op
   */

  /**
   * op deleted from patch
   * @event onOpDelete
   * @memberof Patch
   * @type {Object}
   * @property {Op} op that will be deleted
   */

  /**
   * link event - two ports will be linked
   * @event onLink
   * @memberof Patch
   * @type {Object}
   * @property {Port} port1
   * @property {Port} port2
   */

  /**
   * unlink event - a link was deleted
   * @event onUnLink
   * @memberof Patch
   * @type {Object}
   */

  /**
   * variables has been changed / a variable has been added to the patch
   * @event variablesChanged
   * @memberof Patch
   * @type {Object}
   * @property {Port} port1
   * @property {Port} port2
   */

  /**
   * @namespace external:CABLES#Link
   * @description a link is a connection between two ops/ports -> one input and one output port
   * @hideconstructor
   * @class
   */
  class Link extends Events {
    /**
     * @param {Patch} p
     */
    constructor(p) {
      super();

      this.id = CABLES.simpleId();

      /**
       * @type {Port}
       */
      this.portIn = null;

      /**
       * @type {Port}
       */
      this.portOut = null;

      /**
       * @type {Patch}
       */
      this._patch = p;
      this.activityCounter = 0;
      this.ignoreInSerialize = false;
    }

    /**
     * @param {any} v
     */
    setValue(v) {
      if (v === undefined) this._setValue();
      else this.portIn.set(v);
    }

    activity() {
      this.activityCounter++;
    }

    _setValue() {
      if (!this.portOut) {
        this.remove();
        return;
      }
      const v = this.portOut.get();

      if (v == v) {
        // NaN is the only JavaScript value that is treated as unequal to itself
        if (this.portIn.type != Port.TYPE_FUNCTION) this.activity();

        if (this.portIn.get() !== v) {
          this.portIn.set(v);
        } else {
          if (this.portIn.changeAlways) this.portIn.set(v);
          if (this.portOut.forceRefChange) this.portIn.forceChange();
        }
      }
    }

    /**
     * @function getOtherPort
     * @memberof Link
     * @instance
     * @param {Port} p port
     * @description returns the port of the link, which is not port
     */
    getOtherPort(p) {
      if (p == this.portIn) return this.portOut;
      return this.portIn;
    }

    /**
     * @function remove
     * @memberof Link
     * @instance
     * @description unlink/remove this link from all ports
     */
    remove() {
      if (this.portIn) this.portIn.removeLink(this);
      if (this.portOut) this.portOut.removeLink(this);
      if (this._patch) {
        this._patch.emitEvent("onUnLink", this.portIn, this.portOut, this);
      }

      if (
        this.portIn &&
        (this.portIn.type == Port.TYPE_OBJECT ||
          this.portIn.type == Port.TYPE_ARRAY)
      ) {
        this.portIn.set(null);
        if (this.portIn.links.length > 0)
          this.portIn.set(this.portIn.links[0].getOtherPort(this.portIn).get());
      }

      if (this.portIn) this.portIn.op._checkLinksNeededToWork();
      if (this.portOut) this.portOut.op._checkLinksNeededToWork();

      this.portIn = null;
      this.portOut = null;
      this._patch = null;
    }

    /**
     * @function link
     * @memberof Link
     * @instance
     * @description link those two ports
     * @param {Port} p1 port1
     * @param {Port} p2 port2
     */
    link(p1, p2) {
      if (!Link.canLink(p1, p2)) {
        console.warn("[core_link] cannot link ports!", p1, p2);
        return false;
      }

      if (p1.direction == Port.DIR_IN) {
        this.portIn = p1;
        this.portOut = p2;
      } else {
        this.portIn = p2;
        this.portOut = p1;
      }

      p1.addLink(this);
      p2.addLink(this);

      this.setValue();

      p1.op._checkLinksNeededToWork();
      p2.op._checkLinksNeededToWork();
    }

    getSerialized() {
      const obj = {};

      obj.portIn = this.portIn.getName();
      obj.portOut = this.portOut.getName();
      obj.objIn = this.portIn.op.id;
      obj.objOut = this.portOut.op.id;

      return obj;
    }
  }

  // --------------------------------------------

  /**
   * @function canLinkText
   * @memberof Link
   * @instance
   * @description return a text message with human readable reason if ports can not be linked, or can be
   * @param {Port} p1 port1
   * @param {Port} p2 port2
   */
  Link.canLinkText = function (p1, p2) {
    if (p1.direction == p2.direction) {
      let txt = "(out)";
      if (p2.direction == Port.DIR_IN) txt = "(in)";
      return "can not link: same direction " + txt;
    }
    if (p1.op == p2.op) return "can not link: same op";
    if (p1.type != Port.TYPE_DYNAMIC && p2.type != Port.TYPE_DYNAMIC) {
      if (p1.type != p2.type) return "can not link: different type";
    }

    if (CABLES.UI && p1.type == Port.TYPE_OBJECT && p2.type == Port.TYPE_OBJECT) {
      if (p1.uiAttribs.objType && p2.uiAttribs.objType)
        if (p1.uiAttribs.objType != p2.uiAttribs.objType)
          return "incompatible objects";
    }

    if (!p1) return "can not link: port 1 invalid";
    if (!p2) return "can not link: port 2 invalid";

    if (p1.direction == Port.DIR_IN && p1.isAnimated())
      return "can not link: is animated";
    if (p2.direction == Port.DIR_IN && p2.isAnimated())
      return "can not link: is animated";

    if (p1.isLinkedTo(p2)) return "ports already linked";

    if ((p1.canLink && !p1.canLink(p2)) || (p2.canLink && !p2.canLink(p1)))
      return "Incompatible";

    return "can link";
  };

  /**
   * @function canLink
   * @memberof Link
   * @instance
   * @description return true if ports can be linked
   * @param {Port} p1 port1
   * @param {Port} p2 port2
   * @returns {Boolean}
   */
  Link.canLink = function (p1, p2) {
    if (!p1) return false;
    if (!p2) return false;
    if (p1.direction == Port.DIR_IN && p1.isAnimated()) return false;
    if (p2.direction == Port.DIR_IN && p2.isAnimated()) return false;

    if (p1.isHidden() || p2.isHidden()) return false;

    if (p1.isLinkedTo(p2)) return false;

    if (p1.direction == p2.direction) return false;

    if (CABLES.UI && p1.type == Port.TYPE_OBJECT && p2.type == Port.TYPE_OBJECT) {
      if (p1.uiAttribs.objType && p2.uiAttribs.objType) {
        if (
          p1.uiAttribs.objType.indexOf("sg_") == 0 &&
          p2.uiAttribs.objType.indexOf("sg_") == 0
        )
          return true;
        if (p1.uiAttribs.objType != p2.uiAttribs.objType) return false;
      }
    }

    if (
      p1.type != p2.type &&
      p1.type != Port.TYPE_DYNAMIC &&
      p2.type != Port.TYPE_DYNAMIC
    )
      return false;
    if (p1.type == Port.TYPE_DYNAMIC || p2.type == Port.TYPE_DYNAMIC) return true;

    if (p1.op == p2.op) return false;

    if (p1.canLink && !p1.canLink(p2)) return false;
    if (p2.canLink && !p2.canLink(p1)) return false;

    return true;
  };

  /**
   * @typedef PortUiAttribs
   * @property  {String} [title] overwrite title of port (by default this is portname)
   * @property  {String} [display] how the port is displayed and interacted in the paramerer panel
   * @property  {Boolean} [greyout] port paramater will appear greyed out, can not be
   * @property  {Boolean} [hidePort] port will be hidden from op
   * @property  {Boolean} [hideParam] port params will be hidden from parameter panel
   * @property  {Boolean} [showIndex] only for dropdowns - show value index (e.g. `0 - normal` )
   * @property  {String} [editorSyntax] set syntax highlighting theme for editor port
   * @property  {Boolean} [ignoreObjTypeErrors] do not auto check object types
   * @property  {string} [group] do not set manually - group ports, usually set by op.setPortGroup...
   * @property  {Boolean} [isAnimated] internal: do not set manually
   * @property  {Boolean} [useVariable] internal: do not set manually
   * @property  {string} [variableName] internal: do not set manually
   * @property  {Number} [order] internal: do not set manually
   * @property  {Number} [stride] internal: do not set manually
   * @property  {Boolean} [expose] internal: do not set manually
   * @property  {Boolean} [multiPortManual] internal: do not set manually
   * @property  {String} [increment] internal: do not set manually
   * @property  {Number} [multiPortNum] internal: do not set manually
   * @property  {String} [display] internal: do not set manually
   * @property  {String} [axis] internal: do not set manually
   * @property  {String} [type] internal: do not set manually
   * @property  {String} [objType] internal: do not set manually
   * @property  {String} [filter] internal: do not set manually
   * @property  {boolean} [hideFormatButton] internal: do not set manually
   * @property  {boolean} [editShortcut] internal: do not set manually
   * @property  {String} [filter] internal: do not set manually
   * @property  {boolean} [preview] internal: do not set manually
   * @property  {boolean} [colorPick] internal: do not set manually
   * @property  {Array<String>} [values] internal: do not set manually
   * @property  {boolean} [boundToVar] internal: do not set manually
   *
   */

  /**
   * data is coming into and out of ops through input and output ports
   * @namespace external:CABLES#Port
   * @module Port
   * @class
   * @example
   * const myPort=op.inString("String Port");
   */
  class Port extends Events {
    static DIR_IN = 0;
    static DIR_OUT = 1;

    static TYPE_VALUE = 0;
    static TYPE_NUMBER = 0;
    static TYPE_FUNCTION = 1;
    static TYPE_TRIGGER = 1;
    static TYPE_OBJECT = 2;
    static TYPE_TEXTURE = 2;
    static TYPE_ARRAY = 3;
    static TYPE_DYNAMIC = 4;
    static TYPE_STRING = 5;

    #oldAnimVal = -5711;

    #uiActiveState = true;
    #valueBeforeLink = null;
    // #lastAnimFrame = -1;
    #animated = false;
    // #tempLastUiValue = null;
    #useVariableName = null;

    /**
     * @param {Op} ___op
     * @param {string} name
     * @param {number} type
     * @param {PortUiAttribs} uiAttribs
     */
    constructor(___op, name, type, uiAttribs = {}) {
      super();
      this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops
      this._log = new Logger("core_port");

      /**
       * @type {Number}
       * @name direction
       * @instance
       * @memberof Port
       * @description direction of port (input(0) or output(1))
       */
      this.direction = Port.DIR_IN;
      this.id = String(CABLES.simpleId());

      /** @type {Op} */
      this._op = ___op;

      /** @type {Array<Link>} */
      this.links = [];

      /** @type {any} */
      this.value = 0.0;

      this.name = name;

      /** @type {number} */
      this.type = type || Port.TYPE_VALUE;

      /** @type {PortUiAttribs} */
      this.uiAttribs = uiAttribs || {};

      /** @type {Anim} */
      this.anim = null;

      this.defaultValue = null;

      this.ignoreValueSerialize = false;
      this.onLinkChanged = null;
      this.crashed = false;

      this.onValueChanged = null;
      this.onTriggered = null;
      this.changeAlways = false;
      this.forceRefChange = false;

      this.activityCounter = 0;
      this.apf = 0;
      this.activityCounterStartFrame = 0;

      this.canLink = null; // function can be overwritten
      this.preserveLinks = null;
      this.indexPort = null;
    }

    get parent() {
      this._log.stack("use port.op, not .parent");
      return this.op;
    }

    get title() {
      return this.uiAttribs.title || this.name;
    }

    get op() {
      return this._op;
    }

    get val() {
      return this.get();
    }

    set val(v) {
      this.setValue(v);
    }

    /**
     * copy over a uiattrib from an external connected port to another port
     * @function copyLinkedUiAttrib
     * @memberof Port
     * @param {string} which attrib name
     * @param {Port} port source port
     * @instance
     * @example
     *
     *  inArray.onLinkChanged=()=>
     *  {
     *      if(inArray) inArray.copyLinkedUiAttrib("stride", outArray);
     *  };
     *
     */
    copyLinkedUiAttrib(which, port) {
      if (!CABLES.UI) return;
      if (!this.isLinked()) return;

      const attr = {};
      attr[which] = this.links[0].getOtherPort(this).getUiAttrib(which);
      port.setUiAttribs(attr);
    }

    /*
     * sdjksdjklsd
     * TODO make extend class for ports, like for ops only for ui
     */
    getValueForDisplay() {
      let str = this.value;

      if (typeof this.value === "string" || this.value instanceof String) {
        if (str.length > 1000) {
          str = str.substring(0, 999);
          str += "...";
        }
        if (this.uiAttribs && this.uiAttribs.display == "boolnum") {
          str += " - ";

          if (!this.value) str += "false";
          else str += "true";
        }

        str = str.replace(
          /[\u00A0-\u9999<>\&]/g,
          function (/** @type {String} */ i) {
            return "&#" + i.charCodeAt(0) + ";";
          },
        );

        if (str.length > 100) str = str.substring(0, 100);
      } else {
        str = this.value;
      }
      return str;
    }

    /**
     * change listener for input value ports, overwrite to react to changes
     * @function onChange
     * @memberof Port
     * @instance
     * @example
     * const myPort=op.inString("MyPort");
     * myPort.onChange=function()
     * {
     *   console.log("was changed to: ",myPort.get());
     * }
     *
     */
    onAnimToggle() {}

    _onAnimToggle() {
      this.onAnimToggle();
    }

    /**
     * @function remove
     * @memberof Port
     * @instance
     * @description remove port
     */
    remove() {
      this.removeLinks();
      this._op.removePort(this);
    }

    /**
       * set ui attributes
       * @function setUiAttribs
       * @memberof Port
       * @instance
       * @param {PortUiAttribs} newAttribs

       * @example
       * myPort.setUiAttribs({greyout:true});
       */
    setUiAttribs(newAttribs) {
      let changed = false;
      if (!this.uiAttribs) this.uiAttribs = {};

      for (const p in newAttribs) {
        if (newAttribs[p] === undefined) {
          delete this.uiAttribs[p];
          continue;
        }
        if (this.uiAttribs[p] != newAttribs[p]) changed = true;
        this.uiAttribs[p] = newAttribs[p];

        if (p == "group" && this.indexPort)
          this.indexPort.setUiAttribs({ group: newAttribs[p] });
      }

      if (newAttribs.hasOwnProperty("expose"))
        this._op.patch.emitEvent("subpatchExpose", this._op.uiAttribs.subPatch);

      if (changed) this.emitEvent("onUiAttrChange", newAttribs, this);
    }

    /**
     * get ui attributes
     * @function getUiAttribs
     * @memberof Port
     * @example
     * myPort.getUiAttribs();
     */
    getUiAttribs() {
      return this.uiAttribs;
    }

    /**
     * get ui attribute
     * @function getUiAttrib
     * @memberof Port
     * @instance
     * @param {String} attribName
     * <pre>
     * attribName - return value of the ui-attribute, or null on unknown attribute
     * </pre>
     * @example
     * myPort.setUiAttribs("values");
     */
    getUiAttrib(attribName) {
      if (!this.uiAttribs || !this.uiAttribs.hasOwnProperty(attribName))
        return null;
      return this.uiAttribs[attribName];
    }

    /**
     * @function get
     * @memberof Port
     * @instance
     * @description get value of port
     */
    get() {
      if (this.#animated && this.lastAnimFrame != this._op.patch.getFrameNum()) {
        this.lastAnimFrame = this._op.patch.getFrameNum();

        let animval = this.anim.getValue(this._op.patch.timer.getTime());

        if (this.value != animval) {
          this.value = animval;
          this.#oldAnimVal = this.value;
          this.forceChange();
        }
      }

      return this.value;
    }

    setRef(v) {
      this.forceRefChange = true;
      this.set(v);
    }

    /**
     * @function setValue
     * @memberof Port
     * @instance
     * @description set value of port / will send value to all linked ports (only for output ports)
     */
    set(v) {
      this.setValue(v);
    }

    setValue(v) {
      if (v === undefined) v = null;

      if (CABLES.UI && CABLES.UI.showDevInfos)
        if (
          this.direction == CONSTANTS.PORT.PORT_DIR_OUT &&
          this.type == Port.TYPE_OBJECT &&
          v &&
          !this.forceRefChange
        )
          this._log.warn(
            "object port [" + this.name + "] uses .set [" + this.op.objName + "]",
          );

      if (this._op.enabled && !this.crashed) {
        if (
          v !== this.value ||
          this.changeAlways ||
          this.type == Port.TYPE_TEXTURE ||
          this.type == Port.TYPE_ARRAY
        ) {
          if (this.#animated) {
            this.anim.setValue(this._op.patch.timer.getTime(), v);
          } else {
            try {
              this.value = v;
              this.forceChange();
            } catch (ex) {
              this.crashed = true;

              this.setValue = function (_v) {};
              this.onTriggered = function (a) {};

              this._log.error("exception in ", this._op);
              this._log.error(ex);

              this._op.patch.emitEvent("exception", ex, this._op);
            }

            if (
              this._op &&
              this._op.patch &&
              this._op.patch.isEditorMode() &&
              this.type == Port.TYPE_TEXTURE
            )
              gui.texturePreview().updateTexturePort(this);
          }

          if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT)
            for (let i = 0; i < this.links.length; ++i) this.links[i].setValue();
        }
      }
    }

    updateAnim() {
      if (this.#animated) {
        this.value = this.get();

        if (this.#oldAnimVal != this.value || this.changeAlways) {
          this.#oldAnimVal = this.value;
          this.forceChange();
        }
        this.#oldAnimVal = this.value;
      }
    }

    forceChange() {
      if (this.onValueChanged || this.onChange) ;
      this._activity();
      this.emitEvent("change", this.value, this);

      if (this.onChange) this.onChange(this, this.value);
      else if (this.onValueChanged) this.onValueChanged(this, this.value); // deprecated
    }

    /**
     * @function getTypeString
     * @memberof Port
     * @instance
     * @description get port type as string, e.g. "Function","Value"...
     * @return {String} type
     */
    getTypeString() {
      if (this.type == Port.TYPE_VALUE) return "Number";
      if (this.type == Port.TYPE_FUNCTION) return "Trigger";
      if (this.type == Port.TYPE_OBJECT) return "Object";
      if (this.type == Port.TYPE_DYNAMIC) return "Dynamic";
      if (this.type == Port.TYPE_ARRAY) return "Array";
      if (this.type == Port.TYPE_STRING) return "String";
      return "Unknown";
    }

    /**
     * @param {Object} objPort
     */
    deSerializeSettings(objPort) {
      if (!objPort) return;
      if (objPort.animated) this.setAnimated(objPort.animated);
      if (objPort.useVariable) this.setVariableName(objPort.useVariable);
      if (objPort.title) this.setUiAttribs({ title: objPort.title });
      if (objPort.expose) this.setUiAttribs({ expose: true });
      if (objPort.order) this.setUiAttribs({ order: objPort.order });

      if (objPort.multiPortManual)
        this.setUiAttribs({ multiPortManual: objPort.multiPortManual });
      if (objPort.multiPortNum)
        this.setUiAttribs({ multiPortNum: objPort.multiPortNum });

      if (objPort.anim) {
        if (!this.anim) this.anim = new Anim({ name: "port " + this.name });
        this._op.hasAnimPort = true;
        this.anim.on("onChange", () => {
          this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
        });
        this.anim.deserialize(objPort.anim);
        this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);

        this.anim.sortKeys();
      }
    }

    /**
     * @param {any} v
     */
    setInitialValue(v) {
      if (this.op.preservedPortLinks[this.name]) {
        for (let i = 0; i < this.op.preservedPortLinks[this.name].length; i++) {
          const lobj = this.op.preservedPortLinks[this.name][i];
          this.op.patch._addLink(
            lobj.objIn,
            lobj.objOut,
            lobj.portIn,
            lobj.portOut,
          );
        }
      }

      if (
        this.op.preservedPortValues &&
        this.op.preservedPortValues.hasOwnProperty(this.name) &&
        this.op.preservedPortValues[this.name] !== undefined
      ) {
        this.set(this.op.preservedPortValues[this.name]);
      } else if (v !== undefined) this.set(v);
      if (v !== undefined) this.defaultValue = v;
    }

    getSerialized() {
      let obj = { name: this.getName() };

      if (!this.ignoreValueSerialize && this.links.length === 0) {
        if (this.type == Port.TYPE_OBJECT && this.value && this.value.tex) ; else obj.value = this.value;
      }
      if (this.#useVariableName) obj.useVariable = this.#useVariableName;
      if (this.#animated) obj.animated = true;
      if (this.anim) obj.anim = this.anim.getSerialized();
      if (this.uiAttribs.multiPortNum)
        obj.multiPortNum = this.uiAttribs.multiPortNum;
      if (this.uiAttribs.multiPortManual)
        obj.multiPortManual = this.uiAttribs.multiPortManual;

      if (this.uiAttribs.display == "file") obj.display = this.uiAttribs.display;
      if (this.uiAttribs.expose) {
        obj.expose = true;
        if (this.uiAttribs.hasOwnProperty("order"))
          obj.order = this.uiAttribs.order;
      }
      if (this.uiAttribs.title) obj.title = this.uiAttribs.title;
      if (
        (this.preserveLinks || this.direction == CONSTANTS.PORT.PORT_DIR_OUT) &&
        this.links.length > 0
      ) {
        obj.links = [];
        for (const i in this.links) {
          if (
            !this.links[i].ignoreInSerialize &&
            this.links[i].portIn &&
            this.links[i].portOut
          )
            obj.links.push(this.links[i].getSerialized());
        }
      }

      if (this.direction == Port.DIR_IN && this.links.length > 0) {
        for (const i in this.links) {
          if (!this.links[i].portIn || !this.links[i].portOut) continue;

          const otherp = this.links[i].getOtherPort(this);
          // check if functions exist, are defined in core_extend_ops code in ui
          if (otherp.op.isInBlueprint2 && this.op.isInBlueprint2) {
            if (otherp.op.isInBlueprint2() && !this.op.isInBlueprint2()) {
              obj.links = obj.links || [];
              obj.links.push(this.links[i].getSerialized());
            }
          }
        }
      }

      if (obj.links && obj.links.length == 0) delete obj.links;
      if (this.type === Port.TYPE_FUNCTION) delete obj.value;
      if (this.type === Port.TYPE_FUNCTION && this.links.length == 0) obj = null;
      if (obj && Object.keys(obj).length == 1 && obj.name) obj = null; // obj is null if there is no real information other than name

      cleanJson(obj);

      return obj;
    }

    /**
     * will be overwritten in ui
     * @param {Port} port1
     * @param {Port} port2
     * @returns {boolean}
     */
    shouldLink(port1, port2) {
      return !!(port1 && port2);
    }

    /**
     * @function removeLinks
     * @memberof Port
     * @instance
     * @description remove all links from port
     */
    removeLinks() {
      let count = 0;
      while (this.links.length > 0) {
        count++;
        if (count > 5000) {
          this._log.warn("could not delete links... / infinite loop");
          this.links.length = 0;
          break;
        }
        this.links[0].remove();
      }
    }

    /**
     * @function removeLink
     * @memberof Port
     * @instance
     * @description remove all link from port
     * @param {Link} link
     */
    removeLink(link) {
      for (let i = 0; i < this.links.length; i++)
        if (this.links[i] == link) this.links.splice(i, 1);

      if (this.direction == Port.DIR_IN) {
        if (this.type == Port.TYPE_VALUE)
          this.setValue(this.#valueBeforeLink || 0);
        else this.setValue(this.#valueBeforeLink || null);
      }

      if (CABLES.UI && this._op.checkLinkTimeWarnings)
        this._op.checkLinkTimeWarnings();

      try {
        if (this.onLinkChanged) this.onLinkChanged();
        this.emitEvent("onLinkChanged");
        this.emitEvent("onLinkRemoved");
        this._op.emitEvent("onLinkChanged");
      } catch (e) {
        this._log.error(e);
      }
    }

    /**
     * @function getName
     * @memberof Port
     * @instance
     * @description return port name
     */
    getName() {
      return this.name;
    }

    /**
     * @function getTitle
     * @memberof Port
     * @instance
     * @description return port name or title
     */
    getTitle() {
      if (this.uiAttribs.title) return this.uiAttribs.title;
      return this.name;
    }

    /**
     * @param {Link} l
     */
    addLink(l) {
      this.#valueBeforeLink = this.value;
      this.links.push(l);
      if (CABLES.UI && this._op.checkLinkTimeWarnings)
        this._op.checkLinkTimeWarnings();

      try {
        if (this.onLinkChanged) this.onLinkChanged();
        this.emitEvent("onLinkChanged");
        this._op.emitEvent("onLinkChanged");
      } catch (e) {
        this._log.error(e);
      }
    }

    /**
     * @function getLinkTo
     * @memberof Port
     * @instance
     * @param {Port} p2 otherPort
     * @description return link, which is linked to otherPort
     */
    getLinkTo(p2) {
      for (const i in this.links)
        if (this.links[i].portIn == p2 || this.links[i].portOut == p2)
          return this.links[i];
    }

    /**
     * @function removeLinkTo
     * @memberof Port
     * @instance
     * @param {Port} p2 otherPort
     * @description removes link, which is linked to otherPort
     */
    removeLinkTo(p2) {
      for (const i in this.links) {
        if (this.links[i].portIn == p2 || this.links[i].portOut == p2) {
          this.links[i].remove();
          if (CABLES.UI && this._op.checkLinkTimeWarnings)
            this._op.checkLinkTimeWarnings();

          if (this.onLinkChanged) this.onLinkChanged();
          this.emitEvent("onLinkChanged");
          this.emitEvent("onLinkRemoved");
          return;
        }
      }
    }

    /**
     * @function isLinkedTo
     * @memberof Port
     * @instance
     * @param {Port} p2 otherPort
     * @description returns true if port is linked to otherPort
     */
    isLinkedTo(p2) {
      for (const i in this.links)
        if (this.links[i].portIn == p2 || this.links[i].portOut == p2)
          return true;

      return false;
    }

    _activity() {
      this.activityCounter++;
    }

    /**
     * @function trigger
     * @memberof Port
     * @instance
     * @description trigger the linked port (usually invoked on an output function port)
     */
    trigger() {
      const linksLength = this.links.length;

      this._activity();
      if (linksLength === 0) return;
      if (!this._op.enabled) return;

      let portTriggered = null;
      try {
        for (let i = 0; i < linksLength; ++i) {
          if (this.links[i].portIn) {
            portTriggered = this.links[i].portIn;

            portTriggered.op.patch.pushTriggerStack(portTriggered);
            if (!portTriggered._onTriggered) {
              console.log(portTriggered, portTriggered._onTriggered);
            }
            portTriggered._onTriggered(null);

            portTriggered.op.patch.popTriggerStack();
          }
          if (this.links[i]) this.links[i].activity();
        }
      } catch (ex) {
        portTriggered.op.enabled = false;

        if (this._op.patch.isEditorMode()) {
          if (portTriggered.op.onError) portTriggered.op.onError(ex);
        }
        this._log.error(
          "exception in port: ",
          portTriggered.name,
          portTriggered.op.name,
          portTriggered.op.id,
        );
        this._log.error(ex);
      }
    }

    call() {
      this._log.warn("call deprecated - use trigger() ");
      this.trigger();
    }

    execute() {}

    /**
     * @param {string} n
     */
    setVariableName(n) {
      this.#useVariableName = n;

      this._op.patch.on("variableRename", (oldname, newname) => {
        if (oldname != this.#useVariableName) return;
        this.#useVariableName = newname;
      });
    }

    getVariableName() {
      return this.#useVariableName;
    }

    /**
     * @param {String} v
     */
    setVariable(v) {
      this.setAnimated(false);
      const attr = { useVariable: false };

      if (this._variableIn && this._varChangeListenerId) {
        this._variableIn.off(this._varChangeListenerId);
        this._variableIn = null;
      }

      if (v) {
        this._variableIn = this._op.patch.getVar(v);

        if (!this._variableIn) ; else {
          if (this.type == Port.TYPE_OBJECT) {
            this._varChangeListenerId = this._variableIn.on("change", () => {
              this.set(null);
              this.set(this._variableIn.getValue());
            });
          } else {
            this._varChangeListenerId = this._variableIn.on(
              "change",
              this.set.bind(this),
            );
          }
          this.set(this._variableIn.getValue());
        }
        this.#useVariableName = v;
        attr.useVariable = true;
        attr.variableName = this.#useVariableName;
      } else {
        attr.variableName = this.#useVariableName = null;
        attr.useVariable = false;
      }

      this.setUiAttribs(attr);
      this._op.patch.emitEvent("portSetVariable", this._op, this, v);
    }

    /**
     * @param {boolean} a
     */
    _handleNoTriggerOpAnimUpdates(a) {
      // for (let i = 0; i < this._op.portsIn.length; i++)
      // {
      //     if (this._op.portsIn[i].type == Port.TYPE_FUNCTION)
      //     {
      //         hasTriggerPort = true;
      //         break;
      //     }
      // }

      {
        if (a)
          this._notriggerAnimUpdate = this._op.patch.on("onRenderFrame", () => {
            this.updateAnim();
          });
        else if (this._notriggerAnimUpdate)
          this._notriggerAnimUpdate = this._op.patch.off(
            this._notriggerAnimUpdate,
          );
      }
    }

    /**
     * @param {boolean} a
     */
    setAnimated(a) {
      if (this.#animated != a) {
        this.#animated = a;
        this._op.hasAnimPort = true;

        if (this.#animated && !this.anim) {
          this.anim = new Anim({ name: "port " + this.name });
          this.anim.on("onChange", () => {
            this._op.patch.emitEvent(
              "portAnimUpdated",
              this._op,
              this,
              this.anim,
            );
          });
        }
        this._onAnimToggle();
      }

      this._handleNoTriggerOpAnimUpdates(a);
      if (!a) {
        this.anim = null;
      }

      this._op.patch.emitEvent("portAnimToggle", this._op, this, this.anim);

      this.setUiAttribs({ isAnimated: this.#animated });
    }

    toggleAnim() {
      this.#animated = !this.#animated;
      if (this.#animated && !this.anim) {
        this.anim = new Anim({ name: "port " + this.name });
        this.anim.on("onChange", () => {
          this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
        });
      }
      this.setAnimated(this.#animated);
      this._onAnimToggle();
      this.setUiAttribs({ isAnimated: this.#animated });
      this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
    }

    /**
     * <pre>
     * CABLES.Port.TYPE_VALUE = 0;
     * CABLES.Port.TYPE_FUNCTION = 1;
     * CABLES.Port.TYPE_OBJECT = 2;
     * CABLES.Port.TYPE_TEXTURE = 2;
     * CABLES.Port.TYPE_ARRAY = 3;
     * CABLES.Port.TYPE_DYNAMIC = 4;
     * CABLES.Port.TYPE_STRING = 5;
     * </pre>
     * @function getType
     * @memberof Port
     * @instance
     * @return {Number} type of port
     */
    getType() {
      return this.type;
    }

    /**
     * @function isLinked
     * @memberof Port
     * @instance
     * @return {Boolean} true if port is linked
     */
    isLinked() {
      return (
        this.links.length > 0 || this.#animated || this.#useVariableName != null
      );
    }

    isBoundToVar() {
      const b = this.#useVariableName != null;
      this.uiAttribs.boundToVar = b;
      return b;
    }

    /**
     * @return {Boolean} true if port is animated
     */
    isAnimated() {
      return this.#animated;
    }

    /**
     * @function isHidden
     * @memberof Port
     * @instance
     * @return {Boolean} true if port is hidden
     */
    isHidden() {
      return this.uiAttribs.hidePort;
    }

    /**
     * @function onTriggered
     * @memberof Port
     * @instance
     * @param {function} a onTriggeredCallback
     * @description set callback, which will be executed when port was triggered (usually output port)
     */
    _onTriggered(a) {
      this._activity();
      this._op.updateAnims();
      if (this._op.enabled && this.onTriggered) this.onTriggered(a);

      if (this._op.enabled) this.emitEvent("trigger");
    }

    /**
     * @param {any} v
     */
    _onSetProfiling(
      v, // used in editor: profiler tab
    ) {
      this._op.patch.profiler.add("port", this);
      this.setValue(v);
      this._op.patch.profiler.add("port", null);
    }

    _onTriggeredProfiling() {
      // used in editor: profiler tab
      if (this._op.enabled && this.onTriggered) {
        this._op.patch.profiler.add("port", this);
        this.onTriggered();
        this._op.patch.profiler.add("port", null);
      }
    }

    /**
     * @deprecated
     * @param {function} cb
     */
    onValueChange(cb) {
      this.onChange = cb;
    }

    /**
     * @deprecated
     */
    hidePort() {}
  }

  /**
   * Returns the port type string, e.g. "value" based on the port type number
   * @function portTypeNumberToString
   * @instance
   * @memberof Port
   * @param {Number} type - The port type number
   * @returns {String} - The port type as string
   */
  Port.portTypeNumberToString = function (type) {
    if (type == Port.TYPE_VALUE) return "value";
    if (type == Port.TYPE_FUNCTION) return "function";
    if (type == Port.TYPE_OBJECT) return "object";
    if (type == Port.TYPE_ARRAY) return "array";
    if (type == Port.TYPE_STRING) return "string";
    if (type == Port.TYPE_DYNAMIC) return "dynamic";
    return "unknown";
  };

  class SwitchPort extends Port {
    constructor(__parent, name, type, uiAttribs, indexPort) {
      super(__parent, name, type, uiAttribs);

      this.get = () => {
        let s = super.get();

        if (CABLES.UI) {
          if (
            s === "" ||
            s === null ||
            s === undefined ||
            (uiAttribs.values && uiAttribs.values.indexOf(String(s)) === -1)
          ) {
            this.op.setUiError(
              "invalidswitch",
              "Invalid Value [" + this.name + ']: "' + s + '"',
              1,
            );
          } else this.op.setUiError("invalidswitch", null);
        }

        if (s === null || s === undefined) s = "";

        return s;
      };

      this.indexPort = indexPort;
      this.indexPort.set = (value) => {
        const values = uiAttribs.values;

        if (!values) {
          // console.log("switch port has no values", this);
          return;
        }

        let intValue = Math.floor(value);

        intValue = Math.min(intValue, values.length - 1);
        intValue = Math.max(intValue, 0);

        this.indexPort.setValue(intValue);
        this.set(values[intValue]);

        if (
          this.op.patch.isEditorMode() &&
          performance.now() - (this.lastTime || 0) > 100 &&
          window.gui &&
          gui.patchView.isCurrentOp(this.op)
        ) {
          gui.opParams.show(this.op);
          this.lastTime = performance.now();
        }
      };
    }

    setUiAttribs(attribs) {
      const hidePort = attribs.hidePort;
      attribs.hidePort = true;
      super.setUiAttribs(attribs);
      if (typeof hidePort !== "undefined") {
        this.indexPort.setUiAttribs({ hidePort });
      }
    }
  }

  class ValueSelectPort extends SwitchPort {
    setUiAttribs(newAttribs) {
      // never unhide valuePort when indexPort is linked
      if (this.indexPort.isLinked()) {
        for (const p in newAttribs) {
          if (p == "greyout" && !newAttribs[p]) newAttribs[p] = "true";
        }
      }
      super.setUiAttribs(newAttribs);
    }
  }

  const MIN_NUM_PORTS = 2;

  class MultiPort extends Port {
    constructor(__parent, name, type, dir, uiAttribs, uiAttribsPorts) {
      super(__parent, name, Port.TYPE_ARRAY, uiAttribs);

      this.setUiAttribs({ multiPort: true, group: this.name, order: -1 });
      this.ports = [];
      this.direction = dir;
      this._uiAttribsPorts = uiAttribsPorts;

      const updateArray = () => {
        const arr = [];

        let ll = 1;
        if (this.uiAttribs.multiPortManual) ll = 0;

        for (let i = 0; i < this.ports.length - ll; i++) arr[i] = this.ports[i];

        this.setRef(arr);
      };

      const updateUi = () => {
        let grey = !this.uiAttribs.multiPortManual || false;

        if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT) grey = false;

        for (let i = 0; i < this.ports.length; i++) {
          let lp; // undefined to remove/not set it
          // let opacity;// undefined to remove/not set it
          // let grey;// undefined to remove/not set it
          let addPort = false;
          let title;
          let o = {};

          // console.log("this.op.preservedPortTitles", this.op.preservedPortTitles, this.op.preservedPortTitles[po.name], po.name);
          if (
            this.op.preservedPortTitles &&
            this.op.preservedPortTitles[this.ports[i].name]
          )
            title = this.op.preservedPortTitles[this.ports[i].name];

          // if (!this.uiAttribs.multiPortManual)grey = true;
          if (i == 0) lp = this.ports.length;

          if (!this.uiAttribs.multiPortManual)
            if (i == this.ports.length - 1) {
              title = "add port";
              addPort = true;
              grey = true;
            }

          for (const attin in this._uiAttribsPorts) {
            o[attin] = this._uiAttribsPorts[attin];
          }

          o.addPort = addPort;
          o.longPort = lp;
          o.title = title;
          o.greyout = grey;
          o.group = this.name;

          this.ports[i].setUiAttribs(o);
        }
      };

      this.removeInvalidPorts = () => {
        for (let i = 0; i < this.ports.length; i++) {
          if (!this.ports[i]) this.ports.splice(i, 1);
        }

        if (!this.uiAttribs.multiPortManual) {
          if (this.ports.length > MIN_NUM_PORTS)
            for (let i = this.ports.length - 1; i > 1; i--) {
              if (!this.ports[i].isLinked()) this.uiAttribs.multiPortNum = i;
              else break;
            }
        }

        updateArray();
      };

      this.countPorts = () => {
        if (
          CABLES.UI &&
          !gui.isRemoteClient &&
          gui.patchView &&
          gui.patchView.patchRenderer &&
          gui.patchView.patchRenderer.isDraggingPort()
        ) {
          clearTimeout(this.retryTo);
          this.retryTo = setTimeout(this.countPorts.bind(this));
          return;
        }
        this.retryTo = null;

        let redo = false;
        this.removeListeners();
        this.removeInvalidPorts();

        for (let i = 0; i < this.ports.length; i++) {
          if (this.ports[i] && this.ports[i].links.length > 1) {
            const po = this.ports[i + 1];
            const otherPort = this.ports[i].links[0].getOtherPort(this.ports[i]);

            if (!po || !otherPort) {
              this._log.warn("no port found?");
            } else {
              this.ports[i].links[0].remove();
              this.op.patch.link(this.op, po.name, otherPort.op, otherPort.name);
              redo = true;
            }
            break;
          }
        }

        if (!this.uiAttribs.multiPortManual) {
          let foundHole = true;
          while (foundHole) {
            // console.log("search holes...");
            foundHole = false;

            for (let i = this.ports.length - 1; i > 1; i--) {
              if (
                this.ports[i] &&
                this.ports[i].links.length > 0 &&
                this.ports[i - 1].links.length == 0
              ) {
                // console.log("found hole!");

                // found hole
                const otherPort = this.ports[i].links[0].getOtherPort(
                  this.ports[i],
                );
                this.ports[i].links[0].remove();

                const po = this.ports[i - 1];

                if (po && this.ports[i]) {
                  // console.log("move ", this.ports[i].name, "to", po.name);
                  this.op.patch.link(
                    this.op,
                    po.name,
                    otherPort.op,
                    otherPort.name,
                  );
                  foundHole = true;
                  redo = true;
                  break;
                }
              }
            }

            // this.checkNum();
          }

          // this.removeInvalidPorts();
        }

        if (!this.uiAttribs.multiPortManual) {
          // if auto
          while (
            this.ports.length > MIN_NUM_PORTS &&
            !this.ports[this.ports.length - 1].isLinked() &&
            !this.ports[this.ports.length - 2].isLinked()
          ) {
            let i = this.ports.length - 1;
            if (
              !this.ports[i].isLinked() &&
              this.ports[i - 1] &&
              !this.ports[i - 1].isLinked()
            ) {
              this.ports[i].setUiAttribs({ removed: true });
              this.ports[i].remove();
              // this.ports[i] = null;
              this.ports.splice(i, 1);
            }
          }
        }

        this.removeInvalidPorts();

        if (
          !this.uiAttribs.multiPortManual &&
          this.ports.length > 0 &&
          this.ports[this.ports.length - 1].isLinked()
        )
          this.newPort();

        updateArray();
        updateUi();

        if (redo) this.countPorts();
        else this.addListeners();
      };

      this.removeListeners = () => {
        for (let i = 0; i < this.ports.length; i++) {
          const po = this.ports[i];
          if (po.multiPortChangeListener)
            po.multiPortChangeListener = po.off(po.multiPortChangeListener);
          if (po.multiLinkChangeListener)
            po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
        }
      };

      this.addListeners = () => {
        for (let i = 0; i < this.ports.length; i++) {
          const po = this.ports[i];
          const idx = i;

          if (po.multiPortChangeListener)
            po.multiPortChangeListener = po.off(po.multiPortChangeListener);
          po.multiPortChangeListener = po.on("change", updateArray.bind(this));

          if (po.multiPortTriggerListener)
            po.multiPortTriggerListener = po.off(po.multiPortTriggerListener);
          po.multiPortTriggerListener = po.on("trigger", () => {
            this._onTriggered(idx);
          });

          if (po.multiLinkChangeListener)
            po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
          po.multiLinkChangeListener = po.on("onLinkChanged", () => {
            this.countPorts();
            this.emitEvent("onLinkChanged");
          });

          if (po.multiLinkRemoveListener)
            po.multiLinkRemoveListener = po.off(po.multiLinkRemoveListener);
          po.multiLinkRemoveListener = po.on("onLinkRemoved", () => {
            // this.removeInvalidPorts();
            // this.checkNum();
            // this.countPorts();
            updateUi();
            this.emitEvent("onLinkChanged");
            // this.countPorts.bind(this);
          });
        }
      };

      this.newPort = () => {
        const attrs = {};
        // if (type == CABLES.OP_PORT_TYPE_STRING) attrs.type = "string";
        attrs.type = type;
        const po = new Port(this.op, name + "_" + this.ports.length, type, attrs);

        po.direction = dir;
        this.ports.push(po);
        // console.log("CONSTANTS.PORT_DIR_OUT", CONSTANTS.PORT.PORT_DIR_OUT, this.direction);
        if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT) this.op.addOutPort(po);
        else this.op.addInPort(po);

        if (type == Port.TYPE_NUMBER) po.setInitialValue(0);
        else if (type == Port.TYPE_STRING) po.setInitialValue("");

        this.addListeners();

        updateUi();
        updateArray();
        this.emitEvent("onLinkChanged");
        // console.log("this.op.preservedPortTitles", this.op.preservedPortTitles, this.op.preservedPortTitles[po.name], po.name);
        if (this.op.preservedPortTitles && this.op.preservedPortTitles[po.name])
          po.setUiAttribs({ title: this.op.preservedPortTitles[po.name] });

        return po;
      };

      this.initPorts = () => {
        for (let i = 0; i < MIN_NUM_PORTS; i++) this.newPort();
        updateArray();
        updateUi();
      };

      this.checkNum = () => {
        this.uiAttribs.multiPortNum = Math.max(
          MIN_NUM_PORTS,
          this.uiAttribs.multiPortNum,
        );

        while (this.ports.length < this.uiAttribs.multiPortNum) this.newPort();
        while (this.ports.length > this.uiAttribs.multiPortNum)
          if (this.ports[this.ports.length - 1]) this.ports.pop().remove();

        this.removeInvalidPorts();
      };

      this.incDec = (incDir) => {
        this.uiAttribs.multiPortNum =
          this.uiAttribs.multiPortNum || MIN_NUM_PORTS;
        // console.log("this.uiAttribs.multiPortNum", this.uiAttribs.multiPortNum, this.uiAttribs.multiPortNum + incDir);
        this.setUiAttribs({ multiPortNum: this.uiAttribs.multiPortNum + incDir });
        this.checkNum();

        updateUi();
      };

      this.toggleManual = () => {
        this.setUiAttribs({ multiPortManual: !this.uiAttribs.multiPortManual });
        this.op.refreshParams();
      };

      this.on("onUiAttrChange", (attribs) => {
        if (attribs.hasOwnProperty("multiPortManual")) {
          updateUi();
          this.removeInvalidPorts();
          this.checkNum();
          this.countPorts();
          updateUi();
        }
      });

      this.on("onUiAttrChange", this.checkNum.bind(this));
      this.checkNum();
      this.countPorts();
      this.removeInvalidPorts();
      updateUi();
    }
  }

  /**
   * @typedef Translation
   * @property {number} [x]
   * @property {number} [y]
   */

  /**
   * configuration object for loading a patch
   * @typedef OpUiAttribs
   * @property {string} [title] overwrite op title
   * @property {string} [hidePort] hidePort
   * @property {string} [title] overwrite op title
   * @property {String} [title=''] overwrite title of port (by default this is portname)
   * @property {string} [extendTitle] extended op title, shown in grey next to op name
   * @property {object} [storage] internal - do not use manualy
   * @property {boolean} [working] internal - do not use manualy
   * @property {boolean} [bookmarked] internal - do not use manualy
   * @property {boolean} [selected] internal - do not use manualy
   * @property {boolean} [disabled] internal - do not use manualy
   * @property {boolean} [loading] internal - do not use manualy
   * @property {object} [uierrors] internal - do not use manualy - use op.setUiError
   * @property {string} [color]
   * @property {object} [area]
   * @property {string} [comment]
   * @property {number} [height]
   * @property {number} [width]
   * @property {Translation} [translate]
   * @property {string} [subPatch] internal - do not use manualy - use op.setUiError
   */

  /**
   * @typedef CorePatch
   * @type Patch
   */

  /**
   * @template {CorePatch} Patch
   */
  class Op extends Events {
    static OP_VERSION_PREFIX = "_v";

    #objName = "";
    _log = new Logger("core_op");
    //    #name = "";
    #shortOpName = "";

    opId = ""; // unique op id

    /** @type {Array<Port>} */
    portsOut = [];

    /** @type {Patch} */
    patch = null;

    data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops
    storage = {}; // op-specific data to be included in export

    /** @type {Array<Port>} */
    portsIn = [];
    portsInData = []; // original loaded patch data

    /** @type {OpUiAttribs} */
    uiAttribs = {};
    enabled = true;

    onAnimFrame = null;

    preservedPortTitles = {};
    preservedPortValues = {};
    preservedPortLinks = {};

    linkTimeRules = {
      needsLinkedToWork: [],
      needsStringToWork: [],
      needsParentOp: null,
    };

    shouldWork = {};
    hasUiErrors = 0;

    /** @type {Object} */
    uiErrors = {};
    hasAnimPort = false;

    /** @type {Port} */
    patchId = null; // will be defined by subpatchops

    /**
     * @param {Patch} _patch
     * @param {String} _objName
     * @param {String} _id=null
     */
    constructor(_patch, _objName, _id = null) {
      super();

      // this.#name = _objName;
      this.opId = _id;
      this.#objName = _objName;
      this.patch = _patch;

      this.#shortOpName = CABLES.getShortOpName(_objName);
      this.getTitle();

      this.id = _id || shortId(); // instance id
      this.onAddPort = null;
      this.onCreate = null;
      this.onResize = null;
      this.onLoaded = null;
      this.onDelete = null;
      this.onError = null;

      this._instances = null;

      /**
       * overwrite this to prerender shader and meshes / will be called by op `loadingStatus`
       */
      this.preRender = null;

      /**
       * overwrite this to initialize your op
       */
      this.init = null;

      /**
       * Implement to render 2d canvas based graphics from in an op - optionaly defined in op instance
       * @param {CanvasRenderingContext2D} context of canvas 2d
       * @param {Object} layer info
       * @param {number} layer.x x position on canvas
       * @param {number} layer.y y position on canvas
       * @param {number} layer.width width of canvas
       * @param {number} layer.height height of canvas
       * @param {number} layer.scale current scaling of patchfield view
       */
      this.renderVizLayer = null;
      this.checkLinkTimeWarnings = null;
    }

    isInBlueprint2() {
      // will be overwritten in ui
      return false;
    }

    get name() {
      return this.getTitle();
    }

    set name(n) {
      this.setTitle(n);
    }

    /**
     * @param {string} on
     */
    set _objName(on) {
      this.#objName = on;
      this._log = new Logger("op " + on);
    }

    get objName() {
      return this.#objName;
    }

    get shortName() {
      return this.#shortOpName;
    }

    /**
     * op.require
     *
     * @param {String} _name - module name
     * @returns {Object}
     */
    require(_name) {
      if (
        CABLES.platform &&
        CABLES.StandaloneElectron &&
        !CABLES.platform.frontendOptions.isElectron
      )
        this.setUiError(
          "notstandalone",
          "This op will only work in cables standalone version",
          3,
        );

      return null;
    }

    checkMainloopExists() {
      if (!CABLES.UI) return;
      if (!this.patch.tempData.mainloopOp)
        this.setUiError(
          "nomainloop",
          "patch should have a mainloop to use this op",
        );
      else this.setUiError("nomainloop", null);
    }

    /** @returns {string} */
    getTitle() {
      if (!this.uiAttribs) return "nouiattribs" + this.shortName;

      /*
       * if ((this.uiAttribs.title === undefined || this.uiAttribs.title === "") && this.objName.indexOf("Ops.Ui.") == -1)
       *     this.uiAttribs.title = this._shortOpName;
       */

      return this.uiAttribs.title || this.#shortOpName;
    }

    /**
     * @param {string} title
     */
    setTitle(title) {
      /*
       * this._log.log("settitle", title);
       * this._log.log(
       *     (new Error()).stack
       * );
       */

      if (title != this.getTitle()) this._setUiAttrib({ title: title });
    }

    /**
     * @param {Object} newAttribs
     */
    setStorage(newAttribs) {
      if (!newAttribs) return;
      this.storage = this.storage || {};

      let changed = false;
      for (const p in newAttribs) {
        if (this.storage[p] != newAttribs[p]) changed = true;
        this.storage[p] = newAttribs[p];
      }

      if (changed) this.emitEvent("onStorageChange", newAttribs);
    }

    isSubPatchOp() {
      if (this.patchId && this.storage)
        return this.storage.subPatchVer || this.storage.blueprintVer || 0;
      return false;
    }

    /**
       * setUiAttrib
       * possible values:
       * <pre>
       * warning - warning message - showing up in op parameter panel
       * error - error message - showing up in op parameter panel
       * extendTitle - op title extension, e.g. [ + ]
       * </pre>
       // * @param {OpUiAttribs} newAttribs, e.g. {"attrib":value}
       * @example
       * op.setUiAttrib({"extendTitle":str});
       */
    setUiAttrib(newAttribs) {
      this._setUiAttrib(newAttribs);
    }

    /**
     * @deprecated
     * @param {OpUiAttribs} a
     */
    setUiAttribs(a) {
      this._setUiAttrib(a);
    }

    /**
     * @deprecated
     * @param {OpUiAttribs} a
     */
    uiAttr(a) {
      this._setUiAttrib(a);
    }

    /**
     * @param {OpUiAttribs} newAttribs
     */
    _setUiAttrib(newAttribs) {
      if (!newAttribs) return;

      if (typeof newAttribs != "object")
        this._log.error("op.uiAttrib attribs are not of type object");
      if (!this.uiAttribs) this.uiAttribs = {};

      let changed = false;
      let emitMove = false;
      if (
        CABLES.UI &&
        newAttribs.hasOwnProperty("translate") &&
        (!this.uiAttribs.translate ||
          this.uiAttribs.translate.x != newAttribs.translate.x ||
          this.uiAttribs.translate.y != newAttribs.translate.y)
      )
        emitMove = true;

      if (
        newAttribs.hasOwnProperty("title") &&
        newAttribs.title != this.uiAttribs.title
      ) {
        // const doEmitEvent = newAttribs.title != this.getTitle();
        this.uiAttribs.title = newAttribs.title;
        // if (doEmitEvent) this.emitEvent("onTitleChange", newAttribs.title);
        changed = true;
        // this.setTitle(newAttribs.title);
      }

      if (newAttribs.hasOwnProperty("disabled"))
        this.setEnabled(!newAttribs.disabled);

      for (const p in newAttribs) {
        if (this.uiAttribs[p] != newAttribs[p]) changed = true;
        this.uiAttribs[p] = newAttribs[p];
      }

      if (
        this.uiAttribs.hasOwnProperty("selected") &&
        this.uiAttribs.selected == false
      )
        delete this.uiAttribs.selected;

      if (changed) {
        this.emitEvent("onUiAttribsChange", newAttribs);
        this.patch.emitEvent("onUiAttribsChange", this, newAttribs);
      }

      if (emitMove) this.emitEvent("move");
    }

    getName() {
      // if (this.uiAttribs.name)
      // {
      //     console.log("uiattr name exist!");// otherwise delete
      //     return this.uiAttribs.name;
      // }
      return this.#shortOpName;
    }

    /**
     * @param {Port} p
     */
    addOutPort(p) {
      p.direction = CONSTANTS.PORT.PORT_DIR_OUT;
      p._op = this;
      this.portsOut.push(p);
      this.emitEvent("onPortAdd", p);
      return p;
    }

    hasDynamicPort() {
      let i = 0;
      for (i = 0; i < this.portsIn.length; i++) {
        if (this.portsIn[i].type == Port.TYPE_DYNAMIC) return true;
        if (this.portsIn[i].getName() == "dyn") return true;
      }
      for (i = 0; i < this.portsOut.length; i++) {
        if (this.portsOut[i].type == Port.TYPE_DYNAMIC) return true;
        if (this.portsOut[i].getName() == "dyn") return true;
      }

      return false;
    }

    /**
     * @param {any|Port | MultiPort} p
     */
    addInPort(p) {
      // if (!(p instanceof Port)) throw new Error("parameter is not a port!", p);
      // if (!(p instanceof Port) && !(p instanceof MultiPort)) throw new Error("parameter is not a port!", p);

      // console.log("a", p.constructor.name);

      p.direction = Port.DIR_IN;
      p._op = this;

      this.portsIn.push(p);
      this.emitEvent("onPortAdd", p);

      return p;
    }

    /**
     *
     * @param {string} name
     * @param {string} v
     */
    inFunction(name, v) {
      return this.inTrigger(name, v);
    }

    /**
     * create a trigger input port
     * @param {String} name
     * @param {String} v
     * @return {Port} created port
     *
     */
    inTrigger(name, v) {
      const p = this.addInPort(new Port(this, name, Port.TYPE_FUNCTION));
      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * create multiple UI trigger buttons
     * @param {String} name
     * @param {Array} v
     * @return {Port} created port
     */
    inTriggerButton(name, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_FUNCTION, {
          display: "button",
        }),
      );
      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * @param {string} name
     * @param {any} v
     */
    inUiTriggerButtons(name, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_FUNCTION, {
          display: "buttons",
        }),
      );
      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * @deprecated
     */
    inValueFloat(name, v) {
      return this.inFloat(name, v);
    }

    /**
     * @deprecated
     */
    inValue(name, v) {
      return this.inFloat(name, v);
    }

    /**
     * create a number value input port
     * @param {String} name
     * @param {Number} v
     * @return {Port} created port
     */
    inFloat(name, v) {
      const p = this.addInPort(new Port(this, name, Port.TYPE_VALUE));

      p.setInitialValue(v);

      return p;
    }

    /**
     * @deprecated
     */
    inValueBool(name, v) {
      return this.inBool(name, v);
    }

    /**
     * create a boolean input port, displayed as a checkbox
     * @param {String} name
     * @param {Boolean|number} v
     * @return {Port} created port
     */
    inBool(name, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_NUMBER, {
          display: "bool",
        }),
      );

      if (v === true) v = 1;
      if (v === false) v = 0;
      p.setInitialValue(v);

      return p;
    }

    /**
     * @param {string} name
     * @param {number} type
     */
    inMultiPort(name, type) {
      const p = new MultiPort(this, name, type, Port.DIR_IN, {
        addPort: true,
        hidePort: true,
      });
      p.ignoreValueSerialize = true;

      this.addInPort(p);
      p.initPorts();

      return p;
    }

    /**
     * @param {string} name
     * @param {number} type
     */
    outMultiPort(name, type, uiAttribsPort = {}) {
      const p = new MultiPort(
        this,
        name,
        type,
        CONSTANTS.PORT.PORT_DIR_OUT,
        {
          display: "multiport",
          hidePort: true,
        },
        uiAttribsPort,
      );
      p.ignoreValueSerialize = true;

      this.addOutPort(p);
      p.initPorts();

      return p;
    }

    /**
     * @param {string} name
     * @param {string} v
     */
    inValueString(name, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_VALUE, {
          type: "string",
        }),
      );
      p.value = "";

      p.setInitialValue(v);
      return p;
    }

    /**
     * create a String value input port
     * @param {String} name
     * @param {String} v default value
     * @return {Port} created port
     */
    inString(name, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_STRING, {
          type: "string",
        }),
      );
      v = v || "";
      // p.value = v;

      p.setInitialValue(v);
      return p;
    }

    // /**
    //  * create a String value input port displayed as TextArea
    //  * @memberof Op
    //  * @param {String} name
    //  * @param {String} v default value
    //  * @return {Port} created port
    //  */
    // inValueText(name, v)
    // {
    //     const p = this.addInPort(
    //         new Port(this, name, Port.TYPE_VALUE, {
    //             "type": "string",
    //             "display": "text"
    //         })
    //     );
    //     p.value = "";

    //     p.setInitialValue(v);

    //     /*
    //      * if (v !== undefined)
    //      * {
    //      *     p.set(v);
    //      *     p.defaultValue = v;
    //      * }
    //      */
    //     return p;
    // }

    /**
     * @param {string} name
     * @param {string} v
     */
    inTextarea(name, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_STRING, {
          type: "string",
          display: "text",
        }),
      );
      p.value = "";
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    }

    /**
     * create a String value input port displayed as editor
     * @param {String} name
     * @param {String} v default value
     * @param {String} syntax language
     * @param {Boolean} hideFormatButton
     * @return {Port} created port
     */
    inStringEditor(name, v, syntax, hideFormatButton = true) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_STRING, {
          type: "string",
          display: "editor",
          editShortcut: true,
          editorSyntax: syntax,
          hideFormatButton: hideFormatButton,
        }),
      );

      p.value = "";
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    }

    /**
     *
     * @param {string} name
     * @param {String} v
     * @param {String} syntax
     */
    inValueEditor(name, v, syntax, hideFormatButton = true) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_NUMBER, {
          type: "string",
          display: "editor",
          editorSyntax: syntax,
          hideFormatButton: hideFormatButton,
        }),
      );
      p.value = "";
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    }

    /**
     * @deprecated
     * @param {string} name
     * @param {any[]} values
     * @param {string} v
     * @param {boolean} noindex
     */
    inValueSelect(name, values, v, noindex) {
      return this.inDropDown(name, values, v, noindex);
    }

    /**
     * create a string select box
     * @param {String} name
     * @param {Array} values
     * @param {String} v default value
     * @return {Port} created port
     * @param {boolean} [noindex]
     */
    inDropDown(name, values, v, noindex) {
      let p = null;
      if (!noindex) {
        const indexPort = new Port(this, name + " index", Port.TYPE_NUMBER, {
          increment: "integer",
          hideParam: true,
        });
        const n = this.addInPort(indexPort);

        if (values)
          for (let i = 0; i < values.length; i++) values[i] = String(values[i]);

        const valuePort = new ValueSelectPort(
          this,
          name,
          Port.TYPE_NUMBER,
          {
            display: "dropdown",
            hidePort: true,
            type: "string",
            values: values,
          },
          n,
        );

        valuePort.indexPort = indexPort;

        valuePort.on(
          "change",
          (/** @type {any} */ val, /** @type {Port} */ thePort) => {
            if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values) {
              const idx = thePort.uiAttribs.values.indexOf(val);
              if (idx > -1) thePort.indexPort.set(idx);
            }
          },
        );

        indexPort.onLinkChanged = () => {
          valuePort.setUiAttribs({ greyout: indexPort.isLinked() });
        };

        p = this.addInPort(valuePort);

        if (v !== undefined) {
          p.set(v);
          const index = values.findIndex((item) => {
            return item == v;
          });
          n.setValue(index);
          p.defaultValue = v;
          n.defaultValue = index;
        }
      } else {
        const valuePort = new Port(this, name, Port.TYPE_VALUE, {
          display: "dropdown",
          hidePort: true,
          type: "string",
          values: values,
        });

        p = this.addInPort(valuePort);
      }

      return p;
    }

    /**
     * create a string switch box
     * @param {String} name
     * @param {Array} values
     * @param {String} v default value
     * @param {boolean} noindex
     * @return {Port} created port
     */
    inSwitch(name, values, v, noindex) {
      let p = null;
      if (!noindex) {
        if (!v) v = values[0];
        const indexPort = new Port(this, name + " index", Port.TYPE_VALUE, {
          increment: "integer",
          values: values,
          hideParam: true,
        });
        const n = this.addInPort(indexPort);

        if (values)
          for (let i = 0; i < values.length; i++) values[i] = String(values[i]);

        const switchPort = new SwitchPort(
          this,
          name,
          Port.TYPE_STRING,
          {
            display: "switch",
            hidePort: true,
            type: "string",
            values: values,
          },
          n,
        );

        switchPort.indexPort = indexPort;

        switchPort.on("change", (val, thePort) => {
          if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values) {
            const idx = thePort.uiAttribs.values.indexOf(val);
            if (idx > -1) thePort.indexPort.set(idx);
          }
        });

        indexPort.onLinkChanged = function () {
          switchPort.setUiAttribs({ greyout: indexPort.isLinked() });
        };
        p = this.addInPort(switchPort);

        if (v !== undefined) {
          p.set(v);
          const index = values.findIndex((item) => {
            return item == v;
          });
          n.setValue(index);
          p.defaultValue = v;
          n.defaultValue = index;
        }
      } else {
        const switchPort = new Port(this, name, Port.TYPE_STRING, {
          display: "switch",
          hidePort: true,
          type: "string",
          values: values,
        });
        p = this.addInPort(switchPort);
      }

      return p;
    }

    /**
     * @deprecated
     */
    inValueInt(name, v) {
      return this.inInt(name, v);
    }

    /**
     * create a integer input port
     * @param {String} name
     * @param {number} v default value
     * @return {Port} created port
     */
    inInt(name, v) {
      // old
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_VALUE, {
          increment: "integer",
        }),
      );
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    }

    /**
     * create a file/URL input port
     * @param {String} name
     * @param {String} filter
     * @param {String} v
     * @return {Port} created port
     */
    inFile(name, filter, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_VALUE, {
          display: "file",
          type: "string",
          filter: filter,
        }),
      );
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    }

    /**
     * @deprecated
     */
    inUrl(name, filter, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_STRING, {
          display: "file",
          type: "string",
          filter: filter,
        }),
      );
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    }

    /**
     * create a texture input port
     * @param {String} name
     * @return {Port} created port
     */
    inTexture(name, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_OBJECT, {
          display: "texture",
          objType: "texture",
          preview: true,
        }),
      );
      p.ignoreValueSerialize = true;
      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * create a object input port
     * @param {String} name
     * @param {Object} v
     * @param {String} objType
     * @return {Port} created port
     */
    inObject(name, v, objType) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_OBJECT, { objType: objType }),
      );
      p.ignoreValueSerialize = true;

      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * @param {string} name
     * @param {string} v
     */
    inGradient(name, v) {
      const p = this.addInPort(
        new Port(this, name, Port.TYPE_VALUE, {
          display: "gradient",
          // "hidePort": true
        }),
      );
      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * @param {Port} p
     * returns {number}
     */
    getPortVisibleIndex(p) {
      let ports = this.portsIn;
      if (p.direction == CONSTANTS.PORT_DIR_OUT) ports = this.portsOut;

      let index = 0;
      for (let i = 0; i < ports.length; i++) {
        if (ports[i].uiAttribs.hidePort) continue;
        index++;
        if (ports[i] == p) return index;
      }
    }

    /**
     * create a array input port
     * @param {String} name
     * @param {Array|Number} v
     * @param {Number} _stride
     * @return {Port} created port
     */
    inArray(name, v = undefined, _stride = undefined) {
      let stride = _stride;
      // @ts-ignore
      if (!_stride && CABLES.isNumeric(v)) stride = v;

      const p = this.addInPort(
        new Port(this, name, Port.TYPE_ARRAY, { stride: stride }),
      );

      if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);

      return p;
    }

    /**
     * @deprecated
     */
    inValueSlider(name, v, min, max) {
      return this.inFloatSlider(name, v, min, max);
    }

    /**
     * create a value slider input port
     * @param {String} name
     * @param {number} v
     * @param {number} min
     * @param {number} max
     * @return {Port} created port
     */
    inFloatSlider(name, v, min, max) {
      const uiattribs = { display: "range" };

      if (min != undefined && max != undefined) {
        uiattribs.min = min;
        uiattribs.max = max;
      }

      const p = this.addInPort(new Port(this, name, Port.TYPE_VALUE, uiattribs));
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    }

    /**
     * @deprecated
     */
    outFunction(name, v) {
      return this.outTrigger(name, v);
    }

    /**
     * create output trigger port
     * @param {String} name
     * @param {String} v
     * @return {Port} created port
     */
    outTrigger(name, v) {
      // old
      const p = this.addOutPort(new Port(this, name, Port.TYPE_FUNCTION));
      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * @deprecated
     */
    outValue(name, v) {
      return this.outNumber(name, v);
    }

    /**
     * create output value port
     * @param {String} name
     * @param {number} v default value
     * @return {Port} created port
     */
    outNumber(name, v) {
      const p = this.addOutPort(new Port(this, name, Port.TYPE_VALUE));
      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * @deprecated
     */
    outValueBool(name, v) {
      return this.outBool(name, v);
    }

    /**
     * deprecated create output boolean port
     * @deprecated
     * @param {String} name
     * @param {boolean} v default value
     * @return {Port} created port
     */
    outBool(name, v) {
      // old: use outBoolNum
      const p = this.addOutPort(
        new Port(this, name, Port.TYPE_VALUE, {
          display: "bool",
        }),
      );
      if (v !== undefined) p.set(v);
      else p.set(0);
      return p;
    }

    /**
     * create output boolean port,value will be converted to 0 or 1
     * @param {String} name
     * @return {Port} created port
     */
    outBoolNum(name, v) {
      const p = this.addOutPort(
        new Port(this, name, Port.TYPE_VALUE, {
          display: "boolnum",
        }),
      );

      p.set = function (b) {
        this.setValue(b ? 1 : 0);
      }.bind(p);

      if (v !== undefined) p.set(v);
      else p.set(0);
      return p;
    }

    /**
     * @deprecated
     * @param {string} name
     * @param {string} v
     */
    outValueString(name, v) {
      const p = this.addOutPort(
        new Port(this, name, Port.TYPE_VALUE, {
          type: "string",
        }),
      );
      if (v !== undefined) p.set(v);
      return p;
    }

    /**
     * create output string port
     * @param {string} name
     * @param {String} v
     * @return {Port} created port
     */
    outString(name, v) {
      const p = this.addOutPort(
        new Port(this, name, Port.TYPE_STRING, {
          type: "string",
        }),
      );
      if (v !== undefined) p.set(v);
      else p.set("");
      return p;
    }

    /**
     * create output object port
     * @param {String} name
     * @return {Port} created port
     * @param {object} v
     * @param {string} objType
     */
    outObject(name, v, objType) {
      const p = this.addOutPort(
        new Port(this, name, Port.TYPE_OBJECT, { objType: objType || null }),
      );
      p.set(v || null);
      p.ignoreValueSerialize = true;
      return p;
    }

    /**
     * create output array port
     * @param {String} name
     * @return {Port} created port
     * @param {array|number} v
     * @param {number} stride
     */
    outArray(name, v, stride) {
      if (!stride && CABLES.isNumeric(v)) stride = v;
      const p = this.addOutPort(
        new Port(this, name, Port.TYPE_ARRAY, { stride: stride }),
      );
      if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);

      p.ignoreValueSerialize = true;
      return p;
    }

    /**
     * create output texture port
     * @param {String} name
     * @return {Port} created port
     * @param {any} v
     */
    outTexture(name, v) {
      const p = this.addOutPort(
        new Port(this, name, Port.TYPE_OBJECT, {
          preview: true,
          objType: "texture",
          display: "texture",
        }),
      );
      if (v !== undefined) p.setRef(v || Texture$1.getEmptyTexture(this.patch.cgl));

      p.ignoreValueSerialize = true;
      return p;
    }

    /**
     * @deprecated
     * @param {string} name
     * @param {any} filter
     * @param {any} options
     * @param {any} v
     */
    inDynamic(name, filter, options, v) {
      const p = new Port(this, name, Port.TYPE_DYNAMIC, options);

      p.shouldLink = (p1, p2) => {
        if (filter && CABLES.isArray(filter)) {
          // for (let i = 0; i < filter.length; i++)
          // {
          // if (p1 == this && p2.type === filter[i]) return true;
          // if (p2 == this && p1.type === filter[i]) return true;
          // }
          return false; // types do not match
        }
        return true; // no filter set
      };

      this.addInPort(p);
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    }

    removeLinks() {
      for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].removeLinks();
      for (let i = 0; i < this.portsOut.length; i++)
        this.portsOut[i].removeLinks();
    }

    getSerialized() {
      const opObj = {};

      if (this.opId) opObj.opId = this.opId;
      if (this.patch.storeObjNames) opObj.objName = this.objName;

      opObj.id = this.id;
      opObj.uiAttribs = JSON.parse(JSON.stringify(this.uiAttribs)) || {};

      if (this.storage && Object.keys(this.storage).length > 0)
        opObj.storage = JSON.parse(JSON.stringify(this.storage));
      if (
        this.uiAttribs.hasOwnProperty("working") &&
        this.uiAttribs.working == true
      )
        delete this.uiAttribs.working;
      if (opObj.uiAttribs.hasOwnProperty("uierrors"))
        delete opObj.uiAttribs.uierrors;

      if (opObj.uiAttribs.title === "") delete opObj.uiAttribs.title;
      if (opObj.uiAttribs.color === null) delete opObj.uiAttribs.color;
      if (opObj.uiAttribs.comment === null) delete opObj.uiAttribs.comment;

      if (
        opObj.uiAttribs.title == this.#shortOpName ||
        (this.uiAttribs.title || "").toLowerCase() ==
          this.#shortOpName.toLowerCase()
      )
        delete opObj.uiAttribs.title;

      opObj.portsIn = [];
      opObj.portsOut = [];

      for (let i = 0; i < this.portsIn.length; i++) {
        const s = this.portsIn[i].getSerialized();
        if (s) opObj.portsIn.push(s);
      }

      for (let i = 0; i < this.portsOut.length; i++) {
        const s = this.portsOut[i].getSerialized();
        if (s) opObj.portsOut.push(s);
      }

      if (opObj.portsIn.length == 0) delete opObj.portsIn;
      if (opObj.portsOut.length == 0) delete opObj.portsOut;
      cleanJson(opObj);

      return opObj;
    }

    /**
     * @param {number} type
     */
    getFirstOutPortByType(type) {
      for (const ipo in this.portsOut)
        if (this.portsOut[ipo].type == type) return this.portsOut[ipo];
    }

    /**
     * @param {number} type
     */
    getFirstInPortByType(type) {
      for (const ipo in this.portsIn)
        if (this.portsIn[ipo].type == type) return this.portsIn[ipo];
    }

    /**
     * return port by the name portName
     * @param {String} name
     * @param {boolean} [lowerCase]
     * @return {Port}
     */
    getPort(name, lowerCase = false) {
      return this.getPortByName(name, lowerCase);
    }

    /**
     * @param {string} name
     * @param {boolean} [lowerCase]
     * @returns {Port}
     */
    getPortByName(name, lowerCase = false) {
      if (lowerCase) {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
          if (
            this.portsIn[ipi].getName().toLowerCase() == name ||
            this.portsIn[ipi].id.toLowerCase() == name
          )
            return this.portsIn[ipi];

        for (let ipo = 0; ipo < this.portsOut.length; ipo++)
          if (
            this.portsOut[ipo].getName().toLowerCase() == name ||
            this.portsOut[ipo].id.toLowerCase() == name
          )
            return this.portsOut[ipo];
      } else {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
          if (this.portsIn[ipi].getName() == name || this.portsIn[ipi].id == name)
            return this.portsIn[ipi];

        for (let ipo = 0; ipo < this.portsOut.length; ipo++)
          if (
            this.portsOut[ipo].getName() == name ||
            this.portsOut[ipo].id == name
          )
            return this.portsOut[ipo];
      }
    }

    /**
     * return port by the name id
     * @param {String} id
     * @return {Port}
     */
    getPortById(id) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        if (this.portsIn[ipi].id == id) return this.portsIn[ipi];
      for (let ipo = 0; ipo < this.portsOut.length; ipo++)
        if (this.portsOut[ipo].id == id) return this.portsOut[ipo];
    }

    updateAnims() {
      if (this.hasAnimPort)
        for (let i = 0; i < this.portsIn.length; i++)
          this.portsIn[i].updateAnim();
    }

    log() {
      this._log.log(...arguments);
    }

    /**
     * @deprecated
     */
    error() {
      this._log.error(...arguments);
    }

    logError() {
      this._log.error(...arguments);
    }

    /**
     * @deprecated
     */
    warn() {
      this._log.warn(...arguments);
    }

    logWarn() {
      this._log.warn(...arguments);
    }

    /**
     * @deprecated
     */
    verbose() {
      this._log.verbose(...arguments);
    }

    logVerbose() {
      this._log.verbose(...arguments);
    }

    profile() {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
        this.portsIn[ipi]._onTriggered = this.portsIn[ipi]._onTriggeredProfiling;
        this.portsIn[ipi].set = this.portsIn[ipi]._onSetProfiling;
      }
    }

    // findParent(objName)
    // {
    //     for (let ipi = 0; ipi < this.portsIn.length; ipi++)
    //     {
    //         if (this.portsIn[ipi].isLinked())
    //         {
    //             if (this.portsIn[ipi].links[0].portOut.parent.objName == objName)
    //                 return this.portsIn[ipi].links[0].portOut.parent;

    //             let found = null;
    //             found = this.portsIn[ipi].links[0].portOut.parent.findParent(objName);
    //             if (found) return found;
    //         }
    //     }
    //     return null;
    // }

    // todo: check instancing stuff?
    cleanUp() {
      if (this._instances) {
        for (let i = 0; i < this._instances.length; i++)
          if (this._instances[i].onDelete) this._instances[i].onDelete();

        this._instances.length = 0;
      }

      for (let i = 0; i < this.portsIn.length; i++)
        this.portsIn[i].setAnimated(false);

      if (this.onAnimFrame) this.patch.removeOnAnimFrame(this);
    }

    // todo: check instancing stuff?
    instanced(triggerPort) {
      return false;

      /*
       * this._log.log("instanced", this.patch.instancing.numCycles());
       * if (this.patch.instancing.numCycles() === 0) return false;
       */

      /*
       * let i = 0;
       * let ipi = 0;
       * if (!this._instances || this._instances.length != this.patch.instancing.numCycles())
       * {
       *     if (!this._instances) this._instances = [];
       *     this._.log("creating instances of ", this.objName, this.patch.instancing.numCycles(), this._instances.length);
       *     this._instances.length = this.patch.instancing.numCycles();
       */

      /*
       *     for (i = 0; i < this._instances.length; i++)
       *     {
       *         this._instances[i] = this.patch.createOp(this.objName, true);
       *         this._instances[i].instanced ()
       *         {
       *             return false;
       *         };
       *         this._instances[i].uiAttr(this.uiAttribs);
       */

      /*
       *         for (let ipo = 0; ipo < this.portsOut.length; ipo++)
       *         {
       *             if (this.portsOut[ipo].type == Port.TYPE_FUNCTION)
       *             {
       *                 this._instances[i].getPortByName(this.portsOut[ipo].name).trigger = this.portsOut[ipo].trigger.bind(this.portsOut[ipo]);
       *             }
       *         }
       *     }
       */

      /*
       *     for (ipi = 0; ipi < this.portsIn.length; ipi++)
       *     {
       *         this.portsIn[ipi].onChange = null;
       *         this.portsIn[ipi].onValueChanged = null;
       *     }
       * }
       */

      /*
       * const theTriggerPort = null;
       * for (ipi = 0; ipi < this.portsIn.length; ipi++)
       * {
       *     if (
       *         this.portsIn[ipi].type == Port.TYPE_VALUE ||
       *         this.portsIn[ipi].type == Port.TYPE_ARRAY
       *     )
       *     {
       *         this._instances[this.patch.instancing.index()].portsIn[ipi].set(this.portsIn[ipi].get());
       *     }
       *     if (this.portsIn[ipi].type == Port.TYPE_FUNCTION)
       *     {
       *         // if(this._instances[ this.patch.instancing.index() ].portsIn[ipi].name==triggerPort.name)
       *         // theTriggerPort=this._instances[ this.patch.instancing.index() ].portsIn[ipi];
       *     }
       * }
       */

      // if (theTriggerPort) theTriggerPort.onTriggered();

      /*
       * for (ipi = 0; ipi < this.portsOut.length; ipi++)
       * {
       *     if (this.portsOut[ipi].type == Port.TYPE_VALUE)
       *     {
       *         this.portsOut[ipi].set(this._instances[this.patch.instancing.index()].portsOut[ipi].get());
       *     }
       * }
       */

      // return true;
    }

    // todo: check instancing stuff?
    initInstancable() {
      //         if(this.isInstanced)
      //         {
      //             this._log.log('cancel instancing');
      //             return;
      //         }
      //         this._instances=[];
      //         for(var ipi=0;ipi<this.portsIn.length;ipi++)
      //         {
      //             if(this.portsIn[ipi].type==Port.TYPE_VALUE)
      //             {
      //
      //             }
      //             if(this.portsIn[ipi].type==Port.TYPE_FUNCTION)
      //             {
      //                 // var piIndex=ipi;
      //                 this.portsIn[ipi].onTriggered=function(piIndex)
      //                 {
      //
      //                     var i=0;
      // // this._log.log('trigger',this._instances.length);
      //
      //                 }.bind(this,ipi );
      //
      //             }
      // };
      // this._instances=null;
    }

    // setValues(obj)
    // {
    //     for (const i in obj)
    //     {
    //         const port = this.getPortByName(i);
    //         if (port) port.set(obj[i]);
    //         else this._log.warn("op.setValues: port not found:", i);
    //     }
    // }

    /**
     * return true if op has this error message id
     * @param {String} id
     * @returns {Boolean} - has id
     */
    hasUiError(id) {
      return this.uiErrors.hasOwnProperty(id) && this.uiErrors[id];
    }

    /**
     * show op error message - set message to null to remove error message
     * @param {string} id error id
     * @param {string} txt text message
     * @param {number} level level
     */
    setUiError(id, txt, level = 2, options = {}) {
      // overwritten in ui: core_extend_op
    }

    /**
     * enable/disable op
     * @function
     * @param {boolean} b
     */
    setEnabled(b) {
      this.enabled = b;
      this.emitEvent("onEnabledChange", b);
    }

    /**
     * organize ports into a group
     * @function
     * @param {String} name
     * @param {Array} ports
     */
    setPortGroup(name, ports) {
      for (let i = 0; i < ports.length; i++) {
        if (ports[i])
          if (ports[i].setUiAttribs) ports[i].setUiAttribs({ group: name });
          else this._log.error("setPortGroup: invalid port!");
      }
    }

    /**
     * visually indicate ports that they are coordinate inputs
     * @function
     * @param {Port} px
     * @param {Port} py
     * @param {Port} pz
     */
    setUiAxisPorts(px, py, pz) {
      if (px) px.setUiAttribs({ axis: "X" });
      if (py) py.setUiAttribs({ axis: "Y" });
      if (pz) pz.setUiAttribs({ axis: "Z" });
    }

    /**
     * remove port from op
     * @param {Port} port to remove
     */
    removePort(port) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
        if (this.portsIn[ipi] == port) {
          this.portsIn.splice(ipi, 1);
          this.emitEvent("onUiAttribsChange", {});
          this.emitEvent("onPortRemoved", {});
          return;
        }
      }
      for (let ipi = 0; ipi < this.portsOut.length; ipi++) {
        if (this.portsOut[ipi] == port) {
          this.portsOut.splice(ipi, 1);
          this.emitEvent("onUiAttribsChange", {});
          this.emitEvent("onPortRemoved", {});
          return;
        }
      }
    }

    _checkLinksNeededToWork() {}

    /**
     * show a warning of this op is not a child of parentOpName
     * @function
     * @param {String} parentOpName
     */
    toWorkNeedsParent(parentOpName) {
      this.linkTimeRules.needsParentOp = parentOpName;
    }

    /**
     * show a warning of this op is a child of parentOpName
     * @function
     * @instance
     * @memberof Op
     * @param {String} parentOpName
     * @param {number} type
     */
    toWorkShouldNotBeChild(parentOpName, type) {
      if (!this.patch.isEditorMode()) return;
      this.linkTimeRules.forbiddenParent = parentOpName;
      if (type != undefined) this.linkTimeRules.forbiddenParentType = type;
    }

    toWorkPortsNeedsString() {
      if (!this.patch.isEditorMode()) return;
      for (let i = 0; i < arguments.length; i++)
        if (this.linkTimeRules.needsStringToWork.indexOf(arguments[i]) == -1)
          this.linkTimeRules.needsStringToWork.push(arguments[i]);
    }

    /**
     * show a small X to indicate op is not working when given ports are not linked
     * @function
     * @instance
     * @memberof Op
     * @param {Array<Port>} port
     */
    toWorkPortsNeedToBeLinked() {
      if (!this.patch.isEditorMode()) return;
      for (let i = 0; i < arguments.length; i++)
        if (this.linkTimeRules.needsLinkedToWork.indexOf(arguments[i]) == -1)
          this.linkTimeRules.needsLinkedToWork.push(arguments[i]);
    }

    toWorkPortsNeedToBeLinkedReset() {
      if (!this.patch.isEditorMode()) return;
      this.linkTimeRules.needsLinkedToWork.length = 0;
      if (this.checkLinkTimeWarnings) this.checkLinkTimeWarnings();
    }

    initVarPorts() {
      for (let i = 0; i < this.portsIn.length; i++) {
        if (this.portsIn[i].getVariableName())
          this.portsIn[i].setVariable(this.portsIn[i].getVariableName());
      }
    }

    checkLinkTimeWarnings() {}

    /**
     * refresh op parameters, if current op is selected
     * @function
     * @instance
     * @memberof Op
     */
    refreshParams() {
      if (this.patch && this.patch.isEditorMode() && this.isCurrentUiOp())
        gui.opParams.show(this);
    }

    /**
     * Returns true if op is selected and parameter are shown in the editor, can only return true if in editor/ui
     * @instance
     * @memberof Op
     * @returns {Boolean} - is current ui op
     */
    isCurrentUiOp() {
      if (this.patch.isEditorMode()) return gui.patchView.isCurrentOp(this);
    }

    checkGraphicsApi(api = 0) {
      if (this.patch.isEditorMode())
        if (this.patch.cg && this.patch.cg.gApi != api)
          this.setUiError("wronggapi", "Wrong graphics API", 2);
    }
  }

  /**
   * configuration object for loading a patch
   * @typedef {Object} AnimCfg
   * @property {number} [defaultEasing] use easing index as default
   * @property {string} [name] anim name
   */

  /**
   * Keyframed interpolated animation.
   *
   * @class
   * @param cfg
   * @example
   * var anim=new CABLES.Anim();
   * anim.setValue(0,0);  // set value 0 at 0 seconds
   * anim.setValue(10,1); // set value 1 at 10 seconds
   * anim.getValue(5);    // get value at 5 seconds - this returns 0.5
   */

  class Anim extends Events {
    static EASING_LINEAR = 0;
    static EASING_ABSOLUTE = 1;
    static EASING_SMOOTHSTEP = 2;
    static EASING_SMOOTHERSTEP = 3;
    static EASING_CUBICSPLINE = 4;

    static EASING_CUBIC_IN = 5;
    static EASING_CUBIC_OUT = 6;
    static EASING_CUBIC_INOUT = 7;

    static EASING_EXPO_IN = 8;
    static EASING_EXPO_OUT = 9;
    static EASING_EXPO_INOUT = 10;

    static EASING_SIN_IN = 11;
    static EASING_SIN_OUT = 12;
    static EASING_SIN_INOUT = 13;

    static EASING_BACK_IN = 14;
    static EASING_BACK_OUT = 15;
    static EASING_BACK_INOUT = 16;

    static EASING_ELASTIC_IN = 17;
    static EASING_ELASTIC_OUT = 18;

    static EASING_BOUNCE_IN = 19;
    static EASING_BOUNCE_OUT = 21;

    static EASING_QUART_IN = 22;
    static EASING_QUART_OUT = 23;
    static EASING_QUART_INOUT = 24;

    static EASING_QUINT_IN = 25;
    static EASING_QUINT_OUT = 26;
    static EASING_QUINT_INOUT = 27;

    static EASINGNAMES = [
      "linear",
      "absolute",
      "smoothstep",
      "smootherstep",
      "Cubic In",
      "Cubic Out",
      "Cubic In Out",
      "Expo In",
      "Expo Out",
      "Expo In Out",
      "Sin In",
      "Sin Out",
      "Sin In Out",
      "Quart In",
      "Quart Out",
      "Quart In Out",
      "Quint In",
      "Quint Out",
      "Quint In Out",
      "Back In",
      "Back Out",
      "Back In Out",
      "Elastic In",
      "Elastic Out",
      "Bounce In",
      "Bounce Out",
    ];
    static EVENT_CHANGE = "onChange";
    #tlActive = true;

    /**
     * @param {AnimCfg} [cfg]
     */
    constructor(cfg = {}) {
      super();
      cfg = cfg || {};
      this.id = uuid();

      /** @type {AnimKey[]} */
      this.keys = [];
      this.onChange = null;
      this.stayInTimeline = false;
      this.loop = false;
      this._log = new Logger("Anim");
      this._lastKeyIndex = 0;
      this._cachedIndex = 0;
      this.name = cfg.name || null;

      /**
       * @type {Number}
       */
      this.defaultEasing = cfg.defaultEasing || Anim.EASING_LINEAR;
      this.onLooped = null;

      this._timesLooped = 0;
      this._needsSort = false;
    }

    forceChangeCallback() {
      if (this.onChange !== null) this.onChange();
      this.emitEvent(Anim.EVENT_CHANGE, this);
    }

    getLoop() {
      return this.loop;
    }

    /**
     * @param {boolean} enable
     */
    setLoop(enable) {
      this.loop = enable;
      this.emitEvent(Anim.EVENT_CHANGE, this);
    }

    /**
     * returns true if animation has ended at @time
     * checks if last key time is < time
     * @param {Number} time
     * @returns {Boolean}
     * @memberof Anim
     * @instance
     * @function
     */
    hasEnded(time) {
      if (this.keys.length === 0) return true;
      if (this.keys[this._lastKeyIndex].time <= time) return true;
      return false;
    }

    /**
     * @param {number} time
     */
    isRising(time) {
      if (this.hasEnded(time)) return false;
      const ki = this.getKeyIndex(time);
      if (this.keys[ki].value < this.keys[ki + 1].value) return true;
      return false;
    }

    /**
     * remove all keys from animation before time
     * @param {Number} time
     * @memberof Anim
     * @instance
     * @function
     */
    clearBefore(time) {
      const v = this.getValue(time);
      const ki = this.getKeyIndex(time);

      this.setValue(time, v);

      if (ki > 1) this.keys.splice(0, ki);
      this._updateLastIndex();
    }

    /**
     * remove all keys from animation
     * @param {Number} [time=0] set a new key at time with the old value at time
     * @memberof Anim
     * @instance
     * @function
     */
    clear(time) {
      let v = 0;
      if (time) v = this.getValue(time);
      this.keys.length = 0;
      this._updateLastIndex();
      if (time) this.setValue(time, v);
      if (this.onChange !== null) this.onChange();
      this.emitEvent(Anim.EVENT_CHANGE, this);
    }

    sortKeys() {
      this.keys.sort((a, b) => {
        return parseFloat(a.time) - parseFloat(b.time);
      });
      this._updateLastIndex();
      this._needsSort = false;
      if (this.keys.length > 999 && this.keys.length % 1000 == 0)
        console.log(this.name, this.keys.length);
    }

    hasDuplicates() {
      const test = {};
      let count = 0;
      for (let i = 0; i < this.keys.length; i++) {
        test[this.keys[i].time] = 1;
        count++;
      }

      const keys = Object.keys(test);
      if (keys.length != count) {
        return true;
      }
      return false;
    }

    removeDuplicates() {
      if (this.hasDuplicates()) {
        this.sortKeys();

        while (this.hasDuplicates()) {
          for (let i = 0; i < this.keys.length - 1; i++) {
            if (this.keys[i].time == this.keys[i + 1].time)
              this.keys.splice(i, 1);
          }
        }
        this._updateLastIndex();
      }
    }

    getLength() {
      if (this.keys.length === 0) return 0;
      return this.keys[this.keys.length - 1].time;
    }

    /**
     * @param {number} time
     */
    getKeyIndex(time) {
      let index = 0;
      let start = 0;
      if (
        this._cachedIndex &&
        this.keys.length > this._cachedIndex &&
        time >= this.keys[this._cachedIndex].time
      )
        start = this._cachedIndex;
      for (let i = start; i < this.keys.length; i++) {
        if (time >= this.keys[i].time) index = i;
        if (this.keys[i].time > time) {
          if (time != 0) this._cachedIndex = index;
          return index;
        }
      }

      return index;
    }

    /**
     * set value at time
     * @function setValue
     * @memberof Anim
     * @instance
     * @param {Number} time
     * @param {Number} value
     * @param {Function} cb callback
     */
    setValue(time, value, cb = null) {
      let found = null;

      if (this.keys.length == 0 || time <= this.keys[this.keys.length - 1].time)
        for (let i = 0; i < this.keys.length; i++)
          if (this.keys[i].time == time) {
            found = this.keys[i];
            this.keys[i].setValue(value);
            this.keys[i].cb = cb;
            break;
          }

      if (!found) {
        found = new AnimKey({
          time: time,
          value: value,
          e: this.defaultEasing,
          cb: cb,
          anim: this,
        });
        this.keys.push(found);

        // if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);
        this._updateLastIndex();
      }

      if (this.onChange) this.onChange();
      this.emitEvent(Anim.EVENT_CHANGE, this);
      this._needsSort = true;
      return found;
    }

    /**
     * @param {number} index
     * @param {number} easing
     */
    setKeyEasing(index, easing) {
      if (this.keys[index]) {
        this.keys[index].setEasing(easing);
        this.emitEvent(Anim.EVENT_CHANGE, this);
      }
    }

    /**
     * @param {object} obj
     */
    deserialize(obj) {
      if (obj.loop) this.loop = obj.loop;
      if (obj.tlActive) this.#tlActive = obj.tlActive;
      for (const ani in obj.keys) {
        this.keys.push(new CABLES.AnimKey(obj.keys[ani], this));
      }
    }

    /**
     * @returns {Object}
     */
    getSerialized() {
      const obj = {};
      obj.keys = [];
      obj.loop = this.loop;
      if (this.#tlActive) obj.tlActive = this.tlActive;

      for (let i = 0; i < this.keys.length; i++)
        obj.keys.push(this.keys[i].getSerialized());

      return obj;
    }

    /**
     * @param {number} time
     */
    getKey(time) {
      const index = this.getKeyIndex(time);
      return this.keys[index];
    }

    /**
     * @param {number} time
     */
    getNextKey(time) {
      let index = this.getKeyIndex(time) + 1;
      if (index >= this.keys.length) index = this.keys.length - 1;

      return this.keys[index];
    }

    /**
     * @param {number} time
     */
    isFinished(time) {
      if (this.keys.length <= 0) return true;
      return time > this.keys[this.keys.length - 1].time;
    }

    /**
     * @param {number} time
     */
    isStarted(time) {
      if (this.keys.length <= 0) return false;
      return time >= this.keys[0].time;
    }

    /**
     * @param {AnimKey} k
     */
    remove(k) {
      for (let i = 0; i < this.keys.length; i++) {
        if (this.keys[i] == k) {
          this.keys.splice(i, 1);
          this._updateLastIndex();
          return;
        }
      }
      console.log("key remove not found", k);
    }

    /**
     * get value at time
     * @function getValue
     * @memberof Anim
     * @instance
     * @param {Number} [time] time
     * @returns {Number} interpolated value at time
     */
    getValue(time) {
      if (this.keys.length === 0) {
        return 0;
      }
      if (this._needsSort) this.sortKeys();

      if (!this.loop && time > this.keys[this._lastKeyIndex].time) {
        if (
          this.keys[this._lastKeyIndex].cb &&
          !this.keys[this._lastKeyIndex].cbTriggered
        )
          this.keys[this._lastKeyIndex].trigger();

        return this.keys[this._lastKeyIndex].value;
      }

      if (time < this.keys[0].time) return this.keys[0].value;

      if (this.loop && time > this.keys[this._lastKeyIndex].time) {
        const currentLoop = time / this.keys[this._lastKeyIndex].time;
        if (currentLoop > this._timesLooped) {
          this._timesLooped++;
          if (this.onLooped) this.onLooped();
        }
        time =
          (time - this.keys[0].time) %
          (this.keys[this._lastKeyIndex].time - this.keys[0].time);
        time += this.keys[0].time;
      }

      const index = this.getKeyIndex(time);
      if (index >= this._lastKeyIndex) {
        if (
          this.keys[this._lastKeyIndex].cb &&
          !this.keys[this._lastKeyIndex].cbTriggered
        )
          this.keys[this._lastKeyIndex].trigger();

        return this.keys[this._lastKeyIndex].value;
      }

      const index2 = index + 1;
      const key1 = this.keys[index];
      const key2 = this.keys[index2];

      if (key1.cb && !key1.cbTriggered) key1.trigger();

      if (!key2) return -1;

      const perc = (time - key1.time) / (key2.time - key1.time);

      return key1.ease(perc, key2);
    }

    _updateLastIndex() {
      this._lastKeyIndex = this.keys.length - 1;
    }

    /**
     * @param {AnimKey} k
     */
    addKey(k) {
      if (k.time === undefined) {
        this._log.warn("key time undefined, ignoring!");
      } else {
        this.keys.push(k);
        if (this.onChange !== null) this.onChange();
        this.emitEvent(Anim.EVENT_CHANGE, this);
        this._needsSort = true;
      }
      this._updateLastIndex();
    }

    /**
     * @param {string} str
     */
    easingFromString(str) {
      // todo smarter way to map ?
      if (str == "linear") return Anim.EASING_LINEAR;
      if (str == "absolute") return Anim.EASING_ABSOLUTE;
      if (str == "smoothstep") return Anim.EASING_SMOOTHSTEP;
      if (str == "smootherstep") return Anim.EASING_SMOOTHERSTEP;

      if (str == "Cubic In") return Anim.EASING_CUBIC_IN;
      if (str == "Cubic Out") return Anim.EASING_CUBIC_OUT;
      if (str == "Cubic In Out") return Anim.EASING_CUBIC_INOUT;

      if (str == "Expo In") return Anim.EASING_EXPO_IN;
      if (str == "Expo Out") return Anim.EASING_EXPO_OUT;
      if (str == "Expo In Out") return Anim.EASING_EXPO_INOUT;

      if (str == "Sin In") return Anim.EASING_SIN_IN;
      if (str == "Sin Out") return Anim.EASING_SIN_OUT;
      if (str == "Sin In Out") return Anim.EASING_SIN_INOUT;

      if (str == "Back In") return Anim.EASING_BACK_IN;
      if (str == "Back Out") return Anim.EASING_BACK_OUT;
      if (str == "Back In Out") return Anim.EASING_BACK_INOUT;

      if (str == "Elastic In") return Anim.EASING_ELASTIC_IN;
      if (str == "Elastic Out") return Anim.EASING_ELASTIC_OUT;

      if (str == "Bounce In") return Anim.EASING_BOUNCE_IN;
      if (str == "Bounce Out") return Anim.EASING_BOUNCE_OUT;

      if (str == "Quart Out") return Anim.EASING_QUART_OUT;
      if (str == "Quart In") return Anim.EASING_QUART_IN;
      if (str == "Quart In Out") return Anim.EASING_QUART_INOUT;

      if (str == "Quint Out") return Anim.EASING_QUINT_OUT;
      if (str == "Quint In") return Anim.EASING_QUINT_IN;
      if (str == "Quint In Out") return Anim.EASING_QUINT_INOUT;

      console.log("unknown anim easing?", str);
    }

    /**
     * @param {Op} op
     * @param {string} title
     * @param {function} cb
     * @returns {Port}
     */
    createPort(op, title, cb) {
      const port = op.inDropDown(title, Anim.EASINGNAMES, "linear");
      port.set("linear");
      port.defaultValue = "linear";

      port.onChange = () => {
        this.defaultEasing = this.easingFromString(port.get());
        this.emitEvent("onChangeDefaultEasing", this);

        if (cb) cb();
      };

      return port;
    }

    get tlActive() {
      return this.#tlActive;
    }

    set tlActive(b) {
      this.#tlActive = b;
      gui.emitEvent("tlActiveChanged", this);
    }
  }

  // ------------------------------

  /**
   * @param {number} time
   * @param {quat} q
   * @param {Anim} animx
   * @param {Anim} animy
   * @param {Anim} animz
   * @param {Anim} animw
   */
  Anim.slerpQuaternion = function (time, q, animx, animy, animz, animw) {
    if (!Anim.slerpQuaternion.q1) {
      Anim.slerpQuaternion.q1 = create$2();
      Anim.slerpQuaternion.q2 = create$2();
    }

    const i1 = animx.getKeyIndex(time);
    let i2 = i1 + 1;
    if (i2 >= animx.keys.length) i2 = animx.keys.length - 1;

    if (i1 == i2) {
      set$2(
        q,
        animx.keys[i1].value,
        animy.keys[i1].value,
        animz.keys[i1].value,
        animw.keys[i1].value,
      );
    } else {
      const key1Time = animx.keys[i1].time;
      const key2Time = animx.keys[i2].time;
      const perc = (time - key1Time) / (key2Time - key1Time);

      set$2(
        Anim.slerpQuaternion.q1,
        animx.keys[i1].value,
        animy.keys[i1].value,
        animz.keys[i1].value,
        animw.keys[i1].value,
      );

      set$2(
        Anim.slerpQuaternion.q2,
        animx.keys[i2].value,
        animy.keys[i2].value,
        animz.keys[i2].value,
        animw.keys[i2].value,
      );

      slerp(q, Anim.slerpQuaternion.q1, Anim.slerpQuaternion.q2, perc);
    }
    return q;
  };

  const CONSTANTS = {
    ANIM: {
      EASINGS: Anim.EASINGNAMES,
      EASING_LINEAR: 0,
      EASING_ABSOLUTE: 1,
      EASING_SMOOTHSTEP: 2,
      EASING_SMOOTHERSTEP: 3,
      EASING_CUBICSPLINE: 4,

      EASING_CUBIC_IN: 5,
      EASING_CUBIC_OUT: 6,
      EASING_CUBIC_INOUT: 7,

      EASING_EXPO_IN: 8,
      EASING_EXPO_OUT: 9,
      EASING_EXPO_INOUT: 10,

      EASING_SIN_IN: 11,
      EASING_SIN_OUT: 12,
      EASING_SIN_INOUT: 13,

      EASING_BACK_IN: 14,
      EASING_BACK_OUT: 15,
      EASING_BACK_INOUT: 16,

      EASING_ELASTIC_IN: 17,
      EASING_ELASTIC_OUT: 18,

      EASING_BOUNCE_IN: 19,
      EASING_BOUNCE_OUT: 21,

      EASING_QUART_IN: 22,
      EASING_QUART_OUT: 23,
      EASING_QUART_INOUT: 24,

      EASING_QUINT_IN: 25,
      EASING_QUINT_OUT: 26,
      EASING_QUINT_INOUT: 27,
    },

    OP: {
      OP_PORT_TYPE_VALUE: 0,
      OP_PORT_TYPE_NUMBER: 0,
      OP_PORT_TYPE_FUNCTION: 1,
      OP_PORT_TYPE_TRIGGER: 1,
      OP_PORT_TYPE_OBJECT: 2,
      OP_PORT_TYPE_TEXTURE: 2,
      OP_PORT_TYPE_ARRAY: 3,
      OP_PORT_TYPE_DYNAMIC: 4,
      OP_PORT_TYPE_STRING: 5,

      OP_VERSION_PREFIX: "_v",
    },

    PORT: {
      PORT_DIR_IN: 0,
      PORT_DIR_OUT: 1,
    },

    PACO: {
      PACO_CLEAR: 0,
      PACO_VALUECHANGE: 1,
      PACO_OP_DELETE: 2,
      PACO_UNLINK: 3,
      PACO_LINK: 4,
      PACO_LOAD: 5,
      PACO_OP_CREATE: 6,
      PACO_OP_ENABLE: 7,
      PACO_OP_DISABLE: 8,
      PACO_UIATTRIBS: 9,
      PACO_VARIABLES: 10,
      PACO_TRIGGERS: 11,
      PACO_PORT_SETVARIABLE: 12,
      PACO_PORT_SETANIMATED: 13,
      PACO_PORT_ANIM_UPDATED: 14,
      PACO_DESERIALIZE: 15,
      PACO_OP_RELOAD: 16,
    },
  };

  /**
   * extend javascript functionality
   */

  /**
   * @external Math
   */

  /**
   * set random seed for seededRandom()
   * @type Number
   * @static
   */
  Math.randomSeed = 1;

  /**
   * @function external:Math#setRandomSeed
   * @param {number} seed
   */
  Math.setRandomSeed = function (seed) {
    // https://github.com/cables-gl/cables_docs/issues/622
    Math.randomSeed = seed * 50728129;
    if (seed != 0) {
      Math.randomSeed = Math.seededRandom() * 17624813;
      Math.randomSeed = Math.seededRandom() * 9737333;
    }
  };

  /**
   * generate a seeded random number
   * @function seededRandom
   * @memberof Math
   * @param {Number} max minimum possible random number
   * @param {Number} min maximum possible random number
   * @return {Number} random value
   * @static
   */
  Math.seededRandom = function (max, min) {
    if (Math.randomSeed === 0) Math.randomSeed = Math.random() * 999;
    max = max || 1;
    min = min || 0;

    Math.randomSeed = (Math.randomSeed * 9301 + 49297) % 233280;
    const rnd = Math.randomSeed / 233280.0;

    return min + rnd * (max - min);
  };

  /**
   * @namespace String
   */

  /**
   * append a linebreak to a string
   * @this {String}
   * @returns {string} string with newline appended
   */
  String.prototype.endl = function () {
    return this + "\n";
  };

  String.prototype.contains = function (str) {
    console.warn("string.contains deprecated, use string.includes");
    console.log(new Error().stack);
    return this.includes(str);
  };

  /**
   * @namespace external:CABLES#Utils
   */


  /**
   * Merge two Float32Arrays.
   * @function float32Concat
   * @param {Float32Array} first Left-hand side array
   * @param {Float32Array} second Right-hand side array
   * @return {Float32Array}
   * @static
   */
  function float32Concat(first, second) {
    if (!(first instanceof Float32Array)) first = new Float32Array(first);
    if (!(second instanceof Float32Array)) second = new Float32Array(second);

    const result = new Float32Array(first.length + second.length);

    result.set(first);
    result.set(second, first.length);

    return result;
  }

  /**
   * get op shortname: only last part of fullname and without version
   * @function getShortOpName
   * @memberof CABLES
   * @param {string} fullname full op name
   * @static
   */
  const getShortOpName = function (fullname) {
    let name = fullname.split(".")[fullname.split(".").length - 1];

    if (name.includes(CONSTANTS.OP.OP_VERSION_PREFIX)) {
      const n = name.split(CONSTANTS.OP.OP_VERSION_PREFIX)[1];
      name = name.substring(
        0,
        name.length - (CONSTANTS.OP.OP_VERSION_PREFIX + n).length,
      );
    }
    return name;
  };

  /**
   * randomize order of an array
   * @function shuffleArray
   * @param {Array|Float32Array} array {Array} original
   * @return {Array|Float32Array} shuffled array
   * @static
   */
  const shuffleArray = function (array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.seededRandom() * (i + 1));
      const temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
    return array;
  };

  /**
   * generate a short "relativly unique" id
   * @function shortId
   * @return {String} generated ID
   * @static
   */

  const _shortIds = {};
  const shortId = function () {
    let str = Math.random().toString(36).substr(2, 9);

    if (_shortIds.hasOwnProperty(str)) str = shortId();
    _shortIds[str] = true;
    return str;
  };

  /**
   * @typedef {String} UUID
   */

  /**
   * generate a UUID
   * @function uuid
   * @return {UUID} generated UUID
   * @static
   */
  const uuid = function () {
    let d = new Date().getTime();
    const uuidStr = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      (c) => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == "x" ? r : (r & 0x3) | 0x8).toString(16);
      },
    );
    return uuidStr;
  };
  const generateUUID = uuid;

  function cleanJson(obj) {
    for (const i in obj) {
      if (obj[i] && typeof objValue === "object" && obj[i].constructor === Object)
        obj[i] = cleanJson(obj[i]);

      if (obj[i] === null || obj[i] === undefined) delete obj[i];
      else if (Array.isArray(obj[i]) && obj[i].length == 0) delete obj[i];
    }

    return obj;
  }

  /**
   * @see http://stackoverflow.com/q/7616461/940217
   * @param {string} str
   * @param {string} prefix
   * @return {string}
   */
  const prefixedHash = function (str, prefix = "id") {
    let hash = 0;
    if (str.length > 0) {
      for (let i = 0; i < str.length; i++) {
        let character = str.charCodeAt(i);
        hash = (hash << 5) - hash + character;
        hash &= hash; // Convert to 32bit integer
      }
    }
    return prefix + "" + hash;
  };

  /**
   * generate a simple ID
   * @return {Number} new id
   * @static
   */
  let simpleIdCounter = 0;
  const simpleId = function () {
    simpleIdCounter++;
    return simpleIdCounter;
  };

  /**
   * smoothStep a value
   * @param {Number} perc value value to be smoothed [0-1]
   * @return {Number} smoothed value
   * @static
   */
  const smoothStep = function (perc) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * (3 - 2 * x); // smoothstep
    return perc;
  };

  /**
   * smootherstep a value
   * @param {Number} perc value to be smoothed [0-1]
   * @return {Number} smoothed value
   * @static
   */
  const smootherStep = function (perc) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep
    return perc;
  };

  /**
   * clamp number / make sure its between min/max
   * @param {Number} value value to be mapped
   * @param {Number} min minimum value
   * @param {Number} max maximum value
   * @static
   */
  const clamp = function (value, min, max) {
    return Math.min(Math.max(value, min), max);
  };

  /**
   * map a value in a range to a value in another range
   * @param {Number} x value to be mapped
   * @param {Number} _oldMin old range minimum value
   * @param {Number} _oldMax old range maximum value
   * @param {Number} _newMin new range minimum value
   * @param {Number} _newMax new range maximum value
   * @param {Number} _easing
   * @return {Number} mapped value
   * @static
   */
  const map = function (
    x,
    _oldMin,
    _oldMax,
    _newMin,
    _newMax,
    _easing = 0,
    clamp = true,
  ) {
    if (clamp) {
      if (x >= _oldMax) return _newMax;
      if (x <= _oldMin) return _newMin;
    }

    let reverseInput = false;
    const oldMin = Math.min(_oldMin, _oldMax);
    const oldMax = Math.max(_oldMin, _oldMax);
    if (oldMin != _oldMin) reverseInput = true;

    let reverseOutput = false;
    const newMin = Math.min(_newMin, _newMax);
    const newMax = Math.max(_newMin, _newMax);
    if (newMin != _newMin) reverseOutput = true;

    let portion = 0;
    let r = 0;

    if (reverseInput)
      portion = ((oldMax - x) * (newMax - newMin)) / (oldMax - oldMin);
    else portion = ((x - oldMin) * (newMax - newMin)) / (oldMax - oldMin);

    if (reverseOutput) r = newMax - portion;
    else r = portion + newMin;

    if (!_easing) return r;
    if (_easing == 1) {
      // smoothstep
      x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
      return _newMin + x * x * (3 - 2 * x) * (_newMax - _newMin);
    }
    if (_easing == 2) {
      // smootherstep
      x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
      return _newMin + x * x * x * (x * (x * 6 - 15) + 10) * (_newMax - _newMin);
    }

    return r;
  };

  // ----------------------------------------------------------------

  /**
   * returns true if parameter is a number
   * @param {any} n value The value to check.
   * @return {Boolean}
   * @static
   */
  function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * returns true if parameter is array
   * @function isArray
   * @param {any} v value Value to check
   * @return {Boolean}
   * @static
   */
  function isArray(v) {
    return Object.prototype.toString.call(v) === "[object Array]";
  }

  // ----------------------------------------------------------------

  /**
   * append a unique/random parameter to a url, so the browser is forced to reload the file, even if its cached
   * @static
   * @param {String} url The url to append the cachebuster parameter to.
   * @return {String} url with cachebuster parameter
   */
  const cacheBust = function (url = "") {
    if (!url) return "";
    if (url.startsWith("data:")) return;
    if (url.includes("?")) url += "&";
    else url += "?";
    return url + "cache=" + CABLES.uuid();
  };

  /**
   * copy the content of an array
   * @static
   * @param {Array} src sourceArray
   * @param {Array} dst optional
   * @return {Array} dst
   */
  const copyArray = function (src, dst) {
    if (!src) return null;
    dst = dst || [];
    dst.length = src.length;
    for (let i = 0; i < src.length; i++) dst[i] = src[i];

    return dst;
  };

  /**
   * return the filename part of a url without extension
   * @static
   * @param {String} url
   * @return {String} just the filename
   */
  const basename = function (url) {
    let name = CABLES.filename(url);

    const parts2 = name.split(".");
    name = parts2[0];

    return name;
  };

  /**
   * output a stacktrace to the console
   * @static
   */
  const logStack = function () {
    console.log("logstack", new Error().stack);
  };

  /**
   * return the filename part of a url
   * @static
   * @param {String} url
   * @return {String} just the filename
   */
  const filename = function (url) {
    let name = "";
    if (!url) return "";

    if (url.startsWith("data:") && url.includes(":")) {
      const parts = url.split(",");
      return parts[0];
    }

    let parts = (url + "").split("/");
    if (parts.length > 0) {
      const str = parts[parts.length - 1];
      let parts2 = str.split("?");
      name = parts2[0];
    }

    return name || "";
  };

  const ajaxSync = function (url, cb, method, post, contenttype) {
    request({
      url: url,
      cb: cb,
      method: method,
      data: post,
      contenttype: contenttype,
      sync: true,
    });
  };

  /**
   * make an ajax request
   * @static
   * @function ajax
   * @param url
   * @param cb
   * @param method
   * @param post
   * @param contenttype
   * @param jsonP
   * @param headers
   * @param options
   */
  const ajax = function (
    url,
    cb,
    method,
    post,
    contenttype,
    jsonP,
    headers = {},
    options = {},
  ) {
    const requestOptions = {
      url: url,
      cb: cb,
      method: method,
      data: post,
      contenttype: contenttype,
      sync: false,
      jsonP: jsonP,
      headers: headers,
    };
    if (options && options.credentials)
      requestOptions.credentials = options.credentials;
    request(requestOptions);
  };

  const request = function (options) {
    if (!options.hasOwnProperty("asynch")) options.asynch = true;

    let xhr;
    try {
      xhr = new XMLHttpRequest();
    } catch (e) {}

    xhr.onreadystatechange = function () {
      if (xhr.readyState != 4) return;

      if (options.cb) {
        if (xhr.status == 200 || xhr.status == 0)
          options.cb(false, xhr.responseText, xhr);
        else options.cb(true, xhr.responseText, xhr);
      }
    };

    try {
      xhr.open(
        options.method ? options.method.toUpperCase() : "GET",
        options.url,
        !options.sync,
      );
    } catch (e) {
      if (options.cb && e) options.cb(true, e.msg, xhr);
    }

    if (typeof options.headers === "object") {
      if (options.headers) {
        const keys = Object.keys(options.headers);
        for (let i = 0; i < keys.length; i++) {
          const name = keys[i];
          const value = options.headers[name];
          xhr.setRequestHeader(name, value);
        }
      }
    }

    if (options.credentials && options.credentials !== "omit") {
      xhr.withCredentials = true;
    }

    try {
      if (!options.post && !options.data) {
        xhr.send();
      } else {
        xhr.setRequestHeader(
          "Content-type",
          options.contenttype
            ? options.contenttype
            : "application/x-www-form-urlencoded",
        );
        xhr.send(options.data || options.post);
      }
    } catch (e) {
      if (options.cb) options.cb(true, e.msg, xhr);
    }
  };

  // ----------------------------------------------------------------

  const logErrorConsole = function (initiator) {
    CABLES.errorConsole = CABLES.errorConsole || { log: [] };
    CABLES.errorConsole.log.push({ initiator: initiator, arguments: arguments });

    if (!CABLES.errorConsole.ele) {
      const ele = document.createElement("div");
      ele.id = "cablesErrorConsole";
      ele.style.width = "90%";
      ele.style.height = "300px";
      ele.style.zIndex = "9999999";
      ele.style.display = "inline-block";
      ele.style.position = "absolute";
      ele.style.padding = "10px";
      ele.style.fontFamily = "monospace";
      ele.style.color = "red";
      ele.style.backgroundColor = "#200";

      CABLES.errorConsole.ele = ele;
      document.body.appendChild(ele);
    }

    let logHtml =
      "ERROR<br/>for more info, open your browsers dev tools console (Ctrl+Shift+I or Command+Alt+I)<br/>";

    for (let l = 0; l < CABLES.errorConsole.log.length; l++) {
      logHtml += CABLES.errorConsole.log[l].initiator + " ";
      for (let i = 1; i < CABLES.errorConsole.log[l].arguments.length; i++) {
        if (i > 2) logHtml += ", ";
        let arg = CABLES.errorConsole.log[l].arguments[i];
        if (
          arg.constructor.name.indexOf("Error") > -1 ||
          arg.constructor.name.indexOf("error") > -1
        ) {
          let txt = "Uncaught ErrorEvent ";
          if (arg.message) txt += " message: " + arg.message;
          logHtml += txt;
        } else if (typeof arg == "string") logHtml += arg;
        else if (typeof arg == "number") logHtml += String(arg) + " ";
      }
      logHtml += "<br/>";
    }

    CABLES.errorConsole.ele.innerHTML = logHtml;
  };

  /**
   * @param {Array<any>} arr
   */
  function uniqueArray(arr) {
    const u = {},
      a = [];
    for (let i = 0, l = arr.length; i < l; ++i) {
      if (!u.hasOwnProperty(arr[i])) {
        a.push(arr[i]);
        u[arr[i]] = 1;
      }
    }
    return a;
  }

  const EMBED = {};

  /**
   * add patch into html element (will create canvas and set size to fill containerElement)
   * @name CABLES.EMBED#addPatch
   * @param {object|string} _element containerElement dom element or id of element
   * @param {Object} options patch options
   * @function
   */
  EMBED.addPatch = function (_element, options) {
    let el = _element;
    let id = generateUUID();
    if (typeof _element == "string") {
      id = _element;
      el = document.getElementById(id);

      if (!el) {
        console.error(id + " Polyshape Container Element not found!");
        return;
      }
    }

    const canvEl = document.createElement("canvas");
    canvEl.id = "glcanvas_" + id;
    canvEl.width = el.clientWidth;
    canvEl.height = el.clientHeight;

    window.addEventListener(
      "resize",
      function () {
        this.setAttribute("width", el.clientWidth);
        this.height = el.clientHeight;
      }.bind(canvEl),
    );

    el.appendChild(canvEl);

    options = options || {};
    options.glCanvasId = canvEl.id;

    if (!options.onError) {
      options.onError = function (err) {
        console.error(err);
      };
    }

    CABLES.patch = new Patch(options);
    return canvEl;
  };

  /** @namespace WEBAUDIO */


  const WEBAUDIO = {};

  WEBAUDIO.toneJsInitialized = false;

  /*
   * External JSDoc definitions
   */

  /**
   * Part of the Web Audio API, the AudioBuffer interface represents a short audio asset residing in memory.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer}
   */

  /**
   * Part of the Web Audio API, the AudioNode interface is a generic interface for representing an audio processing module.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioNode}
   */

  /**
   * The AudioContext interface represents an audio-processing graph built from audio modules linked together
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext}
   */

  /**
   * Checks if a global audio context has been created and creates
   * it if necessary. This audio context can be used for native Web Audio as well as Tone.js ops.
   * Associates the audio context with Tone.js if it is being used
   * @param {Op} op - The operator which needs the Audio Context
   */
  WEBAUDIO.createAudioContext = function (op) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    if (window.AudioContext) {
      if (!window.audioContext) {
        window.audioContext = new AudioContext();
      }
      // check if tone.js lib is being used
      if (window.Tone && !WEBAUDIO.toneJsInitialized) {
        // set current audio context in tone.js
        Tone.setContext(window.audioContext);
        WEBAUDIO.toneJsInitialized = true;
      }
    } else {
      if (op.patch.config.onError)
        op.logError("NO_WEBAUDIO", "Web Audio is not supported in this browser.");
      return;
    }
    return window.audioContext;
  };

  /**
   * Returns the audio context.
   * Before `createAudioContext` must have been called at least once.
   * It most cases you should use `createAudioContext`, which just returns the audio context
   * when it has been created already.
   */
  WEBAUDIO.getAudioContext = function () {
    return window.audioContext;
  };

  /**
   * Creates an audio in port for the op with name `portName`
   * When disconnected it will disconnect the previous connected audio node
   * from the op's audio node.
   * @param {Op} op - The operator to create the audio port in
   * @param {string} portName - The name of the port
   * @param {AudioNode} audioNode - The audionode incoming connections should connect to
   * @param {number} [inputChannelIndex=0] - If the audio node has multiple inputs, this is the index of the input channel to connect to
   * @returns {Port|undefined} - The newly created audio in port or `undefined` if there was an error
   */
  WEBAUDIO.createAudioInPort = function (
    op,
    portName,
    audioNode,
    inputChannelIndex,
  ) {
    if (!op || !portName || !audioNode) {
      const msg =
        "ERROR: createAudioInPort needs three parameters, op, portName and audioNode";
      op.log(msg);
      throw new Error(msg);
      // return;
    }
    if (!inputChannelIndex) {
      inputChannelIndex = 0;
    }
    op.webAudio = op.webAudio || {};
    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
    const port = op.inObject(portName);
    port.webAudio = {};
    port.webAudio.previousAudioInNode = null;
    port.webAudio.audioNode = audioNode;

    op.webAudio.audioInPorts[portName] = port;

    port.onChange = function () {
      const audioInNode = port.get();
      // when port disconnected, disconnect audio nodes
      if (!audioInNode) {
        if (port.webAudio.previousAudioInNode) {
          try {
            if (port.webAudio.previousAudioInNode.disconnect)
              port.webAudio.previousAudioInNode.disconnect(
                port.webAudio.audioNode,
                0,
                inputChannelIndex,
              );
            op.setUiError("audioCtx", null);
          } catch (e) {
            try {
              port.webAudio.previousAudioInNode.disconnect(
                port.webAudio.audioNode,
              );
            } catch (er) {
              op.log(
                "Disconnecting audio node with in/out port index, as well as without in/out-port-index did not work ",
                e,
              );
              if (e.printStackTrace) {
                e.printStackTrace();
              }
              throw e;
            }
          }
        }
      } else {
        try {
          if (audioInNode.connect) {
            audioInNode.connect(port.webAudio.audioNode, 0, inputChannelIndex);
            op.setUiError("audioCtx", null);
          } else
            op.setUiError(
              "audioCtx",
              "The passed input is not an audio context. Please make sure you connect an audio context to the input.",
              2,
            );
        } catch (e) {
          op.log("Error: Failed to connect web audio node!", e);
          op.log("port.webAudio.audioNode", port.webAudio.audioNode);
          op.log("audioInNode: ", audioInNode);
          op.log("inputChannelIndex:", inputChannelIndex);
          op.log("audioInNode.connect: ", audioInNode.connect);
          throw e;
        }
      }
      port.webAudio.previousAudioInNode = audioInNode;
    };
    // TODO: Maybe add subtype to audio-node-object?
    return port;
  };

  /**
   * Sometimes it is necessary to replace a node of a port, if so all
   * connections to this node must be disconnected and connections to the new
   * node must be made.
   * Can be used for both Audio ports as well as AudioParam ports
   * if used with an AudioParam pass e.g. `synth.frequency` as newNode
   * @param {Port} port - The port where the audio node needs to be replaced
   * @param oldNode
   * @param newNode
   */
  WEBAUDIO.replaceNodeInPort = function (port, oldNode, newNode) {
    const connectedNode = port.webAudio.previousAudioInNode;
    // check if connected
    if (connectedNode && connectedNode.disconnect) {
      try {
        connectedNode.disconnect(oldNode);
      } catch (e) {
        if (e.printStackTrace) {
          e.printStackTrace();
        }
        throw new Error(
          "replaceNodeInPort: Could not disconnect old audio node. " +
            e.name +
            " " +
            e.message,
        );
      }
      port.webAudio.audioNode = newNode;
      try {
        connectedNode.connect(newNode);
      } catch (e) {
        if (e.printStackTrace) {
          e.printStackTrace();
        }
        throw new Error(
          "replaceNodeInPort: Could not connect to new node. " +
            e.name +
            " " +
            e.message,
        );
      }
    }
  };

  /**
   * Creates an audio out port which takes care of (dis-)connecting on its own
   * @param {Op} op - The op to create an audio out port for
   * @param {string} portName - The name of the port to be created
   * @param {AudioNode} audioNode - The audio node to link to the port
   * @returns {(CABLES.Port|undefined)} - The newly created audio out port or `undefined` if there was an error
   */
  WEBAUDIO.createAudioOutPort = function (op, portName, audioNode) {
    if (!op || !portName || !audioNode) {
      const msg =
        "ERROR: createAudioOutPort needs three parameters, op, portName and audioNode";
      op.log(msg);
      throw new Error(msg);
    }

    const port = op.outObject(portName);
    // TODO: Maybe add subtype to audio-node-object?
    port.set(audioNode);
    return port;
  };

  /**
   * Creates an audio param in port for the op with name portName.
   * The port accepts other audio nodes as signals as well as values (numbers)
   * When the port is disconnected it will disconnect the previous connected audio node
   * from the op's audio node and restore the number value set before.
   * @param {Op} op - The operator to create an audio param input port for
   * @param {string} portName - The name of the port to create
   * @param audioNode
   * @param options
   * @param defaultValue
   * @returns {(CABLES.Port|undefined)} - The newly created port, which takes care of (dis-)connecting on its own, or `undefined` if there was an error
   */
  WEBAUDIO.createAudioParamInPort = function (
    op,
    portName,
    audioNode,
    options,
    defaultValue,
  ) {
    if (!op || !portName || !audioNode) {
      op.log(
        "ERROR: createAudioParamInPort needs three parameters, op, portName and audioNode",
      );
      if (op && op.name) op.log("opname: ", op.name);
      op.log("portName", portName);
      op.log("audioNode: ", audioNode);
      return;
    }
    op.webAudio = op.webAudio || {};
    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
    // var port = op.inObject(portName);
    const port = op.inDynamic(
      portName,
      [CONSTANTS.OP.OP_PORT_TYPE_VALUE, CONSTANTS.OP.OP_PORT_TYPE_OBJECT],
      options,
      defaultValue,
    );
    port.webAudio = {};
    port.webAudio.previousAudioInNode = null;
    port.webAudio.audioNode = audioNode;

    op.webAudio.audioInPorts[portName] = port;

    /*
     * port.onLinkChanged = function() {
     *   op.log("onLinkChanged");
     *   if(port.isLinked()) {
     *
     *       if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_) { // value
     *
     *       } else if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) { // object
     *
     *       }
     *   } else { // unlinked
     *
     *   }
     * };
     */

    port.onChange = function () {
      const audioInNode = port.get();
      const node = port.webAudio.audioNode;
      const audioCtx = WEBAUDIO.getAudioContext();

      if (audioInNode != undefined) {
        if (typeof audioInNode === "object" && audioInNode.connect) {
          try {
            audioInNode.connect(node);
          } catch (e) {
            op.log("Could not connect audio node: ", e);
            if (e.printStackTrace) {
              e.printStackTrace();
            }
            throw e;
          }
          port.webAudio.previousAudioInNode = audioInNode;
        } else {
          // tone.js audio param
          if (node._param && node._param.minValue && node._param.maxValue) {
            if (
              audioInNode >= node._param.minValue &&
              audioInNode <= node._param.maxValue
            ) {
              try {
                if (node.setValueAtTime) {
                  node.setValueAtTime(audioInNode, audioCtx.currentTime);
                } else {
                  node.value = audioInNode;
                }
              } catch (e) {
                op.log("Possible AudioParam problem with tone.js op: ", e);
                if (e.printStackTrace) {
                  e.printStackTrace();
                }
                throw e;
              }
            } else {
              op.log(
                "Warning: The value for an audio parameter is out of range!",
              );
            }
          } // native Web Audio param
          else if (node.minValue && node.maxValue) {
            if (audioInNode >= node.minValue && audioInNode <= node.maxValue) {
              try {
                if (node.setValueAtTime) {
                  node.setValueAtTime(audioInNode, audioCtx.currentTime);
                } else {
                  node.value = audioInNode;
                }
              } catch (e) {
                op.log(
                  "AudioParam has minValue / maxValue defined, and value is in range, but setting the value failed! ",
                  e,
                );
                if (e.printStackTrace) {
                  e.printStackTrace();
                }
                throw e;
              }
            } else {
              op.log(
                "Warning: The value for an audio parameter is out of range!",
              );
            }
          } // no min-max values, try anyway
          else {
            try {
              if (node.setValueAtTime) {
                node.setValueAtTime(audioInNode, audioCtx.currentTime);
              } else {
                node.value = audioInNode;
              }
            } catch (e) {
              op.log(
                "Possible AudioParam problem (without minValue / maxValue): ",
                e,
              );
              if (e.printStackTrace) {
                e.printStackTrace();
              }
              throw e;
            }
          }

          if (
            port.webAudio.previousAudioInNode &&
            port.webAudio.previousAudioInNode.disconnect
          ) {
            try {
              port.webAudio.previousAudioInNode.disconnect(node);
            } catch (e) {
              op.log("Could not disconnect previous audio node: ", e);
              throw e;
            }
            port.webAudio.previousAudioInNode = undefined;
          }
        }
      } else {
        // disconnected
        if (port.webAudio.previousAudioInNode) ;
      }
    };
    return port;
  };

  /**
   * Loads an audio file and updates the loading indicators when cables is run in the editor.
   * @param {Patch} patch - The cables patch, when called from inside an op this is `op.patch`
   * @param {string} url - The url of the audio file to load
   * @param {function} onFinished - The callback to be called when the loading is finished, passes the AudioBuffer
   * @param {function} onError - The callback when there was an error loading the file, the rror message is passed
   * @param loadingTask
   * @see {@link https://developer.mozilla.org/de/docs/Web/API/AudioContext/decodeAudioData}
   */
  WEBAUDIO.loadAudioFile = function (
    patch,
    url,
    onFinished,
    onError,
    loadingTask,
  ) {
    const audioContext = WEBAUDIO.createAudioContext();

    if (!audioContext) onError(new Error("No Audiocontext"));

    let loadingId = null;
    if (loadingTask || loadingTask === undefined) {
      loadingId = patch.loading.start("audio", url);
      if (patch.isEditorMode())
        gui.jobs().start({
          id: "loadaudio" + loadingId,
          title: " loading audio (" + url + ")",
        });
    }
    const request = new XMLHttpRequest();

    if (!url) return;

    request.open("GET", url, true);
    request.responseType = "arraybuffer";

    request.onload = function () {
      patch.loading.finished(loadingId);
      if (patch.isEditorMode()) gui.jobs().finish("loadaudio" + loadingId);

      audioContext
        .decodeAudioData(request.response, onFinished, onError)
        .catch((e) => {
          onError(e);
        });
    };
    request.send();
  };

  /**
   * Checks if the passed time is a valid time to be used in any of the Tone.js ops.
   * @param {(string|number)} t - The time to check
   * @returns {boolean} - True if time is valid, false if not
   */
  WEBAUDIO.isValidToneTime = function (t) {
    try {
      const time = new Tone.Time(t);
    } catch (e) {
      return false;
    }
    return true;
  };

  /**
   * Checks if the passed note is a valid note to be used with Tone.js
   * @param {string} note - The note to be checked, e.g. `"C4"`
   * @returns {boolean} - True if the note is a valid note, false otherwise
   */
  WEBAUDIO.isValidToneNote = function (note) {
    try {
      Tone.Frequency(note);
    } catch (e) {
      return false;
    }
    return true;
  };

  // todo: old... remove this from ops...

  /**
   * todo: old... remove this from ops...
   *
   * @class
   */
  const Variable = function () {
    let value = null;
    const changedCallbacks = [];

    this.onChanged = function (f) {
      changedCallbacks.push(f);
    };

    this.getValue = function () {
      return value;
    };

    this.setValue = function (v) {
      value = v;
      this.emitChanged();
    };

    this.emitChanged = function () {
      for (let i = 0; i < changedCallbacks.length; i++) {
        changedCallbacks[i]();
      }
    };
  };

  var defaultShaderSrcVert = `
struct MyVSInput
{
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) texcoord: vec2<f32>,
};

struct MyVSOutput
{
    @builtin(position) position: vec4<f32>,
    @location(0) normal: vec3<f32>,
    @location(1) texcoord: vec2<f32>,
};

@vertex
fn myVSMain(v: MyVSInput) -> MyVSOutput
{
    var vsOut: MyVSOutput;
    var pos =vec4<f32>(v.position, 1.0);

    var mvMatrix=uniVert.viewMatrix * uniVert.modelMatrix;
    vsOut.position = uniVert.projMatrix * mvMatrix * pos;

    vsOut.normal = v.normal;
    vsOut.texcoord = v.texcoord;
    return vsOut;
}

@fragment
fn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>
{
    return vec4<f32>(.5,.5,.5,1.0);
}

`;

  class CgpUniform extends CgUniform {
    /** @type {CgpContext} */
    #cgp = null;

    /** @type {GPUBuffer} */
    gpuBuffer = null;

    gpuBufferChanged = false;

    /**
     * Description
     * @param {CgpShader} __shader
     * @param {string} __type
     * @param {string} __name
     * @param {any} _value
     * @param {any} _port2
     * @param {any} _port3
     * @param {any} _port4
     */
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4) {
      super(__shader, __type, __name, _value, _port2, _port3, _port4);
      this.#cgp = __shader._cgp;

      if (!_value || (_value.get && !_value.get())) {
        // if (this.getType() == "m4") this._value = mat4.create();
        if (this.getType() == "t") {
          this._value = this.#cgp.getEmptyTexture();
        }
        // else if (this.getType() == "2f") this._value = [0, 0];
        // else if (this.getType() == "4f") this._value = [0, 1, 0, 1];
        // else if (this.getType() == "3f") this._value = [0, 1, 0];
      }
    }

    getInfo() {
      return { name: this.name, type: this.type, value: this.getValue() };
    }

    updateValueF() {}

    updateValueArrayF() {}

    setValueArrayF(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    setValueF(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValue2F() {}

    setValue2F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValue3F() {}

    setValue3F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValue4F() {}

    setValue4F(v) {
      if (v[0] == undefined) {
        this._log.stack("uniform value undefined");
        console.error("uniform value undefined");
      }
      this.needsUpdate = true;
      this._value = v;
    }

    setValueT(v) {
      // if (this._value != v)
      //     this._shader.needsPipelineUpdate = "texture changed"; // todo really needed ? change binding instead?

      this.needsUpdate = true;
      this._value = v;
    }

    updateValueM4(v) {}

    setValueM4(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    setValueAny(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueAny() {}

    updateValueT() {}

    /**
     * @param {GPUBuffer} b
     */
    setGpuBuffer(b) {
      this.gpuBufferChanged = true;
      this.gpuBuffer = b;
    }

    copyToBuffer(buff, pos = 0) {
      if (this._type == "f") {
        buff[pos] = this._value;
      } else if (this._type == "t") ; else if (this._type == "4f") {
        buff[pos] = this._value[0];
        buff[pos + 1] = this._value[1];
        buff[pos + 2] = this._value[2];
        buff[pos + 3] = this._value[3];
      } else if (this._type == "2f") {
        buff[pos] = this._value[0];
        buff[pos + 1] = this._value[1];
      } else if (this._type == "3f") {
        buff[pos] = this._value[0];
        buff[pos + 1] = this._value[1];
        buff[pos + 2] = this._value[2];
      } else if (this._type == "f[]") {
        for (let i = 0; i < this._value.length; i++)
          buff[pos + i] = this._value[i];
      } else if (this._type == "m4") {
        for (let i = 0; i < 16; i++) buff[pos + i] = this._value[i];
      } else {
        this._log.warn("uniform copy to buffer unknown", this._type);
      }
    }

    getWgslTypeStr() {
      if (this._type == "m4") return "mat4x4f";
      if (this._type == "4f") return "vec4f";
      if (this._type == "3f") return "vec3f";
      if (this._type == "2f") return "vec2f";
      if (this._type == "f") return "f32";
      if (this._type == "f[]") return "array<vec4f>";
      if (this._type == "i") return "int";
      if (this._type == "sampler") return "sampler";
      if (this._type == "t") return "texture_2d<f32>";
      this._log.warn("unknown type getWgslTypeStr", this._type);
      return "???";
    }

    getSizeBytes() {
      const bytesPerFloat = 4;
      const bytesPerInt = 4;
      if (this._type == "t") return 4;
      if (this._type == "sampler") return 4;
      if (this._type == "f") return 1 * bytesPerFloat;
      if (this._type == "2f") return 2 * bytesPerFloat;
      if (this._type == "3f") return 3 * bytesPerFloat;
      if (this._type == "4f") return 4 * bytesPerFloat;
      if (this._type == "f[]") return this._value.length * bytesPerFloat;
      if (this._type == "m4") return 4 * 4 * bytesPerFloat;
      if (this._type == "i") return 1 * bytesPerInt;
      if (this._type == "2i") return 2 * bytesPerInt;

      this._log.warn("unknown type getSizeBytes", this._type);
      return 4;
    }

    /**
     * @param {CgpShader} shader
     */
    copy(shader) {
      const uni = new CgpUniform(
        shader,
        this._type,
        this._name,
        this._value,
        this._port2,
        this._port3,
        this._port4,
      );
      uni.shaderType = this.shaderType;

      // console.log(this._name, this._value, uni._value);

      return uni;
    }
  }

  /**
   * @param {string} str
   * @param {object} vars
   */
  function preproc(str, vars) {
    if (!str) {
      console.warn("shader preproc no shader code given");
    }
    str = str || "";
    const lines = str.split("\n");
    const outLines = [];
    let stack = [];

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      let parts = line.split(" ");

      if (line.startsWith("#ifdef ")) {
        const s = vars[parts[1]];
        stack.push({ state: s });
        continue;
      }
      if (line.startsWith("#ifndef ")) {
        const s = vars[parts[1]];
        stack.push({ state: !s });
        continue;
      }
      if (line.startsWith("#endif")) {
        stack.pop();
        continue;
      }
      const state = stack[stack.length - 1];

      if (line.startsWith("#else")) {
        state.state = !state.state;
        continue;
      }

      if (!state || state.state) {
        outLines.push(lines[i]);
      }
    }

    return outLines.join("\n");
  }

  class Binding {
    id = simpleId();
    name = "";
    bindNum = 0;
    stage = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
    define = "";
    log = new Logger("binding");
    needsRebuildBindgroup = false;

    /** @type {CgpContext} */
    cgp = null;

    /**
     * Description
     * @param {CgpContext} cgp
     * @param {string} name
     * @param {object} options
     */
    constructor(cgp, name, options) {
      this.cgp = cgp;
      this.name = name;
      if (!name) this.log.error("no binding name given");
      this.options = options || {};
      if (options.hasOwnProperty("stage")) this.stage = options.stage;
    }

    /**
     * @param {number} _inst
     */
    getResource(_inst) {
      // overwrite
      return null;
    }

    /**
     * @param {number} i
     */
    setBindNum(i) {
      if (this.bindNum != i) this.needsRebuildBindgroup = true;
      this.bindNum = i;
    }

    /**
     * @returns {GPUBindGroupLayoutEntry}
     * @param {CgpShader} _shader
     */
    getLayoutEntry(_shader) {
      this.log.warn("unknown binding type?", this);
      return null;
    }

    /**
     * @returns {GPUBindGroupEntry}
     * @param {number} inst
     */
    getBindgroupEntry(inst) {
      "layout " + this.name + " [" + this.constructor.name;

      return {
        binding: this.bindNum,
        resource: this.getResource(inst),
      };
    }

    /** @param {CgpShader} _shader */
    isActiveByDefine(_shader) {
      if (!this.define) return true;
      // if (this.define && !shader.hasDefine(this.define)) return false;
      return true;
    }

    /** @param {number} _inst */
    updateValues(_inst) {
      // overwrite
    }

    /**
     * @param {CgpShader} _shader
     * @param {number} _bindGroupNum
     * @returns {String}
     */
    getShaderHeaderCode(_shader, _bindGroupNum) {
      return "//getShaderHeaderCode function not emplemented " + nl;
    }

    /**
     * @param {CgpShader} _shader
     * @returns {Binding}
     */
    copy(_shader) {
      // implenented in inheriting classes
      return null;
    }

    getInfo() {
      const o = { name: this.name, id: this.id, class: this.constructor.name };
      return o;
    }
  }

  class BindGroup {
    /** @type {Array<GPUBindGroup>} */
    #gpuBindGroups = [];

    /** @type {Array<Binding>} */
    #bindings = [];

    name = "";

    needsPipelineUpdate = false;

    bla = 1;

    /** @type {CgpContext} */
    #cgp;

    /**
     * @param {CgpContext} cgp
     * @param {string} name
     */
    constructor(cgp, name) {
      this.#cgp = cgp;
      this.name = name;
    }

    /**
     * @returns {GPUBindGroup}
     */
    // get gpuBindgroup()
    // {
    //     if (!this.#gpuBindGroup)
    //     {
    //         this.create();
    //     }
    //     // console.log(this.#gpuBindGroup);
    //     return this.#gpuBindGroup;
    // }

    /**
     * @param {Binding} b
     * @returns {boolean}
     */
    hasBinding(b) {
      return this.#bindings.includes(b);
    }

    /**
     * @param {string} n
     * @returns {Binding}
     */
    getBindingByName(n) {
      for (let i = 0; i < this.#bindings.length; i++) {
        if (this.#bindings[i].name == n) return this.#bindings[i];
      }
    }

    /**
     * @param {Binding} b
     */
    removeBinding(b) {
      const idx = this.#bindings.indexOf(b);
      this.#bindings.splice(idx, 1);
    }

    /**
     * @param {Binding} b
     * @returns {Binding}
     */
    addBinding(b) {
      const oldBinding = this.getBindingByName(b.name);
      if (oldBinding) this.removeBinding(oldBinding);
      b.needsRebuildBindgroup = true;
      b.bindNum = this.#bindings.length;
      this.#bindings.push(b);

      return b;
    }

    // /**
    //  * @param {CgpShader} shader
    //  */
    // bind(shader)
    // {
    //     shader.setBindgroup(this);
    // }

    /**
     * @param {CgpShader} [shader]
     */
    getLayoutEntries(shader) {
      const arr = [];
      for (let i = 0; i < this.#bindings.length; i++) {
        arr.push(this.#bindings[i].getLayoutEntry(shader));
      }

      if (arr.length == 0) ;
      return arr;
    }

    /**
     * @returns {Array<GPUBindGroupEntry>}
     * @param {number} inst
     */
    getEntries(inst) {
      const arr = [];
      for (let i = 0; i < this.#bindings.length; i++) {
        arr.push(this.#bindings[i].getBindgroupEntry(inst));
      }

      if (arr.length == 0) ;
      return arr;
    }

    /**
     * @param {CgpShader} [shader]
     */
    getLayout(shader) {
      // console.log(this.getLayoutEntries(shader));

      /** @type {GPUBindGroupLayout} */
      const bindGroupLayout = this.#cgp.device.createBindGroupLayout({
        label: "bindgrouplayout " + this.name,
        entries: this.getLayoutEntries(shader),
      });

      return bindGroupLayout;
    }

    /**
     * @param {number} inst
     */
    create(inst) {
      /** @type {GPUBindGroupDescriptor} */
      const bg = {
        label: " " + this.name + " i" + inst,
        layout: this.getLayout(),
        entries: this.getEntries(inst),
      };

      this.#cgp.profileData.count("bindgroup created", this.name);

      // if (bindingGroupEntries.length != this.bindingGroupLayoutEntries.length)
      // {
      //     this.#log.error("bindingGroupEntries.length!= this.bindingGroupLayoutEntries.length", bindingGroupEntries.length, this.bindingGroupLayoutEntries.length);
      //     this.#rebuildNumBindingGroups = true;
      //     this.#isValid = false;
      //     return;
      // }

      try {
        this.#gpuBindGroups[inst] = this.#cgp.device.createBindGroup(bg);
        this.needsRebuildBindgroup = true;
      } catch (e) {
        console.log(bg);
        console.error(e);
      }

      this.updateValues(inst);
    }

    /**
     * @param {number} inst
     */
    updateValues(inst) {
      for (let i = 0; i < this.#bindings.length; i++) {
        this.#bindings[i].updateValues(inst);
      }
    }

    /**
     * @param {number} inst
     * @param {GPURenderPassEncoder|GPUComputePassEncoder} passEnc
     */
    bind(inst = 0, passEnc = null, idx = 0) {
      for (let i = 0; i < this.#bindings.length; i++)
        if (this.#bindings[i].needsRebuildBindgroup) {
          // console.log("rebuild bg");
          this.create(inst);
          this.#bindings[i].needsRebuildBindgroup = false;
          this.#gpuBindGroups = [];
          // todo: dispose
        }

      if (!this.#gpuBindGroups[inst]) this.create(inst);
      (passEnc || this.#cgp.passEncoder).setBindGroup(
        idx,
        this.#gpuBindGroups[inst],
      );
    }

    /**
     * @param {CgpShader} shader
     * @param {number} idx
     */
    getShaderHeaderCode(shader, idx) {
      const srcs = { vertex: "", fragment: "", compute: "" };

      this.#cgp.profileData.count("bindgroup shadercode", this.name);
      for (let i = 0; i < this.#bindings.length; i++) {
        const bind = this.#bindings[i];
        let src = "";
        src += bind.getShaderHeaderCode(shader, idx);
        if (bind.stage & GPUShaderStage.VERTEX) srcs.vertex += src;
        else if (bind.stage === GPUShaderStage.FRAGMENT) srcs.fragment += src;
        else if (bind.stage & GPUShaderStage.COMPUTE) srcs.compute += src;
      }

      return srcs;
    }

    /**
     * @param {CgpShader} shader
     */
    copy(shader) {
      const newBg = new BindGroup(this.#cgp, this.name);
      for (let i = 0; i < this.#bindings.length; i++) {
        newBg.addBinding(this.#bindings[i].copy(shader));
      }
      return newBg;
    }

    setBindingNums() {
      for (let i = 0; i < this.#bindings.length; i++) {
        this.#bindings[i].setBindNum(i);
      }
    }

    getInfo() {
      const o = { name: this.name, bindings: [] };
      for (let i = 0; i < this.#bindings.length; i++) {
        o.bindings.push(this.#bindings[i].getInfo());
      }
      return o;
    }
  }

  /** @typedef GPUBufferOptions
   * @property {number} [length]
   * @property {GPUBufferDescriptor} [buffCfg]
   */

  class CgpGguBuffer extends Events {
    #name = "unknown";

    /** @type {CgpContext} */
    #cgp = null;

    /** @type {GPUBuffer} */
    #gpuBuffer = null;

    /** @type {GPUBufferDescriptor} */
    buffCfg = null;

    #length = 0;
    id = CABLES.shortId();
    floatArr = null;
    needsUpdate = true;
    #log;

    // static BINDINGTYPE_STORAGE = "storage";
    // static BINDINGTYPE_UNIFORM = "uniform";
    // static BINDINGTYPE_READONLY_STORAGE = "read-only-storage";

    /**
     * Description
     * @param {CgpContext} cgp
     * @param {String} name
     * @param {Array} data=null
     * @param {GPUBufferOptions} options={}
     */
    constructor(cgp, name, data = null, options = {}) {
      super();
      this.#log = new Logger("cgpGpubuffer");
      if (!cgp.supported) return;

      this.#name = name;
      // this.setData([0, 0, 0, 0]);

      this.buffCfg = options.buffCfg || {};
      if (data) this.setData(data);
      if (options.length) this.setLength(options.length);

      this.buffCfg.usage =
        this.buffCfg.usage ||
        GPUBufferUsage.COPY_DST |
          GPUBufferUsage.STORAGE |
          GPUBufferUsage.COPY_SRC;
      this.updateGpuBuffer(cgp);
    }

    /**
     * @param {Array} arr
     */
    setData(arr) {
      this.floatArr = new Float32Array(arr);
      this.setLength(this.floatArr.length);

      this.needsUpdate = true;
    }

    /**
     * @param {number} s
     */
    setLength(s) {
      this.#length = s;
      if (!this.floatArr || s != this.floatArr.length) {
        this.floatArr = new Float32Array(this.#length);
        this.needsUpdate = true;
      }
    }

    /**
     * @param {number} flag
     */
    hasUsage(flag) {
      return (this.buffCfg.usage & flag) === flag;
    }

    /** @param {CgpContext} cgp */
    updateGpuBuffer(cgp = null) {
      if (cgp) this.#cgp = cgp;
      if (!this.#cgp || !this.#cgp.device) {
        this.#log.warn("no cgp...", this.#name, this.#cgp);
        return;
      }

      this.#cgp.pushErrorScope("updateGpuBuffer");
      if (!this.#gpuBuffer || this.buffCfg.mappedAtCreation) {
        this.buffCfg = /** @type {GPUBufferDescriptor} */ (this.buffCfg || {});
        this.buffCfg.label = "gpuBuffer-" + this.#name;
        if (!this.buffCfg.hasOwnProperty("size") && this.floatArr)
          this.buffCfg.size = this.floatArr.length * 4;

        this.#gpuBuffer = this.#cgp.device.createBuffer(this.buffCfg);
      }

      if (this.floatArr) {
        if (this.buffCfg.mappedAtCreation) {
          new Float32Array(this.#gpuBuffer.getMappedRange()).set(this.floatArr);
          this.#gpuBuffer.unmap();
        } else
          this.#cgp.device.queue.writeBuffer(
            this.#gpuBuffer,
            0,
            this.floatArr.buffer,
            this.floatArr.byteOffset,
            this.floatArr.byteLength,
          );
      }

      this.#cgp.popErrorScope();

      this.needsUpdate = false;
    }

    get name() {
      return this.#name;
    }

    /** @returns {GPUBuffer} */
    get gpuBuffer() {
      if (!this.#gpuBuffer || this.needsUpdate) this.updateGpuBuffer();

      return this.#gpuBuffer;
    }

    get length() {
      return this.#length;
    }

    getSizeBytes() {
      return this.floatArr.length * 4;
    }

    dispose() {
      // setTimeout(() =>
      // {
      //     if (this._gpuBuffer) this._gpuBuffer.destroy();
      // }, 100);
    }
  }

  /** @extends Binding */
  class BindingUniform extends Binding {
    /** @type {Array<CgpUniform>} */
    #uniforms = [];

    /** @type {Array<CgpGguBuffer>} */
    cgpBuffer = [];

    /**
     * Description
     * @param {CgpContext} cgp
     * @param {string} name
     * @param {object} options
     */
    constructor(cgp, name, options) {
      super(cgp, name, options);

      console.log("new binding uniform", this.id);
      // CABLES.logStack();
    }

    /**
     * @param {CgpShader} shader
     * @returns {Binding}
     */
    copy(shader) {
      const b = new BindingUniform(this.cgp, this.name, this.options);
      console.log("copybinuni", this.id, b.id);
      b.stage = this.stage;

      for (let i = 0; i < this.#uniforms.length; i++) {
        let foundWorldUni = false;
        for (let j = 0; j < shader.worldUniforms.length; j++) {
          if (shader.worldUniforms[j].getName() == this.#uniforms[i].getName()) {
            b.addUniform(shader.worldUniforms[j]);
            foundWorldUni = true;
          }
        }
        if (!foundWorldUni) b.addUniform(this.#uniforms[i]);
      }

      return b;
    }

    /**
     * @param {CgpUniform} u
     */
    addUniform(u) {
      this.#uniforms.push(u);
      this.needsRebuildBindgroup = true;
      console.log(this.#uniforms, this);
      // CABLES.logStack();
      return u;
    }

    /**
     * @returns {GPUBindingResource}
     * @param {number} inst
     */
    getResource(inst) {
      this.updateBuffer(inst);
      return {
        buffer: this.cgpBuffer[inst].gpuBuffer,
      };
    }

    getSizeBytes() {
      let size = 0;
      for (let i = 0; i < this.#uniforms.length; i++)
        size += this.#uniforms[i].getSizeBytes();

      return size;
    }

    /**
     * @param {string} name
     */
    getUniform(name) {
      for (let i = 0; i < this.#uniforms.length; i++) {
        if (this.#uniforms[i].name == name) return this.#uniforms[i];
      }
      return null;
    }

    /**
     * @param {string} name
     */
    removeUniformByName(name) {
      for (let i = 0; i < this.#uniforms.length; i++)
        if (this.#uniforms[i].name == name) {
          this.needsRebuildBindgroup = true;
          return this.#uniforms.splice(i, 1);
        }
    }

    /**
     * @param {number} inst
     */
    createBuffer(inst) {
      let buffCfg = {
        label: this.name,
        size: this.getSizeBytes(),
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
      };

      this.cgpBuffer[inst] = new CgpGguBuffer(
        this.cgp,
        this.name + " buff",
        null,
        { buffCfg: buffCfg },
      );
    }

    pipelineUpdated() {
      this.needsRebuildBindgroup = false;
    }

    needsPipeUpdate() {
      return this.needsRebuildBindgroup;
    }

    /**
     * @param {number} inst
     */
    updateBuffer(inst) {
      let info = {
        name: this.#uniforms.length + " uniforms",
        "stage ": CgpShader.getStageString(this.stage),
        uniforms: [],
      };

      let s = this.getSizeBytes() / 4;
      info.s = this.getSizeBytes();
      if (s == 16) s = 16;
      if (!this.cgpBuffer[inst]) {
        this.createBuffer(inst);
        // console.log("no cpubuff? ", s, this.#uniforms);
        // return;
      }
      this.cgpBuffer[inst].setLength(s);

      let off = 0;
      for (let i = 0; i < this.#uniforms.length; i++) {
        this.#uniforms[i].copyToBuffer(this.cgpBuffer[inst].floatArr, off);

        if (this.#uniforms[i].gpuBufferChanged)
          console.log("un changed", this.cgpBuffer[inst].floatArr);

        info.uniforms.push(this.#uniforms[i].getInfo());

        off += this.#uniforms[i].getSizeBytes() / 4;
      }
      if (this.cgp.branchProfiler)
        this.cgp.branchProfiler.push(
          "binding update buff",
          CgpShader.getStageString(this.stage),
          { info: info },
        );

      this.cgpBuffer[inst].updateGpuBuffer();

      if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();
    }

    /**
     * @param {CgpShader} shader
     * @param {number} bindGroupNum
     */
    getShaderHeaderCode(shader, bindGroupNum) {
      this.cgp.profileData.count("shadercode uni", this.name);
      let str = "";
      let typeStr = "";
      let name = this.name;

      str +=
        '//   [binding_uniform] - "' +
        this.name +
        '" ' +
        this.id +
        " uniforms:" +
        this.#uniforms.length +
        "\n";

      if (!this.isActiveByDefine(shader)) {
        str +=
          "// " +
          typeStr +
          " " +
          this.name +
          ": excluded because define " +
          this.define +
          "\n";
        return str;
      }

      if (this.#uniforms.length > 1) {
        typeStr = "strct_" + name;

        str += "struct " + typeStr + "\n";
        str += "{\n";
        // if (this.#uniforms.length == 0) str += "placehoder:1.";
        // else
        for (let i = 0; i < this.#uniforms.length; i++) {
          str +=
            "    " +
            this.#uniforms[i].name +
            ": " +
            this.#uniforms[i].getWgslTypeStr();
          if (i != this.#uniforms.length - 1) str += ",";
          str += "\n";
        }
        str += "};\n";
      } else if (this.#uniforms.length == 1) {
        typeStr = this.#uniforms[0].getWgslTypeStr();
        name = this.#uniforms[0].name;
      } else if (this.#uniforms.length == 0) {
        return str;
        // typeStr = "float";
        // name = "placeholder";
      }

      // console.log("shadercode uniforms", this.#uniforms[0].name);
      str += "@group(" + bindGroupNum + ") ";
      str += "@binding(" + this.bindNum + ") ";

      str += "var<uniform> ";
      str += name + ": " + typeStr + ";\n";

      // console.log(str);
      return str + "\n";
    }

    /** @returns {GPUBindGroupLayoutEntry} */
    getLayoutEntry() {
      return {
        visibility: this.stage,
        binding: this.bindNum,
        minBindingSize: this.getSizeBytes(),
        hasDynamicOffset: 0,
        buffer: {},
      };
    }

    /**
     * @param {number} inst
     */
    updateValues(inst) {
      for (let i = 0; i < this.#uniforms.length; i++) {
        // if (this.#uniforms[i].needsUpdate)
      }
      return this.updateBuffer(inst);
    }

    getInfo() {
      const o = {
        name: this.name,
        id: this.id,
        stage: this.stage,
        class: this.constructor.name,
        uniforms: [],
      };

      for (let i = 0; i < this.#uniforms.length; i++) {
        o.uniforms.push(this.#uniforms[i].getInfo());
      }
      return o;
    }
  }

  /** @extends Binding */
  class BindingSampler extends Binding {
    /** @type {GPUSamplerDescriptor} */
    smplDesc = {
      addressModeU: "mirror-repeat",
      addressModeV: "mirror-repeat",
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
    };

    /** @type {GPUSampler} */
    sampler = null;

    constructor(cgp, name, options) {
      super(cgp, name, options);
      this.sampler = this.cgp.device.createSampler(this.smplDesc);
    }

    copy() {
      const b = new BindingSampler(this.cgp, this.name, this.options);
      return b;
    }

    getResource() {
      return this.sampler;
    }

    /** @returns {GPUBindGroupLayoutEntry} */
    getLayoutEntry() {
      return {
        visibility: this.stage,
        binding: this.bindNum,
        sampler: {},
      };
    }

    /**
     * @param {CgpShader} shader
     * @param {number} bindGroupNum
     */
    getShaderHeaderCode(shader, bindGroupNum) {
      let str = "@group(" + bindGroupNum + ") @binding(" + this.bindNum + ") ";
      str += "var " + this.name + ": sampler;".endl();
      return str;
    }
  }

  /** @extends {Binding} */
  class BindingTexture extends Binding {
    /** @type {GPUSampler} */
    sampler = null;
    uniform = null;

    /**
     * @param {CgpContext} cgp
     * @param {string} name
     * @param {object} options
     */
    constructor(cgp, name, options) {
      super(cgp, name, options);

      /** @type {CgpUniform} */
      this.uniform = options.uniform;

      if (this.uniform.port) {
        this.uniform.port.on("change", () => {
          this.needsRebuildBindgroup = true;
        });
      }

      console.log(this.uniform);
    }

    copy() {
      const b = new BindingTexture(this.cgp, this.name, this.options);
      return b;
    }

    getResource() {
      if (this.uniform.getValue() && this.uniform.getValue().gpuTexture)
        return this.uniform.getValue().gpuTexture.createView();
      else return this.cgp.getDefaultTexture().createView();
    }

    /** @returns {GPUBindGroupLayoutEntry} */
    getLayoutEntry() {
      return {
        visibility: this.stage,
        binding: this.bindNum,
        texture: {},
      };
    }

    /**
     * @param {CgpShader} _shader
     * @param {number} bindGroupNum
     */
    getShaderHeaderCode(_shader, bindGroupNum) {
      let str = "@group(" + bindGroupNum + ") @binding(" + this.bindNum + ") ";
      str += "var " + this.name + ": " + this.uniform.getWgslTypeStr() + ";\n";
      return str;
    }
  }

  /** @typedef CgpShaderOptions
   * @property {Boolean} [compute]
   * @property {String} [entryPoint]
   */

  class CgpShader extends CgShader {
    #lastCompileReason = "first";

    /** @type {CgpUniform} */
    uniModelMatrix;

    /** @type {CgpUniform} */
    uniViewMatrix;

    /** @type {CgpUniform} */
    uniProjMatrix;

    /**
     * @type {GPUCompilationInfo}
     */
    compilationInfo;

    /**
     * @param {CgpContext} _cgp
     * @param {String} _name
     * @param {CgpShaderOptions} options={}
     */
    constructor(_cgp, _name, options = {}) {
      super();
      if (!_cgp) throw new Error("shader constructed without cgp " + _name);
      this._log = new Logger("cgp_shader");
      this._cgp = _cgp;
      this._name = _name;
      this.options = options;
      this.options.compute = this.options.compute || false;

      if (!_name) this._log.stack("no shader name given");
      this._name = _name || "unknown";
      this.gpuShaderModule = null;
      this.frameUsageCounter = 0;
      this.lastFrameUsageCounter = -2;
      this.frameUsageFrame = -1;

      this._bindingIndexCount = 0;
      this.compileCount = 0;
      this.worldUniforms = [];

      this.defaultBindGroup = new BindGroup(_cgp, this._name);
      this.modsBindGroup = new BindGroup(_cgp, this._name);

      /** @type {Array<BindGroup>} */
      this.bindGroups = [this.defaultBindGroup, this.modsBindGroup];

      if (!this.options.compute) {
        // this.bindingWorld = new BindingUniform(_cgp, "world", { "stage": GPUShaderStage.VERTEX });
        // this.defaultBindGroup.addBinding(this.bindingWorld);

        this.defaultUniBindingVert = new BindingUniform(_cgp, "uniVert", {
          stage: GPUShaderStage.VERTEX,
        });
        this.defaultBindGroup.addBinding(this.defaultUniBindingVert);

        this.defaultUniBindingFrag = new BindingUniform(_cgp, "uniFrag", {
          stage: GPUShaderStage.FRAGMENT,
        });
        this.defaultBindGroup.addBinding(this.defaultUniBindingFrag);
      } else {
        this.defaultUniBindingCompute = new BindingUniform(_cgp, "uniCompute", {
          stage: GPUShaderStage.COMPUTE,
        });
        this.defaultBindGroup.addBinding(this.defaultUniBindingCompute);
      }

      if (!this.options.compute) {
        this.uniModelMatrix = this.addUniform(
          new CgpUniform(this, "m4", "modelMatrix"),
          GPUShaderStage.VERTEX,
        );
        this.uniViewMatrix = this.addUniform(
          new CgpUniform(this, "m4", "viewMatrix"),
          GPUShaderStage.VERTEX,
        );
        this.uniProjMatrix = this.addUniform(
          new CgpUniform(this, "m4", "projMatrix"),
          GPUShaderStage.VERTEX,
        );
        this.uniNormalMatrix = this.addUniform(
          new CgpUniform(this, "m4", "normalMatrix"),
          GPUShaderStage.VERTEX,
        );
        this.uniModelViewMatrix = this.addUniform(
          new CgpUniform(this, "m4", "modelViewMatrix"),
          GPUShaderStage.VERTEX,
        );
        this._tempNormalMatrix = create$5();
        this._tempModelViewMatrix = create$5();
        this.worldUniforms.push(
          this.uniModelMatrix,
          this.uniViewMatrix,
          this.uniProjMatrix,
          this.uniNormalMatrix,
          this.uniModelViewMatrix,
        );
      }

      this._src = "";

      this._cgp.on("deviceChange", () => {
        this.gpuShaderModule = null;
        this.setWhyCompile("device changed");
      });
    }

    reInit() {}

    /** @returns {boolean} */
    isValid() {
      return this._isValid;
    }

    getName() {
      return this._name;
    }

    incFrameUsageCount() {
      if (this.frameUsageFrame != this._cgp.frame) {
        this.lastFrameUsageCounter = this.frameUsageCounter;
        this.frameUsageCounter = 0;
      } else this.frameUsageCounter++;
      this.frameUsageFrame = this._cgp.frame;

      return this.frameUsageCounter;
    }

    getNewBindingGroupIndex() {
      return ++this._bindingIndexCount;
    }

    /**
     * @param {String} src
     */
    setSource(src) {
      this._src = src;
      this.setWhyCompile("Source changed");
    }

    /**
     * @param {import("../cg/cg_shader.js").ShaderModule} mod
     * @param {string} src
     */
    _replaceModPrefixes(mod, src) {
      return src.replace(/MOD_/g, mod.prefix);
    }

    /**
     * @param {String} vs
     * @param {{}} defs
     */
    _replaceMods(vs, defs) {
      let srcHeadVert = "";
      for (let i = 0; i < this._moduleNames.length; i++) {
        let srcVert = "";

        for (let j = 0; j < this._modules.length; j++) {
          const mod = this._modules[j];
          if (mod.name == this._moduleNames[i]) {
            srcHeadVert +=
              nl +
              nl +
              "//---- MOD: group:" +
              mod.group +
              ": idx:" +
              j +
              " - prfx:" +
              mod.prefix +
              " - " +
              mod.title +
              " ------" +
              nl;

            srcVert +=
              nl +
              nl +
              "//---- MOD: " +
              mod.title +
              " / " +
              mod.priority +
              " ------" +
              nl;

            if (mod.attributes)
              for (let k = 0; k < mod.attributes.length; k++) {
                const r = this._getAttrSrc(mod.attributes[k], false);
                if (r.srcHeadVert) srcHeadVert += r.srcHeadVert;
                if (r.srcVert) srcVert += r.srcVert;
              }

            srcHeadVert += mod.srcHead || "";
            srcVert += mod.srcBody || "";

            srcHeadVert += nl + "//---- end mod ------" + nl;

            srcVert += nl + "//---- end mod ------" + nl;

            srcVert = this._replaceModPrefixes(mod, srcVert);
            srcHeadVert = this._replaceModPrefixes(mod, srcHeadVert);
          }
        }

        srcVert = preproc(srcVert, defs);
        vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
      }

      srcHeadVert = preproc(srcHeadVert, defs);
      vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
      return vs;
    }

    /**
     * @param {string} src
     */
    _replaceVertexOutputs(src = "") {
      const strVertOut = "{{VERTEX_OUTPUT";
      const posVertOut = src.indexOf(strVertOut);
      if (posVertOut > -1) {
        try {
          let str = src.substring(
            posVertOut + strVertOut.length,
            posVertOut + 100,
          );
          let endPos = str.indexOf("}}");
          let startNum = parseInt(str.substring(0, endPos));

          for (let j = 0; j < this._modules.length; j++) {
            if (!this._modules[j].outputs) continue;
            let outs = this._modules[j].outputs;
            let l = 0;
            while (outs.indexOf("@location(" + l + ")") > -1) {
              outs = outs.replaceAll(
                "@location(" + l + ")",
                "@location(" + (l + startNum) + ")",
              );
            }
            outs = this._replaceModPrefixes(this._modules[j], outs);
            src = src.replaceAll(strVertOut + " " + startNum + "}}", outs);
          }
        } catch (e) {
          console.log(e);
        }
      }
      return src;
    }

    getDefines() {
      return this._defines;
    }

    getProcessedSource() {
      const defs = {};
      for (let i = 0; i < this._defines.length; i++)
        defs[this._defines[i][0]] = this._defines[i][1] || true;

      let src = "";
      src += preproc(this._src, defs);

      let strDefs = "";
      for (let i = 0; i < this._defines.length; i++)
        strDefs += "// #define " + this._defines[i] + "\n";

      let bindingsHeadVert = "";
      let bindingsHeadFrag = "";
      let bindingsHeadCompute = "";

      for (let i = 0; i < this.bindGroups.length; i++) {
        const src = this.bindGroups[i].getShaderHeaderCode(this, i);
        bindingsHeadFrag += src.fragment || "";
        bindingsHeadVert += src.vertex || "";
        bindingsHeadCompute += src.compute || "";
      }

      if (this.options.compute)
        src = bindingsHeadCompute + "\n\n////////////////\n\n" + src;
      else
        src =
          bindingsHeadFrag +
          "\n\n////////////////\n\n" +
          bindingsHeadVert +
          "\n\n////////////////\n\n" +
          src;

      src = this._replaceMods(src, defs);

      src = this._replaceVertexOutputs(src);

      const strVertOut = "{{VERTEX_OUTPUT";
      const posVertOut = src.indexOf(strVertOut);
      if (posVertOut > -1) {
        try {
          let str = src.substring(
            posVertOut + strVertOut.length,
            posVertOut + 100,
          );
          let endPos = str.indexOf("}}");
          let startNum = parseInt(str.substring(0, endPos));
          let locCode = "@location(" + startNum + ") pos:vec4f, // generated";

          src = src.replaceAll(strVertOut + " " + startNum + "}}", locCode);
        } catch (e) {
          console.log(e);
        }
      }
      src = strDefs + "\n" + src;

      let srcHead = "//" + nl + "// ";
      if (this.options.compute) srcHead += "Compute ";
      else srcHead += "Render ";

      srcHead += "Shader: " + this._name + " - " + this.id + nl;
      srcHead += "//" + nl;

      return srcHead + src;
    }

    compile() {
      this._isValid = true;
      this._cgp.pushErrorScope("cgp_shader " + this._name);

      if (this._cgp.branchProfiler)
        this._cgp.branchProfiler.push("shadercompile", this._name, {
          info: this.getInfo(),
        });

      this._cgp.profileData.count("shader compile", this._name);
      this.gpuShaderModule = this._cgp.device.createShaderModule({
        code: this.getProcessedSource(),
        label: this._name,
      });

      this.gpuShaderModule.getCompilationInfo().then((compInfo) => {
        this.compilationInfo = compInfo;
        if (compInfo.messages.length > 0) {
          let hasErrors = false;
          for (const msg of compInfo.messages) {
            switch (msg.type) {
              case "error":
                console.error(
                  "Shader " +
                    msg.type +
                    " at line " +
                    msg.lineNum +
                    ":" +
                    msg.linePos +
                    " :" +
                    msg.message,
                );
                hasErrors = true;
              case "warning":
                console.warn(
                  "Shader " +
                    msg.type +
                    " at line " +
                    msg.lineNum +
                    ":" +
                    msg.linePos +
                    " :" +
                    msg.message,
                );
                break;
              case "info":
                console.info(
                  "Shader " +
                    msg.type +
                    " at line " +
                    msg.lineNum +
                    ":" +
                    msg.linePos +
                    " :" +
                    msg.message,
                );
                break;
            }
          }
          if (hasErrors) {
            console.log("has errrrrrrrrrr");
            CABLES.UI.showShaderErrorCgp(
              this,
              compInfo,
              this.getProcessedSource(),
            );
          }
        }
      });

      this._cgp.popErrorScope(this.error.bind(this));

      this.#lastCompileReason = this._compileReason;

      this.lastCompile = now();
      // console.log("#lastCompileReason", this.#lastCompileReason);

      this.emitEvent("compiled", this._compileReason);
      this._needsRecompile = false;
      this._compileReason = "none";
      this.compileCount++;

      if (this._cgp.branchProfiler) this._cgp.branchProfiler.pop();
    }

    error(e) {
      this._isValid = false;
    }

    bind(passEnc = null) {
      this.incFrameUsageCount();
      if (!this.options.compute) {
        this.uniModelMatrix.setValue(this._cgp.mMatrix);
        this.uniViewMatrix.setValue(this._cgp.vMatrix);
        this.uniProjMatrix.setValue(this._cgp.pMatrix);

        // mat4.invert(this._tempNormalMatrix, this._cgp.mMatrix);
        // mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);
        mul$5(this._tempModelViewMatrix, this._cgp.vMatrix, this._cgp.mMatrix);
        this.uniModelViewMatrix.setValue(this._tempModelViewMatrix);

        copy$5(this._tempNormalMatrix, this._cgp.mMatrix);
        invert$2(this._tempNormalMatrix, this._tempNormalMatrix);
        transpose(this._tempNormalMatrix, this._tempNormalMatrix);

        // cpu billboarding?
        // this._tempModelViewMatrix[0 * 4 + 0] = 1.0;
        // this._tempModelViewMatrix[0 * 4 + 1] = 0.0;
        // this._tempModelViewMatrix[0 * 4 + 2] = 0.0;

        // // #ifndef BILLBOARDING_CYLINDRIC
        // this._tempModelViewMatrix[1 * 4 + 0] = 0.0;
        // this._tempModelViewMatrix[1 * 4 + 1] = 1.0;
        // this._tempModelViewMatrix[1 * 4 + 2] = 0.0;
        // // #endif

        // this._tempModelViewMatrix[2 * 4 + 0] = 0.0;
        // this._tempModelViewMatrix[2 * 4 + 1] = 0.0;
        // this._tempModelViewMatrix[2 * 4 + 2] = 1.0;

        this.uniNormalMatrix.setValue(this._tempNormalMatrix);
      }

      for (let i = 0; i < this.bindGroups.length; i++) {
        this.bindGroups[i].updateValues(this.frameUsageCounter);
        this.bindGroups[i].bind(this.frameUsageCounter, passEnc, i);
      }
      if (this._needsRecompile) this.compile();
    }

    /**
     * @param {number} stage
     * @returns {BindingUniform}
     */
    getDefaultUniBinding(stage) {
      let binding = this.defaultUniBindingFrag;
      if (stage == GPUShaderStage.VERTEX) binding = this.defaultUniBindingVert;
      if (this.options.compute && stage == GPUShaderStage.COMPUTE)
        binding = this.defaultUniBindingCompute;
      return binding;
    }

    pipelineUpdated() {
      if (this.defaultUniBindingFrag)
        this.defaultUniBindingFrag.pipelineUpdated();
      if (this.defaultUniBindingVert)
        this.defaultUniBindingVert.pipelineUpdated();
      if (this.defaultUniBindingCompute)
        this.defaultUniBindingCompute.pipelineUpdated();
    }

    bindingsNeedPipeUpdate() {
      return (
        (this.defaultUniBindingFrag &&
          this.defaultUniBindingFrag.needsPipeUpdate()) ||
        (this.defaultUniBindingVert &&
          this.defaultUniBindingVert.needsPipeUpdate()) ||
        (this.defaultUniBindingCompute &&
          this.defaultUniBindingCompute.needsPipeUpdate())
      );
    }

    /**
     * @param {String} name
     * @param {number} stage
     */
    hasUniformInStage(name, stage) {
      let binding = this.getDefaultUniBinding(stage);

      // console.log("bindingget uni", stage, binding, CgpShader.getStageString(stage));
      if (!binding) return false;
      return !!binding.getUniform(name);
    }

    /**
     * @param {String} name
     */
    hasUniform(name) {
      return (
        this.hasUniformInStage(name, GPUShaderStage.FRAGMENT) ||
        this.hasUniformInStage(name, GPUShaderStage.VERTEX) ||
        this.hasUniformInStage(name, GPUShaderStage.COMPUTE)
      );
    }

    /**
     * @param {CgpUniform} u
     * @param {number} stage
     * @returns {CgpUniform}
     */
    addUniform(u, stage) {
      const binding = this.getDefaultUniBinding(stage);
      if (u.type == "t")
        this.defaultBindGroup.addBinding(
          new BindingTexture(this._cgp, u.name, { uniform: u }),
        );
      else if (u.type == "sampler")
        this.defaultBindGroup.addBinding(
          new BindingSampler(this._cgp, u.name, { uniform: u }),
        );
      else {
        binding.addUniform(u);
      }

      this.needsPipelineUpdate = "add uniform";
      console.log(
        "adduni2",
        this._name,
        u.name,
        this.id,
        binding,
        CgpShader.getStageString(stage),
      );
      console.log("code", binding.getShaderHeaderCode(this, 0));

      // if (!this.defaultBindGroup.hasBinding(binding)) this.defaultBindGroup.addBinding(binding);
      return u;
    }

    removeUniformByName(name) {
      const binding = this.getDefaultUniBinding(stage);
      binding.removeUniformByName(name);
    }

    /**
     * copy current shader
     * @returns newShader
     */
    copy() {
      this.bind();
      const shader = new CgpShader(this._cgp, this._name + " copy", this.options);
      console.log("copyyyyyy", this.id, shader.id);
      shader.setSource(this._src);

      shader._modules = JSON.parse(JSON.stringify(this._modules));
      shader._defines = JSON.parse(JSON.stringify(this._defines));

      shader._moduleNames = this._moduleNames;

      shader.bindGroups = [];
      for (let i = 0; i < this.bindGroups.length; i++) {
        const bg = this.bindGroups[i].copy(shader);
        shader.bindGroups.push(bg);

        if (this.bindGroups[i] == this.defaultBindGroup)
          shader.defaultBindGroup = bg;
        // if (this.bindGroups[i] == this.modsBindGroup) shader.modsBindGroup = bg;
        bg.setBindingNums();
      }

      shader.setWhyCompile("copy");
      shader.compile();
      return shader;
    }

    dispose() {}

    /**
     * @param {number} stage
     */
    static getStageString(stage) {
      if (stage == GPUShaderStage.FRAGMENT) return "frag";
      if (stage == GPUShaderStage.VERTEX) return "vertex";
      if (stage == (GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX))
        return "frag+vertex";
      if (
        stage ==
        (GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE)
      )
        return "frag+vertex+comp";
      if (stage == GPUShaderStage.COMPUTE) return "compute";

      return "unknown" + stage;
    }

    getInfo() {
      const o = {
        class: this.constructor.name,
        id: this.id,
        name: this._name,
        needsPipelineUpdate: this.needsPipelineUpdate,
        frameUsageCounter: this.lastFrameUsageCounter,
        lastCompileReason: this.#lastCompileReason,
        compileCount: this.compileCount,
        defines: this._defines,
        isCompute: this.options.compute,
        modules: [],
        bindgroups: [],
      };

      for (let i = 0; i < this.bindGroups.length; i++) {
        o.bindgroups.push(this.bindGroups[i].getInfo());
      }

      for (let i = 0; i < this._modules.length; i++) {
        o.modules.push(
          this._modules[i].title +
            " " +
            this._modules[i].name +
            " " +
            this._modules[i].group,
        );
        // console.log(this._modules[i]);
      }

      return o;
    }

    copyUniformValues(orig) {}
  }

  class Texture extends CgTexture {
    #log = new Logger("cgp_texture");

    /** @type {CgpContext} */
    #cgp = null;

    /** @type {GPUTexture} */
    gpuTexture = null;

    /** @type {GPUTextureDescriptor} */
    gpuTextureDescriptor = null;
    name = "unknown";
    width = 8;
    height = 8;
    textureType = "???";

    samplerDesc = {};

    /**
     * @param {CgpContext} _cgp
     * @param {Object} options={}
     */
    constructor(_cgp, options = {}) {
      super(options);
      options = options || {};

      this.#cgp = _cgp;
      if (!this.#cgp) throw new Error("no cgp");

      if (options.name) this.name = options.name;
      if (options.height && options.width)
        this.setSize(options.width, options.height);

      this.#cgp.on("deviceChange", () => {});
      this.samplerDesc = {
        addressModeU: options.wrap || options.addressModeU || "clamp-to-edge",
        addressModeV: options.wrap || options.addressModeV || "clamp-to-edge",
        magFilter: options.magFilter || options.filter || "linear",
        minFilter: options.minFilter || options.filter || "linear",
      };
    }

    /**
     * @param {Number} w
     * @param {Number} h
     */
    setSize(w, h) {
      this.width = w;
      this.height = h;
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter) {
      this.width = img.width;
      this.height = img.height;

      const textureType = "rgba8unorm";

      this.#cgp.pushErrorScope("inittexture", { logger: this.#log });

      this.gpuTextureDescriptor = {
        size: { width: img.width, height: img.height },
        format: textureType,
        // "sampleCount": 4,
        usage:
          GPUTextureUsage.TEXTURE_BINDING |
          GPUTextureUsage.COPY_DST |
          GPUTextureUsage.RENDER_ATTACHMENT,
      };

      this.gpuTexture = this.#cgp.device.createTexture(this.gpuTextureDescriptor);
      this.#cgp.device.queue.copyExternalImageToTexture(
        { source: img },
        { texture: this.gpuTexture },
        this.gpuTextureDescriptor.size,
      );

      this.#cgp.popErrorScope();

      return this.gpuTexture;
    }

    dispose() {
      console.log("todo dispose");
    }

    getInfo() {
      const obj = {};

      obj.name = this.name || "???";
      obj.size = this.width + " x " + this.height;

      obj.textureType = this.textureType;

      return obj;
    }

    createView() {
      if (!this.gpuTexture) {
        console.log("no gputexture...");
        return null;
      }
      return this.gpuTexture.createView();
    }

    getSampler() {
      // "clamp-to-edge"
      // "repeat"
      // "mirror-repeat"

      return this.samplerDesc;
    }

    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {ArrayBuffer} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap) {
      if (!w || !h) this.#log.error("texture size is 0");
      this.width = w;
      this.height = h;
      this.gpuTexture = this.#cgp.device.createTexture({
        size: [w, h],
        format: "rgba8unorm",
        usage:
          GPUTextureUsage.TEXTURE_BINDING |
          GPUTextureUsage.COPY_DST |
          GPUTextureUsage.RENDER_ATTACHMENT,
      });

      this.#cgp.device.queue.writeTexture(
        { texture: this.gpuTexture },
        data,
        { bytesPerRow: w * 4 },
        { width: w, height: h },
      );
    }

    /**
     * @param {any} v
     */
    setWrap(v) {
      this.samplerDesc.addressModeU = this.samplerDesc.addressModeV = v;
    }

    /**
     * @param {any} v
     */
    setFilter(v) {
      this.samplerDesc.minFilter = this.samplerDesc.magFilter = v;
    }
  }

  /**
   * @function load
   * @static
   * @memberof Texture
   * @description load an image from an url
   * @param {CgpContext} cgp
   * @param {String} url
   * @param {Function} onFinished
   * @param {Object} settings
   */
  Texture.load = function (cgp, url, onFinished, settings) {
    fetch(url).then((response) => {
      const texture = new Texture(cgp, { name: url });

      response.blob().then((blob) => {
        createImageBitmap(blob)
          .then((imgBitmap) => {
            texture.initTexture(imgBitmap);
            if (onFinished) onFinished(texture);
            else console.log("Texture.load no onFinished callback");
          })
          .catch((err) => {
            if (onFinished) onFinished(cgp.getErrorTexture());
          });
      });
    });
  };

  /// <reference types="@webgpu/types" />

  class Pipeline {
    static TYPE_RENDER = 0;
    static TYPE_COMPUTE = 1;

    #log = new Logger("pipeline");
    name = "";

    /** @type {CgpContext} */
    #cgp = null;
    #isValid = true;

    /** @type {string} */
    presentationFormat = null;

    /** @type {GPURenderPipelineDescriptor} */
    #pipeCfg = null;

    /** @type {GPUBindGroupLayout} */
    bindGroupLayout = null;

    /** @type {Array<string>} */
    #shaderListeners = [];
    #type = -1;
    lastRebuildReason = "first";
    rebuildCount = 0;
    profile = false;

    /** @type {Array<GPUBindGroupLayoutEntry>} */
    bindingGroupLayoutEntries = [];

    /**
     * Description
     * @param {CgpContext} _cgp
     * @param {String} name
     * @param {Number} type
     */
    constructor(_cgp, name, type = 0) {
      if (!_cgp) throw new Error("Pipeline constructed without cgp " + name);
      this.name = name;
      this.#cgp = _cgp;
      this.#type = type;

      // this.#cgp.on("deviceChange", () =>
      // {
      //     this.#renderPipeline = null;
      // });
    }

    get passEncoder() {
      return this.#cgp.passEncoder;
    }

    get log() {
      return this.#log;
    }

    get cgp() {
      return this.#cgp;
    }

    get isValid() {
      return this.#isValid;
    }

    /**
     * @param {String} name
     */
    setName(name) {
      this.name = name;
    }

    // setShaderListener(oldShader, newShader)
    // {
    //     for (let i = 0; i < this.#shaderListeners.length; i++) oldShader.off(this.#shaderListeners[i]);
    //     this.#shaderListeners = [];
    //     this.#shaderListeners.push(
    //         newShader.on("compiled", (/** @type {string} */ reason) =>
    //         {
    //             this.needsRebuildReason = "shader compiled: " + reason || "???";
    //         }));
    // }

    getInfo() {
      const info = {
        class: this.constructor.name,
        name: this.name,
        rebuildReason: this.lastRebuildReason,
        rebuildCount: this.rebuildCount,
        // "numBindgroups": this.#bindingInstances.length,
        bindingGroupLayoutEntries: this.bindingGroupLayoutEntries,
      };

      if (this.#type == Pipeline.TYPE_COMPUTE) info.type = "COMPUTE";
      if (this.#type == Pipeline.TYPE_RENDER) info.type = "RENDER";

      return info;
    }

    pushDebug() {
      this.#cgp.currentPipeDebug = {
        name: this.name,
        rebuildreason: this.lastRebuildReason,
        rebuildCount: this.rebuildCount,
        cfg: this.#pipeCfg,
        bindingGroupLayoutEntries: this.bindingGroupLayoutEntries,
      };
    }

    /**
     * @param {CgpShader} shader
     */
    _bindUniforms(shader) {
      shader.bind();
    }

    dispose() {
      // todo...
    }
  }

  /// <reference types="@webgpu/types" />

  class RenderPipeline extends Pipeline {
    static DEPTH_COMPARE_FUNCS_STRINGS = [
      "never",
      "less",
      "equal",
      "lessequal",
      "greater",
      "notequal",
      "greaterequal",
      "always",
    ];

    #isValid = true;

    /** @type {string} */
    presentationFormat = null;

    /** @type {GPURenderPipelineDescriptor} */
    #pipeCfg = null;

    /** @type {GPURenderPipeline} */
    #renderPipeline = null;

    /** @type {GPUBindGroupLayout} */
    bindGroupLayout = null;

    /** @type {GPURenderPassEncoder} */
    #passEncoder;

    // #shaderListeners = [];
    #old = {};
    #type = RenderPipeline.TYPE_RENDER;
    lastRebuildReason = "first";
    #rebuildNumBindingGroups = false;
    #compileCount = -1;

    /**
     * Description
     * @param {CgpContext} _cgp
     * @param {String} name
     */
    constructor(_cgp, name) {
      super(_cgp, name, Pipeline.TYPE_RENDER);
    }

    /**
     * @param {CgpShader} shader
     * @param {CgpMesh} mesh
     */
    setPipeline(shader, mesh = null) {
      if (this.#type == RenderPipeline.TYPE_RENDER) {
        if (!mesh) {
          this.log.log("pipeline unknown mesh");
          return;
        }
      }
      if (!shader) {
        this.log.log("pipeline unknown shader");
        return;
      }

      if (this.cgp.branchProfiler)
        this.cgp.branchProfiler.push("setPipeline", this.name, {
          info: this.getInfo(),
          shader: shader.getInfo(),
        });

      let needsRebuildReason = "";
      if (!this.#renderPipeline) needsRebuildReason = "no renderpipeline";
      if (!this.#pipeCfg) needsRebuildReason = "no pipecfg";
      if (this.#old.mesh != mesh) needsRebuildReason = "no mesh";
      if (this.#old.shader != shader) {
        // this.setShaderListener(this.#old.shader, shader);
        needsRebuildReason = "shader changed";
      }

      if (shader.needsPipelineUpdate) {
        needsRebuildReason = "shader needs update: " + shader.needsPipelineUpdate;
        shader.needsPipelineUpdate = "";
      }

      if (this.#type == RenderPipeline.TYPE_RENDER && mesh.needsPipelineUpdate) {
        needsRebuildReason = "mesh needs update";
        mesh.needsPipelineUpdate = false;
      }

      if (
        this.bindingGroupLayoutEntries.length !=
        shader.defaultBindGroup.getLayoutEntries(shader).length
      ) {
        needsRebuildReason = "num bindgroup layouts wrong...";
      }

      if (shader.bindingsNeedPipeUpdate()) {
        console.log("binding needs uptate");
        needsRebuildReason = "bindings needs update";
        this.needsRebuildBindgroup = true;
      }

      // if (this.#rebuildNumBindingGroups)
      // {
      //     needsRebuildReason = "num bindgroups wrong...";
      // }

      if (this.#pipeCfg) {
        this.#pipeCfg = /** @type {GPURenderPipelineDescriptor} */ (
          this.#pipeCfg || {}
        );
        if (
          this.#pipeCfg.depthStencil.depthWriteEnabled !=
          this.cgp.stateDepthWrite()
        )
          needsRebuildReason = "depth changed";

        if (this.#pipeCfg.fragment.targets[0].blend != this.cgp.stateBlend()) {
          needsRebuildReason = "blend changed";
          this.#pipeCfg.fragment.targets[0].blend = this.cgp.stateBlend();
        }

        if (this.#pipeCfg.depthStencil.depthCompare != this.cgp.getDepthCompare())
          needsRebuildReason = "depth compare changed";

        if (this.#pipeCfg.primitive.cullMode != this.cgp.stateCullFaceFacing())
          needsRebuildReason = "cullmode change";

        if (this.#pipeCfg.multisample.count != this.cgp.stateMultisampling())
          needsRebuildReason = "multisample change";
      }
      if (this.#compileCount != shader.compileCount) {
        needsRebuildReason = "shader compiled " + shader.compileCount;
      }

      this.pushDebug();

      if (needsRebuildReason != "") {
        this.cgp.profileData.addHeavyEvent(
          "pipeline created",
          this.name,
          needsRebuildReason,
        );
        this.lastRebuildReason = needsRebuildReason;
        this.rebuildCount++;
        this.cgp.pushErrorScope("createPipeline", { logger: this.log });

        this.#rebuildNumBindingGroups = false;

        this.#pipeCfg = this.getPipelineObject(shader);

        this.#old.device = this.cgp.device;
        this.#old.shader = shader;
        this.#old.mesh = mesh;
        this.#isValid = true;
        this.#compileCount = shader.compileCount;
        shader.pipelineUpdated();

        try {
          this.#renderPipeline = this.cgp.device.createRenderPipeline(
            this.#pipeCfg,
          );
        } catch (e) {
          console.error("pipe error catch...", e.message, this.#pipeCfg);
          this.#isValid = false;
        }

        this.cgp.popErrorScope(() => {
          console.log("this.#pipeCfg", this.#pipeCfg);
        });
      }

      if (this.#renderPipeline && this.#isValid) {
        this.cgp.pushErrorScope("setpipeline", { logger: this.log });

        let passEnc = this.cgp.passEncoder;

        // if (this.#type != RenderPipeline.TYPE_RENDER) passEnc = this.#passEncoder;

        if (this.cgp.branchProfiler)
          this.cgp.branchProfiler.push("pipe updateUniforms", this.name, {
            shader: shader.getInfo(),
          });

        /// ///////////////////

        shader.bind();
        passEnc.setPipeline(this.#renderPipeline);

        if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();

        this.cgp.popErrorScope();
      }
      if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();
    }

    /**
     * @param {CgpShader} shader
     * @returns {GPURenderPipelineDescriptor}
     */
    getPipelineObject(shader) {
      this.bindingGroupLayoutEntries = [];
      this.bindingGroupLayoutEntries =
        shader.defaultBindGroup.getLayoutEntries(shader);

      const bindGroupLayouts = [shader.defaultBindGroup.getLayout(shader)];

      /** @type {GPUPipelineLayout} */
      const pipelineLayout = this.cgp.device.createPipelineLayout({
        label: "pipe layout " + this.name,
        bindGroupLayouts: bindGroupLayouts,
      });

      /** @type {Array<GPUVertexBufferLayout>} */
      let buffers = [
        // position
        {
          arrayStride: 3 * 4, // 3 floats, 4 bytes each
          attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }],
        },
        // texcoords
        {
          arrayStride: 2 * 4, // 2 floats, 4 bytes each
          attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }],
        },
        // normals
        {
          arrayStride: 3 * 4, // 3 floats, 4 bytes each
          attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }],
        },
      ];

      /** @type {GPURenderPipelineDescriptor} */
      let pipeCfg = {
        label: this.name,
        layout: pipelineLayout,

        primitive: {
          topology: "triangle-list",
          cullMode: this.cgp.stateCullFaceFacing(), // back/none/front
          // "point-list",
          // "line-list",
          // "line-strip",
          // "triangle-list",
          // "triangle-strip"
        },
        multisample: {
          count: this.cgp.stateMultisampling(),
          alphaToCoverageEnabled: false, // Enable if using alpha testing
        },
        depthStencil: {
          depthWriteEnabled: this.cgp.stateDepthWrite(),
          depthCompare: this.cgp.getDepthCompare(),
          format: "depth24plus",
        },
        vertex: {
          module: shader.gpuShaderModule,
          entryPoint: "myVSMain",
          buffers: buffers,
        },
        fragment: {
          module: shader.gpuShaderModule,
          entryPoint: "myFSMain",
          targets: [
            {
              format: this.cgp.presentationFormat,
              blend: this.cgp.stateBlend(),
            },
          ],
        },
      };
      return pipeCfg;
    }

    dispose() {
      // todo...
    }
  }

  class CgpMesh extends CgMesh {
    #log = new Logger("cgl_mesh");
    needsPipelineUpdate = false;

    /**
     * @param {any} _cgp
     * @param {any} __geom
     */
    constructor(_cgp, __geom) {
      super();

      this.cgp = _cgp;
      this._geom = null;
      this.numIndex = 0;
      this.instances = 1;

      this._pipe = new RenderPipeline(this.cgp, "pipe mesh " + __geom.name);
      this._numNonIndexed = 0;
      this._positionBuffer = null;

      this._attributes = [];

      if (__geom) this.setGeom(__geom);
    }

    /**
     * @param {GPUDevice} device
     * @param {any} data
     * @param {any} usage
     */
    _createBuffer(device, data, usage) {
      let bo = {
        size: data.byteLength,
        usage: usage,
        mappedAtCreation: true,
      };
      const buffer = device.createBuffer(bo);
      const dst = new data.constructor(buffer.getMappedRange());
      dst.set(data);
      buffer.unmap();
      return buffer;
    }

    /**
     * @function setGeom
     * @memberof Mesh
     * @instance
     * @description set geometry for mesh
     * @param {Geometry} geom geometry
     */
    setGeom(geom) {
      this.needsPipelineUpdate = true;
      this._geom = geom;
      this._disposeAttributes();

      this._positionBuffer = this._createBuffer(
        this.cgp.device,
        new Float32Array(geom.vertices),
        GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      );

      let vi = geom.verticesIndices;
      if (!geom.isIndexed())
        vi = Array.from(Array(geom.vertices.length / 3).keys());
      this._numIndices = vi.length;
      this._indicesBuffer = this._createBuffer(
        this.cgp.device,
        new Uint32Array(vi),
        GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
      );

      if (geom.texCoords && geom.texCoords.length)
        this.setAttribute("texCoords", geom.texCoords, 2);
      if (geom.vertexNormals && geom.vertexNormals.length)
        this.setAttribute("normals", geom.vertexNormals, 3);

      this.setAttribute("normals", geom.vertexNormals, 3);
    }

    _disposeAttributes() {
      this.needsPipelineUpdate = true;
      for (let i = 0; i < this._attributes.length; i++)
        this._attributes[i].buffer.destroy();
      this._attributes.length = 0;
    }

    dispose() {
      this._disposeAttributes();
    }

    /**
     * @function setAttribute
     * @description update attribute
     * @memberof Mesh
     * @instance
     * @param {String} name attribute name
     * @param {Array} array data
     * @param {Number} itemSize
     * @param {Object} options
     */
    setAttribute(name, array, itemSize, options = {}) {
      if (!array) {
        this.#log.error("mesh addAttribute - no array given! " + name);
        throw new Error();
      }

      let instanced = false;
      if (options.instanced) instanced = options.instanced;

      const buffer = this._createBuffer(
        this.cgp.device,
        new Float32Array(array),
        GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      );

      const attr = {
        buffer: buffer,
        name: name,
        instanced: instanced,
      };
      this._attributes.push(attr);

      return attr;
    }

    /**
     * @param {CgpShader} shader
     */
    render(shader) {
      if (!this._positionBuffer) return;
      if (this.instances <= 0) return;

      if (this.cgp.branchProfiler)
        this.cgp.branchProfiler.push("mesh.render()", "geom " + this._geom.name);

      shader = shader || this.cgp.getShader();
      if (shader) shader.bind();

      if (!shader || !shader.isValid) {
        // this.status = "shader invalid";
        return;
      }

      this._pipe.setName(
        "mesh.render " +
          this._geom.name +
          " " +
          shader.getName() +
          " " +
          shader.id,
      );
      this._pipe.setPipeline(shader, this);

      if (this._pipe.isValid) {
        if (this.cgp.branchProfiler)
          this.cgp.branchProfiler.push(
            "mesh.render().draw",
            "geom " + this._geom.name,
            {
              geom: this._geom.getInfo(),
              shader: shader.getInfo(),
              numAttributes: this._attributes.length,
            },
          );

        this.cgp.passEncoder.setVertexBuffer(0, this._positionBuffer);
        for (let i = 0; i < this._attributes.length; i++)
          this.cgp.passEncoder.setVertexBuffer(i + 1, this._attributes[i].buffer);

        this.cgp.passEncoder.setIndexBuffer(this._indicesBuffer, "uint32");

        this.cgp.profileData.count("draw mesh", this._name);
        if (this._numNonIndexed)
          this.cgp.passEncoder.draw(this._numIndices, this.instances);
        else this.cgp.passEncoder.drawIndexed(this._numIndices, this.instances);

        if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();
      } else {
        if (this.cgp.branchProfiler) {
          this.cgp.branchProfiler.push(
            "mesh invalid pipeline ",
            "geom " + this._geom.name,
          );
          this.cgp.branchProfiler.pop();
        }
      }

      if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();

      // if (shader)shader.unbind();
    }
  }

  // https://github.com/greggman/webgpu-utils
  // https://developer.chrome.com/blog/from-webgl-to-webgpu/
  // https://gpuweb.github.io/gpuweb/explainer/

  /**
   * cables webgpu context/state manager
   * @class
   * @namespace external:CGP
   * @hideconstructor
   */
  class CgpContext extends CgContext {
    branchProfiler = null;

    /**
     * @param {Patch} _patch
     */
    constructor(_patch) {
      super(_patch);
      this.patch = _patch;

      this.lastErrorMsg = "";

      this._log = new Logger("WebGpuContext");
      this.gApi = CgContext.API_WEBGPU;
      this._viewport = [0, 0, 256, 256];
      this._shaderStack = [];
      this._simpleShader = null;
      this.frame = 0;
      this.catchErrors = true;

      this._stackCullFaceFacing = [];
      this._stackDepthTest = [];
      this._stackCullFace = [];
      this._stackDepthFunc = [];
      this._stackDepthWrite = [];
      this._stackErrorScope = [];
      this._stackBlend = [];
      this._stackErrorScopeLogs = [];
      this._stackMultisampling = [];

      this.currentPipeDebug = null;
      this.canvasAttachments = [];

      /** @type {GPUDevice} */
      this.device = null;

      /** @type {GPURenderPassEncoder} */
      this.passEncoder = null;

      this._defaultBlend = {
        color: {
          operation: "add",
          srcFactor: "one",
          dstFactor: "zero",
        },
        alpha: {
          operation: "add",
          srcFactor: "one",
          dstFactor: "zero",
        },
      };

      this.DEPTH_FUNCS = [
        "never",
        "always",
        "less",
        "less-equal",
        "greater",
        "greater-equal",
        "equal",
        "not-equal",
      ];

      this.CULL_MODES = [
        "none",
        "back",
        "front",
        "none", // both does not exist in webgpu
      ];

      /** @type {GPUTextureFormat} */
      this.presentationFormat = "bgra8unorm";
    }

    get supported() {
      return !!navigator.gpu;
    }

    /// ////////////////////

    /**
     * Description
     * @param {any} cgp
     * @param {any} identTranslate
     * @param {any} identTranslateView
     * @returns {any}
     */
    renderStart(cgp, identTranslate, identTranslateView) {
      this.frame++;
      this.pushErrorScope("cgpstate internal", { scope: "internal" });
      this.pushErrorScope("cgpstate out-of-memory", { scope: "out-of-memory" });

      if (!this._simpleShader) {
        this._simpleShader = new CgpShader(this, "simple default shader");
        this._simpleShader.setSource(defaultShaderSrcVert);

        this._simpleShader.addUniform(
          new CgpUniform(this._simpleShader, "4f", "color", [1, 1, 0, 1]),
          GPUShaderStage.FRAGMENT,
        );
      }

      this.fpsCounter.startFrame();

      this._startMatrixStacks(identTranslate, identTranslateView);
      this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);

      this.pushShader(this._simpleShader);
      this.pushDepthTest(true);
      this.pushDepthWrite(true);
      this.pushDepthFunc("less-equal");

      this.pushBlend(this._defaultBlend);

      this._execOneTimeCallbacks();

      this.emitEvent("beginFrame");
    }

    renderEnd() {
      this._endMatrixStacks();

      this.popShader();
      this.popDepthFunc();
      this.popDepthWrite();
      this.popDepthTest();

      this.popErrorScope();
      this.popErrorScope();

      if (this._stackErrorScope.length > 0)
        console.log("error scope stack length invalid...");
      this._stackErrorScope.length = 0;

      this.emitEvent("endFrame");
      this.fpsCounter.endFrame();
    }

    /**
     * @param {number} x
     * @param {number} [y]
     * @param {undefined} [w]
     * @param {undefined} [h]
     */
    setViewPort(x, y, w, h) {
      this._viewport = [x, y, w, h];
    }

    /**
     * @function getViewPort
     * @memberof Context
     * @instance
     * @description get current gl viewport
     * @returns {Array} array [x,y,w,h]
     */
    getViewPort() {
      return this._viewPort;
    }

    /**
     * @param {Geometry} geom
     * @param {any} glPrimitive
     * @returns {CgpMesh}
     */
    createMesh(geom, glPrimitive) {
      return new CgpMesh(this, geom);
    }

    /**
     * @function popViewPort
     * @memberof Context
     * @instance
     * @description pop viewPort stack
     */
    popViewPort() {
      this._viewPortStack.pop();

      if (this._viewPortStack.length == 0)
        this._viewPort = [0, 0, this.canvasWidth, this.canvasHeight];
      else this.setViewPort(this._viewPortStack[this._viewPort.length - 1]);
    }

    /**
     * @function pushViewPort
     * @memberof Context
     * @instance
     * @description push a new viewport onto stack
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */

    pushViewPort(x, y, w, h) {
      this._viewPortStack.push([x, y, w, h]);
      this._viewPort = [x, y, w, h];
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Object} shader
     * @function
     */
    pushShader(shader) {
      this._shaderStack.push(shader);
      // currentShader = shader;
    }

    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    popShader() {
      if (this._shaderStack.length === 0)
        throw new Error("Invalid shader stack pop!");
      this._shaderStack.pop();
      // currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    getShader() {
      return this._shaderStack[this._shaderStack.length - 1];
    }

    /**
     * @param {GPUDevice} device
     */
    setDevice(device) {
      this.device = device;

      if (this._emptyTexture) this._emptyTexture = this._emptyTexture.dispose();
      if (this._defaultTexture)
        this._defaultTexture = this._defaultTexture.dispose();
      if (this._errorTexture) this._errorTexture = this._errorTexture.dispose();

      this.emitEvent("deviceChange");
    }

    /**
     * @typedef ErrorScopeOptions
     * @property {Logger} [logger]
     * @property {GPUErrorFilter} [scope]
     */

    /**
     * @param {String} name
     * @param {ErrorScopeOptions} options
     */
    pushErrorScope(name, options = {}) {
      if (this.catchErrors) {
        this._stackErrorScope.push(name);
        this._stackErrorScopeLogs.push(options.logger || null);
        this.device.pushErrorScope(options.scope || "validation");
      }
    }

    /**
     * @param {Function} [cb]
     */
    popErrorScope(cb) {
      if (this.catchErrors) {
        const name = this._stackErrorScope.pop();
        const logger = this._stackErrorScopeLogs.pop();
        this.device.popErrorScope().then((error) => {
          if (error) {
            if (this.lastErrorMsg == error.message) ; else {
              (logger || this._log).error(
                error.constructor.name,
                "in ERROR SCOPE:",
                name,
              );
              (logger || this._log).error(error.message);
            }
            this.lastErrorMsg = error.message;

            if (cb) cb(error);
          }
        });
      }
    }

    /**
     * push depth testing enabled state
     * @function pushDepthTest
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthTest(b) {
      this._stackDepthTest.push(b);
    }

    getDepthCompare() {
      let depthComp = this.stateDepthFunc();
      if (!this.stateDepthTest()) depthComp = "always";
      return depthComp;
    }

    /**
     * current state of depth testing
     * @function stateDepthTest
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthTest() {
      return this._stackDepthTest[this._stackDepthTest.length - 1];
    }

    /**
     * pop depth testing state
     * @function popDepthTest
     * @memberof Context
     * @instance
     */
    popDepthTest() {
      this._stackDepthTest.pop();
    }

    // --------------------------------------
    // state depthwrite

    /**
     * push depth write enabled state
     * @function pushDepthWrite
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthWrite(b) {
      b = b || false;
      this._stackDepthWrite.push(b);
    }

    /**
     * current state of depth writing
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthWrite() {
      return this._stackDepthWrite[this._stackDepthWrite.length - 1];
    }

    /**
     * pop depth writing state
     * @memberof Context
     * @instance
     */
    popDepthWrite() {
      this._stackDepthWrite.pop();
    }

    // --------------------------------------
    // state depthfunc

    /**
     * @function pushDepthFunc
     * @memberof Context
     * @instance
     * @param {GPUCompareFunction} depthFunc depth compare func
     */
    pushDepthFunc(depthFunc) {
      this._stackDepthFunc.push(depthFunc);
    }

    /**
     * @function stateDepthFunc
     * @memberof Context
     * @instance
     * @returns {GPUCompareFunction}
     */
    stateDepthFunc() {
      if (this._stackDepthFunc.length > 0)
        return this._stackDepthFunc[this._stackDepthFunc.length - 1];
      return "less";
    }

    /**
     * pop depth compare func
     * @function popDepthFunc
     * @memberof Context
     * @instance
     */
    popDepthFunc() {
      this._stackDepthFunc.pop();
    }

    // --------------------------------------
    // state CullFace

    /**
     * push face culling face enabled state
     * @function pushCullFace
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushCullFace(b) {
      this._stackCullFace.push(b);
    }

    // --------------------------------------
    // state multisambling
    /**
     * @returns {number}
     */
    stateMultisampling() {
      return this._stackMultisampling[this._stackMultisampling.length - 1];
    }

    /**
     * @param {number} samples
     */
    pushMultisampling(samples) {
      this._stackMultisampling.push(samples);
    }

    popMultisampling() {
      this._stackMultisampling.pop();
    }

    // --------------------------------------
    // state CullFace Facing

    /**
     * push face culling face side
     * @param {string} b
     * @instance
     */
    pushCullFaceFacing(b) {
      this._stackCullFaceFacing.push(b);
    }

    /**
     * current state of face culling side
     * @returns {string}
     */
    stateCullFaceFacing() {
      return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
    }

    /**
     * pop face culling face side
     * @function popCullFaceFacing
     * @memberof Context
     * @instance
     */
    popCullFaceFacing() {
      this._stackCullFaceFacing.pop();
    }

    pushBlend(b) {
      this._stackBlend.push(b);
    }

    popBlend() {
      this._stackBlend.pop();
    }

    /**
     * @returns {GPUBlendComponent}
     */
    stateBlend() {
      return this._stackBlend[this._stackBlend.length - 1];
    }

    getEmptyTexture() {
      if (this._emptyTexture) return this._emptyTexture;
      const size = 8;
      this._emptyTexture = new Texture(this, {});
      this._emptyTexture.initFromData(
        CgTexture.getDefaultTextureData("empty", size),
        size,
        size,
      );
      return this._emptyTexture;
    }

    getErrorTexture() {
      // if (this._errorTexture) return this._errorTexture;
      const size = 256;
      this._errorTexture = new Texture(this, {});
      this._errorTexture.initFromData(
        CgTexture.getDefaultTextureData("stripes", size, { r: 1, g: 0, b: 0 }),
        size,
        size,
      );
      return this._errorTexture;
    }

    getDefaultTexture() {
      if (this._defaultTexture) return this._defaultTexture;
      const size = 256;
      this._defaultTexture = new Texture(this, {});
      this._defaultTexture.initFromData(
        CgTexture.getDefaultTextureData("stripes", size),
        size,
        size,
      );
      return this._defaultTexture;
    }

    /**
     * @param {function} cb
     * @param {boolean} _doScreenshotClearAlpha
     * @param {string} mimeType
     * @param {number} quality
     */
    screenShot(cb, _doScreenshotClearAlpha, mimeType, quality) {
      if (this.canvas && this.canvas.toBlob) {
        this.canvas.toBlob(
          (blob) => {
            if (cb) cb(blob);
            else this._log.log("no screenshot callback...");
          },
          mimeType,
          quality,
        );
      }
    }
  }

  class WebGpuCanvasAttachment {
    /** @type {HTMLCanvasElement} */
    #canvas = null;

    /** @type {CgpContext} */
    #cgp = null;

    /** @type {GPUCanvasContext} */
    #ctx = null;

    /**
     * @param {CgpContext} cgp
     */
    constructor(cgp) {
      this.#cgp = cgp;
      this.#canvas = document.createElement("canvas");
      this.#canvas.id = "webgpucanvasOut";
      this.#canvas.style.width = 128 + "px";
      this.#canvas.style.height = 128 + "px";
    }

    get canvas() {
      return this.#canvas;
    }

    /**
     * @param {function} cb
     */
    render(cb) {
      const canvas = this.#cgp.canvas;
      if (
        this.#canvas.width != canvas.width ||
        this.#canvas.height != canvas.height
      ) {
        this.#canvas.style.width = canvas.width + "px";
        this.#canvas.style.height = canvas.height + "px";
        this.#canvas.width = canvas.width;
        this.#canvas.height = canvas.height;
      }

      if (!this.#ctx) {
        this.#ctx = this.#canvas.getContext("webgpu");

        if (!this.#ctx) return console.log("no context", this.#canvas, this.#ctx);
        this.#ctx.configure({
          device: this.#cgp.device,
          format: this.#cgp.presentationFormat,
        });
      }

      // const cgp = this.#cgp;
      // cgp.canvasInfo.depthTextureView = this.#ctx.createView();

      this.#cgp.renderPassDescriptor = {
        label: "preview renderpass",
        colorAttachments: [
          {
            view: this.#ctx.getCurrentTexture().createView(),
            loadOp: "clear",
            storeOp: "store",
          },
        ],
        depthStencilAttachment: {
          view: this.#cgp.canvasInfo.depthTextureView,
          depthClearValue: 1,
          depthLoadOp: "clear",
          depthStoreOp: "store",
        },
      };

      // make a render pass encoder to encode render specific commands
      this.#cgp.passEncoder = this.#cgp.commandEncoder.beginRenderPass(
        this.#cgp.renderPassDescriptor,
      );
      this.#cgp.textureView = this.#ctx.getCurrentTexture().createView();
      this.#cgp.renderStart();

      cb();

      this.#cgp.tempPrevCanvas = this.#canvas;

      this.#cgp.renderEnd();
      this.#cgp.passEncoder.end();
    }
  }

  /** @extends Binding */
  class BindingStorage extends Binding {
    /** @type {CgpGguBuffer} */
    cgpbuffer = null;
    bindingType = "read-only-storage";

    /**
     * Description
     * @param {CgpContext} cgp
     * @param {string} name
     * @param {object} options
     */
    constructor(cgp, name, options) {
      super(cgp, name, options);
      this.cgpbuffer =
        options.cgpBuffer || new CgpGguBuffer(cgp, "temp", [0, 0, 0, 0]);
    }

    copy() {
      const b = new BindingStorage(this.cgp, this.name, this.options);
      return b;
    }

    /**
     * @returns {GPUBindingResource}
     * @param {number} _inst
     */
    getResource(_inst) {
      return {
        buffer: this.cgpbuffer.gpuBuffer,
      };
    }

    /**
     * @returns {GPUBindGroupLayoutEntry}
     * @param {CgpShader} [_shader]
     */
    getLayoutEntry(_shader = null) {
      /** @type {GPUBufferBindingType} */
      let access = "read-only-storage";

      if (this.stage & GPUShaderStage.COMPUTE)
        if (
          this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_SRC) &&
          this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_DST)
        )
          access = "storage";
      // else if (this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_DST)) access = "write-only-storage";

      return {
        visibility: this.stage,
        binding: this.bindNum,
        // "minBindingSize": this.getSizeBytes(),
        // "hasDynamicOffset": 0,
        buffer: {
          type: access,
        },
      };
    }

    /**
     * @param {CgpShader} _shader
     * @param {number} bindGroupNum
     */
    getShaderHeaderCode(_shader, bindGroupNum) {
      this.cgp.profileData.count("shadercode storage", this.name);
      let str = "";

      let access = "read";

      if (this.stage & GPUShaderStage.COMPUTE)
        if (
          this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_SRC) &&
          this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_DST)
        )
          access = "read_write";
        else if (this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_DST))
          access = "write";

      str += "@group(" + bindGroupNum + ") ";
      str += "@binding(" + this.bindNum + ") ";

      str += "var<storage," + access + "> ";
      let typeStr = "array<f32>";
      str += this.name + ": " + typeStr + ";\n";

      return str + "\n";
    }
  }

  /// <reference types="@webgpu/types" />

  class ComputePipeline extends Pipeline {
    #isValid = true;

    /** @type {string} */
    presentationFormat = null;

    /** @type {GPUComputePipelineDescriptor} */
    #pipeCfg = null;

    /** @type {GPUComputePipeline} */
    #computePipeline = null;

    /** @type {GPUBindGroupLayout} */
    bindGroupLayout = null;

    /** @type {GPUComputePassEncoder} */
    #computePassEncoder;

    #shaderListeners = [];
    #old = {};
    #errorCount = 0;
    lastRebuildReason = "first";
    rebuildCount = 0;
    profile = false;
    #rebuildNumBindingGroups = false;

    /**
     * Description
     * @param {CgpContext} _cgp
     * @param {String} name
     */
    constructor(_cgp, name) {
      super(_cgp, name, Pipeline.TYPE_COMPUTE);
    }

    /**
     * @param {CgpShader} shader
     * @param {CgpMesh} mesh
     */
    setPipeline(shader, mesh = null) {
      if (!shader) {
        this.log.log("pipeline unknown shader");
        return;
      }

      let needsRebuildReason = "";
      if (!this.#pipeCfg) needsRebuildReason = "no pipecfg";
      if (this.#old.mesh != mesh) needsRebuildReason = "no mesh";
      if (this.#old.shader != shader) {
        needsRebuildReason = "shader changed";
      }

      if (shader.needsPipelineUpdate) {
        needsRebuildReason = "shader needs update: " + shader.needsPipelineUpdate;
        shader.needsPipelineUpdate = "";
      }

      if (this.#rebuildNumBindingGroups) {
        needsRebuildReason = "num bindgroups wrong...";
      }

      this.pushDebug();

      if (needsRebuildReason != "") {
        this.cgp.profileData.count("pipeline created", this.name);

        this.lastRebuildReason = needsRebuildReason;
        this.rebuildCount++;
        // console.log("needsRebuildReason");
        this.cgp.pushErrorScope("createPipeline", { logger: this.log });

        this.#rebuildNumBindingGroups = false;

        this.#pipeCfg = this.getPipelineObject(shader);
        console.log(this.#pipeCfg);

        this.#old.device = this.cgp.device;
        this.#old.shader = shader;
        this.#old.mesh = mesh;
        this.#isValid = true;
        console.log(this.#pipeCfg);
        try {
          this.#computePipeline = this.cgp.device.createComputePipeline(
            this.#pipeCfg,
          );
        } catch (e) {
          console.error("pipe error catch...", e.message, this.#pipeCfg);
          this.#isValid = false;
        }

        this.cgp.popErrorScope(() => {
          console.log("this.#pipeCfg", this.#pipeCfg);
        });
      }

      if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();
    }

    /**
     * @param {CgpShader} shader
     * @returns {GPUComputePipelineDescriptor}
     */
    getPipelineObject(shader) {
      /** @type {Array<GPUBindGroupLayoutEntry>} */
      this.bindingGroupLayoutEntries = [];
      this.bindingGroupLayoutEntries =
        shader.defaultBindGroup.getLayoutEntries(shader);

      const bindGroupLayouts = [shader.defaultBindGroup.getLayout(shader)];

      /** @type {GPUPipelineLayout} */
      const pipelineLayout = this.cgp.device.createPipelineLayout({
        label: "pipe layout " + this.name,
        bindGroupLayouts: bindGroupLayouts,
      });

      /** @type {GPUComputePipelineDescriptor} */
      let pipeCfg = {
        label: this.name,
        layout: pipelineLayout,
        compute: {
          module: shader.gpuShaderModule,
          entryPoint: shader.options.entryPoint || "main",
        },
      };
      console.log("pipecft", pipeCfg, bindGroupLayouts);

      return pipeCfg;
    }

    /**
     * @param {CgpShader} shader
     * @param {Array} workGroups
     */
    compute(shader, workGroups = [8, 8]) {
      if (!shader.gpuShaderModule) shader.compile();

      /** @type {GPUCommandEncoder} */
      const commandEncoder = this.cgp.device.createCommandEncoder();

      this.#computePassEncoder = commandEncoder.beginComputePass({
        label: "computepass " + shader.getName(),
      });

      // if (!this.#computePipeline)
      this.setPipeline(shader);

      if (!this.#computePipeline) {
        this.log.warn("no render pipe");
        return;
      }

      this.#computePassEncoder.setPipeline(this.#computePipeline);
      shader.bind(this.#computePassEncoder);

      if (workGroups.length == 1)
        this.#computePassEncoder.dispatchWorkgroups(workGroups[0] || 8);
      else if (workGroups.length == 2)
        this.#computePassEncoder.dispatchWorkgroups(
          workGroups[0] || 8,
          workGroups[1] || 8,
        );
      else if (workGroups.length == 3)
        this.#computePassEncoder.dispatchWorkgroups(
          workGroups[0] || 8,
          workGroups[1] || 8,
          workGroups[2] || 8,
        );
      else console.log("workgroups length wrong,,,");

      this.#computePassEncoder.end();

      this.cgp.profileData.count("compute pipe", this.name);
      // console.log("llllllll", shader.defaultBindGroup.getLayout());
      const gpuCommands = commandEncoder.finish();
      this.cgp.device.queue.submit([gpuCommands]);
      this.pushDebug();
      // const entry = shader.bindingsVert[i].getBindingGroupEntry(shader.bindingCounter);
      // this._passEncoder = commandEncoder.beginComputePass();
      // this._passEncoder.setPipeline(computePipeline);
      // this.#passEncoder.setBindGroup(0, shader.defaultBindGroupshader.defaultBindGroup;
      // outBuff.setRef(gpuBuff);
    }

    dispose() {
      // todo...
    }
  }

  /**
   * @typedef UniformDescrip
   * @property {string} name
   * @property {string} type
   * @property {number} stage
   * @property {any} v1
   * @property {any} v2
   * @property {any} v3
   * @property {any} v4
   */

  class ShaderModifier {
    onBind = null;

    /**
     * @param {CgpContext} cgl
     * @param {string} name
     * @param {object} options
     */
    constructor(cgl, name, options) {
      /** @type {CgpContext} */
      this._cgl = cgl;
      this._name = name;
      this._origShaders = {};

      /** @type {Array<UniformDescrip>} */
      this._uniforms = [];
      this._structUniforms = [];
      this._definesToggled = {};
      this._defines = {};
      this._mods = [];
      this._textures = [];

      /** @type {object} */
      this._boundShader = null;
      this._changedDefines = true;
      this._changedUniforms = true;
      this._modulesChanged = false;
      this.needsTexturePush = false;

      /** @type {CgpShader} */
      this._lastShader = null;
      this._attributes = [];
      if (options && options.opId) this.opId = options.opId;
    }

    /**
     * @param {CgpShader} curShader
     * @param {boolean} pushShader
     */
    bind(curShader, pushShader = true) {
      const shader = curShader || this._cgl.getShader();
      if (!shader) return;

      this._boundShader = this._origShaders[shader.id];
      let missingMod = false;

      if (this._boundShader && this._lastShader != this._boundShader.shader) {
        // shader changed since last bind
        if (!this._boundShader.shader.hasModule(this._mods[0].id))
          missingMod = true;
      }

      if (missingMod) console.warn("copy because  (missingMod)");
      if (!this._boundShader) console.warn("copy because  (!this._boundShader)");
      else if (shader.lastCompile != this._boundShader.lastCompile)
        console.warn("copy because  shader.lastCompile");
      if (this._modulesChanged)
        console.warn("copy because  this._modulesChanged");
      if (shader._needsRecompile)
        console.warn(
          "copy because  shader._needsRecompile ",
          shader._compileReason,
        );

      if (
        missingMod ||
        !this._boundShader ||
        shader.lastCompile != this._boundShader.lastCompile ||
        this._modulesChanged ||
        shader._needsRecompile
      ) {
        if (this._boundShader) this._boundShader.shader.dispose();
        if (shader._needsRecompile) shader.compile();
        this.needsTexturePush = true;

        this._boundShader = this._origShaders[shader.id] = {
          lastCompile: shader.lastCompile,
          orig: shader,
          shader: shader.copy(),
        };

        console.log(
          "mod shaderrrrrrrrrrr",
          shader.getName(),
          this._boundShader.shader.getName(),
        );

        this._addModulesToShader(this._boundShader.shader);
        this._updateDefinesShader(this._boundShader.shader);
        this._updateUniformsShader(this._boundShader.shader);
      }

      this._boundShader.wireframe = shader.wireframe;
      if (this._changedDefines) this._updateDefines();
      if (this._changedUniforms) this._updateUniforms();

      if (pushShader) {
        this._cgl.pushShader(this._boundShader.shader);
        // console.log(this._boundShader.shader.id);
      }

      // this._boundShader.shader.copyUniformValues(this._boundShader.orig);

      if (this.needsTexturePush) {
        for (let j = 0; j < this._textures.length; j++) {
          const uniformName = this._textures[j][0];
          const tex = this._textures[j][1];
          const texType = this._textures[j][2];

          if (this._getUniform(uniformName)) {
            const name = this.getPrefixedName(uniformName);
            const uni = this._boundShader.shader.getUniform(name);

            if (uni) this._boundShader.shader.pushTexture(uni, tex, texType);
          }
        }

        this.needsTexturePush = false;
        this._textures.length = 0;
      }

      this._modulesChanged = false;

      this._boundShader.shader.fromMod = this;

      if (this.onBind) this.onBind(this._boundShader.shader);

      return this._boundShader.shader;
    }

    /**
     * @param {boolean} popShader
     */
    unbind(popShader = true) {
      if (this._boundShader) if (popShader) this._cgl.popShader();

      this._boundShader = null;
    }

    /**
     * @param {CgpShader} shader
     */
    _addModulesToShader(shader) {
      let firstMod;

      if (this._mods.length > 1) firstMod = this._mods[0];

      for (let i = 0; i < this._mods.length; i++)
        shader.addModule(this._mods[i], firstMod);
    }

    /**
     * @param {import("../cg/cg_shader.js").ShaderModule} mod
     */
    _removeModulesFromShader(mod) {
      for (const j in this._origShaders)
        this._origShaders[j].shader.removeModule(mod);
    }

    /**
     * @param {import("../cg/cg_shader.js").ShaderModule} mod
     */
    addModule(mod) {
      this._mods.push(mod);
      this._modulesChanged = true;
    }

    /**
     * @param {string} title
     */
    removeModule(title) {
      const indicesToRemove = [];
      for (let i = 0; i < this._mods.length; i++) {
        if (this._mods[i].title == title) {
          this._removeModulesFromShader(this._mods[i]);
          indicesToRemove.push(i);
        }
      }

      // * go in reverse order so the indices of the mods stay the same
      for (let j = indicesToRemove.length - 1; j >= 0; j -= 1)
        this._mods.splice(indicesToRemove[j], 1);

      this._modulesChanged = true;
    }

    /**
     * @param {CgpShader} shader
     */
    _updateUniformsShader(shader) {
      for (let i = 0; i < this._uniforms.length; i++) {
        const uni = this._uniforms[i];
        const name = this.getPrefixedName(uni.name);

        if (!shader.hasUniform(name)) {
          console.log("shadermod uni ", name, shader.id, uni.stage);
          const u = new CgpUniform(
            shader,
            uni.type,
            name,
            uni.v1,
            uni.v2,
            uni.v3,
            uni.v4,
          );

          console.log(uni);
          shader.addUniform(u, uni.stage);
        }
      }
    }

    _updateUniforms() {
      for (const j in this._origShaders)
        this._updateUniformsShader(this._origShaders[j].shader);

      this._changedUniforms = false;
    }

    /**
     * @param {CgShader} shader
     * @param {string} uniformName
     * @param {number} value
     */
    _setUniformValue(shader, uniformName, value) {
      const uniform = shader.getUniform(uniformName);

      if (uniform) uniform.setValue(value);
    }

    /**
     * @param {string} name
     * @param {number} value
     */
    setUniformValue(name, value) {
      const uni = this._getUniform(name);
      if (!uni) return;

      const defineName = this.getPrefixedName(name);

      for (const j in this._origShaders) {
        this._setUniformValue(this._origShaders[j].shader, defineName, value);
      }
    }

    /**
     * @param {string} name
     */
    hasUniform(name) {
      return !!this._getUniform(name);
    }

    /**
     * @param {string} name
     */
    _getUniform(name) {
      for (let i = 0; i < this._uniforms.length; i++) {
        if (this._uniforms[i].name == name) return this._uniforms[i];
      }
      return null;
    }

    /**
     * @param {number} stage
     * @param {string} name
     * @param {string} type
     * @param {any} valOrPort
     * @param {any} v2
     * @param {any} v3
     * @param {any} v4
     */
    addUniform(stage, type, name, valOrPort, v2, v3, v4) {
      if (!this._getUniform(name)) {
        this._uniforms.push({
          name: name,
          stage: stage,
          type: type,
          v1: valOrPort,
          v2: v2,
          v3: v3,
          v4: v4,
        });
        this._changedUniforms = true;
      }
    }

    // addUniformFrag(type, name, valOrPort, v2, v3, v4)
    // {
    //     this.addUniform(type, name, valOrPort, v2, v3, v4, null, null, null, "frag");
    //     this._changedUniforms = true;
    // }

    // addUniformVert(type, name, valOrPort, v2, v3, v4)
    // {
    //     this.addUniform(type, name, valOrPort, v2, v3, v4, null, null, null, "vert");
    //     this._changedUniforms = true;
    // }

    // addUniformBoth(type, name, valOrPort, v2, v3, v4)
    // {
    //     this.addUniform(type, name, valOrPort, v2, v3, v4, null, null, null, "both");
    //     this._changedUniforms = true;
    // }

    // addUniformStruct(structName, uniformName, members, shaderType)
    // {
    //     for (let i = 0; i < members.length; i += 1)
    //     {
    //         const member = members[i];
    //         if ((member.type === "2i" || member.type === "i" || member.type === "3i") && shaderType === "both")
    //             console.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", structName, " with member:", member.name, " of type:", member.type, ".");

    //         if (!this._getUniform(uniformName + "." + member.name))
    //         {
    //             this.addUniform(
    //                 member.type,
    //                 uniformName + "." + member.name,
    //                 member.v1,
    //                 member.v2,
    //                 member.v3,
    //                 member.v4,
    //                 uniformName,
    //                 structName,
    //                 member.name,
    //                 shaderType
    //             );
    //         }
    //     }
    //     if (!this._getStructUniform(uniformName))
    //     {
    //         this._structUniforms.push({
    //             "structName": structName,
    //             "uniformName": uniformName,
    //             "members": members,
    //             "shaderType": shaderType,
    //         });
    //     }
    // }

    // addUniformStructVert(structName, uniformName, members)
    // {
    //     this.addUniformStruct(structName, uniformName, members, "vert");
    // }

    // addUniformStructFrag(structName, uniformName, members)
    // {
    //     this.addUniformStruct(structName, uniformName, members, "frag");
    // }

    // addUniformStructBoth(structName, uniformName, members)
    // {
    //     this.addUniformStruct(structName, uniformName, members, "both");
    // }

    addAttribute(attr) {
      for (let i = 0; i < this._attributes.length; i++) {
        if (
          this._attributes[i].name == attr.name &&
          this._attributes[i].nameFrag == attr.nameFrag
        )
          return;
      }
      this._attributes.push(attr);
    }

    pushTexture(uniformName, tex, texType) {
      if (!tex) throw new Error("no texture given to texturestack");

      this._textures.push([uniformName, tex, texType]);
      this.needsTexturePush = true;
    }

    /**
     * @param {string} name
     * @param {CgShader} shader
     */
    _removeUniformFromShader(name, shader) {
      if (shader.hasUniform(name)) shader.removeUniform(name);
    }

    /**
     * @param {string} name
     */
    removeUniform(name) {
      if (this._getUniform(name)) {
        for (let j = this._uniforms.length - 1; j >= 0; j -= 1) {
          const nameToRemove = name;

          if (this._uniforms[j].name == name) {
            for (const k in this._origShaders) {
              this._removeUniformFromShader(
                this.getPrefixedName(nameToRemove),
                this._origShaders[k].shader,
              );
            }

            this._uniforms.splice(j, 1);
          }
        }
        this._changedUniforms = true;
      }
    }

    /**
     * @param {string} name
     */
    getPrefixedName(name) {
      const prefix = this._mods[0].group;
      if (prefix === undefined) {
        return;
      }
      if (name.startsWith("MOD_")) {
        name = name.substr("MOD_".length);
        name = "mod" + prefix + "_" + name;
      }
      return name;
    }

    /**
     * @param {CgpShader} shader
     */
    _updateDefinesShader(shader) {
      for (const i in this._defines) {
        const name = this.getPrefixedName(i);
        if (this._defines[i] !== null && this._defines[i] !== undefined)
          shader.define(name, this._defines[i]);
        else shader.removeDefine(name);
      }

      for (const i in this._definesToggled) {
        const name = this.getPrefixedName(i);
        shader.toggleDefine(name, this._definesToggled[i]);
      }
    }

    _updateDefines() {
      for (const j in this._origShaders)
        this._updateDefinesShader(this._origShaders[j].shader);

      this._changedDefines = false;
    }

    /**
     * @param {string | number} what
     * @param {boolean} value
     */
    define(what, value) {
      if (value === undefined) value = true;
      this._defines[what] = value;
      this._changedDefines = true;
    }

    /**
     * @param {string} name
     */
    removeDefine(name) {
      this._defines[name] = null;
      this._changedDefines = true;
    }

    /**
     * @param {string} name
     */
    hasDefine(name) {
      if (this._defines[name] !== null && this._defines[name] !== undefined)
        return true;
      return false;
    }

    /**
     * @param {string} name
     * @param {any} b
     */
    toggleDefine(name, b) {
      this._changedDefines = true;
      this._definesToggled[name] = b;
    }

    currentShader() {
      if (!this._boundShader) return null;
      return this._boundShader.shader;
    }

    dispose() {}
  }

  const CGP = {
    Context: CgpContext,
    Shader: CgpShader,
    Mesh: CgpMesh,
    Texture: Texture,
    Uniform: CgpUniform,
    MESHES: MESHES,
    GPUBuffer: CgpGguBuffer,
  };

  window.CABLES = window.CABLES || {};
  window.CABLES.CGP = CGP;
  window.CGP = CGP;
  window.CGP.WebGpuCanvasAttachment = WebGpuCanvasAttachment;
  window.CGP.RenderPipeline = RenderPipeline;
  window.CGP.ComputePipeline = ComputePipeline;
  window.CGP.ShaderModifier = ShaderModifier;

  window.CGP.BindingStorage = BindingStorage;
  window.CGP.BindingUniform = BindingUniform;
  window.CGP.BindingTexture = BindingTexture;
  window.CGP.BindingSampler = BindingSampler;

  /** @type {function}
   * @deprecated
   */
  const Marker = function (_cgl) {
    // deprecated...
    this.draw = function (cgl, _size, depthTest) {};
  };

  /** @type {function}
   * @deprecated
   */
  const WirePoint = function (cgl) {
    // deprecated...
    this.render = function (_cgl, _size) {};
  };

  /** @type {function}
   * @deprecated
   */
  const WireCube = function (cgl) {
    // deprecated...
    this.render = function (_cgl, sizeX, sizeY, sizeZ) {};
  };

  class UniColorShader {
    constructor(_cgl) {
      this.shader = new CGL.Shader(_cgl, "markermaterial");

      const frag =
        "".endl() +
        "void main()".endl() +
        "{".endl() +
        "    outColor = vec4(color.rgb,1.0);".endl() +
        "}";

      const vert =
        "".endl() +
        "IN vec3 vPosition;".endl() +
        "UNI mat4 projMatrix;".endl() +
        "UNI mat4 mvMatrix;".endl() +
        "void main()".endl() +
        "{".endl() +
        "   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);".endl() +
        "}";

      this.shader.setSource(vert, frag);
      this.coloruni = this.shader.addUniformFrag("4f", "color", [1, 0.777, 1, 1]);
    }

    setColor(r, g, b, a) {
      this.coloruni.set(r, g, b, a);
    }
  }

  const CGL$1 = {
    Framebuffer2: Framebuffer2,
    Geometry: Geometry,
    BoundingBox: BoundingBox,
    Marker: Marker,
    WirePoint: WirePoint,
    WireCube: WireCube,
    MatrixStack: MatrixStack,
    Mesh: Mesh,
    MESH: MESH,
    ShaderLibMods: ShaderLibMods,
    Shader: CglShader,
    Uniform: Uniform,
    MESHES: MESHES,
    Context: CglContext,
    Texture: Texture$1,
    TextureEffect: TextureEffect,
    isWindows: isWindows,
    getWheelSpeed: getWheelSpeed,
    getWheelDelta: getWheelDelta,
    onLoadingAssetsFinished: onLoadingAssetsFinished,
    ProfileData: ProfileData,
    UniColorShader: UniColorShader,
    ...CONSTANTS$1.BLEND_MODES,
    ...CONSTANTS$1.SHADER,
    ...CONSTANTS$1.MATH,
    ...CONSTANTS$1.BLEND_MODES,
  };

  window.CGL = CGL$1;

  const portType = {
    number: 0,
    trigger: 1,
    object: 2,
    array: 3,
    dynamic: 4,
    string: 5,
  };

  const PortDir = {
    out: 1,
    in: 0,
  };

  /**
   * default ops for various shortcuts/operations/files/variables etc.
   *
   */


  const defaultOpNames = {
    number: "Ops.Number.Number",
    string: "Ops.String.String_v2",
    array: "Ops.Array.Array_v3",
    randomarray: "Ops.Array.RandomNumbersArray_v4",
    defaultOpImage: "Ops.Gl.Texture_v2",
    defaultOpAudio: "Ops.WebAudio.AudioBuffer_v2",
    defaultOpVideo: "Ops.Gl.Textures.VideoTexture_v3",
    defaultOpGltf: "Ops.Gl.GLTF.GltfScene_v4",
    defaultOpJson: "Ops.Json.HttpRequest_v3",
    defaultOpExr: "Ops.Gl.Textures.ExrTexture",
    VarSetNumber: "Ops.Vars.VarSetNumber_v2",
    VarTriggerNumber: "Ops.Vars.VarTriggerNumber",
    VarGetNumber: "Ops.Vars.VarGetNumber_v2",
    VarSetObject: "Ops.Vars.VarSetObject_v2",
    VarTriggerObject: "Ops.Vars.VarTriggerObject",
    VarGetObject: "Ops.Vars.VarGetObject_v2",
    VarSetTexture: "Ops.Vars.VarSetTexture_v2",
    VarGetTexture: "Ops.Vars.VarGetTexture_v2",
    VarSetArray: "Ops.Vars.VarSetArray_v2",
    VarTriggerArray: "Ops.Vars.VarTriggerArray",
    VarGetArray: "Ops.Vars.VarGetArray_v2",
    VarSetString: "Ops.Vars.VarSetString_v2",
    VarTriggerString: "Ops.Vars.VarTriggerString",
    VarGetString: "Ops.Vars.VarGetString",
    VarSetTrigger: "Ops.Trigger.TriggerSend",
    VarGetTrigger: "Ops.Trigger.TriggerReceive",
    defaultFont: "Ops.Html.FontFile_v2",

    incrementor: "Ops.Math.Incrementor",

    performance: "Ops.Gl.Performance",

    subPatch: "Ops.Ui.SubPatch",
    subPatch2: "Ops.Ui.Subpatch2Template",
    subPatchInput2: "Ops.Ui.SubPatchInput",
    subPatchOutput2: "Ops.Ui.SubPatchOutput",

    uiArea: "Ops.Ui.Area",
    defaultOpSvg: "Ops.Gl.Textures.TextureSVG_v2",
    defaultOpCss: "Ops.Html.CSS.CssFile",

    defaultOpVizTexture: "Ops.Ui.VizTexture",

    BoolToString: "Ops.Boolean.BoolToString",
    NumberToString: "Ops.String.NumberToString_v2",

    TriggerOnChangeString: "Ops.Trigger.TriggerOnChangeString_v2",
    TriggerOnChangeArray: "Ops.Trigger.TriggerOnChangeArray_v2",
    TriggerOnChangeNumber: "Ops.Number.TriggerOnChangeNumber_v2",

    TriggerOnChangedTrue: "Ops.Boolean.TriggerChangedTrue",

    TriggerNumber: "Ops.Trigger.TriggerNumber",
    TriggerString: "Ops.Trigger.TriggerString",
    triggerCounter: "Ops.Trigger.TriggerCounter",

    StringLength: "Ops.String.StringLength_v2",
    parseFloat: "Ops.String.StringToNumber",
    arrayLength: "Ops.Array.ArrayLength_v2",
    StringToArray: "Ops.Array.StringToArray_v2",
    arrayToString: "Ops.Array.ArrayToString_v3",
    stringConcat: "Ops.String.Concat_v2",

    VizArrayTable: "Ops.Ui.VizArrayTable_v2",
    VizArrayGraph: "Ops.Ui.VizArrayGraph",
    VizBool: "Ops.Ui.VizBool",
    VizGraph: "Ops.Ui.VizGraph",
    VizNumber: "Ops.Ui.VizNumber",
    VizNumberBar: "Ops.Ui.VizNumberBar",
    VizObject: "Ops.Ui.VizObject",
    VizString: "Ops.Ui.VizString",
    VizTexture: "Ops.Ui.VizTexture",
    VizLogger: "Ops.Ui.VizLogger",
    vizTrigger: "Ops.Ui.VizTrigger",
    VizTextureTable: "Ops.Ui.VizTextureTable",

    stringEditor: "Ops.String.StringEditor",
    sequence: "Ops.Trigger.Sequence",
    divElement: "Ops.Html.Elements.DivElement_v3",
    customShader: "Ops.Gl.Shader.CustomShader_v2",

    GreaterThan: "Ops.Math.Compare.GreaterThan",
    LessThan: "Ops.Math.Compare.LessThan",
    Sum: "Ops.Math.Sum",
    Subtract: "Ops.Math.Subtract",
    Divide: "Ops.Math.Divide",
    Multiply: "Ops.Math.Multiply",
    Equals: "Ops.Math.Compare.Equals",
    Modulo: "Ops.Math.Modulo",
    ArraySum: "Ops.Array.ArraySum",
    ArraySubtract: "Ops.Array.ArraySubtract",
    ArrayDivide: "Ops.Array.ArrayDivide",
    ArrayMultiply: "Ops.Array.ArrayMultiply",
    parseObject: "Ops.Json.ParseObject_v2",

    textureGradient: "Ops.Gl.GradientTexture",
    textureNoise: "Ops.Gl.Textures.NoiseTexture",

    rerouteNumber: "Ops.Ui.Routing.RouteNumber",
    rerouteString: "Ops.Ui.Routing.RouteString",
    rerouteArray: "Ops.Ui.Routing.RouteArray",
    rerouteObject: "Ops.Ui.Routing.RouteObject",
    rerouteTrigger: "Ops.Ui.Routing.RouteTrigger",

    ArrayGetArray: "Ops.Data.JsonPath.ArrayGetArrayByPath",
    ArrayGetArrayValues: "Ops.Data.JsonPath.ArrayGetArrayValuesByPath",
    ArrayGetNumber: "Ops.Data.JsonPath.ArrayGetNumberByPath",
    ArrayGetObject: "Ops.Data.JsonPath.ArrayGetObjectByPath",
    ArrayGetString: "Ops.Data.JsonPath.ArrayGetStringByPath",
    ObjectGetArray: "Ops.Data.JsonPath.ObjectGetArrayByPath",
    ObjectGetArrayValues: "Ops.Data.JsonPath.ObjectGetArrayValuesByPath",
    ObjectGetNumber: "Ops.Data.JsonPath.ObjectGetNumberByPath",
    ObjectGetObject: "Ops.Data.JsonPath.ObjectGetObjectByPath",
    ObjectGetString: "Ops.Data.JsonPath.ObjectGetStringByPath",
    HttpRequest: "Ops.Json.HttpRequest_v3",
    glMainloop: "Ops.Gl.MainLoop_v2",
  };

  /**
   * default ops structure for assets, ports, math operations etc.
   */
  const defaultOps = {
    newOpNameSuggestion: "MyAwesomeOpName",
    defaultOpNames: defaultOpNames,
    prefixes: {
      op: "Ops.",
      patchOp: "Ops.Patch.P",
      userOp: "Ops.User.",
      teamOp: "Ops.Team.",
      extensionOp: "Ops.Extension.",
      webgpu: "Ops.Extension.WebGpu",
      webgl: "Ops.Gl.",
    },
    converterOps: [
      {
        typeFrom: portType.number,
        typeTo: portType.string,
        op: defaultOpNames.NumberToString,
        portIn: "Number",
        portOut: "Result",
      },
      {
        typeFrom: portType.number,
        typeTo: portType.string,
        op: defaultOpNames.BoolToString,
        portIn: "Boolean",
        portOut: "String",
      },

      {
        typeFrom: portType.number,
        typeTo: portType.trigger,
        op: defaultOpNames.TriggerOnChangeNumber,
        portIn: "Value",
        portOut: "Next",
      },
      {
        typeFrom: portType.string,
        typeTo: portType.trigger,
        op: defaultOpNames.TriggerOnChangeString,
        portIn: "String",
        portOut: "Changed",
      },
      {
        typeFrom: portType.array,
        typeTo: portType.trigger,
        op: defaultOpNames.TriggerOnChangeArray,
        portIn: "String",
        portOut: "Changed",
      },
      {
        typeFrom: portType.trigger,
        typeTo: portType.string,
        op: defaultOpNames.TriggerString,
        portIn: "Trigger",
        portOut: "Result",
      },
      {
        typeFrom: portType.trigger,
        typeTo: portType.number,
        op: defaultOpNames.TriggerNumber,
        portIn: "Set",
        portOut: "Out Value",
      },
      {
        typeFrom: portType.number,
        typeTo: portType.trigger,
        op: defaultOpNames.TriggerOnChangedTrue,
        portIn: "Value",
        portOut: "Next",
      },
      {
        typeFrom: portType.string,
        typeTo: portType.number,
        op: defaultOpNames.parseFloat,
        portIn: "String",
        portOut: "Number",
      },
      {
        typeFrom: portType.string,
        typeTo: portType.number,
        op: defaultOpNames.StringLength,
        portIn: "String",
        portOut: "Result",
      },
      {
        typeFrom: portType.array,
        typeTo: portType.number,
        op: defaultOpNames.arrayLength,
        portIn: "array",
        portOut: "length",
      },
      {
        typeFrom: portType.string,
        typeTo: portType.array,
        op: defaultOpNames.StringToArray,

        portIn: "text",
        portOut: "array",
      },
      {
        typeFrom: portType.array,
        typeTo: portType.string,
        op: defaultOpNames.arrayToString,
        portIn: "Array",
        portOut: "Result",
      },
      {
        typeFrom: portType.trigger,
        typeTo: portType.number,
        op: defaultOpNames.triggerCounter,
        portIn: "exe",
        portOut: "timesTriggered",
      },
      {
        typeFrom: portType.trigger,
        typeTo: portType.number,
        op: defaultOpNames.incrementor,
        portIn: "Increment",
        portOut: "Value",
      },
    ],
    jsonPathOps: {
      ArrayGetArray: defaultOpNames.ArrayGetArray,
      ArrayGetArrayValues: defaultOpNames.ArrayGetArrayValues,
      ArrayGetNumber: defaultOpNames.ArrayGetNumber,
      ArrayGetObject: defaultOpNames.ArrayGetObject,
      ArrayGetString: defaultOpNames.ArrayGetString,
      ObjectGetArray: defaultOpNames.ObjectGetArray,
      ObjectGetArrayValues: defaultOpNames.ObjectGetArrayValues,
      ObjectGetNumber: defaultOpNames.ObjectGetNumber,
      ObjectGetObject: defaultOpNames.ObjectGetObject,
      ObjectGetString: defaultOpNames.ObjectGetString,
    },
    hideInOpSelect: [
      "Ops.Ui.SubPatch",
      "Ops.Ui.Subpatch2Template",
      "Ops.Ui.SubPatchInput",
      "Ops.Ui.SubPatchOutput",
      "Ops.Ui.PatchInput",
      "Ops.Ui.PatchOutput",
    ],
    defaultMathOps: {
      default: {
        ">": defaultOpNames.GreaterThan,
        "<": defaultOpNames.LessThan,
        "+": defaultOpNames.Sum,
        "-": defaultOpNames.Subtract,
        "/": defaultOpNames.Divide,
        "*": defaultOpNames.Multiply,
        "=": defaultOpNames.Equals,
        "%": defaultOpNames.Modulo,
      },
      array: {
        "+": defaultOpNames.ArraySum,
        "-": defaultOpNames.ArraySubtract,
        "/": defaultOpNames.ArrayDivide,
        "*": defaultOpNames.ArrayMultiply,
      },
      string: {
        "+": defaultOpNames.stringConcat,
      },
    },
  };

  class opNames {}

  const Log = new Logger("opnames");

  opNames.getNamespaceClassName = (opName) => {
    const opNameParts = opName.split(".");
    return "nsColor_" + opNameParts[0] + "_" + opNameParts[1];
  };

  /**
   * @param {Port} p
   */
  opNames.getVizOpsForPortLink = (p) => {
    if (p && p.direction == PortDir.out) {
      if (p.type == portType.string)
        return [
          defaultOps.defaultOpNames.VizString,
          defaultOps.defaultOpNames.VizLogger,
        ];
      else if (
        p.type == portType.number &&
        (p.uiAttribs.display == "bool" || p.uiAttribs.display == "boolnum")
      )
        return [
          defaultOps.defaultOpNames.VizBool,
          defaultOps.defaultOpNames.VizNumber,
          defaultOps.defaultOpNames.VizLogger,
        ];
      else if (p.type == portType.number)
        return [
          defaultOps.defaultOpNames.VizNumber,
          defaultOps.defaultOpNames.VizGraph,
          defaultOps.defaultOpNames.VizNumberBar,
          defaultOps.defaultOpNames.VizLogger,
        ];
      else if (p.type == portType.array)
        return [
          defaultOps.defaultOpNames.VizArrayTable,
          defaultOps.defaultOpNames.VizArrayGraph,
        ];
      else if (p.type == portType.object && p.uiAttribs.objType == "texture")
        return [
          defaultOps.defaultOpNames.VizTexture,
          defaultOps.defaultOpNames.VizTextureTable,
          defaultOps.defaultOpNames.VizObject,
        ];
      else if (p.type == portType.object)
        return [defaultOps.defaultOpNames.VizObject];
    }
    return [];
  };

  /**
   * @param {Port} p
   */
  opNames.getOpsForPortLink = (p) => {
    if (p && p.direction == PortDir.in) {
      if (p.type == portType.string)
        return [
          defaultOps.defaultOpNames.string,
          defaultOps.defaultOpNames.stringEditor,
        ];
      else if (p.type == portType.number)
        return [defaultOps.defaultOpNames.number];
      else if (p.type == portType.array)
        return [
          defaultOps.defaultOpNames.array,
          defaultOps.defaultOpNames.randomarray,
          defaultOps.defaultOpNames.StringToArray,
        ];
      else if (p.type == portType.trigger)
        return [defaultOps.defaultOpNames.sequence];
      else if (p.type == portType.object && p.uiAttribs.objType == "texture")
        return [
          defaultOps.defaultOpNames.defaultOpImage,
          defaultOps.defaultOpNames.textureGradient,
          defaultOps.defaultOpNames.textureNoise,
        ];
      else if (p.type == portType.object && p.uiAttribs.objType == "element")
        return [defaultOps.defaultOpNames.divElement];
      else if (p.type == portType.object && p.uiAttribs.objType == "shader")
        return [defaultOps.defaultOpNames.customShader];
      else if (p.type == portType.object)
        return [defaultOps.defaultOpNames.parseObject];
    }
    if (p && p.direction == PortDir.out)
      if (p.type == portType.trigger)
        return [
          defaultOps.defaultOpNames.vizTrigger,
          defaultOps.defaultOpNames.sequence,
        ];

    return [];
  };

  /**
   * @param {String} filename
   */
  opNames.getOpsForFilename = (filename) => {
    const ops = [];
    if (!filename) return ops;

    filename = filename.toLowerCase();

    if (
      filename.endsWith(".png") ||
      filename.endsWith(".jpg") ||
      filename.endsWith(".jpeg") ||
      filename.endsWith(".jxl") ||
      filename.endsWith(".webp")
    )
      ops.push(defaultOps.defaultOpNames.defaultOpImage);
    else if (
      filename.endsWith(".ogg") ||
      filename.endsWith(".wav") ||
      filename.endsWith(".mp3") ||
      filename.endsWith(".m4a") ||
      filename.endsWith(".aac")
    )
      ops.push(defaultOps.defaultOpNames.defaultOpAudio);
    else if (
      filename.endsWith(".mp4") ||
      filename.endsWith(".m4a") ||
      filename.endsWith(".mpg") ||
      filename.endsWith(".webm") ||
      filename.endsWith(".mkv") ||
      filename.endsWith(".mov")
    )
      ops.push(defaultOps.defaultOpNames.defaultOpVideo);
    else if (filename.endsWith(".glb"))
      ops.push(defaultOps.defaultOpNames.defaultOpGltf);
    else if (filename.endsWith(".json"))
      ops.push(defaultOps.defaultOpNames.defaultOpJson);
    else if (
      filename.endsWith(".ttf") ||
      filename.endsWith(".woff") ||
      filename.endsWith(".woff2") ||
      filename.endsWith(".otf")
    )
      ops.push(defaultOps.defaultOpNames.defaultFont);
    else if (filename.endsWith(".exr"))
      ops.push(defaultOps.defaultOpNames.defaultOpExr);
    else if (filename.endsWith(".svg"))
      ops.push(defaultOps.defaultOpNames.defaultOpSvg);
    else if (filename.endsWith(".css"))
      ops.push(defaultOps.defaultOpNames.defaultOpCss);

    if (ops.length === 0 && defaultOps.defaultOpNames.defaultOpFallback)
      ops.push(defaultOps.defaultOpNames.defaultOpFallback);

    return ops;
  };
  opNames.getVarGetterOpNameByType = (type, port) => {
    let portName = "Value";
    let portNameOut = portName;
    let opSetterName = "unknown";
    let opGetterName = "unknown";
    let opSetTriggerName = "unknown";

    if (type == portType.number) {
      opSetterName = defaultOps.defaultOpNames.VarSetNumber;
      opGetterName = defaultOps.defaultOpNames.VarGetNumber;
      opSetTriggerName = defaultOps.defaultOpNames.VarTriggerNumber;
    } else if (type == portType.object) {
      opSetterName = defaultOps.defaultOpNames.VarSetObject;
      opGetterName = defaultOps.defaultOpNames.VarGetObject;
      opSetTriggerName = defaultOps.defaultOpNames.VarTriggerObject;

      if (port && port.uiAttribs.objType == "texture") {
        opSetterName = defaultOps.defaultOpNames.VarSetTexture;
        opGetterName = defaultOps.defaultOpNames.VarGetTexture;
      }
    } else if (type == portType.array) {
      opSetterName = defaultOps.defaultOpNames.VarSetArray;
      opGetterName = defaultOps.defaultOpNames.VarGetArray;
      opSetTriggerName = defaultOps.defaultOpNames.VarTriggerArray;
    } else if (type == portType.string) {
      opSetterName = defaultOps.defaultOpNames.VarSetString;
      opGetterName = defaultOps.defaultOpNames.VarGetString;
      opSetTriggerName = defaultOps.defaultOpNames.VarTriggerString;
    } else if (type == portType.trigger) {
      portName = "Trigger";
      portNameOut = "Triggered";

      opSetterName = defaultOps.defaultOpNames.VarSetTrigger;
      opGetterName = defaultOps.defaultOpNames.VarGetTrigger;
      opSetTriggerName = opSetterName;
    } else {
      Log.warn("createvar unknown var", type);
    }

    return {
      portName: portName,
      portNameOut: portNameOut,
      setter: opSetterName,
      getter: opGetterName,
      setTrigger: opSetTriggerName,
    };
  };

  /**
   * @param {number} type
   */
  opNames.getPortTypeClassHtml = (type) => {
    if (type == portType.number) return "port_text_color_value";
    if (type == portType.trigger) return "port_text_color_function";
    if (type == portType.object) return "port_text_color_object";
    if (type == portType.array) return "port_text_color_array";
    if (type == portType.string) return "port_text_color_string";
    if (type == portType.dynamic) return "port_text_color_dynamic";
    return "port_text_color_unknown";
  };

  /**
   * @param {number} type
   */
  opNames.getPortTypeClass = (type) => {
    if (type == portType.number) return "port_color_value";
    if (type == portType.trigger) return "port_color_function";
    if (type == portType.object) return "port_color_object";
    if (type == portType.array) return "port_color_array";
    if (type == portType.string) return "port_color_string";
    if (type == portType.dynamic) return "port_color_dynamic";
    return "port_color_unknown";
  };

  // opNames.getVarClass = (type) =>
  // {
  //     if (type == "number") return "port_text_color_value";
  //     if (type == "trigger") return "link_color_function";
  //     if (type == "object") return "port_text_color_object";
  //     if (type == "array") return "port_text_color_array";
  //     if (type == "string") return "port_text_color_string";
  //     else return "link_color_dynamic";
  // };

  /**
   * @param {number} type
   */
  opNames.getRerouteOp = (type) => {
    if (type == portType.number) return defaultOps.defaultOpNames.rerouteNumber;
    if (type == portType.string) return defaultOps.defaultOpNames.rerouteString;
    if (type == portType.array) return defaultOps.defaultOpNames.rerouteArray;
    if (type == portType.object) return defaultOps.defaultOpNames.rerouteObject;
    if (type == portType.trigger) return defaultOps.defaultOpNames.rerouteTrigger;
  };

  /**
   * Handlebars template helper functions
   */
  const handleBarsPrecompiled = {};

  const log$3 = new Logger("handlebarsjs");

  function handleBarPrecompiled(name) {
    let template = handleBarsPrecompiled[name];
    if (template) return template;

    const source = document.getElementById(name);
    if (!source || !source.innerHTML) {
      log$3.warn("template not found", "template " + name + " not found...");
      return;
    }
    const p = (handleBarsPrecompiled[name] = Handlebars.compile(
      source.innerHTML,
    ));
    return p;
  }

  /**
   * @param {string} name
   * @param {object} obj
   */
  function getHandleBarHtml(name, obj) {
    let perf;
    if (Gui$1.gui.gui) perf = Gui$1.gui.Gui.gui.uiProfiler.start("getHandleBarHtml");

    const template = handleBarPrecompiled(name);

    obj = obj || {};
    obj.frontendOptions = platform.frontendOptions;
    obj.cablesUrl = platform.getCablesUrl();
    obj.cablesDocsUrl = obj.cablesUrl;
    if (platform.getCablesDocsUrl)
      obj.cablesDocsUrl = platform.getCablesDocsUrl();

    const html = template(obj, {
      allowProtoMethodsByDefault: true,
      allowProtoPropertiesByDefault: true,
    });

    if (perf) perf.finish();

    return html;
  }

  /**
   * Managing bookmarks of a patch. bookmarks will be displayed in the param panel when no op is selected
   *
   * @export
   * @class Bookmarks
   */
  class Bookmarks {
    constructor() {
      this._bookmarks = [];
      this._dynCmds = [];
      this.needRefreshSubs = true;
      this._subs = null;
      // this._subpatchOps = {};
    }

    hasBookmarkWithId(id) {
      for (let i = 0; i < this._bookmarks.length; i++)
        if (this._bookmarks[i] === id) return true;

      return false;
    }

    cleanUp() {
      for (let i in this._bookmarks) {
        const op = Gui$1.gui.Gui.gui.corePatch().getOpById(this._bookmarks[i]);
        if (!op) this._bookmarks[i] = null;
      }
    }

    getHtml() {
      // if (this.needRefreshSubs)
      // {
      //     const subs = Gui.gui.Gui.gui.patchView.getSubPatches(true);
      //     const perf = Gui.gui.Gui.gui.uiProfiler.start("bookmark panel subpatches");

      //     this.needRefreshSubs = false;
      //     for (let i = 0; i < subs.length; i++)
      //     {
      //         const subPatchId = subs[i].id;

      //         subs[i].path = Gui.gui.Gui.gui.patchView.getSubpatchPathArray(subPatchId, null, true);
      //         let sortname = "";

      //         for (let j = 0; j < subs[i].path.length; j++)
      //             sortname = subs[i].path[j].name + "+" + sortname;

      //         subs[i].sortname = sortname;
      //     }

      //     subs.sort(function (a, b) { return a.sortname.localeCompare(b.sortname); });

      //     for (let i = 0; i < subs.length; i++)
      //     {
      //         subs[i].indent = "";
      //         for (let j = 0; j < subs[i].path.length; j++)
      //         {
      //             subs[i].indent += "&nbsp;&nbsp;&nbsp;&nbsp;";
      //         }
      //     }
      //     this._subs = subs;

      //     perf.finish();
      // }

      const perf = Gui$1.gui.Gui.gui.uiProfiler.start("bookmarks");

      const bm = [];
      for (const i in this._bookmarks) {
        const op = Gui$1.gui.Gui.gui.corePatch().getOpById(this._bookmarks[i]);

        if (op) {
          bm.push({
            id: this._bookmarks[i],
            name: op.name,
            objName: op.objName,
            class: opNames.getNamespaceClassName(op.objName),
          });
        }
      }
      bm.sort(function (a, b) {
        return a.name.localeCompare(b.name);
      });

      perf.finish();

      const perf2 = Gui$1.gui.Gui.gui.uiProfiler.start("bookmarks handlebars");
      let html = getHandleBarHtml("bookmarks", {
        bookmarks: bm,
        subPatches: this._subs,
        currentSubPatch: Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch(),
      });
      perf2.finish();

      // const perf3 = Gui.gui.Gui.gui.uiProfiler.start("update dynamic commands");
      // this.updateDynamicCommands();
      // perf3.finish();

      return html;
    }

    set(arr) {
      for (let i = 0; i < this._bookmarks.length; i++)
        this.setBoookmarkUiAttr(this._bookmarks[i], false);

      if (arr) this._bookmarks = arr;

      this.updateDynamicCommands();
    }

    setBoookmarkUiAttr(id, bookmarked) {
      const op = Gui$1.gui.Gui.gui.corePatch().getOpById(id);
      if (op) op.setUiAttrib({ bookmarked: bookmarked });
    }

    remove(id) {
      if (id) {
        this.setBoookmarkUiAttr(id, false);
        for (const i in this._bookmarks) {
          if (this._bookmarks[i] == id) this._bookmarks[i] = null;
        }
      }

      while (this._bookmarks.indexOf(null) >= 0)
        this._bookmarks.splice(this._bookmarks.indexOf(null), 1);
      Gui$1.gui.Gui.gui.corePatch().emitEvent("bookmarkschanged");
    }

    add(id) {
      if (id) {
        this.setBoookmarkUiAttr(id, true);
        for (const i in this._bookmarks) {
          if (this._bookmarks[i] == id) {
            this.remove(id);

            const elements = document.getElementsByClassName(
              "toggle-bookmark-button",
            );
            for (let eli = 0; eli < elements.length; eli++) {
              elements[eli].classList.remove("icon-bookmark-filled");
              elements[eli].classList.add("icon-bookmark");
            }
            notify(text.bookmark_removed);
            return;
          }
        }

        this._bookmarks.push(id);

        const elements = document.getElementsByClassName(
          "toggle-bookmark-button",
        );
        for (let eli = 0; eli < elements.length; eli++) {
          elements[eli].classList.add("icon-bookmark-filled");
          elements[eli].classList.remove("icon-bookmark");
        }

        Gui$1.gui.Gui.gui.patchView.centerSelectOp(id);
        notify(text.bookmark_added);
        Gui$1.gui.Gui.gui.corePatch().emitEvent("bookmarkschanged");
      }

      this.updateDynamicCommands();
    }

    goto(id) {
      if (!Gui$1.gui.Gui.gui.keys.shiftKey) {
        const op = Gui$1.gui.Gui.gui.corePatch().getOpById(id);
        Gui$1.gui.Gui.gui.opParams.show(op);
      } else {
        Gui$1.gui.Gui.gui.patchView.centerSelectOp(id);
      }
    }

    getBookmarks() {
      const bm = [];
      for (let i = 0; i < this._bookmarks.length; i++) {
        if (this._bookmarks[i] != null) bm.push(this._bookmarks[i]);
      }

      return bm;
    }

    updateDynamicCommands() {
      for (let i = 0; i < this._bookmarks.length; i++)
        this.setBoookmarkUiAttr(this._bookmarks[i], true);

      for (let i = 0; i < this._dynCmds.length; i++)
        Gui$1.gui.Gui.gui.cmdPallet.removeDynamic(this._dynCmds[i]);

      for (let i = 0; i < this._bookmarks.length; i++) {
        const op = Gui$1.gui.Gui.gui.corePatch().getOpById(this._bookmarks[i]);

        if (!op) continue;
        const cmd = Gui$1.gui.Gui.gui.cmdPallet.addDynamic(
          "bookmark",
          "" + op.getTitle(),
          () => {
            Gui$1.gui.Gui.gui.patchView.centerSelectOp(op.id);
          },
          "bookmark",
        );

        this._dynCmds.push(cmd);
      }

      const subs = Gui$1.gui.Gui.gui.patchView.getSubPatches(false);
      for (let i = 0; i < subs.length; i++) {
        const sub = subs[i];

        const cmd = Gui$1.gui.Gui.gui.cmdPallet.addDynamic(
          "subpatch",
          "" + sub.name,
          () => {
            Gui$1.gui.Gui.gui.patchView.setCurrentSubPatch(sub.id);
            CABLES.CMD.UI.centerPatchOps();
          },
          "subpatch",
        );

        this._dynCmds.push(cmd);
      }
    }
  }

  /**
   * storing/loading user settings/ sending to the user and in localstorage etc.
   *
   * @class UserSettings
   * @extends {Events}
   */
  class UserSettings extends Events {
    static userSettings = null;
    constructor() {
      super();

      this._settings = {};
      this._LOCALSTORAGE_KEY = "cables.usersettings";
      this._wasLoaded = false;
      this._serverDelay = null;
      this.init();

      this._lsSettings =
        JSON.parse(localStorage.getItem(this._LOCALSTORAGE_KEY)) || {};

      UserSettings.userSettings = this;
    }

    reset() {
      this._settings = {};
      this.init();
      this.save();
    }

    init() {
      if (!this.get("patch_wheelmode")) this.set("patch_wheelmode", "zoom");
      if (this.get("glflowmode") === null) this.set("glflowmode", 2);
      if (this.get("snapToGrid2") === null) this.set("snapToGrid2", false);
      if (this.get("bgpreview") === null) this.set("bgpreview", true);
      if (this.get("idlemode") === null) this.set("idlemode", false);
      if (this.get("showTipps") === null) this.set("showTipps", true);
      if (this.get("overlaysShow") === null) this.set("overlaysShow", false);
      if (this.get("quickLinkMiddleMouse") === null)
        this.set("quickLinkMiddleMouse", true);
      if (this.get("doubleClickAction") === null)
        this.set("doubleClickAction", "parentSub");
    }

    load(settings) {
      for (const i in settings) {
        this.set(i, settings[i]);
      }

      if (!this._wasLoaded) this.emitEvent("loaded");
      this._wasLoaded = true;
    }

    setLS(key, value) {
      this._lsSettings[key] = value || false;
      localStorage.setItem(
        CABLES.UI.LOCALSTORAGE_KEY,
        JSON.stringify(this._lsSettings),
      );
    }

    getLS(key) {
      if (!this._lsSettings || !this._lsSettings.hasOwnProperty(key)) return null;
      return this._lsSettings[key];
    }

    save() {
      platform.talkerAPI.send("saveUserSettings", { settings: this._settings });
    }

    /**
     * @param {String} key
     * @param {any} value
     */
    set(key, value) {
      if (value === "true") value = true;
      else if (value === "false") value = false;

      if (typeof value == "string" && CABLES.isNumeric(value))
        value = parseFloat(value);

      const wasChanged = this._settings[key] != value;

      this._settings[key] = value || false;

      if (this._wasLoaded) {
        let delay = 250;
        if (!CABLES.UI.loaded) delay = 2000;
        if (wasChanged) {
          clearTimeout(this._serverDelay);
          this._serverDelay = setTimeout(() => {
            this.save();
          }, delay);
        }
        if (wasChanged) this.emitEvent("change", key, value);
      }
    }

    /**
     * @param {String} key
     * @param {any} defaultValue=null
     */
    get(key, defaultValue = null) {
      if (!this._settings || !this._settings.hasOwnProperty(key))
        return defaultValue;
      return this._settings[key];
    }

    getAll() {
      return this._settings;
    }
  }

  /**
   * Show intro and explain gui elements
   *
   * @export
   * @class Introduction
   */
  class Introduction {
    constructor() {
      this._stepTmp = 1; /* the introjs position when it is explained */
      this._introStepsDefined = false;
    }

    /* Disables intro.js for the current logged-in user */
    disableIntroForUser() {
      UserSettings.userSettings.UserSettings.userSettings.set(
        "introCompleted",
        true,
      );
    }

    /**
     * Defines a intro step, performs check if element exists
     * @param {string} selector - Selector, can be class, id or element, first element picked
     * @param {string} text - The text to show for the element
     * @param {string} position - Where to show the intro for the element, either 'left', 'right', 'top' or 'bottom'
     */
    defineIntroStep(selector, text, position) {
      if (!selector || !text || !position) {
        console.error("defineIntroStep called with empty argument(s)");
        return;
      }
      const el = document.querySelector(selector);
      if (el) {
        /* if element exists */
        el.setAttribute("data-step", this._stepTmp);
        el.setAttribute("data-intro", text);
        this._stepTmp++;
      } else {
        console.error("introduction step missing, selector: ", selector);
      }
    }

    defineIntroSteps() {
      this.defineIntroStep(
        "#glpatch2",
        "Hi and welcome to cables! <br />This is the the patch panel. Here you can connect ops (operators) to create a patch.<br />Now press <code>Enter</code> to move on with the introduction.",
        "right",
      );
      this.defineIntroStep(
        "#cablescanvas",
        "This is the WebGL canvas where the visual output will be rendered to.",
        "bottom",
      );
      this.defineIntroStep(
        "#metatabpanel",
        "In the info area you get help. Hover over any element on the page to receive information about it.",
        "left",
      );
      this.defineIntroStep(
        "#patchname",
        "Click on the patch name to access the settings, here you can e.g. publish a patch or invite collaborators.",
        "bottom",
      );
      this.defineIntroStep(
        "#iconbar_sidebar_left",
        "In the sidebar you can access often used features.",
        "right",
      );
      this.defineIntroStep(
        ".nav-item-help",
        "Make sure to check out the video tutorials and documentation, these will help you get started in a blink!",
        "bottom",
      );
      this.defineIntroStep(
        '#iconbar_sidebar_left div[data-info="cmd_addop"]',
        "To add your first op to the patch you can press the <i>Add Op</i> icon, but it is much faster to just press the <code>Esc</code> key.<br />Happy patching!",
        "right",
      );
    }

    showIntroduction() {
      if (!this._introStepsDefined) {
        this.defineIntroSteps();
        this._introStepsDefined = true;
      }
      introJs()
        .oncomplete(() => {
          this.disableIntroForUser();
        })
        .onskip(() => {
          /* needed because of introjs 2.9.0 bug: https://github.com/usablica/intro.js/issues/848 */
          this.disableIntroForUser();
        })
        .setOptions({
          showBullets: false,
          skipLabel: "Close",
          showProgress: true,
          tooltipPosition: "left",
        })
        .start();
    }
  }

  class Jobs extends Events {
    constructor() {
      super();
      this._log = new Logger("Jobs");
      this._jobs = [];
      this._finishedJobs = [];
      this._lastIndicator = null;
      this._jobsEle = ele.byId("jobs");
      this._listenerStarted = false;
      this.hideProgressTimeout = null;
    }

    startListener() {
      this._listenerStarted = true;
    }

    getList() {
      let arr = [];
      for (const i in this._jobs) {
        arr.push(this._jobs[i]);
      }
      arr = arr.concat(this._finishedJobs);
      return arr;
    }

    updateJobListing() {
      if (!window.gui) return;

      if (platform.isOffline())
        ;

      if (this._jobs.length === 0) {
        this._visibleJobAnim = false;
        Gui$1.gui.Gui.gui.showLoadingProgress(false);
      } else this._visibleJobAnim = true;

      this._updateVisibility();
    }

    update(job, func) {
      for (const i in this._jobs) {
        if (this._jobs[i].id == job.id) {
          this._jobs[i].title = job.title;
          break;
        }
      }
      this.updateJobListing();
    }

    hasJob(id) {
      for (const i in this._jobs) {
        if (this._jobs[i].id == id) {
          return true;
        }
      }
    }

    start(job, func) {
      for (const i in this._jobs) {
        if (this._jobs[i].id == job.id) {
          this._jobs.splice(i, 1);
          break;
        }
      }

      if (!job.id) {
        this._log.error("job undefined", job, new Error());
      }

      Gui$1.gui.Gui.gui.showLoadingProgress(true);

      Gui$1.gui.Gui.gui.on("uiloaded", () => {
        this.updateJobListing();
      });

      if (!job.timeStart) job.timeStart = Date.now();

      this._jobs.push(job);
      this.updateJobListing();
      this.emitEvent("taskAdd");

      if (func) {
        setTimeout(func, 30);
      }

      if (!this.addedListeners) {
        this.addedListeners = true;
        gui
          .corePatch()
          .loading.on("finishedTask", this.updateAssetProgress.bind(this));
        gui
          .corePatch()
          .loading.on("addTask", this.updateAssetProgress.bind(this));
        gui
          .corePatch()
          .loading.on("startTask", this.updateAssetProgress.bind(this));
      }
    }

    _updateVisibility() {
      if (Gui$1.gui.Gui.gui.unload) return;
      const elContainer = ele.byId("uploadprogresscontainer");

      if (elContainer) return;

      if (this._visibleProgressBar) {
        clearTimeout(this.hideProgressTimeout);
        elContainer.classList.remove("hidden");
      } else {
        this.hideProgressTimeout = setTimeout(() => {
          elContainer.classList.add("hidden");
        }, 100);
      }

      if (Gui$1.gui.Gui.gui.isRemoteClient) {
        if (!this._visibleJobAnim && !this._visibleProgressBar)
          ele.byId("menubar").classList.add("hidden");
        else ele.byId("menubar").classList.remove("hidden");
      }
    }

    updateAssetProgress() {
      clearTimeout(this.removeProgressTo);
      let prog = Gui$1.gui.Gui.gui.corePatch().loading.getProgress();

      if (prog === 1) {
        this.removeProgressTo = setTimeout(() => {
          this._visibleProgressBar = false;
          this._updateVisibility();
        }, 100);
      }
      if (prog == 100) {
        this._visibleProgressBar = false;
        this._updateVisibility();
      } else {
        if (Gui$1.gui.Gui.gui.corePatch().loading.getNumAssets() > 2) {
          this._visibleProgressBar = true;
          this._updateVisibility();
        }

        clearTimeout(this.timeout);
        this.timeout = setTimeout(this.updateAssetProgress.bind(this), 300);
      }
    }

    setProgress(jobId, progress) {
      this._visibleProgressBar = progress != 100;

      let avg = 0;
      let avgCount = 0;
      for (const i in this._jobs) {
        if (this._jobs[i].id == jobId) this._jobs[i].progress = progress;

        if (this._jobs[i].progress) {
          avgCount++;
          avg += this._jobs[i].progress;
        }
      }
      if (avgCount) {
        const prog = avg / avgCount;
        ele.byId("uploadprogress").style.width = prog + "%";
        this._visibleProgressBar = prog != 100;
      }
      this._updateVisibility();
    }

    finish(jobId) {
      setTimeout(() => {
        for (const i in this._jobs) {
          if (this._jobs[i].id == jobId) {
            this._jobs[i].finished = true;
            this._jobs[i].timeEnd = Date.now();

            this._finishedJobs.push(this._jobs[i]);
            this._jobs.splice(i, 1);
            this.emitEvent("taskFinish");

            break;
          }
        }

        if (this._jobs.length === 0) {
          const logo = document.querySelector(".cables .logo");
          if (logo) {
            logo.classList.add("cablesLogo");
            logo.classList.remove("fa");
            logo.classList.remove("fa-circle-o-notch");
            logo.classList.remove("fa-spin");
          }
        }
        this.updateJobListing();
        this.emitEvent("taskFinish");
      }, 150);
    }
  }

  class OpHistory extends Events {
    constructor() {
      super();
      this._history = [];
      this._position = this._history.length - 1;
    }

    push(opid) {
      if (this._history[this._position] == opid) return;
      if (this._position != this._history.length - 1 && this._position > 0)
        this._history.length = this._position;

      this._history.push(opid);
      this._position = this._history.length - 1;

      this.emitEvent("changed");
    }

    back() {
      this._position--;
      let opid = this._history[this._position];

      if (Gui$1.gui.Gui.gui.patchView.isCurrentOpId(opid)) {
        this._position--;
        opid = this._history[this._position];
      }
      this._focusCurrent();
    }

    _focusCurrent() {
      const opid = this._history[this._position];

      if (!Gui$1.gui.Gui.gui.keys.shiftKey)
        Gui$1.gui.Gui.gui.patchView.focusOp(opid, true);
      else Gui$1.gui.Gui.gui.patchView.setSelectedOpById(opid);
    }

    forward() {
      if (this._position + 1 > this._history.length - 1) return;
      this._position++;
      this._focusCurrent();
    }

    getAsArray(max) {
      if (max === undefined) max = 9999;
      const h = [];
      const start = Math.max(0, this._history.length - max);
      const end = this._history.length - 1;

      for (let i = end; i >= start; i--) {
        const idx = i;
        const op = Gui$1.gui.Gui.gui.corePatch().getOpById(this._history[idx]);
        if (!op) continue;
        const o = {
          id: this._history[idx],
          title: op.uiAttribs.title,
        };
        h.push(o);
      }
      return h;
    }
  }

  class namespace {
    /**
     * @param {String} opname
     * @returns {String}
     */
    getNamespace(opname) {
      if (!opname) return "";
      const parts = opname.split(".");
      parts.length -= 1;
      return parts.join(".") + ".";
    }

    /**
     * @param {String} opname
     * @returns {String}
     */
    getCollectionName(opname) {
      return opname ? opname.split(".", 3).join(".") : null;
    }

    /**
     * @param {String} namespaceName
     * @returns {Boolean}
     */
    isNamespaceNameValid(namespaceName) {
      return this.isOpNameValid(namespaceName, 4, 1);
    }

    /**
     * @param {String} opName
     * @param {Number} minLength
     * @param {Number} minParts
     * @returns {Boolean}
     */
    isOpNameValid(opName, minLength = 6, minParts = 3) {
      if (!opName) return false;
      if (opName.length < minLength) return false;
      if (opName.indexOf("..") !== -1) return false;
      let matchString =
        "[^abcdefghijklmnopqrstuvwxyz._ABCDEFGHIJKLMNOPQRSTUVWXYZ0-9";
      // patchops can have - because they contain the patch shortid
      if (this.isPatchOp(opName) || this.isTeamOp(opName)) matchString += "\\-";
      matchString += "]";
      if (opName.match(matchString)) return false;

      const parts = opName.split(".");
      if (parts.length < minParts) return false;

      for (
        let i = 0;
        i < parts.length;
        i++ // do not start
      ) {
        const firstChar = parts[i].charAt(0);
        const isnum = firstChar && !isNaN(firstChar);
        if (isnum) return false;
        if (firstChar === "-") return false;
      }

      if (opName.endsWith(".json")) return false;

      return opName.startsWith(defaultOps.prefixes.op);
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isDevOp(opname) {
      return opname && opname.includes(".Dev.");
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isUserOp(opname) {
      return opname && opname.startsWith(defaultOps.prefixes.userOp);
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isCurrentUserOp(opname) {
      return this.isUserOpOfUser(opname, Gui$1.gui.Gui.gui.user.usernameLowercase);
    }

    /**
     * @param {String} opname
     * @param {String} userNameLowercase
     * @returns {Boolean}
     */
    isUserOpOfUser(opname, userNameLowercase) {
      return (
        opname &&
        opname.startsWith(defaultOps.prefixes.userOp + userNameLowercase)
      );
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isDeprecatedOp(opname) {
      return opname && opname.includes(".Deprecated.");
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isExtensionOp(opname) {
      return opname && opname.startsWith(defaultOps.prefixes.extensionOp);
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isTeamOp(opname) {
      return opname && opname.startsWith(defaultOps.prefixes.teamOp);
    }

    isCollectionOp(opname) {
      return opname && (this.isExtensionOp(opname) || this.isTeamOp(opname));
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isCoreOp(opname) {
      return !(
        this.isUserOp(opname) ||
        this.isExtensionOp(opname) ||
        this.isTeamOp(opname) ||
        this.isPatchOp(opname)
      );
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isPrivateOp(opname) {
      return (
        this.isTeamOp(opname) || this.isPatchOp(opname) || this.isUserOp(opname)
      );
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isPatchOp(opname) {
      return opname && opname.indexOf(defaultOps.prefixes.patchOp) === 0;
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isExtension(opname) {
      if (!opname) return false;
      if (!opname.startsWith(defaultOps.prefixes.extensionOp)) return false;
      if (!opname.endsWith(".")) opname += ".";
      const parts = opname.split(".");
      return parts.length < 5;
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isCollection(opname) {
      return opname && (this.isExtension(opname) || this.isTeamNamespace(opname));
    }

    /**
     * @param {String} opname
     * @returns {Boolean}
     */
    isTeamNamespace(opname) {
      if (!opname) return false;
      if (!opname.startsWith(defaultOps.prefixes.teamOp)) return false;
      if (!opname.endsWith(".")) opname += ".";
      const parts = opname.split(".");
      return parts.length < 5;
    }

    getNamespaceHierarchyProblem(outerName, innerName) {
      if (!outerName || !innerName) return "Unknown op";
      if (
        this.getNamespace(innerName).startsWith(this.getNamespace(outerName)) ||
        this.getNamespace(outerName).startsWith(this.getNamespace(innerName))
      )
        return false;

      if (this.isCoreOp(outerName)) {
        if (this.isExtensionOp(innerName))
          return "(SubpatchOp) Core ops cannot contain extension ops.";
        if (this.isTeamOp(innerName))
          return "(SubpatchOp) Core ops cannot contain team ops.";
        if (this.isUserOp(innerName))
          return "(SubpatchOp) Core ops cannot contain user ops.";
        if (this.isPatchOp(innerName))
          return "(SubpatchOp) Core ops cannot contain patch ops.";
      } else if (this.isExtensionOp(outerName)) {
        if (this.isTeamOp(innerName))
          return "(SubpatchOp) Extension ops cannot contain team ops.";
        if (this.isUserOp(innerName))
          return "(SubpatchOp) Extension ops cannot contain user ops.";
        if (this.isPatchOp(innerName))
          return "(SubpatchOp) Extension ops cannot contain patch ops.";
      } else if (this.isTeamOp(outerName)) {
        if (
          this.isTeamOp(innerName) &&
          this.getNamespace(innerName) !== this.getNamespace(outerName)
        )
          return "(SubpatchOp) Team ops cannot contain ops of other teams.";
        if (this.isUserOp(innerName))
          return "(SubpatchOp) Team ops cannot contain user ops.";
        if (this.isPatchOp(innerName))
          return "(SubpatchOp) Team ops cannot contain patch ops.";
      } else if (this.isUserOp(outerName)) {
        if (
          this.isUserOp(innerName) &&
          this.getNamespace(innerName) !== this.getNamespace(outerName)
        )
          return "(SubpatchOp) User ops cannot contain ops of other users.";
        if (this.isPatchOp(innerName))
          return "(SubpatchOp) User ops cannot contain patch ops.";
      } else if (this.isPatchOp(outerName)) ;

      return false;
    }
  }

  var namespace$1 = new namespace();

  class PortHtmlGenerator {
    constructor(panelId) {
      this._panelId = panelId;
      this._templateHead = handleBarPrecompiled("params_op_head");
      this._templatePortGeneral = handleBarPrecompiled("params_port_general");
      this._templatePortGeneralEnd = handleBarPrecompiled(
        "params_port_general_end",
      );
      this._templatePortInput = handleBarPrecompiled("params_port_input");
      this._templatePortOutput = handleBarPrecompiled("params_port_output");
      this._templatePortsHead = handleBarPrecompiled("params_ports_head");
    }

    getHtmlOpHeader(op) {
      let isBookmarked = false;
      let oldversion = false;
      let newestVersion = false;
      let hasExample = false;
      let doc = null;

      if (op) isBookmarked = Gui$1.gui.Gui.gui.bookmarks.hasBookmarkWithId(op.id);

      const canEditOp = Gui$1.gui.Gui.gui.serverOps.canEditOp(
        Gui$1.gui.Gui.gui.user,
        op.objName,
      );
      if (namespace$1.isDeprecatedOp(op.objName)) {
        op.isDeprecated = true;
        const notDeprecatedName = op.objName.replace("Deprecated.", "");
        const alt = CABLES.Patch.getOpClass(notDeprecatedName);
        if (alt) op.isDeprecatedAlternative = notDeprecatedName;
      }
      if (namespace$1.isDevOp(op.objName)) op.isExperimental = true;

      if (Gui$1.gui.Gui.gui.opDocs) {
        op.summary = Gui$1.gui.Gui.gui.opDocs.getSummary(op.objName);
        doc = Gui$1.gui.Gui.gui.opDocs.getOpDocByName(op.objName);
      }

      if (doc) {
        hasExample = doc.hasExample;
        if (doc.oldVersion) oldversion = doc.oldVersion;
        newestVersion = doc.newestVersion;
      }

      let opChanged = false;
      if (Gui$1.gui.serverOps.opIdsChangedOnServer[op.opId]) opChanged = true;

      const o = {
        op: op,
        panelid: this._panelId,
        frontendOptions: platform.frontendOptions,
        isBookmarked: isBookmarked,
        colorClass: opNames.getNamespaceClassName(op.objName),
        texts: text,
        user: Gui$1.gui.Gui.gui.user,
        optitle: op.getTitle(),
        canEditOp: canEditOp,
        opChanged: opChanged,
        oldVersion: oldversion,
        minified:
          UserSettings.userSettings.UserSettings.userSettings.get(
            "minifiedOpHead",
          ),
        newestVersion: newestVersion,
        cablesUrl: platform.getCablesUrl(),
        hasExample: hasExample,
      };

      o.cablesDocsUrl = platform.getCablesDocsUrl();

      return this._templateHead(o, {
        allowProtoPropertiesByDefault: true,
        allowProtoMethodsByDefault: true,
      });
    }

    /**
     * @param {string} dir
     * @param {string} title
     */
    getHtmlHeaderPorts(dir, title) {
      return this._templatePortsHead(
        {
          dirStr: dir,
          title: title,
          texts: text,
        },
        { allowProtoPropertiesByDefault: true, allowProtoMethodsByDefault: true },
      );
    }

    /**
     * @param {Array<Port>} ports
     * @returns {string}
     */
    getHtmlInputPorts(ports) {
      let html = "";
      let lastGroup = null;

      for (let i = 0; i < ports.length; i++) {
        const opGroup = ports[i].uiAttribs.group;
        let startGroup = null;
        let groupSpacer = false;

        if (!ports[i].uiAttribs.hideParam) {
          if (lastGroup != opGroup && !opGroup) groupSpacer = true;

          if (lastGroup != opGroup) {
            groupSpacer = true;
            lastGroup = opGroup;
            startGroup = lastGroup;
          }
        }

        ports[i].watchId = "in_" + i;

        const tmplData = {
          port: ports[i],
          panelid: this._panelId,
          startGroup: startGroup,
          groupSpacer: groupSpacer,
          dirStr: "in",
          cablesUrl: platform.getCablesUrl(),
          openLocalFiles: platform.frontendOptions.openLocalFiles,
          portnum: i,
          isInput: true,
          op: ports[i].op,
          texts: text,
          vars: ports[i].op.patch.getVars(ports[i].type),
        };

        html += this._templatePortGeneral(tmplData, {
          allowProtoPropertiesByDefault: true,
          allowProtoMethodsByDefault: true,
        });
        html += this._templatePortInput(tmplData, {
          allowProtoPropertiesByDefault: true,
          allowProtoMethodsByDefault: true,
        });
        html += this._templatePortGeneralEnd(tmplData, {
          allowProtoPropertiesByDefault: true,
          allowProtoMethodsByDefault: true,
        });
      }
      return html;
    }

    /**
     * @param {Array<Port>} ports
     * @returns {string}
     */
    getHtmlOutputPorts(ports) {
      let lastGroup = null;
      let html = "";
      for (const i in ports) {
        if (
          ports[i].getType() == portType.number ||
          ports[i].getType() == portType.array ||
          ports[i].getType() == portType.string ||
          ports[i].getType() == portType.object
        )
          ports[i].watchId = "out_" + i;

        let startGroup = null;
        let groupSpacer = false;

        const opGroup = ports[i].uiAttribs.group;

        if (lastGroup != opGroup && !opGroup) groupSpacer = true;
        if (lastGroup != opGroup) {
          groupSpacer = true;
          lastGroup = opGroup;
          startGroup = lastGroup;
        }

        const tmplData = {
          port: ports[i],
          dirStr: "out",
          panelid: this._panelId,
          groupSpacer: groupSpacer,
          startGroup: startGroup,
          portnum: i,
          isInput: false,
          op: ports[i].op,
        };
        html += this._templatePortGeneral(tmplData, {
          allowProtoPropertiesByDefault: true,
          allowProtoMethodsByDefault: true,
        });
        html += this._templatePortOutput(tmplData, {
          allowProtoPropertiesByDefault: true,
          allowProtoMethodsByDefault: true,
        });
        html += this._templatePortGeneralEnd(tmplData, {
          allowProtoPropertiesByDefault: true,
          allowProtoMethodsByDefault: true,
        });
      }

      return html;
    }
  }

  class GlUiConfig {
    constructor() {
      this.OpTitlePaddingLeftRight = 10;
      this.OpTitlePaddingExtTitle = 1;

      this.portWidth = 10;
      this.portHeight = 5;

      this.portPadding = 2;
      // this.portLongPortHeight = this.portPadding * 1.5;
      this.portLongPortHeight = this.portHeight;

      this.opHeight = 31;
      this.opWidth = 20;

      this.minZoom = 15;
      this.zoomDefault = 500;

      this.newOpDistanceY = 40;

      this.drawBoundingRect = true;
      this.clickMaxDuration = 300;

      this.zPosOpUnSelected = -0.5;
      this.zPosOpSelected = -0.6;
      this.zPosOpUnlinked = 0.1;

      this.zPosCableButtonRect = -0.4;
      this.zPosCables = -0.4;
      this.zPosGreyOutRect = -0.1;

      this.zPosGlRectSelected = 0.25; // is relative child of op glbgrect
      this.zPosGlTitle = -0.01; // is relative child of op glbgrect

      this.subPatchOpBorder = 2;
      this.rectResizeSize = 10;
    }
  }

  const gluiconfig = new GlUiConfig();

  const undo = typeof window !== "undefined" && new window.UndoManager();

  /**
   * @typedef TabOptions
   * @property {String} [name]
   * @property {boolean} [singleton]
   * @property {boolean} [closable]
   * @property {boolean} [hideToolbar]
   * @property {boolean} [showTitle]
   * @property {boolean} [padding]
   * @property {TabPanel} [tabPanel]
   * @property {string} [dataId]
   * @property {string} [icon]
   * @property {string} [infotext]
   */

  class Tab extends Events {
    /**
     * @param {String} title
     * @param {TabOptions} options
     */
    constructor(title, options) {
      super();
      this.id = CABLES.uuid();

      /** @type {TabOptions} */
      this.options = options || {};
      if (!this.options.hasOwnProperty("showTitle"))
        this.options.showTitle = true;
      if (!this.options.hasOwnProperty("hideToolbar"))
        this.options.hideToolbar = false;
      if (!this.options.hasOwnProperty("closable")) this.options.closable = true;
      if (!this.options.hasOwnProperty("name"))
        this.options.name = title || "???";

      this.tabPanel = this.options.tabPanel || null;
      this.icon = this.options.icon || null;
      this.dataId = this.options.dataId;
      this.title = title;
      this.active = false;
      this.toolbarContainerEle = document.createElement("div");
      this.contentEle = document.createElement("div");
      this.toolbarEle = document.createElement("div");
      this.buttons = [];
    }

    initHtml(eleContainer) {
      if (!this.options.hideToolbar) {
        this.toolbarContainerEle.id = "toolbar" + this.id;
        this.toolbarContainerEle.classList.add("toolbar");
        this.toolbarContainerEle.innerHTML = getHandleBarHtml(
          "tabpanel_toolbar",
          {
            options: this.options,
            id: this.id,
            title: this.title,
            hideToolbar: true,
          },
        );
        eleContainer.appendChild(this.toolbarContainerEle);

        const tbEl = ele.byId("toolbarContent" + this.id);
        if (tbEl) tbEl.appendChild(this.toolbarEle);
      }

      this.contentEle.id = "content" + this.id;
      this.contentEle.classList.add("tabcontent");
      if (this.options.padding) this.contentEle.classList.add("padding");
      this.contentEle.innerHTML = "";
      eleContainer.appendChild(this.contentEle);
    }

    /**
     * @param {HTMLElement} el
     */
    addButtonBarElement(el) {
      this.toolbarEle.appendChild(el);
    }

    addButtonSpacer() {
      const button = document.createElement("span");
      button.innerHTML = "&nbsp;&nbsp;&nbsp;";
      this.toolbarEle.appendChild(button);
      this.buttons.push({ ele: button });
      return button;
    }

    /**
     * @param {string} title
     * @param {Function} cb
     */
    addButton(title, cb, classes) {
      const button = document.createElement("a");
      button.classList.add("button-small");

      let html = "";
      html += title;
      button.innerHTML = html;
      ele.clickable(button, cb);
      this.toolbarEle.appendChild(button);
      this.buttons.push({ ele: button, cb, title });
      if (classes)
        for (let i = 0; i < classes.length; i++) button.classList.add(classes[i]);
      return button;
    }

    getSaveButton() {
      for (let i = 0; i < this.buttons.length; i++)
        if (this.buttons[i].title == text.editorSaveButton)
          return this.buttons[i];
    }

    remove() {
      this.emitEvent("close", this);
      this.contentEle.remove();
      this.toolbarContainerEle.remove();
      if (this.tabPanel) this.tabPanel.closeTab(this.id);
    }

    /**
     * @param {string} html
     */
    html(html) {
      this.contentEle.innerHTML = html;
      this.updateSize();
    }

    isVisible() {
      return this.active;
    }

    updateSize() {
      if (!this.contentEle || !this.contentEle.parentElement) return;
      if (!this.toolbarContainerEle) return;
      this.contentEle.style.height =
        this.contentEle.parentElement.clientHeight -
        this.toolbarContainerEle.clientHeight -
        3 +
        "px";
    }

    activate() {
      this.active = true;
      this.contentEle.style.display = "block";
      this.toolbarContainerEle.style.display = "block";
      this.updateSize();
      this.emitEvent("onActivate");
    }

    deactivate() {
      this.active = false;
      this.contentEle.style.display = "none";
      this.toolbarContainerEle.style.display = "none";
      this.emitEvent("onDeactivate");
    }
  }

  var srcSubPatchOp = `
const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    if(!attachments || !attachments.subpatch_json) return;

    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)Gui.gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}
`;

  const subPatchOpUtil = {};

  subPatchOpUtil.blueprintPortJsonAttachmentFilename = "att_ports.json";
  subPatchOpUtil.blueprintSubpatchAttachmentFilename = "att_subpatch_json";

  const _log = new Logger("subPatchOpUtil");

  subPatchOpUtil.executeBlueprintIfMultiple = (opname, next) => {
    const ops = Gui$1.gui.Gui.gui.corePatch().getOpsByObjName(opname);

    if (ops.length > 0) {
      Gui$1.gui.Gui.gui.serverOps.execute(ops[0].opId, next);
    } else {
      _log.log("no need to execute bp op");
      next();
    }
  };

  subPatchOpUtil.generatePortsAttachmentJsSrc = (ports) => {
    let src = "";

    if (!ports || !ports.ports) ports = { ports: [] };

    for (let i = 0; i < ports.ports.length; i++) {
      const p = ports.ports[i];
      if (!p || !p.id) continue;
      src += "const port_" + p.id + "=";

      if (p.dir == 0) {
        // INPUT
        if (p.type == portType.string && p.display == "switch")
          src += "op.inSwitch";
        else if (p.type == portType.number) src += "op.inFloat";
        else if (p.type == portType.trigger) src += "op.inTrigger";
        else if (p.type == portType.object) src += "op.inObject";
        else if (p.type == portType.array) src += "op.inArray";
        else if (p.type == portType.string) src += "op.inString";

        src += '("' + p.id + '"'; // 1. name

        if (p.type == portType.string)
          src += ',"' + String(p.value).replaceAll("\n", "\\n") + '"'; // 2. param default value
        if (p.type == portType.number) src += "," + p.value; // 2. param default value

        src += ");";
      } // OUTPUT
      else {
        if (p.type == portType.number) src += "op.outNumber";
        if (p.type == portType.trigger) src += "op.outTrigger";
        if (p.type == portType.object) src += "op.outObject";
        if (p.type == portType.array) src += "op.outArray";
        if (p.type == portType.string) src += "op.outString";

        src += '("' + p.id + '"'; // 1. name

        src += ");";
      }

      src += "".endl();
      src += "port_" + p.id + ".setUiAttribs({";
      if (p.title) src += 'title:"' + p.title + '",';

      if (p.uiDisplay == "texture") src += 'display:"texture",objType:"texture",';
      else if (p.uiDisplay == "int") src += 'increment:"integer",';
      else if (p.uiDisplay) src += 'display:"' + p.uiDisplay + '",';

      if (p.objType) src += 'objType:"' + p.objType + '"';

      src += "});".endl();

      if (p.values)
        src +=
          "port_" +
          p.id +
          '.setUiAttribs({"values":' +
          JSON.stringify(p.values) +
          "});".endl();
      if (p.addUiAttribs)
        src +=
          "port_" +
          p.id +
          ".setUiAttribs(" +
          JSON.stringify(p.addUiAttribs) +
          ");".endl();

      src += "".endl();
    }

    src +=
      "op.initInnerPorts=function(addedOps)".endl() +
      "{".endl() +
      "  for(let i=0;i<addedOps.length;i++)".endl() +
      "  {".endl() +
      "    if(addedOps[i].innerInput)".endl() +
      "    {".endl();

    for (let i = 0; i < ports.ports.length; i++) {
      const p = ports.ports[i];
      if (!p) continue;
      if (p.dir != 0) continue; // only INPUT ports: add OUTPUTS to inner input op

      let outPortFunc = "outNumber";

      if (p.type == portType.object && p.uiDisplay == "texture")
        outPortFunc = "outTexture";
      else if (p.type == portType.trigger) outPortFunc = "outTrigger";
      else if (p.type == portType.object) outPortFunc = "outObject";
      else if (p.type == portType.array) outPortFunc = "outArray";
      else if (p.type == portType.string) outPortFunc = "outString";

      src +=
        "const innerOut_" +
        p.id +
        " = addedOps[i]." +
        outPortFunc +
        '("innerOut_' +
        p.id +
        '");'.endl();

      if (
        ports.ports[i].type == portType.number ||
        ports.ports[i].type == portType.string
      )
        src += "innerOut_" + p.id + ".set(port_" + p.id + ".get() );".endl();

      if (p.title)
        src += "innerOut_" + p.id + '.setUiAttribs({title:"' + p.title + '"});\n';

      if (p.type == 0 || p.type == 5)
        src +=
          "port_" +
          p.id +
          '.on("change", (a,v) => { innerOut_' +
          p.id +
          ".set(a); });".endl();
      else if (p.type == 1)
        src +=
          "port_" +
          p.id +
          ".onTriggered = () => { innerOut_" +
          p.id +
          ".trigger(); };".endl();
      else
        src +=
          "port_" +
          p.id +
          '.on("change", (a,v) => { innerOut_' +
          p.id +
          ".setRef(a); });".endl();

      src += "".endl();
    }

    src += "    }".endl();

    src += "if(addedOps[i].innerOutput)".endl() + "{".endl();

    for (let i = 0; i < ports.ports.length; i++) {
      const p = ports.ports[i];
      if (!p) continue;
      if (p.dir != 1) continue;

      let inPortFunc = "inFloat";
      if (ports.ports[i].type == portType.trigger) inPortFunc = "inTrigger";
      if (ports.ports[i].type == portType.object) inPortFunc = "inObject";
      if (ports.ports[i].type == portType.array) inPortFunc = "inArray";
      if (ports.ports[i].type == portType.string) inPortFunc = "inString";

      src +=
        "const innerIn_" +
        p.id +
        " = addedOps[i]." +
        inPortFunc +
        '("innerIn_' +
        p.id +
        '");'.endl();
      if (p.title)
        src += "innerIn_" + p.id + '.setUiAttribs({title:"' + p.title + '"});\n';

      if (p.type == 0 || p.type == 5)
        src +=
          "innerIn_" +
          p.id +
          '.on("change", (a,v) => { port_' +
          p.id +
          ".set(a); });".endl();
      else if (p.type == 1)
        src +=
          "innerIn_" +
          p.id +
          ".onTriggered = () => { port_" +
          p.id +
          ".trigger(); };".endl();
      else
        src +=
          "innerIn_" +
          p.id +
          '.on("change", (a,v) => { port_' +
          p.id +
          ".setRef(a); });".endl();

      src += "".endl();
    }
    src += "}".endl();

    src += "}".endl() + "};".endl();

    return src;
  };

  subPatchOpUtil.portJsonUtil = (opId, portid, options) => {
    // const loadingModal = Gui.gui.Gui.gui.startModalLoading("Modify port ...");
    const oldSubPatchId = Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch();
    const subOuter = Gui$1.gui.Gui.gui.patchView.getSubPatchOuterOp(oldSubPatchId);

    let setSavedParentSubpatch = false;
    if (Gui$1.gui.Gui.gui.savedState.isSavedSubPatch(oldSubPatchId))
      setSavedParentSubpatch = oldSubPatchId;

    const ops = Gui$1.gui.Gui.gui.corePatch().getOpsByOpId(opId);
    for (let i = 0; i < ops.length; i++) {
      for (let k = 0; k < ops[i].portsIn.length; k++)
        ops[i].portsIn[k].setUiAttribs({ title: null });
      for (let k = 0; k < ops[i].portsOut.length; k++)
        ops[i].portsOut[k].setUiAttribs({ title: null });
    }

    // loadingModal.setTask("getting ports json");
    platform.talkerAPI.send(
      "opAttachmentGet",
      {
        opname: opId,
        name: subPatchOpUtil.blueprintPortJsonAttachmentFilename,
      },
      (err, res) => {
        res = res || {};
        res.content = res.content || JSON.stringify({ ports: [] });
        const js = JSON.parse(res.content);

        let found = false;
        for (let i = 0; i < js.ports.length; i++) {
          if (js.ports[i].id == portid) {
            if (options.hasOwnProperty("title"))
              js.ports[i].title = options.title;
            if (options.hasOwnProperty("port")) js.ports[i] = options.port;
            found = true;
          }
        }

        if (!found) {
          if (options.hasOwnProperty("port")) {
            js.ports.push(options.port);
          }
        }

        // loadingModal.setTask("saving ports json");

        subPatchOpUtil.savePortJsonSubPatchOpAttachment(js, opId, () => {
          // loadingModal.setTask("reload op4");

          Gui$1.gui.Gui.gui.serverOps.execute(opId, (newOps) => {
            Gui$1.gui.Gui.gui.opParams.refresh();

            if (subOuter)
              Gui$1.gui.Gui.gui.patchView.setCurrentSubPatch(
                newOps[0].patchId.get(),
              );

            Gui$1.gui.Gui.gui
              .corePatch()
              .clearSubPatchCache(newOps[0].patchId.get());
            Gui$1.gui.Gui.gui.corePatch().buildSubPatchCache();

            if (setSavedParentSubpatch !== false)
              Gui$1.gui.Gui.gui.savedState.setSaved(
                "subppatchoputil",
                setSavedParentSubpatch,
              );

            Gui$1.gui.Gui.gui.endModalLoading();
          });
        });
      },
    );
  };

  subPatchOpUtil.portJsonDelete = (opId, portid) => {
    // const loadingModal = Gui.gui.Gui.gui.startModalLoading("Deleting port...");
    const oldSubPatchId = Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch();
    const subOuter = Gui$1.gui.Gui.gui.patchView.getSubPatchOuterOp(oldSubPatchId);

    let setSavedParentSubpatch = false;
    if (Gui$1.gui.Gui.gui.savedState.isSavedSubPatch(oldSubPatchId))
      setSavedParentSubpatch = oldSubPatchId;

    // loadingModal.setTask("getting ports json");
    platform.talkerAPI.send(
      "opAttachmentGet",
      {
        opname: opId,
        name: subPatchOpUtil.blueprintPortJsonAttachmentFilename,
      },
      (err, res) => {
        res = res || {};
        res.content = res.content || JSON.stringify({ ports: [] });
        const js = JSON.parse(res.content);

        for (let i = 0; i < js.ports.length; i++)
          if (js.ports[i] && js.ports[i].id == portid) js.ports[i] = null;

        js.ports = subPatchOpUtil.sortPortsJsonPorts(js.ports);

        // loadingModal.setTask("saving ports json");

        subPatchOpUtil.savePortJsonSubPatchOpAttachment(js, opId, () => {
          // loadingModal.setTask("reload op3");

          Gui$1.gui.Gui.gui.serverOps.execute(opId, (newOps) => {
            Gui$1.gui.Gui.gui.opParams.refresh();
            if (subOuter)
              Gui$1.gui.Gui.gui.patchView.setCurrentSubPatch(
                newOps[0].patchId.get(),
              );

            Gui$1.gui.Gui.gui
              .corePatch()
              .clearSubPatchCache(newOps[0].patchId.get());
            Gui$1.gui.Gui.gui.corePatch().buildSubPatchCache();
            if (setSavedParentSubpatch !== false)
              Gui$1.gui.Gui.gui.savedState.setSaved(
                "subppatchoputil",
                setSavedParentSubpatch,
              );

            Gui$1.gui.Gui.gui.endModalLoading();
          });
        });
      },
    );
  };

  subPatchOpUtil.portJsonMove = (opId, portid, dir) => {
    // const loadingModal = Gui.gui.Gui.gui.startModalLoading("Moving port...");
    const oldSubPatchId = Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch();
    const subOuter = Gui$1.gui.Gui.gui.patchView.getSubPatchOuterOp(oldSubPatchId);
    let setSavedParentSubpatch = false;
    if (Gui$1.gui.Gui.gui.savedState.isSavedSubPatch(oldSubPatchId))
      setSavedParentSubpatch = oldSubPatchId;

    // loadingModal.setTask("getting ports json");
    platform.talkerAPI.send(
      "opAttachmentGet",
      {
        opname: opId,
        name: subPatchOpUtil.blueprintPortJsonAttachmentFilename,
      },
      (err, res) => {
        res = res || {};
        res.content = res.content || JSON.stringify({ ports: [] });
        const js = JSON.parse(res.content);

        let idx = -1;
        for (let i = 0; i < js.ports.length; i++)
          if (js.ports[i] && js.ports[i].id == portid) idx = i;

        function array_move(arr, old_index, new_index) {
          if (new_index >= arr.length) {
            let k = new_index - arr.length + 1;
            while (k--) {
              arr.push(undefined);
            }
          }
          arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
          return arr; // for testing
        }

        if (idx + dir < 0) {
          Gui$1.gui.Gui.gui.endModalLoading();
          return;
        }

        let newIndex = idx + dir;

        array_move(js.ports, idx, newIndex);

        // loadingModal.setTask("saving ports json");

        subPatchOpUtil.savePortJsonSubPatchOpAttachment(js, opId, () => {
          // loadingModal.setTask("reload op2");

          Gui$1.gui.Gui.gui.serverOps.execute(opId, (newOps) => {
            Gui$1.gui.Gui.gui.opParams.refresh();

            if (subOuter)
              Gui$1.gui.Gui.gui.patchView.setCurrentSubPatch(
                newOps[0].patchId.get(),
              );

            Gui$1.gui.Gui.gui
              .corePatch()
              .clearSubPatchCache(newOps[0].patchId.get());
            Gui$1.gui.Gui.gui.corePatch().buildSubPatchCache();

            if (setSavedParentSubpatch !== false)
              Gui$1.gui.Gui.gui.savedState.setSaved(
                "subppatchoputil",
                setSavedParentSubpatch,
              );

            Gui$1.gui.Gui.gui.endModalLoading();
          });
        });
      },
    );
  };

  subPatchOpUtil.createBlueprintPortJsonElement = (port, reverseDir) => {
    const o = {
      id: CABLES.shortId(),
      title: port.getTitle(),
      dir: port.direction,
      type: port.type,
      objType: port.uiAttribs.objType,
      uiDisplay: port.uiAttribs.display,
    };

    if (reverseDir)
      if (o.dir == 0) o.dir = 1;
      else o.dir = 0;

    if (port.type == portType.number || port.type == portType.string)
      o.value = port.get();

    return o;
  };

  subPatchOpUtil.savePortJsonSubPatchOpAttachment = (portsJson, opname, next) => {
    if (!portsJson.ports) {
      undefined._log.error("thats not json", portsJson);
      return;
    }

    portsJson.ports = subPatchOpUtil.sortPortsJsonPorts(portsJson.ports);

    const atts = {};
    atts[subPatchOpUtil.blueprintPortJsonAttachmentFilename] = JSON.stringify(
      portsJson,
      false,
      4,
    );
    atts["att_inc_gen_ports.js"] =
      subPatchOpUtil.generatePortsAttachmentJsSrc(portsJson);

    if (
      !Gui$1.gui.Gui.gui.savedState.isSavedSubPatch(
        Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch(),
      )
    ) {
      const subOuterOp = Gui$1.gui.Gui.gui.patchView.getSubPatchOuterOp(
        Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch(),
      );
      if (
        subOuterOp &&
        (subOuterOp.opId == opname || subOuterOp.objName == opname) &&
        Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch() != 0
      ) {
        const newSubId = CABLES.shortId();
        const o = subPatchOpUtil._getSubPatchSerialized(
          Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch(),
          newSubId,
        );

        atts[subPatchOpUtil.blueprintSubpatchAttachmentFilename] = JSON.stringify(
          o,
          null,
          "  ",
        );
      }
    }

    platform.talkerAPI.send(
      "opUpdate",
      {
        opname: opname,
        update: {
          attachments: atts,
        },
      },
      (r) => {
        if (next) next();
      },
    );
  };

  subPatchOpUtil.sortPortsJsonPorts = (ports) => {
    ports = ports.filter((n) => {
      return n;
    }); // remove null objects

    for (let i = 0; i < ports.length; i++)
      ports[i].order = ports[i].dir * 1000 + i;

    return ports.sort((a, b) => {
      return a.order - b.order;
    });
  };

  subPatchOpUtil.addPortToBlueprint = (opId, port, options) => {
    options = options || {};
    // const loadingModal = Gui.gui.Gui.gui.startModalLoading("Adding port");
    const oldSubPatchId = Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch();
    const subOuter = Gui$1.gui.Gui.gui.patchView.getSubPatchOuterOp(oldSubPatchId);

    Gui$1.gui.Gui.gui.patchView.unselectAllOps();

    // loadingModal.setTask("getting ports json");
    Gui$1.gui.Gui.gui.savingTitleAnimStart("Adding Subpatch Port...");

    platform.talkerAPI.send(
      "opAttachmentGet",
      {
        opname: opId,
        name: subPatchOpUtil.blueprintPortJsonAttachmentFilename,
      },
      (err, res) => {
        res = res || {};
        res.content = res.content || JSON.stringify({ ports: [] });
        const js = JSON.parse(res.content) || {};
        js.ports = js.ports || [];

        const newPortJson = subPatchOpUtil.createBlueprintPortJsonElement(
          port,
          options.reverseDir,
        );

        js.ports.push(newPortJson);
        js.ports = subPatchOpUtil.sortPortsJsonPorts(js.ports);

        // loadingModal.setTask("saving ports json");

        subPatchOpUtil.savePortJsonSubPatchOpAttachment(js, opId, () => {
          // loadingModal.setTask("reload op1");

          Gui$1.gui.Gui.gui.serverOps.execute(opId, (newOps) => {
            const newOp = newOps[0];
            Gui$1.gui.Gui.gui.patchView.unselectAllOps();
            Gui$1.gui.Gui.gui.opParams.refresh();
            if (subOuter)
              Gui$1.gui.Gui.gui.patchView.setCurrentSubPatch(newOp.patchId.get());

            Gui$1.gui.Gui.gui.corePatch().clearSubPatchCache(newOp.patchId.get());
            Gui$1.gui.Gui.gui.corePatch().buildSubPatchCache();

            if (port.op.storage && port.op.storage.ref) {
              const theOp = gui
                .corePatch()
                .getOpByRefId(port.op.storage.ref, newOp.patchId.get());

              gui
                .corePatch()
                .link(
                  theOp,
                  port.name,
                  Gui$1.gui.gui
                    .corePatch()
                    .getSubPatch2InnerInputOp(newOp.patchId.get()),
                  "innerOut_" + newPortJson.id,
                );

              gui
                .corePatch()
                .link(
                  theOp,
                  port.name,
                  Gui$1.gui.gui
                    .corePatch()
                    .getSubPatch2InnerOutputOp(newOp.patchId.get()),
                  "innerIn_" + newPortJson.id,
                );
            }

            Gui$1.gui.Gui.gui.savingTitleAnimEnd();
            if (options.cb) options.cb(newPortJson, newOp);

            const outerOp = Gui$1.gui.Gui.gui.patchView.getSubPatchOuterOp(
              newOp.patchId.get(),
            );

            subPatchOpUtil.updateSubPatchOpAttachment(outerOp, {
              oldSubId: newOp.patchId.get(),
            });
          });
        });
      },
    );
  };

  subPatchOpUtil.getAutoName = (short) => {
    let newOpName = "";
    const ns = platform.getPatchOpsNamespace();

    for (let i = 0; i < 1000; i++) {
      newOpName = ns + "SubPatch" + i;
      // const ops = Gui.gui.Gui.gui.corePatch().getOpsByObjName(newOpName);
      const doc = Gui$1.gui.Gui.gui.opDocs.getOpDocByName(newOpName);
      // if (ops.length == 0)
      if (!doc) {
        if (short) newOpName = "SubPatch" + i;
        break;
      }
    }

    return newOpName;
  };

  subPatchOpUtil.portEditDialog = (opId, portId, portData) => {
    if (!portId) portId = CABLES.shortId();
    const html = getHandleBarHtml("dialog_createport", {
      portId: portId,
      port: portData,
    });

    new ModalDialog({ html: html });

    const elSubmit = ele.byId("createPortSubmit");

    elSubmit.addEventListener("click", () => {
      // const elePortId = ele.byId("createPortId");
      const eleDir = ele.byId("createPortDir");
      const eleName = ele.byId("createPortName");
      const eleType = ele.byId("createPortType");
      const eleValue = ele.byId("createPortValue");
      const eleValues = ele.byId("createPortUiAttrValues");

      const eleAddUiAttribs = ele.byId("createPortAddUiAttribs");

      let type = 0;
      if (eleType.value.indexOf("Number") == 0) type = portType.number;
      if (eleType.value.indexOf("Boolean") == 0) type = portType.number;
      if (eleType.value.indexOf("String") == 0) type = portType.string;
      if (eleType.value.indexOf("Array") == 0) type = portType.array;
      if (eleType.value.indexOf("Object") == 0) type = portType.object;
      if (eleType.value.indexOf("Trigger") == 0) type = portType.trigger;

      const values = String(eleValues.value);

      if (!eleName.value) {
        eleName.value = eleType.value;

        if (eleName.value.indexOf(" ") > -1)
          eleName.value = eleName.value.slice(0, eleName.value.indexOf(" "));

        if (eleDir.value == 0) eleName.value += " Input";
        else eleName.value += " Output";
      }
      const port = {
        id: portId,
        title: eleName.value,
        dir: parseInt(eleDir.value),
        values: values.split(","),
        type: type,
      };

      try {
        if (eleAddUiAttribs.value)
          port.addUiAttribs = JSON.parse(eleAddUiAttribs.value);
      } catch (e) {
        _log.warn("could not parse add ui attribs...");
      }

      if (type == portType.string) {
        port.value = eleValue.value;
        if (eleType.value.indexOf("Editor") > -1) port.uiDisplay = "editor";
        if (eleType.value.indexOf("URL") > -1) port.uiDisplay = "file";
        if (eleType.value.indexOf("Switch") > -1) port.uiDisplay = "switch";
        if (eleType.value.indexOf("Dropdown") > -1) port.uiDisplay = "dropdown";
      }

      if (type == portType.trigger) {
        if (eleType.value.indexOf("Button") > -1) port.uiDisplay = "button";
      }

      if (type == portType.number) {
        port.value = parseFloat(eleValue.value) || 0;

        if (eleType.value.indexOf("Integer") > -1) port.uiDisplay = "int";
        if (eleType.value.indexOf("Slider") > -1) port.uiDisplay = "range";
        if (eleType.value.indexOf("Boolean") > -1) port.uiDisplay = "bool";
      }

      if (type == portType.object) {
        if (eleType.value.indexOf("Gradient") > -1)
          port.uiDisplay = port.objType = "gradient";
        if (eleType.value.indexOf("Texture") > -1)
          port.uiDisplay = port.objType = "texture";
        if (eleType.value.indexOf("Geometry") > -1) port.objType = "geometry";
        if (eleType.value.indexOf("Element") > -1) port.objType = "element";
        if (eleType.value.indexOf("AudioNode") > -1) port.objType = "audioNode";
      }

      subPatchOpUtil.portJsonUtil(opId, portId, { port: port });
    });
  };

  subPatchOpUtil._getSubPatchSerialized = function (oldSubId, newSubId) {
    const ops = Gui$1.gui.Gui.gui.patchView.getAllOpsInBlueprint(oldSubId);
    const o = { ops: [] };

    ops.forEach((op) => {
      const ser = op.getSerialized();
      delete ser.uiAttribs.history;
      delete ser.uiAttribs.selected;

      if (ser.uiAttribs.subPatch == oldSubId) ser.uiAttribs.subPatch = newSubId;
      o.ops.push(ser);
    });

    CABLES.Patch.replaceOpIds(o, {
      parentSubPatchId: newSubId,
      refAsId: true,
      doNotUnlinkLostLinks: true,
      fixLostLinks: true,
    });

    return o;
  };

  subPatchOpUtil.updateSubPatchOpAttachment = (newOp, options = {}) => {
    const oldSubId = options.oldSubId || 0;

    Gui$1.gui.Gui.gui.savingTitleAnimStart("Saving Subpatch Op...");

    const ops = Gui$1.gui.Gui.gui.patchView.getAllOpsInBlueprint(oldSubId);
    let hasNoSaveError = false;
    let erro = "";

    const a = {};
    Gui$1.gui.Gui.gui.patchView._patchRenderer.viewBox.serialize(a);
    const viewbox = a.viewBoxesGl[oldSubId];

    ops.forEach((op) => {
      if (op.hasUiError("subPatchOpNoSaveError")) {
        hasNoSaveError = true;
        erro = op.getUiError("subPatchOpNoSaveError");
      }
    });

    if (hasNoSaveError) {
      notifyError("Could not save " + erro.txt);
      return;
    }

    const subId = CABLES.shortId();
    const o = subPatchOpUtil._getSubPatchSerialized(oldSubId, subId);
    const oldSubPatchId = Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch();

    const origOpsBounds = Gui$1.gui.Gui.gui.patchView.getSubPatchBounds(
      Gui$1.gui.Gui.gui.patchView.getCurrentSubPatch(),
    );
    if (origOpsBounds.maxAxis > 10000000) {
      CABLES.CMD.PATCH.centerOpsInSubpatch();
      Gui$1.gui.Gui.gui.patchView._patchRenderer.viewBox.centerSelectedOps();

      undefined._log.log("subpatch huge... center subpatch...");
    }

    platform.talkerAPI.send(
      "opAttachmentSave",
      {
        opname: newOp.opId,
        name: subPatchOpUtil.blueprintSubpatchAttachmentFilename,
        content: JSON.stringify(o, null, "  "),
      },
      (err, res) => {
        if (err) {
          Gui$1.gui.Gui.gui.serverOps.showApiError(err);
          notifyError("Could not save " + newOp.objName, "", { force: true });
        } else {
          notify("Saved " + newOp.objName + " (" + o.ops.length + " ops)");
        }

        if (res && res.data && res.data.updated)
          Gui$1.gui.Gui.gui.patchView.store.setServerDate(res.data.updated);

        Gui$1.gui.Gui.gui.showLoadingProgress(false);

        if (newOp.patchId)
          Gui$1.gui.Gui.gui.savedState.setSaved("saved bp", newOp.patchId.get());

        if (options.execute !== false) {
          if (
            Gui$1.gui.Gui.gui.corePatch().getOpsByObjName(newOp.objName).length > 1
          ) {
            if (options.loadingModal)
              options.loadingModal.setTask("execute op...");

            Gui$1.gui.Gui.gui.serverOps.execute(
              newOp.opId,
              (newOps, refNewOp) => {
                Gui$1.gui.gui
                  .corePatch()
                  .clearSubPatchCache(refNewOp.uiAttribs.subPatch);
                Gui$1.gui.Gui.gui
                  .corePatch()
                  .clearSubPatchCache(newOp.patchId.get());

                if (refNewOp) {
                  Gui$1.gui.Gui.gui.patchView.setCurrentSubPatch(
                    Gui$1.gui.Gui.gui.corePatch().getNewSubpatchId(oldSubPatchId),
                    () => {
                      Gui$1.gui.Gui.gui.patchView._patchRenderer.viewBox.scrollTo(
                        viewbox.x,
                        viewbox.y,
                        false,
                      );
                      Gui$1.gui.Gui.gui.patchView._patchRenderer.viewBox.animateZoom(
                        viewbox.z,
                        0.01,
                      );
                    },
                  );
                }

                if (options.next) options.next();
                Gui$1.gui.Gui.gui.savingTitleAnimEnd();
              },
              { refOldOp: newOp },
            );
          } else if (options.next) options.next();
          Gui$1.gui.Gui.gui.savingTitleAnimEnd();
        } else {
          Gui$1.gui.Gui.gui.savingTitleAnimEnd();
          if (options.next) options.next();
        }

        Gui$1.gui.Gui.gui.endModalLoading();
      },
    );
  };

  subPatchOpUtil.createBlueprint2Op = (
    newOp,
    oldSubpatchOp,
    next,
    options = {},
  ) => {
    // const loadingModal = Gui.gui.Gui.gui.startModalLoading("save op code");

    platform.talkerAPI.send(
      "opUpdate",
      {
        opname: newOp.objName,
        update: {
          code: srcSubPatchOp,
          coreLibs: ["subpatchop"],
        },
      },
      (err) => {
        if (err) {
          undefined.showApiError(err);
          return;
        }

        if (oldSubpatchOp && newOp)
          newOp.setUiAttrib({
            translate: {
              x: oldSubpatchOp.uiAttribs.translate.x,
              y: oldSubpatchOp.uiAttribs.translate.y + gluiconfig.newOpDistanceY,
            },
          });

        Gui$1.gui.Gui.gui.patchView.setPositionSubPatchInputOutputOps(
          oldSubpatchOp.patchId.get(),
        );

        subPatchOpUtil.updateSubPatchOpAttachment(newOp, {
          execute: false,
          oldSubId: oldSubpatchOp.patchId.get(),
          replaceIds: true,
          next: () => {
            if (!options.doNotExecute)
              Gui$1.gui.Gui.gui.serverOps.execute(newOp.opId, (newOps) => {
                Gui$1.gui.Gui.gui.endModalLoading();
                if (next) next();
              });
            else {
              Gui$1.gui.Gui.gui.endModalLoading();
              if (next) next();
            }
          },
        });
      },
    );
  };

  /**
   * @typedef ContextMenuItem
   * @property {String} title
   * @property {String} [icon]
   * @property {Function} func
   */

  /**
   * @typedef ContextMenuParams
   * @property {Array<ContextMenuItem>} items
   * @property {String} [title]
   * @property {String} [iconClass]
   // * @property {Function} func
  */

  class ContextMenu {
    constructor() {
      this._element = null;
      this._modalBg = null;
      this._visible = false;
    }

    close() {
      if (this._element) this._element.remove();
      if (this._modalBg) this._modalBg.remove();
      this._element = null;
      this._modalBg = null;
      this._visible = false;
    }

    isVisible() {
      return this._visible;
    }

    /**
     * @param {ContextMenuParams} obj
     * @param {HTMLElement} parent
     */
    show(obj, parent) {
      if (!this._modalBg) {
        this._modalBg = document.createElement("div");
        this._modalBg.classList.add("cables_contextmenu_modal");
        this._modalBg.addEventListener("click", function () {
          contextMenu.close();
        });

        document.body.appendChild(this._modalBg);
      }

      if (!this._element) {
        this._element = document.createElement("ul");
        this._element.classList.add("cables_contextmenu");
        this._element.classList.add("cablesCssUi");

        document.body.appendChild(this._element);
      }

      const rect = parent.getBoundingClientRect();
      if (rect.x == 0 && rect.y == 0 && rect.width == 0 && rect.height == 0)
        return;

      if (rect.left > window.innerWidth - 200) {
        this._element.style.right = window.innerWidth - rect.left + "px";
        this._element.style.left = "initial";
      } else {
        this._element.style.right = "initial";
        this._element.style.left = rect.left + 5 + "px";
      }
      this._element.style.top = rect.top + 5 + "px";

      if (obj && obj.items && obj.items.length > 0) {
        for (let i = 0; i < obj.items.length; i++) {
          const item = document.createElement("li");
          item.classList.add("cm_item");
          item.setAttribute("tabindex", 0);
          item.innerText = obj.items[i].title;

          if (obj.items[i].iconClass) {
            const icon = document.createElement("span");
            icon.classList.add("cm_icon");
            const classes = obj.items[i].iconClass.split(" ");
            for (const ii in classes) icon.classList.add(classes[ii]);

            icon.style.float = "left";
            item.appendChild(icon);
          }

          this._element.appendChild(item);
          this._visible = true;

          // item.addEventListener("click", function ()
          ele.clickable(
            item,
            function () {
              if (obj.refresh) {
                setTimeout(function () {
                  contextMenu.close();
                  obj.refresh(parent);
                }, 100);
              }
              contextMenu.close();

              setTimeout(this.func.bind(this), 20);
            }.bind(obj.items[i]),
          );
        }
      }
    }
  }

  /**
   * @type {ContextMenu}
   */
  let contextMenu = new ContextMenu();

  /**
   * tab panel to welcome users of the electron editor
   *
   * @export
   * @class WelcomeTab
   */
  class WelcomeTab {
    constructor(tabs) {
      this._tab = new Tab("Welcome", {
        icon: "cables",
        infotext: "tab_welcome",
        padding: true,
        singleton: true,
      });
      tabs.addTab(this._tab, true);
      this._tabs = tabs;

      platform.talkerAPI.send("getRecentPatches", {}, (err, r) => {
        const html = getHandleBarHtml("tab_welcome", {
          patches: r,
          url: platform.getCablesStaticUrl(),
          version: platform.getCablesVersion(),
        });
        this._tab.html(html);

        CABLES.ajax("https://dev.cables.gl/api/events/", (err2, res, xhr) => {
          if (!(err2 || (xhr && xhr.status === 0))) {
            const result = JSON.parse(res);
            result.events.reverse();
            if (result.events.length > 3) result.events.length = 3;
            const eventsHtml = getHandleBarHtml("tab_welcome_events", {
              events: result.events || [],
            });
            const eventsEle = ele.byId("welcome_events");
            if (eventsEle) eventsEle.innerHTML = eventsHtml;
          }
        });

        if (platform.frontendOptions.isElectron)
          CABLES.ajax(
            "https://dev.cables.gl/api/downloads/latest/",
            (err2, res, xhr) => {
              if (!(err2 || (xhr && xhr.status === 0))) {
                try {
                  const result = JSON.parse(res);
                  const elePlatVersion = ele.byId("platformaltversion");
                  if (!result || !elePlatVersion || !result.name) return;
                  elePlatVersion.innerHTML =
                    ' - latest standalone release: <a target="_blank" class="link" href="https://cables.gl/standalone">' +
                    result.name +
                    "</a>";
                } catch (e) {}
              }
            },
          );
      });

      editorSession.remove("welcometab", "Welcome");
      editorSession.rememberOpenEditor("welcometab", "Welcome", true);

      this._tab.on("close", () => {
        editorSession.remove("welcometab", "Welcome");
      });
    }
  }

  /**
   * stores opened editors to reopen when loading ui
   */
  class EditorSession {
    /**
     * @param {boolean} userInteraction
     */
    constructor(userInteraction) {
      this._openEditors = [];
      this._listeners = {};
      this._loadingCount = 0;
      this._loadedCurrentTab = false;

      this.addListener("param", (name, data) => {
        paramsHelper.openParamStringEditor(
          data.opid,
          data.portname,
          null,
          userInteraction,
        );
      });

      this.addListener("manageOp", (id, data) => {
        new ManageOp(Gui$1.gui.mainTabs, id);
      });

      this.addListener("welcometab", (name, data) => {
        new WelcomeTab(Gui$1.gui.mainTabs);
      });
    }

    store() {
      UserSettings.userSettings.set("openEditors", this._openEditors);
    }

    loaded() {
      return this._loadingCount == 0;
    }

    openEditors() {
      return this._openEditors;
    }

    startLoadingTab() {
      this._loadingCount++;
    }

    finishLoadingTab() {
      this._loadingCount--;

      setTimeout(() => {
        if (this._loadingCount == 0 && !this._loadedCurrentTab) {
          Gui$1.gui.mainTabs.loadCurrentTabUsersettings();
          this._loadedCurrentTab = true;
        }
      }, 100);
    }

    /**
     * remove a editor session
     * @name remove
     * @param {string} type
     * @param {string} name
     * @function
     */
    remove(type, name) {
      let found = true;
      while (found) {
        found = false;
        for (let i = 0; i < this._openEditors.length; i++) {
          if (
            this._openEditors[i].name == name &&
            this._openEditors[i].type == type
            // ||
            // this._openEditors[i].name == type && this._openEditors[i].type == name
          ) {
            found = true;
            this._openEditors.splice(i, 1);
            break;
          }
        }
      }
      this.store();
    }

    /**
     * remember an open editor
     * @name rememberOpenEditor
     * @param {string} type
     * @param {string} name
     * @param data
     * @param skipSetEditorTab
     * @function
     */
    rememberOpenEditor(type, name, data, skipSetEditorTab) {
      for (let i = 0; i < this._openEditors.length; i++) {
        if (
          this._openEditors[i].name == name &&
          this._openEditors[i].type == type
        ) {
          return;
        }
      }
      const obj = { name: name, type: type, data: data || {} };
      this._openEditors.push(obj);
      this.store();
      if (!skipSetEditorTab) UserSettings.userSettings.set("editortab", name);

      return obj;
    }

    /**
     * reopen saved editors
     * @name open
     * @function
     */
    open() {
      const sessions = UserSettings.userSettings.get("openEditors");

      if (sessions) {
        for (let i = 0; i < sessions.length; i++) {
          if (this._listeners[sessions[i].type])
            this._listeners[sessions[i].type](
              sessions[i].name,
              sessions[i].data || {},
            );
          else
            console.warn(
              "no editorsession listener for " +
                sessions[i].type +
                " (" +
                sessions[i].name +
                ")",
            );
        }
      }
    }

    /**
     * add listener, a callback will be executed for this type when editor is reopened.
     * @name addListener
     * @function
     */
    addListener(type, cb) {
      this._listeners[type] = cb;
    }
  }

  /**
   * @type {EditorSession}
   */
  let editorSession = new EditorSession();

  /**
   * @typedef TabPanelOptions
   * @property {String} [name]
   * @property {boolean} [closable]
   * @property {boolean} [noUserSetting] - does not store last opened tab in userSettings
   */

  /**
   * a tab panel, that can contain tabs
   *
   * @export
   * @class TabPanel
   * @extends {Events}
   */
  class TabPanel extends Events {
    /** @type {TabPanelOptions} */
    #options;

    /**
     * @param {String} eleId
     * @param {TabPanelOptions} options
     */
    constructor(eleId, options = {}) {
      super();
      this._log = new Logger("TabPanel " + eleId);

      this.#options = options;
      this.id = CABLES.uuid();
      this._eleId = eleId;
      this._tabs = [];
      this._eleContentContainer = null;
      this._eleTabPanel = null;
      this.showTabListButton = false;
      this._dynCmds = [];

      this._eleTabPanel = document.createElement("div");
      this._eleTabPanel.classList.add("tabpanel");
      this._eleTabPanel.innerHTML = "";

      const el = ele.byId(this._eleId);
      if (!el) {
        this._log.error("could not find ele " + this._eleId);
        return;
      }
      el.appendChild(this._eleTabPanel);

      this._eleContentContainer = document.createElement("div");
      this._eleContentContainer.classList.add("contentcontainer");
      this._eleContentContainer.innerHTML = "";
      el.appendChild(this._eleContentContainer);

      this.on("resize", () => {
        for (let i = 0; i < this._tabs.length; i++)
          this._tabs[i].emitEvent("resize");
      });
    }

    /**
     * @param {string} title
     * @returns {string}
     */
    getUniqueTitle(title) {
      const existingTab = this.getTabByTitle(title);
      let count = 0;
      while (existingTab) {
        count++;
        if (!this.getTabByTitle(title + " (" + count + ")")) break;
      }

      if (count > 0) title = title + " (" + count + ")";

      return title;
    }

    updateHtml() {
      let html = "";
      html += getHandleBarHtml("tabpanel_bar", { id: this.id, tabs: this._tabs });
      this._eleTabPanel.innerHTML = html;

      const editortabList = document.getElementById("editortabList" + this.id);
      if (!editortabList) {
        this._log.warn("no editortabList?!?");
        return;
      }
      if (!this.showTabListButton) {
        editortabList.style.display = "none";
        editortabList.parentElement.style["padding-left"] = "0";
      } else {
        editortabList.parentElement.style["padding-left"] = "34px";

        editortabList.style.display = "block";
        editortabList.addEventListener("pointerdown", (e) => {
          const items = [];
          for (let i = 0; i < this._tabs.length; i++) {
            const tab = this._tabs[i];
            items.push({
              title: tab.options.name,
              func: () => {
                this.activateTab(tab.id);
              },
            });
          }
          contextMenu.show(
            {
              items: items,
            },
            e.target,
          );
        });
      }

      for (let i = 0; i < this._dynCmds.length; i++)
        Gui$1.gui.cmdPallet.removeDynamic(this._dynCmds[i]);

      for (let i = 0; i < this._tabs.length; i++) {
        if (window.gui && this._eleId == "maintabs") {
          const t = this._tabs[i];

          const cmd = Gui$1.gui.cmdPallet.addDynamic(
            "tab",
            "Tab " + t.title,
            () => {
              Gui$1.gui.maintabPanel.show(true);

              this.activateTab(t.id, true);
            },
            t.icon || "edit",
          );
          this._dynCmds.push(cmd);
        }

        // ----------------

        ele.clickable(ele.byId("editortab" + this._tabs[i].id), (e) => {
          if (e.target.dataset.id) this.activateTab(e.target.dataset.id, true);
        });

        if (this._tabs[i].options.closable) {
          document
            .getElementById("editortab" + this._tabs[i].id)
            .addEventListener(
              "pointerdown",
              function (e) {
                if (e.button == 1)
                  if (e.target.dataset.id) this.closeTab(e.target.dataset.id);
              }.bind(this),
            );
        }

        if (document.getElementById("closetab" + this._tabs[i].id)) {
          document.getElementById("closetab" + this._tabs[i].id).addEventListener(
            "pointerdown",
            function (e) {
              this.closeTab(e.target.dataset.id);
            }.bind(this),
          );
        }
      }

      this.scrollToActiveTab();
    }

    /**
     * @param {string} name
     */
    activateTabByName(name) {
      name = name || "";
      let found = false;
      let tab = null;
      for (let i = 0; i < this._tabs.length; i++) {
        if (
          this._tabs[i].title.toLowerCase() === name.toLowerCase() ||
          (this._tabs[i].options.name || "").toLowerCase() === name.toLowerCase()
        ) {
          tab = this._tabs[i];
          this.activateTab(tab.id);
          found = true;
        } else this._tabs[i].deactivate();
      }

      if (!found) this._log.log("[activateTabByName] could not find tab", name);

      this.updateHtml();
      return tab;
    }

    scrollToActiveTab() {
      const tab = this.getActiveTab();
      const w = this._eleTabPanel.clientWidth;
      if (!tab) return;
      let left = document.getElementById("editortab" + tab.id).offsetLeft;
      left += document.getElementById("editortab" + tab.id).clientWidth;
      left += 25;

      const tabContainer = document.querySelector("#maintabs .tabs");
      if (tabContainer && left > w) tabContainer.scrollLeft = left;
    }

    /**
     * @param {string} id
     */
    activateTab(id) {
      let found = null;
      for (let i = 0; i < this._tabs.length; i++) {
        if (this._tabs[i].id === id) {
          found = this._tabs[i];
          this.emitEvent("onTabActivated", this._tabs[i]);
          this._tabs[i].activate();
        }
      }

      if (found)
        for (let i = 0; i < this._tabs.length; i++)
          if (this._tabs[i].id != id) this._tabs[i].deactivate();

      this.updateHtml();

      if (editorSession && editorSession.loaded() && Gui$1.gui.finishedLoading())
        this.saveCurrentTabUsersettings();
      return found;
    }

    loadCurrentTabUsersettings() {
      if (this.#options.noUserSetting) return;
      for (let i = 0; i < this._tabs.length; i++) {
        if (
          UserSettings.userSettings.get("tabsLastTitle_" + this._eleId) ==
          this._tabs[i].title
        ) {
          this.activateTab(this._tabs[i].id);
          break;
        }
      }
    }

    saveCurrentTabUsersettings() {
      if (this.#options.noUserSetting) return;
      const activeTab = this.getActiveTab();

      if (!activeTab) return;
      UserSettings.userSettings.set(
        "tabsLastTitle_" + this._eleId,
        activeTab.title,
      );
    }

    /**
     * @param {string} dataId
     */
    getTabByDataId(dataId) {
      for (let i = 0; i < this._tabs.length; i++)
        if (this._tabs[i].dataId == dataId) return this._tabs[i];
    }

    /**
     * @param {string} title
     */
    getTabByTitle(title) {
      for (let i = 0; i < this._tabs.length; i++)
        if (this._tabs[i].title == title) return this._tabs[i];
    }

    /**
     * @param {string} id
     */
    getTabById(id) {
      for (let i = 0; i < this._tabs.length; i++)
        if (this._tabs[i].id == id) return this._tabs[i];
    }

    closeAllTabs() {
      while (this._tabs.length) this.closeTab(this._tabs[0].id);
    }

    /**
     * @param {string} id
     */
    closeTab(id) {
      let tab = null;
      let idx = 0;
      for (let i = 0; i < this._tabs.length; i++) {
        if (this._tabs[i].id == id) {
          tab = this._tabs[i];
          // tab.emitEvent("close");
          this._tabs.splice(i, 1);
          idx = i;
          break;
        }
      }
      if (!tab) return;

      this.emitEvent("onTabRemoved", tab);
      tab.remove();

      if (idx > this._tabs.length - 1) idx = this._tabs.length - 1;
      if (this._tabs[idx]) this.activateTab(this._tabs[idx].id);

      this.updateHtml();
    }

    /**
     * @param {string} id
     * @param {boolean} changed
     */
    setChanged(id, changed) {
      if (this.getTabById(id)) this.getTabById(id).options.wasChanged = changed;
      this.updateHtml();
    }

    /**
     * @param {number} num
     */
    setTabNum(num) {
      const tab = this._tabs[Math.min(this._tabs.length, num)];
      this.activateTab(tab.id);
    }

    /**
     * @returns {number}
     */
    getNumTabs() {
      return this._tabs.length;
    }

    /**
     * @returns {Tab}
     */
    cycleActiveTab() {
      if (this._tabs.length <= 1) return;

      for (let i = 1; i < this._tabs.length; i++)
        if (this._tabs[i - 1].active) return this.activateTab(this._tabs[i].id);

      return this.activateTab(this._tabs[0].id);
    }

    /**
     * @returns {Tab}
     */
    getActiveTab() {
      for (let i = 0; i < this._tabs.length; i++)
        if (this._tabs[i].active) return this._tabs[i];
    }

    updateSize() {
      for (let i = 0; i < this._tabs.length; i++) this._tabs[i].updateSize();
    }

    getSaveButton() {
      const t = this.getActiveTab();
      if (!t) return;

      const b = t.getSaveButton();
      if (b) return b;
    }

    /**
     * @param {Tab} tab
     * @param {boolean} [activate]
     * @returns {Tab}
     */
    addTab(tab, activate) {
      if (tab.options.singleton) {
        const t = this.getTabByTitle(tab.title);
        if (t) {
          this.activateTab(t.id);
          this.emitEvent("onTabAdded", t, true);

          if (activate) this.activateTab(t.id);
          return t;
        }
      }

      tab.initHtml(this._eleContentContainer);
      this._tabs.push(tab);

      if (activate) this.activateTab(tab.id);

      this.updateHtml();
      this.emitEvent("onTabAdded", tab, false);

      return tab;
    }

    /**
     * @param {String} title
     * @param {String} url
     * @param {Object} options
     * @param {boolean} userInteraction
     * @returns {Tab}
     */
    addIframeTab(title, url, options, userInteraction) {
      const iframeTab = this.addTab(new CABLES.UI.Tab(title, options));
      const id = CABLES.uuid();

      const html =
        '<div class="loading" id="loading' +
        id +
        '" style="position:absolute;left:45%;top:34%"></div><iframe id="iframe' +
        id +
        '" allow="clipboard-write" style="border:none;width:100%;height:100%" src="' +
        url +
        '" onload="document.getElementById(\'loading' +
        id +
        "').style.display='none';\"></iframe";
      iframeTab.contentEle.innerHTML = html;
      iframeTab.contentEle.style.padding = "0px";
      if (options.gotoUrl) {
        iframeTab.toolbarEle.innerHTML =
          '<a class="button-small" href="' +
          options.gotoUrl +
          '" target="_blank">Open in new tab</a>';
      } else {
        iframeTab.toolbarEle.innerHTML =
          '<a class="button-small" href="' +
          url +
          '" target="_blank">Open in new tab</a>';
      }

      const frame = document.getElementById("iframe" + id);

      const talkerAPI = new CABLESUILOADER.TalkerAPI(frame.contentWindow);

      talkerAPI.on("setSavedState", (opts) => {
        if (opts.state) {
          Gui$1.gui.savedState.setSaved("talkerAPI", opts.subpatch);
        } else {
          Gui$1.gui.savedState.setUnSaved("talkerAPI", opts.subpatch);
        }
      });

      talkerAPI.on("manualScreenshot", (opts, next) => {
        platform.setManualScreenshot(opts.manualScreenshot);

        if (opts.manualScreenshot) {
          Gui$1.gui.patchView.store.saveScreenshot(true, () => {
            talkerAPI.send("screenshotSaved");
          });
        }
      });

      talkerAPI.on("notify", (opts, next) => {
        notify(opts.msg, opts.text, opts.options);
      });

      talkerAPI.on("notifyError", (opts, next) => {
        notifyError(opts.msg, opts.text, opts.options);
      });

      talkerAPI.on("updatePatchName", (opts, next) => {
        Gui$1.gui.setProjectName(opts.name);
        platform.talkerAPI.send("updatePatchName", opts, (err, r) => {});
      });

      talkerAPI.on("updatePatchSummary", (opts, next) => {
        Gui$1.gui.project().summary = opts;
        Gui$1.gui.patchParamPanel.show(true);
      });

      talkerAPI.on("opsDeleted", (opts, next) => {
        const opdocs = Gui$1.gui.opDocs.getAll();
        const deletedOps = opts.ops || [];
        for (let i = 0; i < deletedOps.length; i++) {
          const deletedOp = deletedOps[i];
          const opDocToDelete = opdocs.findIndex((opDoc) => {
            return opDoc.id === deletedOp.id;
          });
          if (opDocToDelete) opdocs.splice(opDocToDelete, 1);
          Gui$1.gui.opSelect().reload();
        }
        let plural = deletedOps.length > 1 ? "s" : "";
        if (deletedOps.length > 0)
          notify("deleted " + deletedOps.length + " op" + plural);
        this.closeTab(iframeTab.id);
      });

      this.activateTab(iframeTab.id);
      Gui$1.gui.maintabPanel.show(userInteraction);
      return iframeTab;
    }
  }

  class ItemManager extends Events {
    constructor(title, tabs) {
      super();
      this.listHtmlOptions = {};
      this._display = "icons";
      this._tab = new Tab(title, {
        icon: "folder",
        singleton: "true",
        padding: true,
      });
      tabs.addTab(this._tab);

      this._tab.addEventListener("close", () => {
        this.emitEvent("close");
      });

      this._items = [];
      this.updateHtml();
    }

    clear() {
      this._items.length = 0;
    }

    setDisplay(t) {
      this._display = t;
      this.updateHtml();
    }

    getDisplay(t) {
      return this._display;
    }

    removeItem(id) {
      let nextId = null;
      for (let i = 1; i < this._items.length; i++)
        if (id === this._items[i - 1].id) nextId = this._items[i].id;

      let idx = -1;
      for (let i = 0; i < this._items.length; i++) {
        if (this._items[i].id == id) idx = i;
      }
      if (idx == -1) return;

      this._items.splice(idx, 1);

      const ele = document.getElementById("item" + id);
      const eleRow = document.getElementById("itemrow" + id);

      if (eleRow) {
        eleRow.remove();
      }
      if (ele) {
        ele.remove();
        if (nextId) this.selectItemById(nextId);
      }
      this.updateDetailHtml();
    }

    updateHtml() {
      let html = "";
      const options = { items: this._items };
      for (const i in this.listHtmlOptions) options[i] = this.listHtmlOptions[i];

      if (this._display === "icons")
        html = getHandleBarHtml("tab_itemmanager", options);
      else html = getHandleBarHtml("tab_itemmanager_list", options);

      this._tab.html(
        '<div id="item_manager" class="item_manager">' + html + "</div>",
      );
    }

    getItemByTitleContains(t) {
      for (let i = 0; i < this._items.length; i++) {
        if (t.indexOf(this._items[i].title) > -1) {
          return this._items[i];
        }
      }
    }

    getItemById(id) {
      for (let i = 0; i < this._items.length; i++)
        if (id === this._items[i].id) return this._items[i];
    }

    getSelectedItems() {
      const selectedItems = [];
      for (let i = 0; i < this._items.length; i++)
        if (this._items[i].selected) selectedItems.push(this._items[i]);
      return selectedItems;
    }

    updateSelectionHtml() {
      for (let i = 0; i < this._items.length; i++) {
        const item = this._items[i];
        const ele = document.getElementById("item" + item.id);
        if (ele) {
          if (item.selected) ele.classList.add("selected");
          else ele.classList.remove("selected");
        }
      }
    }

    unselectAll() {
      for (let i = 0; i < this._items.length; i++)
        this._items[i].selected = false;
      this.updateSelectionHtml();
    }

    toggleSelection(id) {
      const item = this.getItemById(id);
      if (item) item.selected = !item.selected;
      this.updateSelectionHtml();
    }

    selectItemById(id) {
      const item = this.getItemById(id);
      if (item) item.selected = true;
      this.updateSelectionHtml();
    }

    updateDetailHtml(items) {
      const detailItems = [];
      for (let i = 0; i < this._items.length; i++)
        if (this._items[i].selected) detailItems.push(this._items[i]);

      this.emitEvent("onItemsSelected", detailItems);
    }

    setTitleFilter(f) {
      this.titleFilter = String(f).toLowerCase();
      this.filterItems();
    }

    filterItems() {
      const els = document.getElementsByClassName("fileFilterable");
      let i = 0;
      if (this.titleFilter) {
        for (i = 0; i < els.length; i++) {
          if (
            els[i].dataset.searchable.toLowerCase().indexOf(this.titleFilter) ==
            -1
          )
            els[i].style.display = "none";
          else els[i].style.display = "";
        }
      } else {
        for (i = 0; i < els.length; i++) els[i].style.display = "";
      }
    }

    setItems(items) {
      if (!items) items = this._items;
      this._items = items;
      this.updateHtml();

      for (let i = 0; i < this._items.length; i++) {
        const id = this._items[i].id;
        const item = this._items[i];
        const ele = document.getElementById("item" + id);

        if (ele) {
          ele.addEventListener(
            "click",
            function (e) {
              if (!e.shiftKey) {
                this.unselectAll();
                this.selectItemById(item.id);
              } else {
                this.toggleSelection(item.id);
              }
              this.updateSelectionHtml();
              this.updateDetailHtml();
            }.bind(this),
          );
        }
      }
      this.filterItems();
    }
  }

  /**
   * manage files/assets of the patch
   *
   * @export
   * @class FileManager
   */
  class FileManager {
    constructor(cb, userInteraction) {
      this._log = new Logger("filemanager");
      this._filterType = null;
      this._manager = new ItemManager("Files", Gui$1.gui.mainTabs);
      this._filePortEle = null;
      this._firstTimeOpening = true;
      this._refreshDelay = null;
      this._orderReverse = false;
      this._order = UserSettings.userSettings.get("filemanager_order") || "name";
      this._files = [];

      Gui$1.gui.maintabPanel.show(userInteraction);
      UserSettings.userSettings.set("fileManagerOpened", true);

      CABLES.DragNDrop.loadImage();

      this._manager.setDisplay(
        UserSettings.userSettings.get("filemanager_display") || "icons",
      );

      this.reload(cb);

      this._manager.addEventListener("onItemsSelected", (items) => {
        this.setDetail(items);
      });

      this._manager.addEventListener("close", () => {
        UserSettings.userSettings.set("fileManagerOpened", false);
        Gui$1.gui.fileManager = null;
      });

      if (platform.frontendOptions.isElectron)
        Gui$1.gui.on("patchsaved", () => {
          if (!ele.byId("filemanagercontainer")) return;
          Gui$1.gui.refreshFileManager();
        });
    }

    show(userInteraction) {
      Gui$1.gui.maintabPanel.show(userInteraction);
      Gui$1.gui.maintabPanel.show(true);
    }

    refresh() {
      clearTimeout(this._refreshDelay);
      this._refreshDelay = setTimeout(() => {
        this.setSource("patch");
      }, 200);
    }

    setFilePort(portEle, op, previewEle) {
      if (!portEle) {
        this._filePortElePreview = null;
        this._filePortEle = null;
        this._filePortOp = null;

        if (this._filterType) {
          this._filterType = null;
          this._buildHtml();
        }
      } else {
        this._filePortElePreview = previewEle;
        this._filePortEle = portEle;
        this._filePortOp = op;

        Gui$1.gui.fileManager.setFilter("");
      }
      this.updateHeader();
    }

    reload(cb) {
      this._manager.clear();

      this._fileSource = this._fileSource || "patch";
      // if (this._firstTimeOpening) this._fileSource = "patch";

      if (Gui$1.gui.isGuestEditor()) {
        this._buildHtml();
        return;
      }

      const eleContent = ele.byQuery("#item_manager .filelistcontainer");
      if (eleContent)
        eleContent.innerHTML =
          '<div class="loading" style="margin-top:50px;"></div>';

      Gui$1.gui.jobs().start({
        id: "getFileList",
        title: "Loading file list",
      });

      this._getFilesFromSource(this._fileSource, (files) => {
        if (!files) files = [];
        files.filter((file) => {
          return file.projectId && file.projectId === Gui$1.gui.project()._id;
        });

        this._firstTimeOpening = false;
        this._files = files;

        this._buildHtml();
        if (cb) cb();
        Gui$1.gui.jobs().finish("getFileList");
      });
    }

    _getFilesFromSource(source, cb) {
      platform.talkerAPI.send(
        "getFilelist",
        {
          source: source,
        },
        (err, remoteFiles) => {
          if (err) {
            this._log.error(err);
            cb([]);
          } else {
            if (cb) cb(remoteFiles);
          }
        },
      );
    }

    _createItem(items, file, filterType) {
      let size = "";

      if (file.s) size = Math.ceil(file.s / 1024) + " kb";

      const item = {
        title: file.n,
        shortTitle: file.n.replaceAll(".", "<wbr>."),
        id: file._id || "lib" + CABLES.uuid(),
        p: file.p,
        dir: file.d,
        updated: file.updated,
        sizeKb: size,
        size: file.s,
        file: file,
        isReference: file.isReference,
        hasReference: file.hasReference,
        isLibraryFile: file.isLibraryFile,
        referenceCount: file.referenceCount,
        projectId: file.projectId,
        icon: file.icon || "file",
      };

      if (file.t === "SVG") item.preview = file.p;
      else if (file.t === "image") item.preview = file.p;
      else if (file.t === "dir") item.divider = file.n;

      if (item.preview && FileManager.updatedFiles.indexOf(file.n) > -1)
        item.preview += "?cb=" + Math.random();

      if (!filterType) items.push(item);
      else {
        if (this._compareFilter(file, filterType)) items.push(item);

        if (file.t == "dir") {
          // subdir has file with correct file type ??
          for (let i = 0; i < file.c.length; i++) {
            if (this._compareFilter(file.c[i], filterType)) {
              items.push(item);
              break;
            }
          }
        }
      }

      if (file.c)
        for (let i = 0; i < file.c.length; i++)
          this._createItem(items, file.c[i], filterType);
    }

    _compareFilter(file, filterType) {
      if (typeof filterType == "string") {
        if (filterType === file.t) return true;
      } else {
        if (Array.isArray(filterType)) {
          for (let i = 0; i < filterType.length; i++) {
            if (file.n.toLowerCase().indexOf(filterType[i].toLowerCase()) > 0)
              return true;
          }
        }
      }
      return false;
    }

    _buildHtml(o) {
      const items = [];

      if (!this._files) this._files = [];

      if (this._order == "size") {
        this._files.sort(function (a, b) {
          return a.s - b.s;
        });
      }
      if (this._order == "date") {
        this._files.sort(function (a, b) {
          return b.d - a.d;
        });
      }
      if (this._order == "name") {
        this._files.sort(function (a, b) {
          return (a.name || "")
            .toLowerCase()
            .localeCompare((b.name || "").toLowerCase());
        });
      }
      if (this._order == "type") {
        this._files.sort(function (a, b) {
          return (a.t || "")
            .toLowerCase()
            .localeCompare((b.t || "").toLowerCase());
        });
      }

      if (this._orderReverse) this._files.reverse();

      for (let i = 0; i < this._files.length; i++) {
        this._createItem(items, this._files[i], this._filterType);
      }

      this._manager.listHtmlOptions.showHeader = this._fileSource !== "lib";
      this._manager.listHtmlOptions.order = this._order;
      this._manager.listHtmlOptions.orderReverse = this._orderReverse;
      this._manager.setItems(items);

      this.updateHeader();

      if (this._files.length == 0) {
        const els = ele.byQuery("#filemanagercontainer .filelistcontainer");
        if (els) {
          let uploadText = "";
          if (platform.frontendOptions.uploadFiles) {
            uploadText =
              '<br/><br/><br/><br/><div class="text-center">This Patch contains no files yet!<br/><br/>';
            uploadText +=
              '<a class="button-small" onclick="CABLES.CMD.PATCH.uploadFileDialog();">Upload files</a> or ';
            uploadText +=
              'use files from our <a class="button-small" onclick="Gui.gui.fileManager.setSource(\'lib\');">Library</a>';
          } else {
            uploadText =
              '<br/><br/><br/><br/><div class="text-center">Patch does not use any files, yet!<br/><br/>';
            uploadText +=
              '<a class="button-small" onclick="CABLES.CMD.PATCH.uploadFileDialog();">Add files</a> or ';
            uploadText += "drag them onto the patchfiled to use them";
          }
          uploadText += "</div>";
          els.innerHTML = uploadText;
        }
      }
    }

    setFilter(f) {
      this._manager.setTitleFilter(f);
    }

    setOrder(o) {
      if (this._order != o) this._orderReverse = false;
      else this._orderReverse = !this._orderReverse;

      this._order = o;
      UserSettings.userSettings.set("filemanager_order", this._order);
      this._buildHtml();
    }

    setFilterType(f) {
      this._filterType = f;
      this._buildHtml();
    }

    setSource(s, cb) {
      this._fileSource = s;
      this.updateHeader();

      this.reload(cb);
    }

    _selectFile(filename) {
      this._manager.unselectAll();
      const item = this._manager.getItemByTitleContains(filename);
      if (!item) return;
      this._manager.selectItemById(item.id);
      const el = document.getElementById("item" + item.id);
      if (el) el.scrollIntoView();
    }

    selectFile(filename) {
      if (this._fileSource === "patch") {
        this._selectFile(filename);
      } else {
        if (filename.indexOf(Gui$1.gui.project()._id) > -1) {
          this.setSource("patch", () => {
            this._selectFile(filename);
          });
        }
      }
      Gui$1.gui.maintabPanel.show(true);

      const item = this._manager.getItemByTitleContains(filename);
      if (item && !item.isLibraryFile) this.setDetail([item]);
    }

    setDisplay(type) {
      UserSettings.userSettings.set("filemanager_display", type);
      this._manager.setDisplay(type);
      this._manager.setItems();
      this.updateHeader();
    }

    updateHeader(detailItems) {
      if (Gui$1.gui.isGuestEditor()) {
        if (ele.byId("itemmanager_header"))
          ele.byId("itemmanager_header").innerHTML = text.guestHint;
        return;
      }

      const html = getHandleBarHtml("filemanager_header", {
        fileSelectOp: this._filePortOp,
        filterType: this._filterType,
        source: this._fileSource,
        display: this._manager.getDisplay(),
        filter: this._manager.titleFilter,
      });
      if (ele.byId("itemmanager_header"))
        ele.byId("itemmanager_header").innerHTML = html;

      const elSwitchIcons = document.getElementById("switch-display-icons");
      const elSwitchList = document.getElementById("switch-display-list");

      if (elSwitchIcons) {
        elSwitchIcons.addEventListener(
          "click",
          function () {
            // elSwitchIcons.classList.add("switch-active");
            // elSwitchList.classList.remove("switch-active");
            this.setDisplay("icons");
          }.bind(this),
        );
      }
      if (elSwitchList) {
        elSwitchList.addEventListener("click", () => {
          // elSwitchList.classList.add("switch-active");
          // elSwitchIcons.classList.remove("switch-active");
          this.setDisplay("list");
        });
      }
    }

    setDetail(detailItems) {
      let html = "";
      document.getElementById("item_details").innerHTML = "";

      if (detailItems.length === 1) {
        const detailItem = detailItems[0];
        const itemId = detailItem.id;
        let projectId = Gui$1.gui.project()._id;
        if (detailItem.isReference && detailItem.file)
          projectId = detailItem.file.projectId;
        const filename = detailItem.file ? detailItem.file.p : null;

        platform.talkerAPI.send(
          "getFileDetails",
          {
            projectId: projectId,
            fileid: itemId,
            filename: filename,
          },
          function (err, r) {
            if (r.fileDb) r.ops = opNames.getOpsForFilename(r.fileDb.fileName);
            if (this._fileSource !== "lib") {
              let downloadUrl = detailItem.p;
              if (detailItem.file && detailItem.file.cachebuster)
                downloadUrl += "?rnd=" + detailItem.file.cachebuster;

              let editable = false;
              if (r.fileDb && r.fileDb.fileName)
                editable =
                  r.fileDb.fileName.endsWith(".md") ||
                  r.fileDb.fileName.endsWith(".scss");
              editable =
                editable ||
                r.type == "textfile" ||
                r.type == "CSS" ||
                r.type == "javascript" ||
                r.type == "XML" ||
                r.type == "JSON" ||
                r.type == "shader";

              let assetPath = "";
              if (r && r.fileDb)
                assetPath =
                  "/assets/" + r.fileDb.projectId + "/" + r.fileDb.fileName;
              if (platform.frontendOptions.isElectron) assetPath = r.path;

              html = getHandleBarHtml("filemanager_details", {
                projectId: Gui$1.gui.project()._id,
                file: r,
                source: this._fileSource,
                isEditable: editable,
                assetPath: assetPath,
                isPlatformCommunity: platform.frontendOptions.hasCommunity,
                isReference: detailItem.isReference,
                isLibraryFile: detailItem.isLibraryFile,
                referenceCount: detailItem.referenceCount,
                projectUrl:
                  platform.getCablesUrl() + "/edit/" + detailItem.projectId,
                downloadUrl: downloadUrl,
                assetPageUrl:
                  platform.getCablesUrl() +
                  "/asset/patches/?filename=" +
                  detailItem.p,
              });
            } else {
              // * it's a library file
              const item = detailItem;

              const fileParts = item.p.split("/assets/library/");
              const fileInfoPath = fileParts.length > 1 ? fileParts[1] : "";

              const fileCategory = fileInfoPath.split("/")[0];
              const fileName = fileInfoPath.split("/")[1];
              platform.talkerAPI.send(
                "getLibraryFileInfo",
                {
                  filename: fileName,
                  fileCategory: fileCategory,
                  filepath: fileInfoPath,
                },
                (_err, _r) => {
                  const itemInfo = _r;

                  let templateName = "filemanager_details_lib";
                  if (itemInfo.type) templateName += "_" + itemInfo.type;
                  const templateOptions = {
                    filename: item.p,
                    file: item,
                    fileInfo: itemInfo,
                  };

                  try {
                    // * use file-type specific template
                    html = getHandleBarHtml(templateName, templateOptions);
                  } catch (e) {
                    // * use default template
                    html = getHandleBarHtml(
                      "filemanager_details_lib",
                      templateOptions,
                    );
                  }

                  if (document.getElementById("item_details"))
                    document.getElementById("item_details").innerHTML = html;
                },
              );
            }

            if (document.getElementById("item_details"))
              document.getElementById("item_details").innerHTML = html;

            const copyEle = document.querySelector(
              "*[data-info=filemanager_copy_file_url]",
            );
            if (copyEle) {
              copyEle.addEventListener("click", (e) => {
                navigator.clipboard
                  .writeText(JSON.stringify(r.path))
                  .then(() => {
                    notify("Copied to clipboard");
                  })
                  .catch((copyError) => {
                    notifyWarn("Copied to clipboard failed");
                    this._log.warn("copy to clipboard failed", copyError);
                  });
              });
            }

            const editEle = document.querySelector(
              "*[data-info=filemanager_edit_file]",
            );
            if (editEle) {
              editEle.addEventListener("click", (e) => {
                let fileName = r.fileDb.fileName;
                if (platform.frontendOptions.isElectron) fileName = r.path;
                Gui$1.gui.fileManagerEditor.editAssetTextFile(
                  fileName,
                  r.fileDb.type,
                );
              });
            }

            const delEle = document.getElementById("filedelete" + itemId);
            if (delEle) {
              delEle.addEventListener("click", (e) => {
                const loadingModal = Gui$1.gui.startModalLoading(
                  "Checking asset dependencies",
                );
                loadingModal.setTask("Checking patches and ops...");
                const fullName =
                  "/assets/" + Gui$1.gui.project()._id + "/" + r.fileDb.fileName;
                platform.talkerAPI.send(
                  "checkNumAssetPatches",
                  { filenames: [fullName] },
                  (countErr, countRes) => {
                    Gui$1.gui.endModalLoading();
                    let content = "";
                    let allowDelete = true;
                    if (countRes && countRes.data) {
                      const otherCount = countRes.data.countPatches
                        ? countRes.data.countPatches - 1
                        : 0;
                      if (otherCount) {
                        let linkText = otherCount + " other patch";
                        if (otherCount > 1) linkText += "es";
                        content +=
                          'It is used in <a href="' +
                          platform.getCablesUrl() +
                          "/asset/patches/?filename=" +
                          fullName +
                          '" target="_blank">' +
                          linkText +
                          "</a>";
                      }
                      if (countRes.data.countOps) {
                        let linkText = countRes.data.countOps + " op";
                        if (countRes.data.countOps > 1) linkText += "s";
                        if (otherCount) content += "<br/>";
                        content +=
                          'It is used in <a href="' +
                          platform.getCablesUrl() +
                          "/asset/patches/?filename=" +
                          fullName +
                          '" target="_blank">' +
                          linkText +
                          "</a>";
                        allowDelete = false;
                      }
                    } else {
                      content += "It may be used in other patches.";
                    }

                    let title = "Really delete this file?";
                    let okButton = null;

                    if (Gui$1.gui.project().summary.visibility == "public")
                      content +=
                        '<div class="error warning-error warning-error-level2 text-center"><br/><br/>this asset is in a public patch, please make sure your patch continues to work!<br/><br/><br/></div>';

                    if (!allowDelete) {
                      title = "You cannot delete this file!";
                    } else {
                      okButton = {
                        text: "Really delete",
                        cssClasses: "redbutton",
                      };
                    }

                    const options = {
                      title: title,
                      html: content,
                      warning: true,
                      choice: allowDelete,
                      okButton: okButton,
                    };

                    const modal = new ModalDialog(options);
                    if (allowDelete) {
                      modal.on("onSubmit", () => {
                        platform.talkerAPI.send(
                          "deleteFile",
                          { fileid: r.fileDb._id },
                          (errr, rr) => {
                            if (rr && rr.success) {
                              this._manager.removeItem(itemId);
                              this.reload();
                            } else
                              notifyError(
                                "Error: Could not delete file. " + errr.msg,
                              );
                          },
                        );
                      });
                    }
                  },
                );
              });
            }
          }.bind(this),
        );

        if (this._filePortEle) {
          Gui$1.gui.savedState.setUnSaved(
            "filemanager",
            this._filePortOp.getSubPatch(),
          );
          this._filePortEle.value = detailItems[0].p;
          const event = document.createEvent("Event");
          event.initEvent("input", true, true);
          this._filePortEle.dispatchEvent(event);

          if (detailItems[0].t == "image" || detailItems[0].icon == "image")
            if (this._filePortElePreview)
              this._filePortElePreview.innerHTML =
                '<img class="dark" src="' +
                detailItems[0].p +
                '" style="max-width:100%;margin-top:10px;"/>';

          Gui$1.gui.opParams.show(this._filePortOp);
        }
      } else if (detailItems.length > 1) {
        let allSize = 0;
        for (let i = 0; i < detailItems.length; i++)
          allSize += detailItems[i].size;

        if (allSize) allSize = Math.ceil(allSize / 1024);

        html =
          '<div class="text-center"><br/><br/>' +
          detailItems.length +
          " files selected<br/>";
        if (allSize) html += "Size: " + allSize + " kb<br/>";

        html += "<br/>";

        if (this._fileSource == "patch")
          html +=
            '<a class="button" id="filesdeletmulti">delete ' +
            detailItems.length +
            " files</a>";
        html += "</div>";

        document.getElementById("item_details").innerHTML = html;

        const elDelMulti = document.getElementById("filesdeletmulti");
        if (elDelMulti) {
          elDelMulti.addEventListener("click", (e) => {
            const selectedItems = this._manager.getSelectedItems();
            this._manager.unselectAll();

            const selectedFileIds = [];
            const fullNames = [];
            for (let i = 0; i < selectedItems.length; i++) {
              const detailItem = selectedItems[i];
              selectedFileIds.push(detailItem.id);
              fullNames.push(detailItem.p);
            }

            const loadingModal = Gui$1.gui.startModalLoading(
              "Checking asset dependencies",
            );
            loadingModal.setTask("Checking patches and ops...");
            platform.talkerAPI.send(
              "checkNumAssetPatches",
              { filenames: fullNames },
              (countErr, countRes) => {
                Gui$1.gui.endModalLoading();
                let content = "";
                let allowDelete = true;
                let showAssets = false;
                if (countRes && countRes.data) {
                  Gui$1.gui.project().shortId || Gui$1.gui.project()._id;
                  if (countRes.data.countPatches > 1) {
                    let linkText = countRes.data.countPatches + " other patch";
                    if (countRes.data.countPatches > 1) linkText += "es";
                    content += "Some are used in " + linkText;
                    showAssets = true;
                  }
                  if (countRes.data.countOps) {
                    let linkText = countRes.data.countPatches + " op";
                    if (countRes.data.countOps > 1) linkText += "s";
                    if (countRes.data.countPatches > 1) content += "<br/>";
                    content += "Some are used in " + linkText;
                    allowDelete = false;
                    showAssets = true;
                  }
                } else {
                  content += "They may be used in other patches.";
                }

                if (showAssets && countRes.data.assets) {
                  content += "<br><ul>";
                  countRes.data.assets.forEach((asset) => {
                    const link =
                      platform.getCablesUrl() +
                      "/asset/patches/?filename=" +
                      asset;
                    content +=
                      "<li>Check usages of <a href='" +
                      link +
                      "' target='_blank'>" +
                      CABLES.filename(asset) +
                      "</a></li>";
                  });
                  content += "</ul>";
                }

                let title = "Really delete " + selectedFileIds.length + " files?";
                if (!allowDelete) {
                  title = "You cannot delete all of these files!";
                }

                const options = {
                  title: title,
                  html: content,
                  warning: true,
                  choice: allowDelete,
                  okButton: {
                    text: "Really delete",
                    cssClasses: "redbutton",
                  },
                };

                const modal = new ModalDialog(options);
                if (allowDelete) {
                  modal.on("onSubmit", () => {
                    selectedFileIds.forEach((fileId) => {
                      platform.talkerAPI.send(
                        "deleteFile",
                        {
                          fileid: fileId,
                        },
                        (err, r) => {
                          if (r.success) {
                            this._manager.removeItem(fileId);
                            this.reload();
                          } else {
                            notifyError("error: could not delete file", err);
                            this._log.warn(err);
                          }

                          this._manager.unselectAll();
                        },
                        (r) => {
                          this._log.warn("api err", r);
                        },
                      );
                    });
                  });
                }
              },
            );
          });
        }
      }
    }

    createFile() {
      new ModalDialog({
        prompt: true,
        title: "Create new file",
        text: "Enter filename",
        promptValue: "newfile.txt",
        promptOk: (fn) => {
          platform.talkerAPI.send("createFile", { name: fn }, (err, res) => {
            if (err) {
              notifyError("Error: " + err.msg);
              Gui$1.gui.refreshFileManager();
              return;
            }
            if (res) notify("file created");
            Gui$1.gui.refreshFileManager();
          });
        },
      });
    }

    uploadFile(filename, content, cb) {
      Gui$1.gui.jobs().finish("uploadfile" + filename);
      Gui$1.gui.jobs().start({
        id: "uploadfile" + filename,
        title: "uploading file " + filename,
      });

      platform.talkerAPI.send(
        "fileUploadStr",
        {
          fileStr: content,
          filename: filename,
        },
        (err3, res3) => {
          Gui$1.gui.savedState.setSaved("editorOnChangeFile");
          Gui$1.gui.jobs().finish("uploadfile" + filename);
          Gui$1.gui.refreshFileManager();
          if (cb) cb(err3, res3);
        },
      );
    }

    replaceAssetPorts(search, replace, cb = null) {
      const ops = Gui$1.gui.corePatch().ops;
      let numPorts = 0;
      for (let i = 0; i < ops.length; i++) {
        for (let j = 0; j < ops[i].portsIn.length; j++) {
          if (
            ops[i].portsIn[j].uiAttribs &&
            ops[i].portsIn[j].uiAttribs.display &&
            ops[i].portsIn[j].uiAttribs.display == "file"
          ) {
            this._log.log("filename:", ops[i].portsIn[j].get());
            let v = ops[i].portsIn[j].get();

            if (v) this._log.log("srch index", v.indexOf(search));
            if (v && v.indexOf(search) == 0) {
              numPorts++;
              this._log.log("found str!");
              v = replace + v.substring(search.length);
              ops[i].portsIn[j].set(v);
              this._log.log("result filename:", v);
            }
          }
        }
      }
      if (cb) cb(numPorts);
    }

    copyFileToPatch(url, options = null) {
      platform.talkerAPI.send(
        "fileConvert",
        {
          url: url,
          converterId: "copytopatch",
          options: options,
        },
        (err, res) => {
          if (err) {
            notifyError("Over storage quota!");
          } else {
            if (
              res &&
              res.converterResult &&
              res.converterResult.sourceUrl &&
              res.converterResult.targetUrl
            ) {
              this.replaceAssetPorts(
                res.converterResult.sourceUrl,
                res.converterResult.targetUrl,
                (numPorts) => {
                  notify("Copied file, updated " + numPorts + " ports");
                },
              );
            }
          }
          Gui$1.gui.opParams.refresh();
          Gui$1.gui.refreshFileManager();
        },
      );
    }
  }

  FileManager.updatedFiles = [];

  // http://html5doctor.com/drag-and-drop-to-server/

  /**
   * file upload dialog
   *
   * @export
   * @class FileUploader
   */
  class FileUploader {
    constructor() {
      this._log = new Logger("fileuploader");

      this._uploadDropEvent = null;
      this._uploadDropListener = this.uploadDrop.bind(this);
      this._uploadDragOverListener = this.uploadDragOver.bind(this);
      this._uploadDragLeaveListener = this.uploadDragLeave.bind(this);

      this.bindUploadDragNDrop();
    }

    bindUploadDragNDrop() {
      document.body.addEventListener("drop", this._uploadDropListener);
      document.body.addEventListener("dragover", this._uploadDragOverListener);
      document.body.addEventListener("dragleave", this._uploadDragLeaveListener);
    }

    unBindUploadDragNDrop() {
      document.body.removeEventListener("drop", this._uploadDropListener);
      document.body.removeEventListener("dragover", this._uploadDragOverListener);
      document.body.removeEventListener(
        "dragleave",
        this._uploadDragLeaveListener,
      );
    }

    /**
     * @param {DragEvent} event
     */
    uploadDragOver(event) {
      if (Gui$1.gui.isRemoteClient) return;

      this._uploadDropEvent = event.originalEvent;

      if (
        !event ||
        !event.dataTransfer ||
        event.dataTransfer.types.indexOf("Files") == -1
      ) {
        this._log.log("drag has no files...");
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if (platform.frontendOptions.uploadFiles) {
        const el = document.getElementById("uploadarea");
        if (el) {
          if (event.target.classList.contains("uploadarea"))
            el.classList.add("uploadareaActive");
          else el.classList.remove("uploadareaActive");
        }

        let openDialog = true;

        if (el) openDialog = window.getComputedStyle(el).display === "none";
        if (openDialog) CABLES.CMD.PATCH.uploadFileDialog();
      }
    }

    uploadDragLeave(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    /**
     * @param {File} file
     */
    uploadFile(file, filename = null, opId = null, next = null) {
      if (Gui$1.gui.isRemoteClient) return;

      if (platform.frontendOptions.uploadFiles || CABLES.reuploadName) {
        // allow reupload in electron via `|| CABLES.reuploadName`
        CABLES.reuploadName = null;
        const reader = new FileReader();

        let uploadFileName = filename || file.name;
        reader.addEventListener(
          "load",
          () => {
            const talkerCommand = opId ? "uploadFileToOp" : "fileUploadStr";
            platform.talkerAPI.send(
              talkerCommand,
              {
                fileStr: reader.result,
                filename: uploadFileName,
                opId: opId,
              },
              (err, res) => {
                let newFilename = uploadFileName;
                if (res && res.filename) newFilename = res.filename;

                if (err) {
                  if (err.msg === "FAILED_PARSE_DATAURI") {
                    const modalOptions = {
                      title: "Error uploading files",
                      choice: true,
                      okButton: {
                        text: "Try different method",
                      },
                    };
                    const modal = new ModalDialog(modalOptions);
                    modal.on("onSubmit", () => {
                      CABLES.CMD.PATCH.uploadFileTab();
                    });
                  } else {
                    notifyError(
                      "ERROR: fileUploadStr " + err.msg || "Unknown error",
                    );
                    FileManager.updatedFiles.push(newFilename);
                  }
                } else {
                  FileManager.updatedFiles.push(newFilename);
                }
                if (next) next(err, newFilename);
              },
            );
          },
          false,
        );
        reader.readAsDataURL(file);
      } else if (platform.frontendOptions.dragDropLocalFiles) {
        const assetPath = platform.getPrefixAssetPath();
        let finalPath = "file://" + file.path;
        if (file.path.startsWith(assetPath)) {
          finalPath = file.path.replace(assetPath, "./");
        }
        finalPath = finalPath.replaceAll("\\", "/");
        Gui$1.gui.patchView.addAssetOpAuto(finalPath, this._uploadDropEventOrig);
      }
    }

    handleFileInputReUpload(files) {
      if (!window.gui) return;
      if (Gui$1.gui.isRemoteClient) return;

      Gui$1.gui.jobs().start({
        id: "prepareuploadfiles",
        title: "preparing files for upload...",
      });

      if (files.length > 0) {
        const partsNew = files[0].name.split(".");
        const partsOld = CABLES.reuploadName.split(".");

        if (partsNew[partsNew.length - 1] != partsOld[partsOld.length - 1]) {
          notifyError(
            "ERROR: different file ending " +
              partsNew[partsNew.length - 1] +
              "/" +
              partsOld[partsOld.length - 1],
          );
        } else {
          this.uploadFile(files[0], CABLES.reuploadName);
        }
      }

      Gui$1.gui.jobs().finish("prepareuploadfiles");
    }

    uploadFiles(files, opName) {
      if (!window.gui) return;
      if (Gui$1.gui.isRemoteClient) return;

      Gui$1.gui.jobs().start({
        id: "prepareuploadfiles",
        title: "preparing files for upload...",
      });

      for (let i = 0; i < files.length; i++) {
        this.uploadFile(files[i], files[i].name, opName);
      }

      Gui$1.gui.jobs().finish("prepareuploadfiles");
    }

    uploadDrop(event) {
      if (event.dataTransfer.files.length === 0) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();

      if (Gui$1.gui.isRemoteClient) return;

      this._uploadDropEventOrig = event;

      Gui$1.gui.closeModal();

      const files = event.dataTransfer.files;

      this.uploadFiles(files);
    }

    handleFileInputUpload(files) {
      this.uploadFiles(files);
    }
  }

  /**
   * @type {FileUploader}
   */
  const fileUploader = new FileUploader();
  CABLES.fileUploader = fileUploader;

  /**
   * tab to manage op dependencies like libs or npm-modules
   *
   * @export
   * @class OpDependencyTab
   * @extends {Tab}
   */
  class OpDependencyTab extends Tab {
    constructor(tabs, title, options = {}) {
      super(title, options);
      this.options.docsUrl = platform.getCablesDocsUrl();
      this._tabs = tabs || Gui$1.gui.mainTabs;
      this._tabs.addTab(this);
      Gui$1.gui.maintabPanel.show(true);
      this.html(this.getHtml());
      this._initEventListeners();
    }

    getHtml() {
      return getHandleBarHtml(
        "op_add_dependency_" + this.options.depSource,
        this.options,
      );
    }

    _initEventListeners() {
      const depSource = this.options.depSource;
      const viewId = this.options.viewId;
      const opName = this.options.opDoc.name;
      const opDoc = this.options.opDoc;

      const selector = "addopdependency_" + depSource + "_" + viewId;
      const depsEle = ele.byId(selector);

      if (depsEle) {
        const srcEle = depsEle.querySelector(".depSrc");
        const submitEle = depsEle.querySelector(".button.add");
        const depTypeEle = depsEle.querySelector("input[name='depType']");
        const exportNameEle = depsEle.querySelector(".exportName");
        const typeSelectEle = depsEle.querySelector("select.type");

        if (typeSelectEle) {
          typeSelectEle.addEventListener("change", () => {
            depTypeEle.value = typeSelectEle.value;
            if (exportNameEle && typeSelectEle.value === "module") {
              ele.show(exportNameEle);
            } else {
              ele.hide(exportNameEle);
            }
          });
        }

        const warningEle = depsEle.querySelector(".warning-error");
        if (warningEle && depTypeEle.value === "op") {
          srcEle.addEventListener("input", () => {
            if (namespace$1.isOpNameValid(srcEle.value)) {
              ele.hide(warningEle);
            } else {
              ele.show(warningEle);
            }
          });
        }

        let fileInput = null;
        const selectFileButton = depsEle.querySelector(".button.upload");
        if (selectFileButton) {
          fileInput = depsEle.querySelector("input[type='file']");
          selectFileButton.addEventListener("click", () => {
            fileInput.click();
          });
          fileInput.addEventListener("change", () => {
            srcEle.value = fileInput.files[0].name;
          });
        }
        submitEle.addEventListener("click", () => {
          if (submitEle.disabled) return;
          const depSrc = srcEle.value;
          if (!depSrc) return;
          submitEle.innerText = "working...";
          submitEle.disabled = true;

          let exportName = null;
          if (exportNameEle) {
            const exportNameInput = exportNameEle.querySelector("input");
            if (exportNameInput) exportName = exportNameInput.value;
          }

          const depType = depTypeEle.value;
          if (fileInput && fileInput.files && fileInput.files.length > 0) {
            const filename = fileInput.files[0].name;
            fileUploader.uploadFile(
              fileInput.files[0],
              filename,
              opDoc.id,
              (err, newFilename) => {
                if (!err) {
                  Gui$1.gui.serverOps.addOpDependency(
                    opName,
                    "./" + newFilename,
                    depType,
                    exportName,
                    () => {
                      submitEle.innerText = "Add";
                      submitEle.disabled = false;
                    },
                  );
                }
              },
            );
          } else if (depType === "lib") {
            Gui$1.gui.serverOps.addOpLib(opName, depSrc, () => {
              submitEle.innerText = "Add";
              submitEle.disabled = false;
            });
          } else if (depType === "corelib") {
            Gui$1.gui.serverOps.addCoreLib(opName, depSrc, () => {
              submitEle.innerText = "Add";
              submitEle.disabled = false;
            });
          } else {
            Gui$1.gui.serverOps.addOpDependency(
              opName,
              depSrc,
              depType,
              exportName,
              () => {
                submitEle.innerText = "Add";
                submitEle.disabled = false;
              },
            );
          }
        });
      }
    }
  }

  /**
   * a tab panel, that can contain tabs
   *
   * @export
   * @class OpDependencyTabPanel
   * @extends {TabPanel}
   */
  class OpDependencyTabPanel extends TabPanel {
    /**
     * Description
     * @param {string} eleId
     * @param {object} options
     */
    constructor(eleId, options) {
      super(eleId, { noUserSetting: true });

      this._options = options;
      this._sources = [
        { title: "Upload File", value: "file" },
        { title: "From URL", value: "url" },
        { title: "Op", value: "op" },
        { title: "Core-Lib", value: "corelib" },
      ];
      if (gui && Gui$1.gui.user && Gui$1.gui.user.isStaff) {
        this._sources.push({ title: "Lib", value: "lib", icon: "lock" });
      }
      if (platform.getSupportedOpDependencyTypes().includes("npm")) {
        this._sources.splice(2, 0, { title: "From NPM", value: "npm" });
      }
    }

    init() {
      let activeTab = null;
      this._sources.forEach((depSource, i) => {
        const title = depSource.title || depSource.value;
        const tabOptions = {
          hideToolbar: true,
          closable: false,
          depSource: depSource.value,
          icon: depSource.icon,
          ...this._options,
        };
        const depTab = new OpDependencyTab(this, title, tabOptions);
        if (i > 0) {
          depTab.deactivate();
        } else {
          activeTab = depTab;
        }
      });
      if (activeTab) this.activateTab(activeTab.id);
    }
  }

  /**
   * tab panel for managing ops: attachments,libs etc.
   *
   * @export
   * @class ManageOp
   */
  class ManageOp {
    constructor(tabs, opId) {
      this._log = new Logger("ManageOp");
      if (!opId) {
        editorSession.remove("manageOp", opId);
        return;
      }

      let opDoc = Gui$1.gui.opDocs.getOpDocById(opId);
      if (!opDoc && opId.startsWith("Ops.")) {
        this._log.warn(
          "manage op paramerter should not be objname, but id",
          opId,
        );
        opDoc = Gui$1.gui.opDocs.getOpDocByName(opId);
        if (opDoc) opId = opDoc.id;
        else return;
      }

      let opObjName = "";
      if (opDoc) opObjName = opDoc.name;

      this._initialized = false;
      this._currentName = opObjName;
      this._currentId = opId;
      this._id = CABLES.shortId();
      this._refreshListener = [];
      this._refreshCoreListener = [];

      this._tab = new Tab(opObjName, {
        icon: "op",
        infotext: "tab_code",
        padding: true,
        tabPanel: tabs,
        singleton: true,
      });
      tabs.addTab(this._tab, true);
      this.show();

      this._tab.on("close", () => {
        editorSession.remove("manageOp", this._currentId);

        for (let i in this._refreshListener) {
          Gui$1.gui.off(this._refreshListener[i]);
        }
        for (let i in this._refreshCoreListener) {
          Gui$1.gui.corePatch().off(this._refreshCoreListener[i]);
        }
      });

      Gui$1.gui.maintabPanel.show(true);

      this._refreshListener.push(
        Gui$1.gui.on("refreshManageOp", (name) => {
          if (name === undefined || this._currentName == name) this.show();
        }),
      );

      this._refreshCoreListener.push(
        Gui$1.gui.corePatch().on("opReloaded", (name) => {
          if (name === undefined || this._currentName == name) this.show();
        }),
      );
    }

    init() {
      if (this._initialized) return;
      this._initialized = true;
    }

    show() {
      editorSession.remove("manageOp", this._currentId);
      editorSession.rememberOpenEditor(
        "manageOp",
        this._currentId,
        {
          opname: this._currentName,
          opid: this._currentId,
        },
        true,
      );

      this._id = CABLES.shortId();
      this._tab.html(
        '<div class="loading" style="width:40px;height:40px;"></div>',
      );
      const opDoc = Gui$1.gui.opDocs.getOpDocById(this._currentId);

      if (!opDoc) {
        this._tab.html(
          "unknown op/no opdoc...<br/>this may be related to patch access restrictions<br/>please try in original patch",
        );
        this._tab.remove();
        return;
      }

      // timeout needed to not have multiple requests and refreshes when saving i.e. subpatchops
      clearTimeout(this._timeout);
      this._timeout = setTimeout(() => {
        platform.talkerAPI.send(
          "getOpInfo",
          { opName: opDoc.id },
          (error, res) => {
            if (error) this._log.warn("error api?", error);

            const perf = Gui$1.gui.uiProfiler.start("showOpCodeMetaPanel");
            const doc = {};
            const opName = this._currentName;
            let summary = "";
            let portJson = null;

            if (res.changelog && res.changelog.length > 0)
              doc.changelog = res.changelog;

            if (res.attachmentFiles) {
              const attachmentFiles = [];
              for (let i = 0; i < res.attachmentFiles.length; i++) {
                const parts = res.attachmentFiles[i].split(".");
                let suffix = "";
                suffix = parts[parts.length - 1];

                attachmentFiles.push({
                  suffix: suffix,
                  readable: res.attachmentFiles[i].substr(4),
                  original: res.attachmentFiles[i],
                });

                if (res.attachmentFiles[i] === "att_ports.json") {
                  const ops = Gui$1.gui.corePatch().getOpsByObjName(opName);

                  if (ops && ops.length > 0) {
                    try {
                      portJson = JSON.parse(ops[0].attachments.ports_json);
                    } catch (e) {
                      this._log.error(e);
                    }
                  }
                }
              }
              doc.attachmentFiles = attachmentFiles;
            }

            doc.libs = Gui$1.gui.serverOps.getOpLibs(opName, false).map((lib) => {
              return lib.name;
            });
            doc.coreLibs = Gui$1.gui.serverOps
              .getCoreLibs(opName, false)
              .map((lib) => {
                return lib.name;
              });
            summary = Gui$1.gui.opDocs.getSummary(opName) || "No Summary";
            const canEditOp = Gui$1.gui.serverOps.canEditOp(Gui$1.gui.user, opName);
            if (portJson && portJson.ports) {
              portJson.ports = subPatchOpUtil.sortPortsJsonPorts(portJson.ports);

              if (portJson.ports.length > 1)
                for (let i = 1; i < portJson.ports.length; i++) {
                  if (portJson.ports[i - 1].dir != portJson.ports[i].dir)
                    portJson.ports[i].divider = true;
                }
            }
            const allLibs = Gui$1.gui.opDocs.libs.sort((a, b) => {
              return a.localeCompare(b);
            });
            const libs = [];
            allLibs.forEach((lib) => {
              libs.push({
                url: lib,
                name: CABLES.basename(lib),
                isAssetLib: lib.startsWith("/assets/"),
              });
            });

            const html = getHandleBarHtml("tab_manage_op", {
              layoutUrl: platform.getCablesUrl() + "/api/op/layout/" + opName,
              url: platform.getCablesDocsUrl(),
              opLayoutSvg: Gui$1.gui.opDocs.getLayoutSvg(opName),
              opid: opDoc.id,
              opname: opDoc.name,
              doc: doc,
              opDoc: opDoc,
              viewId: this._id,
              subPatchSaved: Gui$1.gui.savedState.isSavedSubOp(opName),
              portJson: portJson,
              summary: summary,
              canEditOp: canEditOp,
              canDeleteOp: platform.frontendOptions.opDeleteInEditor
                ? canEditOp
                : false,
              readOnly: !canEditOp,
              user: Gui$1.gui.user,
              warns: res.warns,
              visibilityString: res.visibilityString,
              hasDependencies:
                (opDoc.coreLibs && opDoc.coreLibs.length) ||
                (opDoc.libs && opDoc.libs.length) ||
                (opDoc.dependencies && opDoc.dependencies.length),
            });

            this._tab.html(html);

            ele.clickables(
              this._tab.contentEle,
              ".dependency-options",
              (e, dataset) => {
                const depSrc = dataset.depsrc;
                const depType = dataset.deptype;

                const items = [];

                if (depType !== "corelib" && depType !== "lib") {
                  items.push({
                    title: "download",
                    iconClass: "icon icon-download",
                    func: () => {
                      let scriptSrc = "";
                      if (depSrc.startsWith("http")) {
                        scriptSrc = depSrc;
                      } else if (depSrc.startsWith("./")) {
                        scriptSrc =
                          platform.getSandboxUrl() +
                          "/api/oplib/" +
                          opName +
                          depSrc.replace(".", "");
                      }
                      if (scriptSrc) window.open(scriptSrc);
                    },
                  });
                }

                items.push({
                  title: "remove",
                  iconClass: "icon icon-x",
                  func: (ee) => {
                    switch (depType) {
                      case "corelib":
                        Gui$1.gui.serverOps.removeCoreLib(opName, depSrc);
                        break;
                      case "lib":
                        Gui$1.gui.serverOps.removeOpLib(opName, depSrc);
                        break;
                      case "commonjs":
                      case "module":
                      default:
                        Gui$1.gui.serverOps.removeOpDependency(
                          opName,
                          depSrc,
                          depType,
                        );
                        break;
                    }
                  },
                });

                if (items.length > 0) {
                  contextMenu.show({ items: items }, event.currentTarget);
                }
              },
            );

            if (canEditOp) {
              const dependencyTabId = this._id + "_dependencytabs";
              const tabPanel = ele.byId(dependencyTabId);
              if (tabPanel) {
                const panelOptions = {
                  opDoc: opDoc,
                  libs: libs,
                  coreLibs: Gui$1.gui.opDocs.coreLibs,
                  user: Gui$1.gui.user,
                  canEditOp: canEditOp,
                  viewId: this._id,
                };

                if (tabPanel) tabPanel.innerHTML = "";
                const depTabs = new OpDependencyTabPanel(
                  dependencyTabId,
                  panelOptions,
                );
                depTabs.init();
              }

              if (portJson && portJson.ports) {
                const buttonCreate = ele.byId(this._id + "_port_create");
                if (buttonCreate)
                  buttonCreate.addEventListener("click", () => {
                    subPatchOpUtil.portEditDialog(opName);
                  });

                for (let i = 0; i < portJson.ports.length; i++) {
                  const p = portJson.ports[i];
                  if (!p || !p.id) continue;

                  const id = p.id;
                  const buttonDelete = ele.byId(this._id + "_port_delete_" + id);
                  if (buttonDelete)
                    buttonDelete.addEventListener("click", () => {
                      subPatchOpUtil.portJsonDelete(opName, id);
                    });

                  const buttonTitle = ele.byId(this._id + "_port_title_" + id);
                  if (buttonTitle)
                    buttonTitle.addEventListener("click", () => {
                      subPatchOpUtil.portEditDialog(opName, id, p);
                    });

                  const buttonMoveUp = ele.byId(this._id + "_port_up_" + id);
                  if (buttonMoveUp)
                    buttonMoveUp.addEventListener("click", () => {
                      subPatchOpUtil.portJsonMove(opName, id, -1);
                    });

                  const buttonMoveDown = ele.byId(this._id + "_port_down_" + id);
                  if (buttonMoveDown)
                    buttonMoveDown.addEventListener("click", () => {
                      subPatchOpUtil.portJsonMove(opName, id, 1);
                    });
                }
              }
            } else {
              document
                .querySelectorAll(
                  "#metatabpanel .libselect select, #metatabpanel .libselect a",
                )
                .forEach((opLibSelect) => {
                  opLibSelect.disabled = true;
                  opLibSelect.addEventListener("pointerenter", (event) => {
                    showToolTip(
                      event.currentTarget,
                      "you are not allowed to add libraries to this op",
                    );
                  });
                  opLibSelect.addEventListener("pointerleave", (event) => {
                    hideToolTip();
                  });
                });

              document
                .querySelectorAll("#metatabpanel .libselect")
                .forEach((select) => {
                  select.classList.add("inactive");
                });
            }
            perf.finish();
          },
        );
      }, 100);
    }
  }

  /**
   * tab panel for editing text and source code using the ace editor
   */

  class EditorTab extends Events {
    constructor(options) {
      super();
      this._log = new Logger("EditorTab");
      this._editor = null;
      if (typeof options.allowEdit === "undefined" || options.allowEdit === null)
        options.allowEdit = true;

      this._options = options;

      Gui$1.gui.maintabPanel.show();

      let title = Gui$1.gui.maintabPanel.tabs.getUniqueTitle(options.title);

      // check if tab exists?

      this._tab = new Tab(title, {
        icon: null,
        type: options.syntax,
        name: options.name,
        dataId: options.dataId || options.name,
        infotext: text.editorTab,
        singleton: options.singleton,
      });

      this._tab.editor = this;

      this._tab.on("onActivate", () => {
        setTimeout(() => {
          if (this._editor) this._editor.focus();
        }, 30);
      });

      this._tab.on("resize", () => {
        if (this._tab) this._tab.updateSize();
        if (this._editor) this._editor.resize();
      });

      const existing = Gui$1.gui.mainTabs.getTabByTitle(title);
      if (existing) {
        Gui$1.gui.mainTabs.activateTab(existing.id);
      } else {
        this._tab.editorObj = options.editorObj;
        Gui$1.gui.mainTabs.addTab(this._tab);
      }

      let style = "";

      if (!options.allowEdit) style = "background-color:#333;";
      const html =
        '<div id="editorcontent' +
        this._tab.id +
        '" style="width:100%;height:100%;' +
        style +
        '"><center><br/><br/><br/><br/><span class="icon icon-loader"></span></center></div>';
      this._tab.html(html);

      if (options.hasOwnProperty("content")) this.setContent(options.content);
    }

    /**
     * @param {string} content
     */
    setContent(content, silent = false) {
      content = content || "";
      if (!this._editor) {
        if (!ele.byId("editorcontent" + this._tab.id)) {
          this._log.error("ele not found!!", this);
          return;
        }
        this.createEditor("editorcontent" + this._tab.id, content, (editor) => {
          this._editor = editor;

          editor.setFontSize(
            parseInt(UserSettings.userSettings.get("fontsize_ace")) || 12,
          );
          editor
            .getSession()
            .setUseWrapMode(
              UserSettings.userSettings.get("wrapmode_ace") || false,
            );

          if (Gui$1.gui.UserSettings.userSettings.get("ace_keymode")) {
            editor.setKeyboardHandler(
              Gui$1.gui.UserSettings.userSettings.get("ace_keymode"),
            );

            ace.config.loadModule("ace/keyboard/vim", (module) => {
              let VimApi = module.CodeMirror.Vim;
              VimApi.defineEx("write", "w", (cm, input) => {
                this.save();
              });
            });
          }

          if (this._options.allowEdit) {
            if (this._options.onSave || this._options.showSaveButton)
              this._tab.addButton(text.editorSaveButton, () => {
                this.save();
              });

            let hideFormatButton = !!this._options.hideFormatButton;
            if (
              !hideFormatButton &&
              this._options.syntax &&
              this._options.syntax === "js"
            )
              hideFormatButton = false;
            else hideFormatButton = true;
            if (!platform.frontendOptions.showFormatCodeButton)
              hideFormatButton = true;

            if (this._options.allowEdit && !hideFormatButton)
              this._tab.addButton(
                text.editorFormatButton,
                this.format.bind(this),
              );
          } else {
            this._editor.setOptions({
              readOnly: "true",
              highlightActiveLine: false,
              highlightGutterLine: false,
            });
            this._editor.renderer.setStyle("disabled", true);
            this._editor.blur();
          }

          let opname = null;
          this._options.editorObj = this._options.editorObj || {};
          if (this._options.editorObj.type === "op")
            opname = this._options.editorObj.name;
          if (this._options.editorObj.data && this._options.editorObj.data.opname)
            opname = this._options.editorObj.data.opname;

          if (!opname) {
            const d = Gui$1.gui.opDocs.getOpDocById(this._options.name);
            if (d) opname = d.name;
          }

          let opId = null;
          if (opname) {
            const opdoc = Gui$1.gui.opDocs.getOpDocByName(opname);
            if (opdoc) {
              opId = opdoc.id;
            } else {
              this._log.warn("could not get opdoc:" + opname);
            }

            this._tab.addButton(
              '<span class="icon icon-op"></span> Manage Op',
              () => {
                new ManageOp(Gui$1.gui.mainTabs, opId);
              },
            );

            if (opdoc && opdoc.attachmentFiles && opdoc.attachmentFiles.length) {
              const el = this._tab.addButton(
                '<span class="icon icon-chevron-down"></span>Op Files',
                () => {
                  const items = [];

                  items.push({
                    title: opdoc.name + ".js",
                    func: () => {
                      Gui$1.gui.serverOps.edit(opdoc.name, false, null, true);
                    },
                  });

                  for (let i = 0; i < opdoc.attachmentFiles.length; i++) {
                    const fn = opdoc.attachmentFiles[i];
                    items.push({
                      title: opdoc.attachmentFiles[i],
                      func: () => {
                        Gui$1.gui.serverOps.editAttachment(opname, fn);
                      },
                    });
                  }

                  contextMenu.show({ items: items }, el);
                },
              );
            }

            this._tab.addButton("Op Docs", () => {
              window.open(platform.getCablesDocsUrl() + "/op/" + opname);
            });
          }

          if (
            platform.frontendOptions.openLocalFiles &&
            this._options.allowEdit
          ) {
            this._tab.addButton(
              '<span class="info nomargin icon icon-1_25x icon-folder" data-info="electron_openfolder" ></span>',
              (e) => {
                if (e.ctrlKey || e.metaKey)
                  CABLES.CMD.ELECTRON.copyOpDirToClipboard(opId);
                else CABLES.CMD.ELECTRON.openOpDir(opId, opname);
              },
            );
          }
          this._tab.addButton(
            '<span class="nomargin icon icon-1_25x icon-help"></span>',
            () => {
              window.open(
                platform.getCablesDocsUrl() +
                  "/docs/5_writing_ops/dev_ops/dev_ops",
              );
            },
          );

          this._editor.resize();

          const undoManager = this._editor.session.getUndoManager();
          undoManager.reset();
          this._editor.session.setUndoManager(undoManager);

          this._editor.on("change", (e) => {
            Gui$1.gui.mainTabs.setChanged(this._tab.id, true);
            if (this._options.onChange) this._options.onChange();
          });

          this._editor.getSession().setUseWorker(true);

          if (this._options.syntax === "md")
            this._editor.session.setMode("ace/mode/Markdown");
          else if (this._options.syntax === "js")
            this._editor.session.setMode("ace/mode/javascript");
          else if (this._options.syntax === "glsl")
            this._editor.session.setMode("ace/mode/glsl");
          else if (this._options.syntax === "css")
            this._editor.session.setMode("ace/mode/css");
          else if (this._options.syntax === "html")
            this._editor.session.setMode("ace/mode/html");
          else if (this._options.syntax === "json")
            this._editor.session.setMode("ace/mode/json");
          else if (this._options.syntax === "sql")
            this._editor.session.setMode("ace/mode/sql");
          else if (this._options.syntax === "inline-css") {
            this._editor.session.setMode("ace/mode/css");
            this._editor.getSession().setUseWorker(false);
          } else {
            if (this._options.syntax)
              this._log.warn(
                "unknown syntax highlighter for ace",
                this._options.syntax,
              );
            this._editor.session.setMode("ace/mode/plain_text");
            this._editor.getSession().setUseWorker(false);
          }

          this._tab.addEventListener("close", this._options.onClose);
          this._tab.addEventListener("onActivate", () => {
            this._editor.resize(true);
            this._editor.focus();
            if (this._tab.editorObj && this._tab.editorObj.name)
              UserSettings.userSettings.set(
                "editortab",
                this._tab.editorObj.name,
              );
          });

          setTimeout(() => {
            this._editor.focus();
            this._tab.updateSize();
            this._editor.resize(true);
            if (this._options.onFinished) this._options.onFinished();
          }, 100);
        });
      } else {
        this._editor.setValue(content, 1);
        if (silent) Gui$1.gui.mainTabs.setChanged(this._tab.id, false);
      }
    }

    focus() {
      this._editor.focus();
    }

    format() {
      platform.talkerAPI.send(
        "formatOpCode",
        {
          code: this._editor.getValue(),
        },
        (err, res) => {
          if (!res || !res.success) {
            notifyError("failed to format code, keeping old version");
            this._log.warn("code formating error", err);
          } else {
            this._editor.setValue(res.opFullCode, 1);
            this._editor.focus();
          }
        },
        (result) => {
          notifyError("failed to format code, keeping old version");
          this._log.warn("code formating http error", result);
        },
      );
    }

    save() {
      function onSaveCb(txt) {
        Gui$1.gui.jobs().finish("saveeditorcontent");

        if (txt.toLowerCase().indexOf("error") == 0) notifyError(txt);
        else {
          notify(txt);
          Gui$1.gui.mainTabs.setChanged(this._tab.id, false);
        }

        this._editor.focus();
        setTimeout(() => {
          this._editor.focus();
        }, 100);
      }

      this._editor.getSession().getAnnotations();
      // this._log.log("annotations", anns);

      gui
        .jobs()
        .start({ id: "saveeditorcontent", title: "saving editor content" });
      if (this._options.onSave) {
        this._options.onSave(
          onSaveCb.bind(this),
          this._editor.getValue(),
          this._editor,
        );
      } else
        this.emitEvent(
          "save",
          onSaveCb.bind(this),
          this._editor.getValue(),
          this._editor,
        );
    }

    createEditor(id, val, cb) {
      loadAce(() => {
        const editor = ace.edit(id);
        editor.setValue(""); // need to do this

        editor.setOptions({
          fontFamily: "SourceCodePro",
          fontSize: "14px",
          enableBasicAutocompletion: true,
          enableLiveAutocompletion: true,
          enableSnippets: true,
          showPrintMargin: false,
        });

        editor.setTheme("ace/theme/cables");

        editor.session.setMode("ace/mode/javascript");
        editor.session.on("changeMode", (e, session) => {
          if (session.getMode().$id !== "ace/mode/javascript") return;
          if (session.$worker) {
            session.$worker.send("changeOptions", [
              { strict: false, esversion: 11, esnext: false },
            ]);
          }
        });
        editor.$blockScrolling = Infinity;

        editor.commands.bindKey("Ctrl-D", "selectMoreAfter");
        editor.commands.bindKey("Cmd-D", "selectMoreAfter");
        editor.commands.bindKey("Cmd-Ctrl-Up", "movelinesup");
        editor.commands.bindKey("Cmd-Ctrl-Down", "movelinesdown");

        editor.setValue(String(val), -1);

        const snipreq = ace.require("ace/snippets");

        if (!snipreq) {
          this._log.error("ace - no snippetmanager ?!");
          alert("ace crash no snippetmanager....");
          return;
        }

        const snippetManager = snipreq.snippetManager;
        const snippets = snippetManager.parseSnippetFile("");

        snippets.push(
          {
            content: 'setUiError = function ("${1:id}","${1:message}")',
            name: "inTriggerButton",
          },
          {
            content: 'inTriggerButton("${1:name}")',
            name: "inTriggerButton",
          },
          {
            content: 'inTrigger("${1:name}")',
            name: "inTrigger",
          },

          {
            content: 'inMultiPort("#1", CABLES.OP_PORT_TYPE_NUMBER)',
            name: "inMultiPort",
          },
          {
            content: 'outTrigger("${1:name}")',
            name: "outTrigger",
          },
          {
            content: 'inBool("${1:name}",${2:false})',
            name: "inBool",
          },
          {
            content: 'inInt("${1:name}",${2:0})',
            name: "inInt",
          },
          {
            content: 'inFloatSlider("${1:name}",${2:0})',
            name: "inFloatSlider",
          },
          {
            content: 'inFloat("${1:name}",${2:0})',
            name: "inFloat",
          },
          {
            content: 'inDropDown("${1:name}",${2:["option a","option b"]})',
            name: "inDropDown",
          },
          {
            content:
              'inSwitch("${1:name}",${2:["option a","option b"]},${3:"default"})',
            name: "inSwitch",
          },
          {
            content: 'inStringEditor("${1:name}","${2:default}","${3:syntax}")',
            name: "inStringEditor",
          },
          {
            content: 'inString("${1:name}","${2:default}")',
            name: "inString",
          },
          {
            content: 'inObject("${1:name}")',
            name: "inObject",
          },
          {
            content: 'inTexture("${1:name}")',
            name: "inTexture",
          },
          {
            content: 'inArray("${1:name}")',
            name: "inArray",
          },
          {
            content: 'inUrl("${1:name}")',
            name: "inUrl",
          },
          {
            content: 'outNumber("${1:name}")',
            name: "outNumber",
          },
          {
            content: 'outBoolNum("${1:name}")',
            name: "outBoolNum",
          },
          {
            content: 'outString("${1:name}")',
            name: "outString",
          },
          {
            content: 'outObject("${1:name}")',
            name: "outObject",
          },
          {
            content: 'outArray("${1:name}")',
            name: "outArray",
          },
          {
            content: 'outTexture("${1:name}")',
            name: "outTexture",
          },
          {
            content: "CABLES.map(${1:name})",
            name: "CABLES.map",
          },
          {
            content: 'console.log("${1:text}");',
            name: "console.log",
          },
          {
            content: 'op.setPortGroup("${1:name}",[${2:port},${3:port}]);',
            name: "op.setPortGroup",
          },
          {
            content:
              "CABLES.map(${1:value},${2:oldMin},${3:oldMax},${4:newMin},${5:newMax});",
            name: "CABLES.map",
          },
          {
            content: "op.toWorkPortsNeedToBeLinked(${1:port1},${2:port2});",
            name: "op.toWorkPortsNeedToBeLinked",
          },
          {
            content: "op.toWorkPortsNeedsString(${1:port1},${2:port2});",
            name: "op.toWorkPortsNeedsString",
          },

          {
            content: "vec3.create();",
            name: "vec3.create",
          },
          {
            content: "vec3.set(${1:out},${2:x},${3:y},${4:z});",
            name: "vec3.set(out, x, y, z)",
          },
          {
            content: "mat4.create();",
            name: "mat4.create",
          },
          {
            content: "mat4.identity();",
            name: "mat4.identity",
          },
          {
            content: "mat4.translate(${1:out},${2:a},${3:v});",
            name: "mat4.translate(out,a,v);",
          },
          {
            content: "CGL.Texture.PFORMATSTR_RGBA32F",
            name: "CGL.Texture.PFORMATSTR_RGBA32F",
          },
          {
            content: "CGL.Texture.PFORMATSTR_RGBA8UB",
            name: "CGL.Texture.PFORMATSTR_RGBA8UB",
          },
          {
            content: "CGL.Texture.PIXELFORMATS",
            name: "CGL.Texture.PIXELFORMATS",
          },
          {
            content: 'op.setUiError("id", "text or null");',
            name: "op.setUiError",
          },
          {
            content: "op.patch.isEditorMode()",
            name: "op.patch.isEditorMode",
          },
        );
        snippetManager.register(snippets, "javascript");

        const snippetsGlsl = snippetManager.parseSnippetFile("");

        snippetsGlsl.push(
          {
            content: "uniform float ${1:varName};",
            name: "uniform float ${1:varName};",
          },
          {
            content: "uniform sampler2D ${1:texName};",
            name: "uniform sampler2D ${1:texName};",
          },
          {
            content: "texture(${1:texCoord},${2:samplerTex});",
            name: "texture(texCoord,tex);",
          },
        );
        snippetManager.register(snippetsGlsl, "glsl");

        const cssSnippets = [];
        cssSnippets.push({ name: "background", content: "background: " });
        cssSnippets.push({
          name: "background-attachment",
          content: "background-attachment: ",
        });
        cssSnippets.push({
          name: "background-break",
          content: "background-break: ",
        });
        cssSnippets.push({
          name: "background-clip",
          content: "background-clip: ",
        });
        cssSnippets.push({
          name: "background-color",
          content: "background-color: ",
        });
        cssSnippets.push({
          name: "background-image",
          content: "background-image: ",
        });
        cssSnippets.push({
          name: "background-origin",
          content: "background-origin: ",
        });
        cssSnippets.push({
          name: "background-position-x",
          content: "background-position-x: ",
        });
        cssSnippets.push({
          name: "background-position-y",
          content: "background-position-y: ",
        });
        cssSnippets.push({
          name: "background-position",
          content: "background-position: ",
        });
        cssSnippets.push({
          name: "background-repeat",
          content: "background-repeat: ",
        });
        cssSnippets.push({
          name: "background-size",
          content: "background-size: ",
        });
        cssSnippets.push({ name: "background", content: "background: " });
        cssSnippets.push({ name: "filter", content: "filter: " });
        cssSnippets.push({ name: "background", content: "background: " });
        cssSnippets.push({ name: "border", content: "border: " });
        cssSnippets.push({ name: "border-bottom", content: "border-bottom: " });
        cssSnippets.push({
          name: "border-bottom-color",
          content: "border-bottom-color: ",
        });
        cssSnippets.push({
          name: "border-bottom-image",
          content: "border-bottom-image: ",
        });
        cssSnippets.push({
          name: "border-bottom-left-image",
          content: "border-bottom-left-image: ",
        });
        cssSnippets.push({
          name: "border-bottom-left-radius",
          content: "border-bottom-left-radius: ",
        });
        cssSnippets.push({
          name: "border-bottom-right-image",
          content: "border-bottom-right-image: ",
        });
        cssSnippets.push({
          name: "border-bottom-right-radius",
          content: "border-bottom-right-radius: ",
        });
        cssSnippets.push({
          name: "border-bottom-style",
          content: "border-bottom-style: ",
        });
        cssSnippets.push({
          name: "border-bottom-width",
          content: "border-bottom-width: ",
        });
        cssSnippets.push({ name: "border-bottom", content: "border-bottom: " });
        cssSnippets.push({ name: "border-break", content: "border-break: " });
        cssSnippets.push({
          name: "border-collapse",
          content: "border-collapse: ",
        });
        cssSnippets.push({ name: "border-color", content: "border-color: " });
        cssSnippets.push({
          name: "border-corner-image",
          content: "border-corner-image: ",
        });
        cssSnippets.push({ name: "border-fit", content: "border-fit: " });
        cssSnippets.push({ name: "border-image", content: "border-image: " });
        cssSnippets.push({ name: "border-left", content: "border-left: " });
        cssSnippets.push({
          name: "border-left-color",
          content: "border-left-color: ",
        });
        cssSnippets.push({
          name: "border-left-image",
          content: "border-left-image: ",
        });
        cssSnippets.push({
          name: "border-left-style",
          content: "border-left-style: ",
        });
        cssSnippets.push({
          name: "border-left-width",
          content: "border-left-width: ",
        });
        cssSnippets.push({ name: "border-left", content: "border-left: " });
        cssSnippets.push({ name: "border-length", content: "border-length: " });
        cssSnippets.push({ name: "border-radius", content: "border-radius: " });
        cssSnippets.push({ name: "border-right", content: "border-right: " });
        cssSnippets.push({
          name: "border-right-color",
          content: "border-right-color: ",
        });
        cssSnippets.push({
          name: "border-right-image",
          content: "border-right-image: ",
        });
        cssSnippets.push({
          name: "border-right-style",
          content: "border-right-style: ",
        });
        cssSnippets.push({
          name: "border-right-width",
          content: "border-right-width: ",
        });
        cssSnippets.push({ name: "border-right", content: "border-right: " });
        cssSnippets.push({ name: "border-spacing", content: "border-spacing: " });
        cssSnippets.push({ name: "border-style", content: "border-style: " });
        cssSnippets.push({ name: "border-top", content: "border-top: " });
        cssSnippets.push({
          name: "border-top-color",
          content: "border-top-color: ",
        });
        cssSnippets.push({
          name: "border-top-image",
          content: "border-top-image: ",
        });
        cssSnippets.push({
          name: "border-top-left-image",
          content: "border-top-left-image: ",
        });
        cssSnippets.push({
          name: "border-corner-image",
          content: "border-corner-image: ",
        });
        cssSnippets.push({
          name: "border-top-left-radius",
          content: "border-top-left-radius: ",
        });
        cssSnippets.push({
          name: "border-top-right-image",
          content: "border-top-right-image: ",
        });
        cssSnippets.push({
          name: "border-top-right-radius",
          content: "border-top-right-radius: ",
        });
        cssSnippets.push({
          name: "border-top-style",
          content: "border-top-style: ",
        });
        cssSnippets.push({
          name: "border-top-width",
          content: "border-top-width: ",
        });
        cssSnippets.push({ name: "border-top", content: "border-top: " });
        cssSnippets.push({ name: "border-width", content: "border-width: " });
        cssSnippets.push({ name: "border", content: "border: " });
        cssSnippets.push({ name: "bottom", content: "bottom: " });
        cssSnippets.push({ name: "box-shadow", content: "box-shadow: " });
        cssSnippets.push({ name: "box-sizing", content: "box-sizing: " });
        cssSnippets.push({ name: "caption-side", content: "caption-side: " });
        cssSnippets.push({ name: "clear", content: "clear: " });
        cssSnippets.push({ name: "clip", content: "clip: " });
        cssSnippets.push({ name: "color", content: "color: " });
        cssSnippets.push({ name: "content", content: "content: " });
        cssSnippets.push({
          name: "counter-increment",
          content: "counter-increment: ",
        });
        cssSnippets.push({ name: "counter-reset", content: "counter-reset: " });
        cssSnippets.push({ name: "cursor", content: "cursor: " });
        cssSnippets.push({ name: "display", content: "display: " });
        cssSnippets.push({ name: "empty-cells", content: "empty-cells: " });
        cssSnippets.push({ name: "expression()", content: "expression(): " });
        cssSnippets.push({ name: "float", content: "float: " });
        cssSnippets.push({ name: "font", content: "font: " });
        cssSnippets.push({ name: "font-effect", content: "font-effect: " });
        cssSnippets.push({
          name: "font-emphasize-position",
          content: "font-emphasize-position: ",
        });
        cssSnippets.push({
          name: "font-emphasize-style",
          content: "font-emphasize-style: ",
        });
        cssSnippets.push({ name: "font-emphasize", content: "font-emphasize: " });
        cssSnippets.push({ name: "font-family", content: "font-family: " });
        cssSnippets.push({
          name: "font-size-adjust",
          content: "font-size-adjust: ",
        });
        cssSnippets.push({ name: "font-size", content: "font-size: " });
        cssSnippets.push({ name: "font-smooth", content: "font-smooth: " });
        cssSnippets.push({ name: "font-stretch", content: "font-stretch: " });
        cssSnippets.push({ name: "font-style", content: "font-style: " });
        cssSnippets.push({ name: "font-variant", content: "font-variant: " });
        cssSnippets.push({ name: "font-weight", content: "font-weight: " });
        cssSnippets.push({ name: "font", content: "font: " });
        cssSnippets.push({ name: "height", content: "height: " });
        cssSnippets.push({ name: "left", content: "left: " });
        cssSnippets.push({ name: "letter-spacing", content: "letter-spacing: " });
        cssSnippets.push({ name: "line-height", content: "line-height: " });
        cssSnippets.push({
          name: "list-style-image",
          content: "list-style-image: ",
        });
        cssSnippets.push({
          name: "list-style-position",
          content: "list-style-position: ",
        });
        cssSnippets.push({
          name: "list-style-type",
          content: "list-style-type: ",
        });
        cssSnippets.push({ name: "list-style", content: "list-style: " });
        cssSnippets.push({ name: "margin-bottom", content: "margin-bottom: " });
        cssSnippets.push({ name: "margin-left", content: "margin-left: " });
        cssSnippets.push({ name: "margin-right", content: "margin-right: " });
        cssSnippets.push({ name: "margin-top", content: "margin-top: " });
        cssSnippets.push({ name: "margin", content: "margin: " });
        cssSnippets.push({ name: "max-height", content: "max-height: " });
        cssSnippets.push({ name: "max-width", content: "max-width: " });
        cssSnippets.push({ name: "min-height", content: "min-height: " });
        cssSnippets.push({ name: "min-width", content: "min-width: " });
        cssSnippets.push({ name: "opacity", content: "opacity: " });
        cssSnippets.push({ name: "filter", content: "filter: " });
        cssSnippets.push({ name: "-ms-filter", content: "-ms-filter: " });
        cssSnippets.push({ name: "orphans", content: "orphans: " });
        cssSnippets.push({ name: "outline", content: "outline: " });
        cssSnippets.push({ name: "outline-color", content: "outline-color: " });
        cssSnippets.push({ name: "outline-offset", content: "outline-offset: " });
        cssSnippets.push({ name: "outline-style", content: "outline-style: " });
        cssSnippets.push({ name: "outline-width", content: "outline-width: " });
        cssSnippets.push({ name: "outline", content: "outline: " });
        cssSnippets.push({ name: "overflow-style", content: "overflow-style: " });
        cssSnippets.push({ name: "overflow-x", content: "overflow-x: " });
        cssSnippets.push({ name: "overflow-y", content: "overflow-y: " });
        cssSnippets.push({ name: "overflow", content: "overflow: " });
        cssSnippets.push({ name: "padding-bottom", content: "padding-bottom: " });
        cssSnippets.push({ name: "padding-left", content: "padding-left: " });
        cssSnippets.push({ name: "padding-right", content: "padding-right: " });
        cssSnippets.push({ name: "padding-top", content: "padding-top: " });
        cssSnippets.push({ name: "padding", content: "padding: " });
        cssSnippets.push({
          name: "page-break-after",
          content: "page-break-after: ",
        });
        cssSnippets.push({
          name: "page-break-before",
          content: "page-break-before: ",
        });
        cssSnippets.push({
          name: "page-break-inside",
          content: "page-break-inside: ",
        });
        cssSnippets.push({ name: "position", content: "position: " });
        cssSnippets.push({ name: "quotes", content: "quotes: " });
        cssSnippets.push({ name: "resize", content: "resize: " });
        cssSnippets.push({ name: "right", content: "right: " });
        cssSnippets.push({ name: "table-layout", content: "table-layout: " });
        cssSnippets.push({
          name: "text-align-last",
          content: "text-align-last: ",
        });
        cssSnippets.push({ name: "text-align", content: "text-align: " });
        cssSnippets.push({
          name: "text-decoration",
          content: "text-decoration: ",
        });
        cssSnippets.push({ name: "text-emphasis", content: "text-emphasis: " });
        cssSnippets.push({ name: "text-height", content: "text-height: " });
        cssSnippets.push({ name: "text-indent", content: "text-indent: " });
        cssSnippets.push({ name: "text-justify", content: "text-justify: " });
        cssSnippets.push({ name: "text-outline", content: "text-outline: " });
        cssSnippets.push({ name: "text-replace", content: "text-replace: " });
        cssSnippets.push({ name: "text-shadow", content: "text-shadow: " });
        cssSnippets.push({ name: "text-transform", content: "text-transform: " });
        cssSnippets.push({ name: "text-wrap", content: "text-wrap: " });
        cssSnippets.push({ name: "top", content: "top: " });
        cssSnippets.push({ name: "vertical-align", content: "vertical-align: " });
        cssSnippets.push({ name: "visibility", content: "visibility: " });
        cssSnippets.push({
          name: "white-space-collapse",
          content: "white-space-collapse: ",
        });
        cssSnippets.push({ name: "white-space", content: "white-space: " });
        cssSnippets.push({ name: "widows", content: "widows: " });
        cssSnippets.push({ name: "width", content: "width: " });
        cssSnippets.push({ name: "word-break", content: "word-break: " });
        cssSnippets.push({ name: "word-spacing", content: "word-spacing: " });
        cssSnippets.push({ name: "word-wrap", content: "word-wrap: " });
        cssSnippets.push({ name: "z-index", content: "z-index: " });
        cssSnippets.push({ name: "zoom", content: "zoom: " });
        snippetManager.register(cssSnippets, "css");

        const staticWordCompleterJs = {
          getCompletions(_editor, session, pos, prefix, callback) {
            const wordList = [
              "op.log",
              "op.logWarn",
              "op.logError",
              "onChange=",
              "onTriggered=",
              "onLinkChanged=",
              "op.toWorkNeedsParent",
              "op.toWorkShouldNotBeChild",
              "setUiAttribs",
              "op.patch.cgl",
              "CABLES.shuffleArray(arr);",
              "Math.seededRandom();",
              "Math.randomSeed=1;",
              "CABLES.now();",
            ];
            callback(
              null,
              wordList.map(function (word) {
                return {
                  caption: word,
                  value: word,
                  meta: "static",
                };
              }),
            );
          },
        };

        editor.completers.push(staticWordCompleterJs);
        editor.resize();
        editor.focus();

        cb(editor);
      });
    }
  }

  function loadAce(cb) {
    if (CABLES.loadedAce) {
      cb();
    } else {
      loadjs.ready("acelibs", () => {
        Gui$1.gui.jobs().finish("acelibs");
        gui
          .jobs()
          .start({ id: "acemisc", title: "loading ace editor misc files" });

        try {
          loadjs(
            ["js/ace/ext-language_tools.js", "js/ace/theme-cables.js"],
            "ace",
          );
        } catch (e) {
          // ignore error when trying to load multiple times
        }
      });

      loadjs.ready("ace", () => {
        Gui$1.gui.jobs().finish("acemisc");
        CABLES.loadedAce = true;
        cb();
      });

      Gui$1.gui.jobs().start({ id: "acelibs", title: "loading ace editor lib" });
      try {
        loadjs(["js/ace/ace.js"], "acelibs");
      } catch (e) {
        // ignore error when trying to load multiple times
      }
    }
  }

  class SpreadSheetTab extends Events {
    constructor(tabs, port, data, options) {
      super();
      this._tabs = tabs;
      this._log = new Logger("SpreadSheetTab");

      options = options || {};

      this._numCols = options.numColumns || 3;
      this._rows = 25;

      this._port = port;
      this.cells = [];
      this._inputs = [];
      this._options = options;
      this.colNames = [];

      this._tab = new CABLES.UI.Tab(options.title || "", {
        icon: "edit",
        infotext: "tab_spreadsheet",
        padding: true,
        singleton: "false",
      });
      this._tabs.addTab(this._tab, true);

      port.on("onUiAttrChange", this._updateUiAttribs.bind(this));

      this.data = { cells: this.cells, colNames: this.colNames };

      if (data) this.initData(data);
      else {
        for (let i = 0; i < this._numCols; i++) this.getColName(i);
      }

      this._id = "spread" + CABLES.uuid();
      this._updateUiAttribs();
    }

    _updateUiAttribs() {
      this._numCols = this._port.uiAttribs.spread_numColumns || 1;
      this.rebuildHtml();
    }

    rebuildHtml() {
      this._tab.html("<div id='" + this._id + "' ></div>");
      this._ele = document.getElementById(this._id);
      if (!this._ele) return;
      this._ele.classList.add("editor_spreadsheet");
      this._ele.classList.add("tabcontent-scroll");

      this._eleTable = ele.create("table");
      this._ele.appendChild(this._eleTable);

      this.cells.length = this._rows;

      this._html();
    }

    getColName(_c) {
      _c = parseFloat(_c);

      if (this.colNames.length > _c && this.colNames[_c]) {
        return this.colNames[_c];
      }

      let str = "";
      let c = parseFloat(_c);

      if (c < 0) throw new Error("col invalid");

      while (c >= 0) {
        str = "abcdefghijklmnopqrstuvwxyz"[c % 26] + str;
        c = Math.floor(c / 26) - 1;
      }

      this.colNames[_c] = str;

      return str;
    }

    _html() {
      for (let i = 0; i < this._inputs.length; i++) this._inputs[i].remove();

      this._inputs.length = 0;
      const table = this._eleTable;

      for (let y = -1; y < this._rows; y++) {
        const tr = ele.create("tr");
        table.appendChild(tr);

        const tdr = ele.create("td");
        if (y >= 0) {
          tdr.innerHTML = y;
          tdr.classList.add("rownum");
        }
        tr.appendChild(tdr);

        for (let x = 0; x < this._numCols; x++) {
          const td = ele.create("td");
          tr.appendChild(td);

          const input = ele.create("input");
          input.dataset.x = x;
          input.dataset.y = y;
          this._inputs[x + y * this._numCols] = input;

          if (y == -1) {
            input.classList.add("colname");
            input.value = this.getColName(x);
          } else {
            input.value = this.get(x, y) || "";
          }

          td.appendChild(input);

          input.addEventListener("change", this._checkNumRows.bind(this));
          input.addEventListener("input", this._onInputChange.bind(this));
          input.addEventListener("keydown", this._onKey.bind(this), false);
        }
      }
    }

    _focusCell(x, y) {
      const inp = this._inputs[y * this._numCols + x];

      if (inp) {
        inp.focus();

        setTimeout(() => {
          // inp.select();
        }, 50);
      }
    }

    _onKey(e) {
      const x = parseFloat(e.target.dataset.x);
      const y = parseFloat(e.target.dataset.y);

      if (e.keyCode == 38) {
        this._focusCell(x, y - 1);
      } else if (e.keyCode == 40) {
        this._focusCell(x, y + 1);
      } else if (e.keyCode == 37) {
        this._focusCell(x - 1, y);
      } else if (e.keyCode == 39) {
        this._focusCell(x + 1, y);
      } else this._onInputChange(e);
    }

    _checkNumRows() {
      this._log.log(this.cells);

      let lastLine = this.cells.length - 1;
      for (let i = this.cells.length - 1; i > 0; i--) {
        if (this.cells[i]) {
          let foundContent = false;
          for (let x = 0; x < this._numCols; x++)
            if (this.cells[i][x] && this.cells[i][x].length > 0) {
              this._log.log(i, this.cells[i]);
              foundContent = true;
              lastLine = i;
            }

          if (foundContent) break;
        }

        /*
         * for (let x = 0; x < this._numCols; x++)
         * {
         *     this._log.log(this.cells[x]);
         * }
         */
      }

      this._log.log("lastLine", lastLine);

      lastLine += 10;
      if (this._rows != lastLine) {
        this._rows = lastLine;
        this.rebuildHtml();
      }

      this._log.log("lastline", lastLine);

      /*
       * const newRows = lastLine + 10;
       * if (this._rows != newRows)
       * {
       *     this._rows = this.cells.length + 10;
       *     this.rebuildHtml();
       * }
       * if()
       */

      /*
       * if (this.cells.length >= this._rows)
       * {
       * }
       */
    }

    initData(data) {
      this.cells = data.cells || [];
      this.colNames = data.colNames || [];
      this._checkNumRows();
    }

    get(x, y) {
      if (y == -1) return this.getColName(x);
      if (!this.cells) return undefined;
      if (!this.cells[y]) return [];
      return this.cells[y][x];
    }

    set(x, y, v) {
      if (y == -1) {
        this._log.log("set colname", x, v);
        this.colNames[x] = v;
        return;
      }

      this.cells[y] = this.cells[y] || [];
      this.cells[y][x] = v;
      this._sendChange();
    }

    _sendChange() {
      this.data.cols = this._numCols;
      this.data.cells = this.cells;
      this.data.colNames = this.colNames;
      this.data.colNames.length = this._numCols;
      this._options.onchange(null);
      if (this._options.onchange) this._options.onchange(this.data);
    }

    _onInputChange(e) {
      this._log.log("onchange...", e.target.value);
      const x = e.target.dataset.x;
      const y = e.target.dataset.y;

      this.set(x, y, e.target.value);
      // for (let i = 0; i < this._numCols; i++) this.getColName(i);
    }

    show() {}
  }

  const paramsHelper = {
    valueChangerSetSliderCSS: (v, eleInput) => {
      if (eleInput.dataset.min || eleInput.dataset.max)
        v = CABLES.map(
          v,
          parseFloat(eleInput.dataset.min),
          parseFloat(eleInput.dataset.max),
          0,
          1,
        );

      v = Math.max(0, v);
      v = Math.min(1, v);
      const cssv = v * 100;
      const grad =
        "linear-gradient(0.25turn, var(--numberinput-bar), var(--numberinput-bar) " +
        cssv +
        "%, var(--numberinput-bg) " +
        cssv +
        "%)";

      eleInput.style.background = grad;
    },

    inputListenerMousewheel: (event) => {
      event.preventDefault();
      let delta = -event.deltaY || event.deltaX;
      if (ele.hasFocus(event.target)) {
        if (delta > 0) {
          if (event.shiftKey)
            event.target.value = paramsHelper.inputIncrement(
              event.target.value,
              0.1,
              event,
            );
          else
            event.target.value = paramsHelper.inputIncrement(
              event.target.value,
              1,
              event,
            );
        } else {
          if (event.shiftKey)
            event.target.value = paramsHelper.inputIncrement(
              event.target.value,
              -0.1,
              event,
            );
          else
            event.target.value = paramsHelper.inputIncrement(
              event.target.value,
              -1,
              event,
            );
        }
        event.target.dispatchEvent(new Event("input"));

        return false;
      }
    },

    inputListenerCursorKeys: (e) => {
      e.target.value = e.target.value.replaceAll(",", ".");

      switch (e.which) {
        case 38: // up
          e.target.value = paramsHelper.inputIncrement(e.target.value, 1, e);
          e.target.dispatchEvent(new Event("input"));
          return false;

        case 40: // down
          e.target.value = paramsHelper.inputIncrement(e.target.value, -1, e);
          e.target.dispatchEvent(new Event("input"));
          return false;
      }
    },

    inputIncrement: (v, dir, e) => {
      if (e.target.type == "search") return v;

      Gui$1.gui.savedState.setUnSaved(
        "paramsInputIncrement",
        Gui$1.gui.opParams.op.getSubPatch(),
      );

      if (v == "true") return "false";
      if (v == "false") return "true";

      const val = parseFloat(v);
      if (val != val) return v;

      let add = 0.1;

      if (e.target.classList.contains("inc_int")) add = 1;

      if (e && e.shiftKey && e.metaKey) add = 0.001;
      else if (e && e.altKey && e.shiftKey) add = 10;
      else if (e && e.shiftKey) add = 0.01;
      else if (e && e.altKey) add = 1;

      let r = val + add * dir;

      if (isNaN(r)) r = 0.0;
      else r = Math.round(1000 * r) / 1000;
      return r;
    },

    checkDefaultValue: (port, index, panelid) => {
      if (port.defaultValue !== undefined && port.defaultValue !== null) {
        const resetEl = ele.byQuery("#portTitle_in_" + index + "_reset");
        const titleEl = ele.byId("portTitle_in_" + index);
        const isDefault = port.get() == port.defaultValue || port.isLinked();
        if (titleEl) titleEl.classList.toggle("nonDefaultValue", !isDefault);

        if (resetEl) {
          if (isDefault) {
            resetEl.classList.add("reset_hidden");
            resetEl.removeAttribute("tabindex");
          } else {
            resetEl.classList.remove("reset_hidden");
            resetEl.setAttribute("tabindex", 0);
          }
        }
      }
    },

    togglePortValBool: (which, checkbox) => {
      // Gui.gui.setStateUnsaved();
      Gui$1.gui.savedState.setUnSaved(
        "paramsTogglePortValBool",
        Gui$1.gui.opParams.op.getSubPatch(),
      );
      const inputEle = document.getElementById(which);
      const checkBoxEle = document.getElementById(checkbox);

      if (!inputEle || !checkBoxEle) return;
      let bool_value = inputEle.value == "true";
      bool_value = !bool_value;

      if (bool_value) {
        checkBoxEle.classList.add("checkbox-active");
        checkBoxEle.classList.remove("checkbox-inactive");
      } else {
        checkBoxEle.classList.add("checkbox-inactive");
        checkBoxEle.classList.remove("checkbox-active");
      }

      inputEle.value = bool_value;
      inputEle.dispatchEvent(new Event("input"));
    },

    openParamSpreadSheetEditor: (opid, portname, cb) => {
      const op = Gui$1.gui.corePatch().getOpById(opid);
      if (!op) return console.warn("paramedit op not found");

      const port = op.getPortByName(portname);
      if (!port) return console.warn("paramedit port not found");

      new SpreadSheetTab(Gui$1.gui.mainTabs, port, port.get(), {
        title: Gui$1.gui.mainTabs.getUniqueTitle("Array " + portname),
        onchange: (content) => {
          port.set(content);
          Gui$1.gui.emitEvent("portValueEdited", op, port, content);
        },
      });
    },

    updateLinkedColorBoxes: (thePort, thePort1, thePort2, panelid, idx) => {
      const id = "watchcolorpick_in_" + idx + "_" + panelid;
      const portNum = idx;
      const colEle = ele.byId(id);

      if (colEle && thePort1 && thePort && thePort2) {
        const inputElements = [
          ele.byId("portval_" + portNum + "_" + panelid),
          ele.byId("portval_" + (portNum + 1) + "_" + panelid),
          ele.byId("portval_" + (portNum + 2) + "_" + panelid),
        ];

        if (!inputElements[0] || !inputElements[1] || !inputElements[2]) {
          colEle.style.backgroundColor = chroma(
            Math.round(255 * thePort.get()),
            Math.round(255 * thePort1.get()),
            Math.round(255 * thePort2.get()),
          ).hex();
        }
      }
    },

    setPortAnimated: (op, index, targetState, defaultValue) => {
      const isOpen = Gui$1.gui.patchView.getSelectedOps()[0]
        ? op.id === Gui$1.gui.patchView.getSelectedOps()[0].id
        : false;

      const elVal = ele.byId("portval_" + index);

      if (!targetState) {
        // const val = Gui.gui.timeLine().removeAnim(op.portsIn[index].anim);
        op.portsIn[index].setAnimated(false);

        // Gui.gui.timeLine().setAnim(null);

        if (isOpen && elVal) {
          // elVal.value = val;
          elVal.dispatchEvent(new Event("input"));
          elVal.focus();
        }

        op.portsIn[index].op.refreshParams();
        return;
      }

      const portAnimEle = ele.byId("portanim_in_" + index);
      if (isOpen && portAnimEle) portAnimEle.classList.add("timingbutton_active");

      op.portsIn[index].toggleAnim();
      ({
        opid: op.id,
        name: op.getTitle() + ": " + op.portsIn[index].name});
      // Gui.gui.timeLine().setAnim(op.portsIn[index].anim, animOptions);
      op.portsIn[index].op.refreshParams();
    },

    openParamStringEditor: (opid, portname, cb, userInteraction) => {
      const op = Gui$1.gui.corePatch().getOpById(opid);
      if (!op) return console.warn("paramedit op not found", opid);
      editorSession.startLoadingTab();

      const port = op.getPortByName(portname);
      if (!port) return console.warn("paramedit port not found", portname);

      let name = Gui$1.gui.mainTabs.getUniqueTitle(op.name + " " + port.name);

      const dataId = opid + portname;
      const existingTab = Gui$1.gui.mainTabs.getTabByDataId(dataId);
      if (existingTab) {
        Gui$1.gui.mainTabs.activateTabByName(existingTab.title);
        Gui$1.gui.maintabPanel.show(userInteraction);
        return;
      }

      const editorObj = editorSession.rememberOpenEditor("param", name, {
        opid: opid,
        portname: portname,
      });

      if (editorObj) {
        const t = new EditorTab({
          title: name,
          dataId: dataId,
          content: port.get() + "",
          name: editorObj.name,
          syntax: port.uiAttribs.editorSyntax,
          hideFormatButton: port.uiAttribs.hideFormatButton,
          editorObj: editorObj,
          onClose: function (which) {
            editorSession.remove(which.editorObj.type, which.editorObj.name);
          },
          onSave: function (setStatus, content) {
            setStatus("updated " + port.name);
            // Gui.gui.setStateUnsaved();
            Gui$1.gui.savedState.setUnSaved("saveeditorcontent", op.getSubPatch());
            Gui$1.gui.jobs().finish("saveeditorcontent");
            port.setRef(content);
            Gui$1.gui.emitEvent("portValueEdited", op, port, content);
          },
          onChange: function (e) {
            // Gui.gui.setStateUnsaved();
            Gui$1.gui.savedState.setUnSaved("editorOnChange", op.getSubPatch());
          },
          onFinished: () => {
            Gui$1.gui.mainTabs.activateTabByName(name);
          },
        });

        Gui$1.gui.corePatch().on(CABLES.Patch.EVENT_OP_DELETED, (deletedOp) => {
          if (deletedOp.id == opid) Gui$1.gui.mainTabs.closeTab(t._tab.id);
        });
      } else {
        Gui$1.gui.mainTabs.activateTabByName(name);
      }

      if (cb) cb();
      else Gui$1.gui.maintabPanel.show(userInteraction);

      editorSession.finishLoadingTab();
    },
  };

  /**
   * general settings for the user interface
   *
   * @class
   */
  class UiConfig {
    constructor() {
      this.snapX = 12;
      this.snapY = 20;

      this.idleModeTimeout = 120;

      this.timingPanelHeight = 250;
      this.rendererDefaultWidth = 640;
      this.rendererDefaultHeight = 320;

      this.watchValuesInterval = 50; // 33
      this.rendererSizes = [
        { w: 640, h: 360 },
        { w: 1024, h: 768 },
        { w: 1280, h: 720 },
        { w: 0, h: 0 },
      ];

      this.infoAreaHeight = 29;
    }
  }

  var uiConfig = new UiConfig();

  // shows a curve of the current hovering output number value in op param panel


  class WatchPortVisualizer {
    constructor() {
      this._canvasWidth = 300;
      this._canvasHeight = 120;

      this.created = false;
      this._lastId = "";
      this._visible = false;

      this._num = this._canvasWidth / 2;
      this._buff = [];
      this._buff.length = this._num;

      this._position = 0;
      this._ele = null;

      this._max = -Number.MAX_VALUE;
      this._min = Number.MAX_VALUE;
      this._lastValue = Number.MAX_VALUE;
      this._firstTime = true;

      this._init();
    }

    bind() {
      let els = document.getElementsByClassName("watchPort");
      for (let i = 0; i < els.length; i++) {
        els[i].addEventListener("pointerenter", this._mouseEnter.bind(this));
        els[i].addEventListener("pointerleave", this._mouseLeave.bind(this));
      }
    }

    _mouseLeave(e) {
      this.canvas.style.display = "none";
      this._visible = false;
      this._lastId = "xxx";
    }

    _mouseEnter(e) {
      this._visible = true;
      this._ele = e.target;

      const offset = e.target.getBoundingClientRect();

      if (offset.left == 0 && offset.top == 0) {
        this._visible = false;
        this.canvas.style.display = "none";
      }

      this.canvas.style.left = offset.left + "px";
      this.canvas.style.top = offset.top + 30 + "px";
    }

    _init() {
      this.canvas = document.createElement("canvas");
      this.canvas.id = "watchportpreview";
      this.canvas.width = this._canvasWidth;
      this.canvas.height = this._canvasHeight;
      this.canvas.style.display = "none";
      this.canvas.style.position = "absolute";
      this.canvas.style["z-index"] = 9999999;
      const body = document.getElementsByTagName("body")[0];
      body.appendChild(this.canvas);
      this.ctx = this.canvas.getContext("2d");
      this.update();
    }

    update(classname, id, value) {
      if (!this._visible) return;
      if (!this._ele.classList.contains(classname)) return;
      if (this._lastId != classname) {
        for (let i = 0; i < this._buff.length; i++)
          this._buff[i] = Number.MAX_VALUE;
        this._position = 0;
        this._lastId = classname;

        this._max = -Number.MAX_VALUE;
        this._min = Number.MAX_VALUE;
        this._lastValue = value;
        this._firstTime = true;

        return;
      }

      if (this._firstTime && this._lastValue == value) return;
      this._firstTime = false;

      this.canvas.style.display = "block";

      this._max = Math.max(value, this._max);
      this._min = Math.min(value, this._min);

      this._buff[this._position % this._num] = value;
      this._position++;

      this.ctx.fillStyle = "#111";
      this.ctx.fillRect(0, 0, this._canvasWidth, this._canvasHeight);
      this.ctx.strokeStyle = "#aaa";
      this.ctx.font = "12px monospace";

      const h = Math.max(Math.abs(this._max), Math.abs(this._min));

      let first = true;

      this.ctx.strokeStyle = "#666";
      this.ctx.lineWidth = 1;

      this.ctx.beginPath();

      this.ctx.moveTo(0, this._canvasHeight / 2);
      this.ctx.lineTo(this._canvasWidth, this._canvasHeight / 2);
      this.ctx.stroke();

      this.ctx.strokeStyle = uiConfig.highlight;
      this.ctx.beginPath();

      this.ctx.lineWidth = 2;
      for (let i = 0; i < this._num; i++) {
        const v = this._buff[(this._position + i) % this._num];
        if (this._buff[(this._position + i) % this._num] != Number.MAX_VALUE) {
          const pos =
            this.canvas.height -
            ((((v / h) * this.canvas.height) / 2) * 0.9 + this.canvas.height / 2);

          if (first) {
            this.ctx.moveTo(0, pos);
            first = false;
          }

          this.ctx.lineTo(i * 2, pos);
        }
      }
      this.ctx.stroke();

      this.ctx.fillStyle = "#666";
      this.ctx.fillText(
        "max:" + Math.round(this._max * 100) / 100,
        10,
        this.canvas.height - 10,
      );
      this.ctx.fillText(
        "min:" + Math.round(this._min * 100) / 100,
        10,
        this.canvas.height - 30,
      );
    }
  }

  let pointerLockFirstTime = true;

  /**
   * mouse and keyboard interactions with port parameters
   */
  function valueChanger(eleId, focus, portName, opid) {
    Gui$1.gui.showInfo(text.valueChangerInput);

    const eleInput = ele.byId(eleId);
    const eleContainer = ele.byId(eleId + "-container");
    const eleNumInputDisplay = document.querySelector(
      "#" + eleId + "-container .numberinput-display",
    );

    const theOp = Gui$1.gui.corePatch().getOpById(opid);
    if (!theOp) return;

    const thePort = theOp.getPort(portName);
    const startVal = eleInputValue();
    let incMode = 0;
    let mouseDownTime = 0;

    let usePointerLock = true;

    if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent))
      usePointerLock = false;

    document.addEventListener("pointerup", up);
    document.addEventListener("pointerdown", down);
    eleInput.addEventListener("focusout", blur);

    if (focus) {
      setTextEdit(true);
      eleInput.addEventListener("keydown", paramsHelper.inputListenerCursorKeys);
      // elem.keydown(paramsHelper.inputListenerCursorKeys);
    }

    function setTextEdit(enabled) {
      ele.forEachClass("numberinput", (elm) => {
        elm.classList.remove("numberinputFocussed");
      });

      if (enabled) {
        if (eleContainer.classList.contains("valuesliderinput"))
          eleInput.addEventListener("input", () => {
            paramsHelper.valueChangerSetSliderCSS(eleInput.value, eleContainer);
          });
        ele.hide(eleNumInputDisplay);

        eleContainer.classList.add("numberinputFocussed");
        ele.show(eleInput);
        eleInput.focus();

        const vv = eleInput.value;
        eleInput.setSelectionRange(0, vv.length);
      } else {
        if (eleContainer.classList.contains("valuesliderinput"))
          eleInput.addEventListener("input", () => {
            paramsHelper.valueChangerSetSliderCSS(eleInput.value, eleContainer);
          });

        ele.show(eleNumInputDisplay);
        ele.hide(eleInput);
        eleInput.blur();

        document.removeEventListener("pointerup", up);
        document.removeEventListener("pointerdown", down);
      }
    }

    function down(e) {
      if (ele.hasFocus(eleInput)) return;

      eleInput.removeEventListener("wheel", paramsHelper.inputListenerMousewheel);
      eleInput.addEventListener("wheel", paramsHelper.inputListenerMousewheel);
      eleInput.addEventListener("keydown", paramsHelper.inputListenerCursorKeys);
      mouseDownTime = performance.now();

      if (usePointerLock) {
        document.addEventListener("pointerlockerror", lockError);
        document.addEventListener("pointerlockchange", lockChange);
        document.addEventListener("mozpointerlockchange", lockChange);
        document.addEventListener("webkitpointerlockchange", lockChange);

        if (eleInput.classList.contains("inc_int")) incMode = 1;

        eleInput.requestPointerLock =
          eleInput.requestPointerLock ||
          eleInput.mozRequestPointerLock ||
          eleInput.webkitRequestPointerLock;
        if (eleInput.requestPointerLock) eleInput.requestPointerLock();
      } else {
        document.addEventListener("pointermove", move);
      }

      CABLES.mouseDraggingValue = true;
    }

    function up(e) {
      if (ele.hasFocus(eleInput)) return;

      CABLES.mouseDraggingValue = false;

      if (opid && portName) {
        ((function (_portName, opId, oldVal, newVal) {
          if (oldVal != newVal)
            undo.add({
              title: "Value mousedrag " + oldVal + " to " + newVal,
              undo() {
                const op = Gui$1.gui.corePatch().getOpById(opid);
                const p = op.getPort(_portName);
                Gui$1.gui.patchView.showDefaultPanel();

                p.set(oldVal);
                Gui$1.gui.opParams.show(op);
                Gui$1.gui.patchView.focusOp(null);
                Gui$1.gui.patchView.focusOp(op.id);
                Gui$1.gui.patchView.centerSelectOp(op.id);
              },
              redo() {
                const op = Gui$1.gui.corePatch().getOpById(opid);
                const p = op.getPort(_portName);
                Gui$1.gui.patchView.showDefaultPanel();

                p.set(newVal);
                Gui$1.gui.opParams.show(op);
                Gui$1.gui.patchView.focusOp(null);
                Gui$1.gui.patchView.focusOp(op.id);
                Gui$1.gui.patchView.centerSelectOp(op.id);
              },
            });
        }))(portName, opid, parseFloat(startVal), parseFloat(eleInput.value));
      }

      // Gui.gui.setStateUnsaved();
      Gui$1.gui.savedState.setUnSaved("valuechangerUp", thePort.op.getSubPatch());

      if (usePointerLock) {
        document.removeEventListener("pointerlockerror", lockError, false);
        document.removeEventListener("pointerlockchange", lockChange, false);
        document.removeEventListener("mozpointerlockchange", lockChange, false);
        document.removeEventListener(
          "webkitpointerlockchange",
          lockChange,
          false,
        );

        if (document.exitPointerLock) document.exitPointerLock();
      }

      document.removeEventListener("pointerup", up);
      document.removeEventListener("pointerdown", down);
      document.removeEventListener("pointermove", move, false);
      if (performance.now() - mouseDownTime < 200) setTextEdit(true);
    }

    function setProgress(v) {
      paramsHelper.valueChangerSetSliderCSS(eleInput.value, eleContainer);
      return v;
    }

    function eleInputValue() {
      eleInput.value = eleInput.value.replaceAll(",", ".");

      let str = eleInput.value;
      let v = parseFloat(str);
      if (v != v) v = 0;

      return v;
    }

    function move(e) {
      if (pointerLockFirstTime) {
        pointerLockFirstTime = false;
        return;
      }

      if (ele.hasFocus(eleInput)) return;

      // Gui.gui.setStateUnsaved();
      Gui$1.gui.savedState.setUnSaved("valuechangerMove", thePort.op.getSubPatch());
      let v = eleInputValue();
      let inc = 0;

      if (thePort.uiAttribs.min != undefined)
        v = CABLES.map(v, thePort.uiAttribs.min, thePort.uiAttribs.max, 0, 1);

      if (Math.abs(e.movementX) > 5) mouseDownTime = 0;

      if (eleContainer.classList.contains("valuesliderinput")) {
        inc = e.movementX * 0.001;
        v += inc;
        v = Math.max(0, v);
        v = Math.min(1, v);
        v = Math.round(v * 1000) / 1000;
        v = setProgress(v);
      } else if (incMode == 0) {
        inc = e.movementX * 0.01;
        if (e.shiftKey || e.which == 3) inc = e.movementX * 0.5;

        v += inc;
        v = Math.round(v * 1000) / 1000;
      } else {
        inc = e.movementX * 1;
        if (e.shiftKey || e.which == 3) inc = e.movementX * 5;

        v += inc;
        v = Math.floor(v);
      }

      if (thePort.uiAttribs.min != undefined)
        v = CABLES.map(v, 0, 1, thePort.uiAttribs.min, thePort.uiAttribs.max);

      eleInput.value = v;
      eleNumInputDisplay.innerHTML = v;

      eleInput.dispatchEvent(new Event("input"));
    }

    function lockError(e) {
      // console.log("pointer lock error...", e);
    }

    function lockChange(e) {
      if (
        document.pointerLockElement === eleInput ||
        document.mozPointerLockElement === eleInput ||
        document.webkitPointerLockElement === eleInput
      ) {
        pointerLockFirstTime = true;
        document.addEventListener("pointermove", move);
      } else {
        // propably cancled by escape key / reset value
        eleInput.value = startVal;
        eleNumInputDisplay.innerHTML = startVal;
        eleInput.dispatchEvent(new Event("input"));
        up();
      }
    }

    function blur(e) {
      // value changed after blur
      if (startVal != eleInputValue()) {
        if (opid && portName) {
          if (isNaN(eleInput.value)) {
            const op = Gui$1.gui.corePatch().getOpById(opid);
            const p = op.getPort(portName);

            let mathParsed = eleInput.value;

            mathParsed = mathParsed.replaceAll(",", ".");

            try {
              mathParsed = CABLES.UI.mathparser.parse(eleInput.value);
            } catch (ex) {
              // failed to parse math, use unparsed value
              mathParsed = eleInputValue();
            }
            eleInput.value = mathParsed;

            p.set(mathParsed);
            hideToolTip();
          }
        }
      }

      hideToolTip();
      eleInput.removeEventListener("focusout", blur);
      eleNumInputDisplay.innerHTML = eleInput.value;
      setTextEdit(false);

      if (eleInput.classList.contains("valuesliderinput")) setProgress();
    }
  }

  /**
   *listen to user interactions with ports in {@link OpParampanel}
   *
   * @class ParamsListener
   * @extends {Events}
   */
  class ParamsListener extends Events {
    constructor(panelid) {
      super();

      this._log = new Logger("Paramslistener");
      this.panelId = panelid;

      this._watchPorts = [];
      this._watchAnimPorts = [];
      this._watchColorPicker = [];
      this._watchStrings = [];
      this._portsIn = [];
      this._portsOut = [];
      this._doFormatNumbers = !(
        UserSettings.userSettings.get("notlocalizeNumberformat") || false
      );
      this._watchPortVisualizer = new WatchPortVisualizer();

      this._updateWatchPorts();
    }

    init(options) {
      this.removePorts();

      if (options.op) {
        this._portsIn = options.op.portsIn;
        this._portsOut = options.op.portsOut;
      } else {
        this._portsIn = options.portsIn || [];
        this._portsOut = options.portsOut || [];
      }

      if (options.element) {
        ele.clickables(options.element, ".clickable", (e, data) => {
          switch (data.click) {
            case "centerSelectOp":
              Gui$1.gui.patchView.centerSelectOp(data.op);
              Gui$1.gui.opParams.show(data.op);
              break;

            case "showAnim":
              Gui$1.gui.toggleTimeline();
              break;

            case "resetOpValues":
              Gui$1.gui.patchView.resetOpValues(data.opid, data.portname);
              break;

            case "addOpAndLink":
              Gui$1.gui.patchView.addOpAndLink(
                CABLES.UI.DEFAULTOPNAMES.defaultOpImage,
                data.opid,
                data.portname,
              );
              break;
          }
        });
      }

      if (this._portsIn.length > 0) {
        for (let i = 0; i < this._portsIn.length; i++) {
          if (this._portsIn[i].getType() == portType.string)
            this._watchStrings.push(this._portsIn[i]);
          if (this._portsIn[i].uiAttribs.colorPick)
            this._watchColorPicker.push(this._portsIn[i]);
          if (this._portsIn[i].isLinked() || this._portsIn[i].isAnimated())
            this._watchPorts.push(this._portsIn[i]);
          this._watchAnimPorts.push(this._portsIn[i]);
        }
      }

      if (this._portsOut.length > 0) {
        for (const i in this._portsOut) {
          if (
            this._portsOut[i].getType() == portType.number ||
            this._portsOut[i].getType() == portType.array ||
            this._portsOut[i].getType() == portType.string ||
            this._portsOut[i].getType() == portType.object
          )
            this._watchPorts.push(this._portsOut[i]);
        }
      }

      for (let i = 0; i < this._portsIn.length; i++)
        this.initPortClickListener(this._portsIn, i, this.panelId, "in");
      for (let i = 0; i < this._portsOut.length; i++)
        this.initPortClickListener(this._portsOut, i, this.panelId, "out");

      for (let i = 0; i < this._portsIn.length; i++) {
        ((index) => {
          const elm = ele.byId("portdelete_in_" + index);
          // if (elm)ele.clickable(elm, () =>
          if (elm)
            elm.addEventListener("click", (e) => {
              this._portsIn[index].removeLinks();
              Gui$1.gui.opParams.show(this._portsIn[index].op);
            });
        })(i);
      }

      for (let i = 0; i < this._portsIn.length; i++)
        this.initPortInputListener(this._portsIn, i, this.panelId);

      function addListenersMultiport(port) {
        const elToggle = ele.byId(
          "multiport_toggleauto_" + port.op.id + "_" + port.name,
        );
        if (elToggle)
          elToggle.addEventListener("click", () => {
            port.toggleManual();
          });
        else this._log.log("cant find multiport");

        const elInc = ele.byId("multiport_inc_" + port.op.id + "_" + port.name);
        if (elInc)
          elInc.addEventListener("click", () => {
            port.incDec(1);
          });

        const elDec = ele.byId("multiport_dec_" + port.op.id + "_" + port.name);
        if (elDec)
          elDec.addEventListener("click", () => {
            port.incDec(-1);
          });
      }

      for (let i = 0; i < this._portsIn.length; i++)
        if (this._portsIn[i].uiAttribs.multiPort)
          addListenersMultiport(this._portsIn[i]);

      for (let i = 0; i < this._portsOut.length; i++)
        if (this._portsOut[i].uiAttribs.multiPort)
          addListenersMultiport(this._portsOut[i]);

      // watch anim ports... this should be in initPOrtInputListener !!
      for (const iwap in this._watchAnimPorts) {
        const thePort = this._watchAnimPorts[iwap];
        (function (_thePort, panelid) {
          const id = "watchPortValue_" + _thePort.watchId + "_" + panelid;
          const elm = ele.byClass(id);
          if (elm)
            elm.addEventListener("focus", () => {
              if (_thePort.isAnimated()) ;
            });
        })(thePort, this.panelId);
      }

      for (const iwcp in this._watchColorPicker) {
        const thePort2 = this._watchColorPicker[iwcp];
        const idx = this._portsIn.indexOf(thePort2);
        this.watchColorPickerPort(thePort2, this.panelId, idx);
      }

      this.valueChangerInitSliders();

      this._watchPortVisualizer.bind();
    }

    valueChangerInitSliders() {
      const els = document.querySelectorAll(".valuesliderinput input");
      for (let i = 0; i < els.length; i++) {
        const v = els[i].value;
        paramsHelper.valueChangerSetSliderCSS(v, els[i].parentElement);
      }
    }

    emitChangeEvent(port) {
      Gui$1.gui.emitEvent("paramsChangedUserInteraction", {
        port: port,
        panelId: this.panelId,
      });
    }

    /*
     * togglePortValBool(which, checkbox)
     * {
     *     this._log.log("HJSAHJKLSHJKLS");
     *     // Gui.gui.setStateUnsaved();
     *     Gui.gui.savedState.setUnSaved("togglePortValBool");
     */

    /*
     *     const inputEle = document.getElementById(which);
     *     const checkBoxEle = document.getElementById(checkbox);
     */

    /*
     *     let bool_value = inputEle.value == "true";
     *     bool_value = !bool_value;
     */

    /*
     *     checkBoxEle.opElement.classList.remove("checkbox-inactive");
     *     checkBoxEle.opElement.classList.remove("checkbox-active");
     */

    /*
     *     if (bool_value) checkBoxEle.opElement.classList.add("checkbox-active");
     *     else checkBoxEle.opElement.classList.add("checkbox-inactive");
     */

    /*
     *     inputEle.value = bool_value;
     *     inputEle.dispatchEvent(new Event("input"));
     * }
     */

    watchColorPickerPort(thePort, panelid, idx) {
      let foundOpacity = false;
      const inputElements = [
        ele.byId("portval_" + idx + "_" + panelid),
        ele.byId("portval_" + (idx + 1) + "_" + panelid),
        ele.byId("portval_" + (idx + 2) + "_" + panelid),
      ];
      const eleA = ele.byId("portval_" + (idx + 3) + "_" + panelid);
      if (
        eleA &&
        eleA.dataset.portname &&
        eleA.dataset.portname.toLowerCase() == "a"
      ) {
        inputElements.push(ele.byId("portval_" + (idx + 3) + "_" + panelid));
        foundOpacity = true;
      }

      if (!inputElements[0] || !inputElements[1] || !inputElements[2]) {
        // this._log.log("NOPEY", "portval_" + idx + "_" + panelid, ele.byId("portval_" + idx + "_" + panelid));
        return;
      }

      const getCurrentColor = () => {
        const arr = [
          Math.round(255 * parseFloat(inputElements[0].value)),
          Math.round(255 * parseFloat(inputElements[1].value)),
          Math.round(255 * parseFloat(inputElements[2].value)),
        ];

        // if (inputElements[3])arr.push(inputElements[3].value);
        return arr;
      };

      const id = "watchcolorpick_in_" + idx + "_" + panelid;
      const colEle = ele.byId(id);

      if (!colEle) {
        this._log.log("color ele not found!", id);
        return;
      }

      const updateColorBox = () => {
        colEle.style.backgroundColor = chroma(getCurrentColor()).hex();
      };

      inputElements[0].addEventListener("input", updateColorBox);
      inputElements[1].addEventListener("input", updateColorBox);
      inputElements[2].addEventListener("input", updateColorBox);

      updateColorBox();

      ele.clickable(colEle, (e) =>
        // colEle.addEventListener("click", (e) =>
        {
          let undoGroup;
          let opacity = 1;
          if (inputElements[3]) opacity = inputElements[3].value;

          new ColorRick({
            ele: colEle,
            showOpacity: foundOpacity,
            color: getCurrentColor(), // "#ffffff",
            opacity: opacity,
            onChange: (col, _opacity) => {
              updateColorBox();
              const glRgb = col.gl();

              const elR = ele.byId(
                "numberinputDisplay_in_" + idx + "_" + panelid,
              );
              const elG = ele.byId(
                "numberinputDisplay_in_" + (idx + 1) + "_" + panelid,
              );
              const elB = ele.byId(
                "numberinputDisplay_in_" + (idx + 2) + "_" + panelid,
              );
              const elA = ele.byId(
                "numberinputDisplay_in_" + (idx + 3) + "_" + panelid,
              );

              if (elR) elR.innerHTML = inputElements[0].value = glRgb[0];
              if (elG) elG.innerHTML = inputElements[1].value = glRgb[1];
              if (elB) elB.innerHTML = inputElements[2].value = glRgb[2];
              if (elA && inputElements[3])
                elA.innerHTML = inputElements[3].value = _opacity;

              inputElements[0].dispatchEvent(
                new CustomEvent("input", { detail: { ignorePaco: true } }),
              );
              inputElements[1].dispatchEvent(
                new CustomEvent("input", { detail: { ignorePaco: true } }),
              );
              inputElements[2].dispatchEvent(
                new CustomEvent("input", { detail: { ignorePaco: true } }),
              );
              if (inputElements[3])
                inputElements[3].dispatchEvent(
                  new CustomEvent("input", { detail: { ignorePaco: true } }),
                );
            },
            onStart: () => {
              undoGroup = undo.startGroup();
            },
            onEnd: () => {
              inputElements[0].dispatchEvent(new Event("input"));
              inputElements[1].dispatchEvent(new Event("input"));
              inputElements[2].dispatchEvent(new Event("input"));
              undo.endGroup(undoGroup, "Change Color");
            },
          });
        },
      );
    }

    initPortClickListener(ports, index, panelid, dirStr) {
      const thePort = ports[index];

      if (ele.byId("portTitle_" + dirStr + "_" + index))
        ele
          .byId("portTitle_" + dirStr + "_" + index)
          .addEventListener("click", function (e) {
            const p = ports[index];
            if (!p.uiAttribs.hidePort)
              Gui$1.gui.opSelect().show(
                {
                  x:
                    p.op.uiAttribs.translate.x +
                    index * (gluiconfig.portWidth + gluiconfig.portPadding),
                  y: p.op.uiAttribs.translate.y - 50,
                },
                thePort.op,
                p,
              );
          });

      if (ele.byId("portCreateOp_" + dirStr + "_" + index))
        ele
          .byId("portCreateOp_" + dirStr + "_" + index)
          .addEventListener("click", function (e) {
            if (thePort.objType && thePort.objType.indexOf("sg_")) {
              gui
                .corePatch()
                .addOp("Ops.Team.ShaderGraph.Input", {}, function (newop) {
                  gui
                    .corePatch()
                    .link(
                      thePort.op,
                      thePort.name,
                      newop,
                      newop.getFirstOutPortByType(thePort.type).name,
                    );
                });
            }
            if (thePort.type == portType.object) {
              gui
                .corePatch()
                .addOp(
                  defaultOps.defaultOpNames.defaultOpImage,
                  {},
                  function (newop) {
                    gui
                      .corePatch()
                      .link(
                        thePort.op,
                        thePort.name,
                        newop,
                        newop.getFirstOutPortByType(thePort.type).name,
                      );
                  },
                );
            }
          });

      if (ele.byId("portspreadsheet_" + dirStr + "_" + index + "_" + panelid))
        ele
          .byId("portspreadsheet_" + dirStr + "_" + index + "_" + panelid)
          .addEventListener("click", function (e) {
            paramsHelper.openParamSpreadSheetEditor(thePort.op.id, thePort.name);
          });

      // /////////////////////
      //
      // input text editor tab
      //
      let el = ele.byId("portedit_" + dirStr + "_" + index + "_" + panelid);
      if (el)
        el.addEventListener("click", () => {
          paramsHelper.openParamStringEditor(
            thePort.op.id,
            thePort.name,
            null,
            true,
          );
        });

      // /////////////////////
      //
      // input button click!!!!
      //
      el = ele.byId("portbutton_" + index + "_" + panelid);
      if (el)
        el.addEventListener("click", (e) => {
          thePort._onTriggered();
        });

      if (ports[index].uiAttribs.display === "buttons") {
        for (let i = 0; i < ports[index].value.length; i++) {
          let eli = ele.byId("portbutton_" + index + "_" + panelid + "_" + i);
          if (eli)
            eli.addEventListener("click", (e) => {
              const name = e.target.dataset.title;
              ports[index]._onTriggered(name);
            });
        }
      }

      //

      /*
       * el = ele.byId("portgraph_" + dirStr + "_" + index);
       * if (el)el.addEventListener("click", function (e)
       * {
       *     if (ports[index].isAnimated())
       *     {
       *         ports[index].anim.stayInTimeline = !ports[index].anim.stayInTimeline;
       */

      /*
       *         Gui.gui.timeLine().setAnim(ports[index].anim, {
       *             "name": op.getTitle() + ": " + ports[index].name,
       *             "opid": op.id,
       *             "defaultValue": parseFloat(ele.byId("portval_" + index).value)
       *         });
       *     }
       * });
       */

      el = ele.byId("portsetvar_" + index);
      if (el)
        el.addEventListener("input", (e) => {
          const port = ports[index].op.getPortById(e.target.dataset.portid);

          if (port) port.setVariable(e.target.value);
          else
            this._log.warn(
              "[portsetvar] PORT NOT FOUND!! ",
              e.target.dataset.portid,
              e,
            );

          // Gui.gui.setStateUnsaved();
          Gui$1.gui.savedState.setUnSaved(
            "initPortClickListener",
            port.op.getSubPatch(),
          );
        });

      /*
       * el = ele.byId("portremovevar_" + index);
       * if (el)el.addEventListener("click", (e) =>
       * {
       *     const port = ports[index].op.getPortById(e.target.dataset.portid);
       *     if (port) port.setVariable(null);
       *     port.op.refreshParams();
       *     Gui.gui.setStateUnsaved();
       * });
       */

      el = ele.byId("port_contextmenu_" + dirStr + "_" + index + "_" + panelid);
      // if (el) el.addEventListener("click", (e) =>
      if (el)
        ele.clickable(el, (e) => {
          const port = thePort; // ports[index].op.getPortById(e.target.dataset.portid);
          if (!thePort) return;

          let items = [];

          if (!port.uiAttribs.display || port.uiAttribs.display != "readonly") {
            if (port.type == portType.string)
              items.push({
                title: "Create String Op",
                func: () => {
                  Gui$1.gui.savedState.setUnSaved(
                    "initPortClickListener",
                    port.op.getSubPatch(),
                  );
                  const oldValue = port.get();

                  Gui$1.gui.patchView.addOpAndLink(
                    defaultOps.defaultOpNames.string,
                    port.op.id,
                    port.name,
                    (op) => {
                      op.getPort("value").set(oldValue);
                      op.setTitle(port.getName());

                      gui
                        .corePatch()
                        .link(
                          port.op,
                          port.name,
                          op,
                          op.getFirstOutPortByType(port.type).name,
                        );
                      op.refreshParams();
                    },
                  );
                },
              });

            if (port.type == portType.number)
              items.push({
                title: "Create Number Op",
                func: () => {
                  Gui$1.gui.savedState.setUnSaved(
                    "initPortClickListener",
                    port.op.getSubPatch(),
                  );
                  const oldValue = port.get();

                  Gui$1.gui.patchView.addOpAndLink(
                    defaultOps.defaultOpNames.number,
                    port.op.id,
                    port.name,
                    (op) => {
                      op.getPort("value").set(oldValue);
                      op.setTitle(port.getName());

                      gui
                        .corePatch()
                        .link(
                          port.op,
                          port.name,
                          op,
                          op.getFirstOutPortByType(port.type).name,
                        );
                      op.refreshParams();
                    },
                  );
                },
              });

            if (
              port.type != portType.trigger &&
              !port.uiAttribs.expose &&
              dirStr == "in" &&
              !port.isAnimated()
            ) {
              const item = {
                title: "Assign variable",
                func: () => {
                  // Gui.gui.setStateUnsaved();
                  Gui$1.gui.savedState.setUnSaved(
                    "initPortClickListener",
                    port.op.getSubPatch(),
                  );

                  if (port.isBoundToVar()) port.setVariable(null);
                  else port.setVariable("unknown");

                  port.op.refreshParams();
                },
              };

              if (port.isBoundToVar()) {
                item.title = "Remove variable assignment";
                item.iconClass = "icon icon-x";
              }

              items.push(item);
            }
          }

          if (
            port.type == portType.number &&
            !port.uiAttribs.expose &&
            !port.isBoundToVar() &&
            dirStr == "in"
          ) {
            let title = "Animate Parameter";
            let icon = "";
            if (thePort.isAnimated()) {
              title = "Remove Animation";
              icon = "icon icon-x";
            }
            items.push({
              title: title,
              iconClass: icon,
              func: () => {
                // Gui.gui.setStateUnsaved();
                Gui$1.gui.savedState.setUnSaved(
                  "setPortAnimated",
                  port.op.getSubPatch(),
                );

                paramsHelper.setPortAnimated(
                  thePort.op,
                  index,
                  !thePort.isAnimated(),
                  thePort.get(),
                );
              },
            });
          }

          if (port.type == portType.string || port.type == portType.number) {
            if (port.op.uiAttribs.extendTitlePort == port.name)
              items.push({
                title: "Remove extended title",
                iconClass: "icon icon-x",
                func: () => {
                  port.op.setUiAttrib({ extendTitlePort: null });
                },
              });
            else
              items.push({
                title: 'Extend title: "' + port.getTitle() + ': x"',
                func: () => {
                  port.op.setUiAttrib({ extendTitlePort: port.name });
                },
              });
          }

          // this._log.log("port.op.uiAttribs",);

          if (
            port.op.isInBlueprint2() &&
            port.op.objName.indexOf("Ops.Ui.") == -1
          ) {
            items.push({
              title: "Subpatch Op: Create Port",
              iconClass: "",
              func: () => {
                const subOuter = Gui$1.gui.patchView.getSubPatchOuterOp(
                  port.op.isInBlueprint2(),
                );

                // this._log.log("isSavedSubOp", Gui.gui.savedState.isSavedSubPatch(port.op.uiAttribs.subPatch));
                if (
                  !Gui$1.gui.savedState.isSavedSubPatch(port.op.uiAttribs.subPatch)
                ) {
                  new ModalDialog({
                    showOkButton: true,
                    title: "Can't create port",
                    text: "You need to save the subPatch before creating a port!",
                  });
                  return;
                }

                Gui$1.gui.patchView.unselectAllOps();

                subPatchOpUtil.addPortToBlueprint(subOuter.opId, port);
              },
            });
          }

          /*
           * else
           * if (
           *     (Gui.gui.patchView.getCurrentSubPatch() != 0 || Gui.gui.patchView.getCurrentSubPatch() != port.op.uiAttribs.subPatch) &&
           *     !port.isAnimated())
           * {
           *     let title = "Subpatch Expose Port ";
           *     let icon = "";
           *     if (port.uiAttribs.expose)
           *     {
           *         title = "Subpatch Remove Exposed Port";
           *         icon = "icon icon-x";
           *     }
           */

          /*
           *     items.push(
           *         {
           *             "title": title,
           *             "iconClass": icon,
           *             "func": () =>
           *             {
           *                 const subOp = Gui.gui.patchView.getSubPatchOuterOp(port.op.uiAttribs.subPatch);
           */

          /*
           *                 if (!subOp)
           *                 { this._log.error("could not find subpatchop!!!!!!!", port.op.uiAttribs.subPatch); }
           */

          //                 port.removeLinks();

          /*
           *                 subOp.removePort(port);
           *                 port.setUiAttribs({ "expose": !port.uiAttribs.expose });
           *                 port.op.refreshParams();
           */

          /*
           *                 Gui.gui.savedState.setUnSaved("Subpatch Expose Port", port.op.uiAttribs.subPatch);
           *             }
           *         });
           * }
           */

          if (port.uiAttribs.expose) ;

          let strEditTitle = "Edit title";
          let icon = "";
          if (port.uiAttribs.title) {
            strEditTitle = "Remove Custom title";
            icon = "icon icon-x";
          }
          items.push({
            title: strEditTitle,
            iconClass: icon,
            func: () => {
              if (port.uiAttribs.title) {
                port.setUiAttribs({ title: null });
                Gui$1.gui.opParams.show(port.op.id);
              } else
                Gui$1.gui.patchView.setPortTitle(port.op.id, port.name, port.title);
            },
          });

          contextMenu.show({ items: items }, e.target);
        });
      else
        this._log.log(
          "contextmenu ele not found...",
          dirStr + "_" + panelid + "_" + index,
        );
    }

    /**
     * @param {any} op
     * @param {any} index
     * @param {any} panelid
     * @param {any} targetState
     * @param {any} defaultValue
     */
    setPortAnimated(op, index, panelid, targetState, defaultValue) {
      const isOpen = Gui$1.gui.patchView.getSelectedOps()[0]
        ? op.id === Gui$1.gui.patchView.getSelectedOps()[0].id
        : false;

      const elVal = ele.byId("portval_" + index + "_" + panelid);

      if (!targetState) {
        // const val = Gui.gui.timeLine().removeAnim(op.portsIn[index].anim);
        op.portsIn[index].setAnimated(false);

        // Gui.gui.timeLine().setAnim(null);

        if (isOpen && elVal) {
          // elVal.value = val;
          elVal.dispatchEvent(new Event("input"));
          elVal.focus();
        }

        op.portsIn[index].op.refreshParams();
        return;
      }

      const portAnimEle = ele.byId("portanim_in_" + index);
      if (isOpen && portAnimEle) portAnimEle.classList.add("timingbutton_active");

      op.portsIn[index].toggleAnim();
      ({
        opid: op.id,
        name: op.getTitle() + ": " + op.portsIn[index].name});
      // Gui.gui.timeLine().setAnim(op.portsIn[index].anim, animOptions);
      op.portsIn[index].op.refreshParams();
    }

    initPortInputListener(ports, index, panelid) {
      if (!CABLES.UI.mathparser) CABLES.UI.mathparser = new MathParser();
      paramsHelper.checkDefaultValue(ports[index], index, panelid);

      // added missing math constants
      CABLES.UI.mathparser.add("pi", function (n, m) {
        return Math.PI;
      });

      const eleId = "portval_" + index + "_" + panelid;

      if (ports[index].uiAttribs.display == "bool") {
        const el = ele.byId("portcheckbox_" + index + "_" + panelid);
        if (el) {
          ele.clickable(el, () => {
            CABLES.UI.paramsHelper.togglePortValBool(
              "portval_" + index + "_" + panelid,
              "portcheckbox_" + index + "_" + panelid,
            );
          });
        }
      } else if (ports[index].uiAttribs.display == "switch") {
        const el = ele.byId("portSwitch_" + index + "_" + panelid);
        if (el) {
          const labels = ele.byQueryAll(
            "#portSwitch_" + index + "_" + panelid + " label",
          );

          for (let j = 0; j < labels.length; j++) {
            const l = labels[j];
            ele.clickable(l, (e) => {
              const labelInput = ele.byQuery(
                "#portSwitch_" + index + "_" + panelid + " #" + l.id + " input",
              );

              ele.byId("portval_" + index + "_" + panelid).value =
                labelInput.value;
              ele
                .byId("portval_" + index + "_" + panelid)
                .dispatchEvent(new Event("input"));

              setTimeout(() => {
                l.focus();
              }, 200);
            });
          }
        }
      } else {
        // id = "portval_{{ portnum }}_{{ panelid }}-container";
        const id = "portval_" + index + "_" + panelid + "-container";
        const el = ele.byId(id);

        // input element container div -> focus real input element
        if (el) {
          let theId = "portval_" + index + "_" + panelid;
          let portName = ports[index].name;
          let opId = ports[index].op.id;

          const cb = (e, keyboard) => {
            valueChanger(theId, keyboard, portName, opId);
            ele.byId(theId).focus();

            /*
             * this._log.log("valuechanger", theId, portName, opId);
             * new ParamTabInputListener(el);
             */
          };

          let isMouse = false;

          el.addEventListener(
            "pointerdown",
            (e) => {
              cb(e, false);
            },
            false,
          ); // does only work with mousedown, not with click or keydown................
          el.addEventListener("pointerenter", () => {
            isMouse = true;
          });
          el.addEventListener("pointerleave", () => {
            isMouse = false;
          });
          el.addEventListener("focus", (e) => {
            if (isMouse) return;
            el.removeAttribute("tabindex");
            cb(e, true);

            ele.byId(theId).addEventListener("blur", () => {
              el.setAttribute("tabindex", 0);
            });
          });

          /*
           * el.addEventListener("keydown", (e) =>
           * {
           *     if (e.keyCode == 13 || e.keyCode == 32)
           *     {
           *         cb(e, true);
           *     }
           * }); // why u no work
           */
        }
      }

      if (ports[index].uiAttribs.type == "string") {
        const str = String(ports[index].get()) || "";

        if (
          str.indexOf("\u2028") > -1 ||
          str.indexOf("\u2029") > -1 ||
          str.indexOf("\u00A0") > -1
        )
          ports[index].op.setUiError(
            "utf8illegal" + ports[index].name,
            "Port " +
              ports[index].name +
              ": String contains unusual UTF8 characters",
            1,
          );
        else ports[index].op.setUiError("utf8illegal" + ports[index].name, null);
      }
      const el = ele.byId(eleId);
      if (
        !ports[index].uiAttribs.type ||
        ports[index].uiAttribs.type == "number" ||
        ports[index].uiAttribs.type == "int"
      ) {
        if (el)
          el.addEventListener("keypress", (e) => {
            const keyCode = e.keyCode || e.which;
            if (keyCode == 13 || keyCode == 8) {
              if (isNaN(e.target.value)) {
                let mathParsed = e.target.value;
                try {
                  mathParsed = CABLES.UI.mathparser.parse(e.target.value);
                } catch (ex) {
                  // failed to parse math, use unparsed value
                  mathParsed = e.target.value || 0;
                }
                e.target.value = mathParsed;

                ports[index].set(mathParsed);
                hideToolTip();
              }
            }
          });
      }

      if (el)
        el.addEventListener(
          "input",

          (e) => {
            let v = "" + el.value;

            Gui$1.gui.savedState.setUnSaved(
              "paramsInput",
              ports[index].op.getSubPatch(),
            );

            if (
              ports[index].uiAttribs.display != "bool" &&
              (!ports[index].uiAttribs.type ||
                ports[index].uiAttribs.type == "number")
            ) {
              if (v.length >= 3 && (isNaN(v) || v === "")) {
                let mathParsed = v;
                try {
                  mathParsed = CABLES.UI.mathparser.parse(v);
                } catch (ex) {
                  // failed to parse math, use unparsed value
                  mathParsed = v;
                }
                if (!isNaN(mathParsed)) {
                  showToolTip(e.target, " = " + mathParsed);
                  el.classList.remove("invalid");
                } else {
                  el.classList.add("invalid");
                  // this._log.log("invalid number", ports[index], mathParsed);
                }
                return;
              } else {
                el.classList.remove("invalid");
                v = parseFloat(v) || 0;
              }
            }

            if (ports[index].uiAttribs.type == "int") {
              if (isNaN(v) || v === "") {
                el.classList.add("invalid");
                return;
              } else {
                el.classList.remove("invalid");
                v = parseInt(v, 10) || 0;
                // this._log.log("invalid int");
              }
            }

            if (!CABLES.mouseDraggingValue) {
              ((function (oldv, newv, opid, portname) {
                if (oldv != newv)
                  undo.add({
                    title: "Value change " + oldv + " to " + newv,
                    context: {
                      portname,
                    },
                    undo() {
                      try {
                        const uop = Gui$1.gui.corePatch().getOpById(opid);
                        const p = uop.getPort(portname);
                        Gui$1.gui.patchView.showDefaultPanel();

                        p.set(oldv);
                        Gui$1.gui.emitEvent("portValueEdited", op, p, oldv);

                        Gui$1.gui.opParams.show(uop);
                        Gui$1.gui.patchView.focusOp(null);
                        Gui$1.gui.patchView.focusOp(opid);
                        Gui$1.gui.patchView.centerSelectOp(opid);
                      } catch (ex) {
                        this._log.warn("undo failed");
                      }
                    },
                    redo() {
                      try {
                        const rop = Gui$1.gui.corePatch().getOpById(opid);
                        const p = rop.getPort(portname);
                        Gui$1.gui.patchView.showDefaultPanel();

                        p.set(newv);
                        Gui$1.gui.emitEvent("portValueEdited", op, p, newv);
                        Gui$1.gui.opParams.show(rop);
                        Gui$1.gui.patchView.focusOp(null);
                        Gui$1.gui.patchView.focusOp(opid);
                        Gui$1.gui.patchView.centerSelectOp(opid);
                      } catch (ex) {
                        this._log.warn("undo failed");
                      }
                    },
                  });
              }))(ports[index].get(), v, ports[index].op.id, ports[index].name);
            }

            if (ports[index].uiAttribs.type == "string") {
              if (v && ports[index].uiAttribs.stringTrim) v = String(v).trim();
              if ((v || v == "") && v.length < ports[index].uiAttribs.minLength) {
                ports[index].op.setUiError(
                  "uiminlength",
                  "User Input: Minimum length of string " +
                    ports[index].title +
                    " is " +
                    ports[index].uiAttribs.minLength,
                  2,
                );
              } else ports[index].op.setUiError("uiminlength", null);

              ports[index].set(v || "");
            } else if (ports[index].uiAttribs.display == "bool") {
              if (!v || v == "false" || v == "0" || v == 0) v = false;
              else v = true;

              ports[index].set(v ? 1 : 0);
            } else {
              ports[index].set(v || 0);
            }

            const op = ports[index].op;
            // update history on change
            if (op && !op.uiAttribs) op.uiAttribs = {};
            if (op && !op.uiAttribs.history) op.uiAttribs.history = {};

            if (op) {
              op.uiAttribs.history.lastInteractionAt = Date.now();
              op.uiAttribs.history.lastInteractionBy = {
                name: Gui$1.gui.user.usernameLowercase,
              };
            }

            paramsHelper.checkDefaultValue(ports[index], index, panelid);
            // if (ports[index].isAnimated()) Gui.gui.timeLine().scaleHeightDelayed();

            ports[index].emitEvent("onValueChangeUi");

            if (!e.detail || !e.detail.ignorePaco) {
              Gui$1.gui.emitEvent("portValueEdited", op, ports[index], v);
            }
          },
        );
    }

    _updateWatchPorts() {
      if (this._watchPorts.length) {
        const perf = Gui$1.gui.uiProfiler.start("[opparampanel] watch ports");

        for (let i = 0; i < this._watchPorts.length; i++) {
          const thePort = this._watchPorts[i];

          if (
            thePort.type != portType.number &&
            thePort.type != portType.string &&
            thePort.type != portType.array &&
            thePort.type != portType.object
          )
            continue;

          let newValue = "";
          const id = "watchPortValue_" + thePort.watchId + "_" + this.panelId;

          if (thePort.isAnimated()) {
            thePort._tempLastUiValue = thePort.get();
            const valDisp = thePort.getValueForDisplay();

            // hier
            if (thePort.type == portType.number) {
              const elVal = ele.byClass(id);

              if (elVal && elVal != document.activeElement)
                if (parseFloat(elVal.value) != parseFloat(valDisp))
                  elVal.value = valDisp;
                else if (elVal.value != valDisp) elVal.value = valDisp;

              const elDisp = ele.byId(
                "numberinputDisplay_" + thePort.watchId + "_" + this.panelId,
              );
              if (elDisp) elDisp.innerHTML = valDisp;
            }
          }
          if (thePort.type == portType.number) {
            if (thePort.uiAttribs.display == "boolnum") {
              if (thePort.get() === 0) newValue = "0 - false";
              else if (thePort.get() === 1) newValue = "1 - true";
              else newValue = "invlaid bool value! " + thePort.get();
            } else newValue = this._formatNumber(thePort.getValueForDisplay());
          } else if (thePort.type == portType.array) {
            let name = "Array";
            if (thePort.uiAttribs.stride) name += thePort.uiAttribs.stride;
            if (thePort.get())
              newValue = name + " (" + String(thePort.get().length) + ")";
            else newValue = name + " (null)";
          } else if (thePort.type == portType.string) {
            const v = thePort.getValueForDisplay();

            if (v && (typeof v === "string" || v instanceof String))
              newValue = '"' + v + '"';
            else newValue = String(v);
          } else if (thePort.type == portType.object) {
            if (thePort.get()) newValue = "";
            else newValue = "null";
          } else {
            newValue = String(thePort.get());
          }

          if (thePort._tempLastUiValue != newValue) {
            let el = thePort._tempLastUiEle;
            if (!el || thePort._tempLastUiEleId != id) {
              el = document.getElementsByClassName(id);
              if (el.length > 0) {
                el = thePort._tempLastUiEle = el[0];
                thePort._tempLastUiEleId = id;
              }
            }

            if (el) {
              el.innerHTML = newValue;
              thePort._tempLastUiValue = newValue;
            } else {
              this._log.log("paramlistener ele unknown", id);
            }
          }

          for (const iwcp in this._watchColorPicker) {
            const thePort2 = this._watchColorPicker[iwcp];
            const idx = thePort.op.portsIn.indexOf(thePort2);
            paramsHelper.updateLinkedColorBoxes(
              thePort2,
              thePort.op.portsIn[idx + 1],
              thePort.op.portsIn[idx + 2],
              this.panelId,
              idx,
            );
          }

          this._watchPortVisualizer.update(id, thePort.watchId, thePort.get());
        }

        perf.finish();
      }

      if (uiConfig.watchValuesInterval == 0) return;

      setTimeout(this._updateWatchPorts.bind(this), uiConfig.watchValuesInterval);
    }

    removePorts() {
      for (let i = 0; i < this._watchPorts.length; i++) {
        delete this._watchPorts[i]._tempLastUiValue;
        delete this._watchPorts[i]._tempLastUiEle;
        delete this._watchPorts[i]._tempLastUiEleId;
      }

      this._watchPorts.length = 0;
      this._watchAnimPorts.length = 0;
      this._watchColorPicker.length = 0;
      this._watchStrings.length = 0;
    }

    _formatNumber(n) {
      const options = { useGrouping: false, maximumSignificantDigits: 16 };
      n = n || 0;
      if (this._doFormatNumbers) return n.toLocaleString("fullwide", options);
      else return String(n);
    }
  }

  /**
   * op parameter panel
   *
   * @class OpParampanel
   * @extends {Events}
   */
  class OpParampanel extends Events {
    /**
     * @param {string} eleid
     */
    constructor(eleid = null) {
      super();

      this.panelId = CABLES.simpleId();
      this._eleId = eleid;
      this._log = new Logger("OpParampanel");
      this._htmlGen = new PortHtmlGenerator(this.panelId);

      this._currentOp = null;
      this._eventPrefix = CABLES.shortId();
      this._isPortLineDragDown = false;

      /** @type {Array<Port>} */
      this._portsIn = [];

      /** @type {Array<Port>} */
      this._portsOut = [];

      this._paramsListener = new ParamsListener(this.panelId);

      this._portUiAttrListeners = [];
      this._startedGlobalListeners = false;

      this.reloadListener = null;
    }

    get op() {
      return this._currentOp;
    }

    setParentElementId(eleid) {
      this._eleId = eleid;
    }

    dispose() {
      this._stopListeners();
    }

    clear() {
      this._stopListeners();
      this._currentOp = null;
    }

    refresh() {
      this.show(this._currentOp);
    }

    _onUiAttrChangeOp(attr) {
      if (attr.hasOwnProperty("uierrors")) this.updateUiErrors();
    }

    _onUiAttrChangePort(attr, port) {
      if (!attr) return;
      if (attr.hasOwnProperty("greyout")) this.refreshDelayed();

      // todo: only update this part of the html
    }

    _stopListeners(op) {
      op = op || this._currentOp;
      if (!op) return;

      for (let i = 0; i < this._portUiAttrListeners.length; i++) {
        const listener = this._portUiAttrListeners[i];
        listener.port.off(listener.listenId);
      }
      this._portUiAttrListeners.length = 0;
      this.onOpUiAttrChange = op.off(this.onOpUiAttrChange);
    }

    _startListeners(op) {
      if (!op) {
        this._stopListeners();
        return;
      }

      if (!this.hasExposeListener) {
        this.hasExposeListener = gui
          .corePatch()
          .on("subpatchExpose", (subpatchid) => {
            if (
              op &&
              op.storage &&
              op.storage.subPatchVer &&
              op.patchId.get() === subpatchid
            ) {
              op.refreshParams();
            }
          });
      }

      this.onOpUiAttrChange = op.on(
        "onUiAttribsChange",
        this._onUiAttrChangeOp.bind(this),
      );

      for (let i = 0; i < this._portsIn.length; i++) {
        const listenId = this._portsIn[i].on(
          "onUiAttrChange",
          this._onUiAttrChangePort.bind(this),
          this._eventPrefix,
        );
        this._portUiAttrListeners.push({
          listenId: listenId,
          port: this._portsIn[i],
        });
      }
    }

    refreshDelayed() {
      clearTimeout(this.refreshTimeout);
      this.refreshTimeout = setTimeout(() => {
        this.show(this._currentOp);
      }, 50);
    }

    /**
     * @param {Op|String} op
     */
    show(op) {
      if (!Gui$1.gui.finishedLoading()) return;
      if (!this._startedGlobalListeners) {
        this._startedGlobalListeners = true;

        Gui$1.gui.corePatch().on("bookmarkschanged", () => {
          Gui$1.gui.bookmarks.needRefreshSubs = true;
          this._startedGlobalListeners = true;
          if (!this._currentOp) Gui$1.gui.patchParamPanel.show(true);
        });
        Gui$1.gui.corePatch().on("subpatchesChanged", () => {
          Gui$1.gui.bookmarks.needRefreshSubs = true;
          this._startedGlobalListeners = true;
          if (!this._currentOp) Gui$1.gui.patchParamPanel.show(true);
        });
        Gui$1.gui.corePatch().on("subpatchCreated", () => {
          Gui$1.gui.bookmarks.needRefreshSubs = true;
          this._startedGlobalListeners = true;
          if (!this._currentOp) Gui$1.gui.patchParamPanel.show(true);
        });
        Gui$1.gui.corePatch().on("patchLoadEnd", () => {
          Gui$1.gui.bookmarks.needRefreshSubs = true;
          this._startedGlobalListeners = true;
          if (!this._currentOp) Gui$1.gui.patchParamPanel.show(true);
        });
      }

      if (this.reloadListener)
        this.reloadListener = Gui$1.gui.corePatch().on("opReloaded", () => {
          this.refreshDelayed();
        });

      const perf = Gui$1.gui.uiProfiler.start("[opparampanel] show");

      if (typeof op == "string") op = Gui$1.gui.corePatch().getOpById(op);

      if (
        !Gui$1.gui.showingtwoMetaPanel &&
        Gui$1.gui.metaTabs.getActiveTab() &&
        Gui$1.gui.metaTabs.getActiveTab().title != "op"
      )
        Gui$1.gui.metaTabs.activateTabByName("op");

      if (this._currentOp) this._stopListeners();

      this._currentOp = op;

      if (!op) return;

      this._portsIn = op.portsIn;
      this._portsOut = op.portsOut;

      if (op.storage && op.storage.subPatchVer && op.patchId) {
        const ports = Gui$1.gui.patchView.getSubPatchExposedPorts(op.patchId.get());
        for (let i = 0; i < ports.length; i++) {
          if (
            ports[i].direction === CABLES.Port.DIR_IN &&
            this._portsIn.indexOf(ports[i]) == -1
          )
            this._portsIn.push(ports[i]);
          if (
            ports[i].direction === CABLES.Port.DIR_OUT &&
            this._portsOut.indexOf(ports[i]) == -1
          )
            this._portsOut.push(ports[i]);
        }
      }

      this._startListeners(this._currentOp);

      op.emitEvent("uiParamPanel", op);

      const perfHtml = Gui$1.gui.uiProfiler.start("[opparampanel] build html ");

      Gui$1.gui.opHistory.push(op.id);
      Gui$1.gui.setTransformGizmo(null);

      Gui$1.gui.emitEvent("opSelectChange", op);

      this.emitEvent("opSelected", op);

      op.isServerOp = Gui$1.gui.serverOps.isServerOp(op.objName);

      /*
       * show first anim in timeline
       * if (self.timeLine)
       * {
       *     let foundAnim = false;
       *     for (let i = 0; i < this._portsIn.length; i++)
       *     {
       *         if (this._portsIn[i].isAnimated())
       *         {
       *             self.timeLine.setAnim(this._portsIn[i].anim, {
       *                 "name": this._portsIn[i].name,
       *             });
       *             foundAnim = true;
       *             continue;
       *         }
       *     }
       *     if (!foundAnim) self.timeLine.setAnim(null);
       * }
       */

      this._portsIn.sort(function (a, b) {
        return (a.uiAttribs.order || 0) - (b.uiAttribs.order || 0);
      });

      let html = this._htmlGen.getHtmlOpHeader(op);

      Gui$1.gui.showInfo(text.patchSelectedOp);

      if (this._portsIn.length > 0) {
        const perfLoop = Gui$1.gui.uiProfiler.start(
          "[opparampanel] _showOpParamsLOOP IN",
        );
        html += this._htmlGen.getHtmlHeaderPorts("in", "Input");
        html += this._htmlGen.getHtmlInputPorts(this._portsIn);

        perfLoop.finish();
      }

      if (this._portsOut.length > 0) {
        html += this._htmlGen.getHtmlHeaderPorts("out", "Output");

        const perfLoopOut = Gui$1.gui.uiProfiler.start(
          "[opparampanel] _showOpParamsLOOP OUT",
        );

        html += this._htmlGen.getHtmlOutputPorts(this._portsOut);

        perfLoopOut.finish();
      }

      html += getHandleBarHtml("params_op_foot", {
        op: op,
        showDevInfos: UserSettings.userSettings.get("devinfos"),
      });

      const el = document.getElementById(
        this._eleId || Gui$1.gui.getParamPanelEleId(),
      );

      if (el) el.innerHTML = html;
      else return;

      this._paramsListener.init({ op: op, element: el });

      perfHtml.finish();

      this.updateUiAttribs();

      for (let i = 0; i < this._portsIn.length; i++) {
        if (
          this._portsIn[i].uiAttribs.display &&
          this._portsIn[i].uiAttribs.display == "file"
        ) {
          let shortName = String(this._portsIn[i].get() || "none");
          if (shortName.indexOf("/") > -1)
            shortName = shortName.substr(shortName.lastIndexOf("/") + 1);

          if (op.getSubPatch()) {
            const subouterOp = op.patch.getSubPatchOuterOp(op.getSubPatch());
            if (subouterOp) {
              const subOuterName = subouterOp.objName;

              if (
                !namespace$1.isPatchOp(subOuterName) &&
                this._portsIn[i].get() &&
                namespace$1.isCoreOp(subOuterName) &&
                namespace$1.isExtensionOp(subOuterName) &&
                String(this._portsIn[i].get()).startsWith("/assets/") &&
                !this._portsIn[i].isLinked()
              )
                this._portsIn[i].op.setUiError(
                  "nonpatchopassets",
                  "This Operator uses assets from a patch, this file will probably not be found when exporting the patch or using in standalone etc.!",
                  1,
                );
            }
          }

          if (ele.byId("portFilename_" + i))
            ele.byId("portFilename_" + i).innerHTML =
              '<span class="button-small tt" data-tt="' +
              this._portsIn[i].get() +
              '" style="text-transform:none;"><span style="pointer-events:none;" class="icon icon-file"></span>' +
              shortName +
              "</span>";

          let srcEle = ele.byId("portFilename_" + i + "_src");
          if (srcEle) {
            let src = "";
            let fn = this._portsIn[i].get() || "";

            if (fn == "" || fn == 0) src = "";
            else if (!fn.startsWith("/")) src = "relative";
            if (fn.startsWith("/")) src = "abs";

            if (fn.startsWith("file:")) src = "file";
            if (fn.startsWith("data:")) src = "dataUrl";

            if (fn.startsWith("http://") || fn.startsWith("https://")) {
              const parts = fn.split("/");
              if (parts && parts.length > 1) src = "ext: " + parts[2];
            }
            if (fn.startsWith("/assets/" + Gui$1.gui.project()._id))
              src = "this patch";
            if (
              fn.startsWith("/assets/") &&
              !fn.startsWith("/assets/" + Gui$1.gui.project()._id)
            ) {
              const parts = fn.split("/");
              if (parts && parts.length > 1) {
                src =
                  '<a target="_blank" class="link" href="' +
                  platform.getCablesUrl() +
                  "/edit/" +
                  parts[2] +
                  '">other patch</a>';
                src +=
                  ' <a target="_blank" class="button-small" id="copyToPatch' +
                  i +
                  '">copy</a>';
              }
            }
            if (fn.startsWith("/assets/library/")) src = "lib";

            if (src != "") src = "[ " + src + " ]";

            srcEle.innerHTML = src;

            ele.clickable(ele.byId("copyToPatch" + i), () => {
              Gui$1.gui.fileManager.copyFileToPatch(fn);
            });
          }
        }

        const f = (e) => {
          if (!this._isPortLineDragDown) return;

          if (Gui$1.gui.patchView._patchRenderer.getOp) {
            const glOp = Gui$1.gui.patchView._patchRenderer.getOp(op.id);

            if (glOp && this._portsIn[i]) {
              const glPort = glOp.getGlPort(this._portsIn[i].name);

              if (this._portsIn[i].name == this._portLineDraggedName)
                Gui$1.gui.patchView._patchRenderer.emitEvent(
                  "mouseDownOverPort",
                  glPort,
                  glOp.id,
                  this._portsIn[i].name,
                  e,
                );
            }
          }
        };

        document.getElementById("portLineTitle_in_" + i).addEventListener(
          "pointerup",
          () => {
            this._isPortLineDragDown = false;
            this._portLineDraggedName = null;
          },
          { passive: false },
        );
        document.getElementById("portLineTitle_in_" + i).addEventListener(
          "pointerdown",
          (e) => {
            this._isPortLineDragDown = true;
            this._portLineDraggedName = e.target.dataset.portname;
          },
          { passive: false },
        );
        if (document.getElementById("patchviews"))
          document
            .getElementById("patchviews")
            .addEventListener("pointerenter", f);
      }

      for (const ipo in this._portsOut) {
        this._showOpParamsCbPortDelete(ipo, op);
        (function (index) {
          const elem = ele.byId("portTitle_out_" + index);
          if (elem)
            elem.addEventListener(
              "click",
              (e) => {
                const p = this._portsOut[index];
                if (!p.uiAttribs.hidePort)
                  Gui$1.gui.opSelect().show(
                    {
                      x:
                        p.parent.uiAttribs.translate.x +
                        index * (gluiconfig.portWidth + gluiconfig.portPadding),
                      y: p.op.uiAttribs.translate.y + 50,
                    },
                    op,
                    p,
                  );
              },
              { passive: false },
            );
          else this._log.warn("ele not found: portTitle_out_" + index);
        }).bind(this)(ipo);

        document.getElementById("portLineTitle_out_" + ipo).addEventListener(
          "pointerup",
          () => {
            this._isPortLineDragDown = false;
            this._portLineDraggedName = null;
          },
          { passive: false },
        );
        document.getElementById("portLineTitle_out_" + ipo).addEventListener(
          "pointerdown",
          (e) => {
            this._isPortLineDragDown = true;
            this._portLineDraggedName = e.target.dataset.portname;
          },
          { passive: false },
        );

        if (document.getElementById("patchviews"))
          document.getElementById("patchviews").addEventListener(
            "pointerenter",
            (e) => {
              if (!this._isPortLineDragDown) return;
              if (Gui$1.gui.patchView._patchRenderer.getOp) {
                const glOp = Gui$1.gui.patchView._patchRenderer.getOp(op.id);
                if (glOp && this._portsOut[ipo]) {
                  const glPort = glOp.getGlPort(this._portsOut[ipo].name);
                  if (this._portsOut[ipo].name == this._portLineDraggedName)
                    Gui$1.gui.patchView._patchRenderer.emitEvent(
                      "mouseDownOverPort",
                      glPort,
                      glOp.id,
                      this._portsOut[ipo].name,
                      e,
                    );
                }
              }
            },
            { passive: false },
          );
      }

      ele.clickable(ele.byId("parampanel_manage_op"), () => {
        CABLES.CMD.OP.manageOp(op.opId);
      });
      ele.clickable(ele.byId("parampanel_edit_op"), CABLES.CMD.OP.editOp);
      ele.clickable(
        ele.byId("watchOpSerialized"),
        CABLES.CMD.DEBUG.watchOpSerialized,
      );
      ele.clickable(
        ele.byId("watchOpUiAttribs"),
        CABLES.CMD.DEBUG.watchOpUiAttribs,
      );
      ele.clickable(
        ele.byId("watchOpDocsJson"),
        CABLES.CMD.DEBUG.watchOpDocsJson,
      );

      ele.forEachClass("portCopyClipboard", (ell) => {
        ell.addEventListener(
          "click",
          (e) => {
            if (!navigator.clipboard) return;

            const cop = Gui$1.gui.corePatch().getOpById(e.target.dataset.opid);
            const port = cop.getPortByName(e.target.dataset.portname);

            navigator.clipboard
              .writeText(String(port.get()))
              .then(() => {
                notify("Copied value to clipboard");
              })
              .catch((err) => {
                this._log.warn("copy to clipboard failed", err);
              });

            e.preventDefault();
          },
          { passive: false },
        );
      });

      if (Gui$1.gui.serverOps.opIdsChangedOnServer[op.opId]) {
        ele.clickable(ele.byId("parampanel_loadchangedop_" + op.opId), () => {
          Gui$1.gui.serverOps.execute(op.opId, () => {
            delete Gui$1.gui.serverOps.opIdsChangedOnServer[op.opId];
            this.refresh();
          });
        });
      }

      perf.finish();
    }

    updateUiErrors() {
      if (!this._currentOp) return;
      const el = document.getElementById("op_params_uierrors");

      if (
        !this._currentOp.uiAttribs.uierrors ||
        this._currentOp.uiAttribs.uierrors.length == 0
      ) {
        if (el) el.innerHTML = "";
        return;
      } else if (
        document.getElementsByClassName("warning-error") !=
        this._currentOp.uiAttribs.uierrors.length
      ) {
        if (el) el.innerHTML = "";
      }

      if (!el) {
        this._log.warn("no uiErrors html ele?!");
      } else {
        for (let i = 0; i < this._currentOp.uiAttribs.uierrors.length; i++) {
          const err = this._currentOp.uiAttribs.uierrors[i];

          let div = document.getElementById("uierror_" + err.id);

          let str = "";
          if (err.level == 0) str += "<b>Hint: </b>";
          if (err.level == 1) str += "<b>Warning: </b>";
          if (err.level == 2) str += "<b>Error: </b>";
          str += err.txt;

          if (err.options) {
            if (err.options.button)
              str +=
                '&nbsp;<a class="button-small" id="err_button_' +
                err.id +
                '">' +
                err.options.button +
                "</a>";
          }

          if (!div) {
            div = document.createElement("div");
            div.id = "uierror_" + err.id;
            div.classList.add("warning-error");
            if (CABLES.isNumeric(err.level))
              div.classList.add("warning-error-level" + err.level);
            else {
              console.error("err level not numeric", err.level);
              console.log(new Error().stack);
            }

            el.appendChild(div);
          }

          div.innerHTML = str;
        }
        Gui$1.gui.patchView.checkPatchErrors();
      }

      for (let i = 0; i < this._currentOp.uiAttribs.uierrors.length; i++) {
        if (this._currentOp.uiAttribs.uierrors[i].options.button)
          ele.clickable(
            ele.byId("err_button_" + this._currentOp.uiAttribs.uierrors[i].id),
            () => {
              if (this._currentOp.uiAttribs.uierrors[i].options.buttonCb)
                this._currentOp.uiAttribs.uierrors[i].options.buttonCb();
              else this._log.log("uierror button has no callback");
            },
          );
      }
    }

    updateUiAttribs() {
      if (Gui$1.gui.patchView.isPasting) return;
      if (!this._currentOp) return;

      this._uiAttrFpsLast = this._uiAttrFpsLast || performance.now();
      this._uiAttrFpsCount++;

      if (performance.now() - this._uiAttrFpsLast > 1000) {
        this._uiAttrFpsLast = performance.now();
        if (this._uiAttrFpsCount >= 10)
          this._log.log(
            "many ui attr updates! ",
            this._uiAttrFpsCount,
            this._currentOp.name,
          );
        this._uiAttrFpsCount = 0;
      }

      const perf = Gui$1.gui.uiProfiler.start("[opparampanel] updateUiAttribs");
      let el = null;

      el = document.getElementById("options_warning");
      if (el) {
        if (
          !this._currentOp.uiAttribs.warning ||
          this._currentOp.uiAttribs.warning.length === 0
        )
          el.style.display = "none";
        else {
          el.style.display = "block";
          if (el) el.innerHTML = this._currentOp.uiAttribs.warning;
        }
      }

      el = document.getElementById("options_hint");
      if (el) {
        if (
          !this._currentOp.uiAttribs.hint ||
          this._currentOp.uiAttribs.hint.length === 0
        )
          el.style.display = "none";
        else {
          el.style.display = "block";
          if (el) el.innerHTML = this._currentOp.uiAttribs.hint;
        }
      }

      el = document.getElementById("options_error");
      if (el) {
        if (
          !this._currentOp.uiAttribs.error ||
          this._currentOp.uiAttribs.error.length === 0
        )
          el.style.display = "none";
        else {
          el.style.display = "block";
          if (el) el.innerHTML = this._currentOp.uiAttribs.error;
        }
      }

      el = document.getElementById("options_info");
      if (el) {
        if (!this._currentOp.uiAttribs.info) el.style.display = "none";
        else {
          el.style.display = "block";
          el.innerHTML =
            '<div class="panelhead">info</div><div class="panel">' +
            this._currentOp.uiAttribs.info +
            "</div>";
        }
      }

      this.updateUiErrors();

      perf.finish();
    }

    _showOpParamsCbPortDelete(index, op) {
      const el = ele.byId("portdelete_out_" + index);
      if (el)
        el.addEventListener("click", (e) => {
          this._portsOut[index].removeLinks();
          this.show(op);
        });
    }

    setCurrentOpComment(v) {
      if (this._currentOp) {
        this._currentOp.uiAttr({ comment: v });
        if (v.length == 0) this._currentOp.uiAttr({ comment: null });
        this._currentOp.patch.emitEvent("commentChanged");
        // Gui.gui.setStateUnsaved({ "op": this._currentOp });
        Gui$1.gui.savedState.setUnSaved(
          "op comment",
          this._currentOp.uiAttribs.subPatch,
        );
      } else {
        this._log.warn("no current op comment");
      }
    }

    setCurrentOpTitle(t) {
      if (this._currentOp) this._currentOp.setTitle(t);

      if (
        this._currentOp &&
        this._currentOp.storage &&
        this._currentOp.storage.subPatchVer
      )
        this._currentOp.patch.emitEvent("subpatchesChanged");
    }

    isCurrentOp(op) {
      return this._currentOp == op;
    }

    isCurrentOpId(opid) {
      if (!this._currentOp) return false;
      return this._currentOp.id == opid;
    }

    // OLD SUBPATCH LIST!!!!!! REMOVE
    subPatchContextMenu(el) {
      const outer = Gui$1.gui.patchView.getSubPatchOuterOp(el.dataset.id);

      const items = [];
      if (outer && outer.storage && outer.storage.blueprint) {
        items.push({
          title: "Goto Blueprint Op",
          func() {
            // Gui.gui.patchView.focusSubpatchOp(el.dataset.id);
          },
        });
        items.push({
          title: "Update Blueprint",
          func() {
            const bp = Gui$1.gui.patchView.getBlueprintOpFromBlueprintSubpatchId(
              el.dataset.id,
            );
            if (bp) Gui$1.gui.patchView.updateBlueprints([bp]);
          },
        });
        items.push({
          title: "Open Patch",
          iconClass: "icon icon-external",
          func() {
            const url =
              platform.getCablesUrl() +
              "/edit/" +
              outer.storage.blueprint.patchId;
            window.open(url, "_blank");
          },
        });
      } else {
        items.push({
          title: "Rename",
          func() {
            Gui$1.gui.patchView.focusSubpatchOp(el.dataset.id);
            CABLES.CMD.PATCH.setOpTitle();
          },
        });

        items.push({
          title: "Goto Subpatch Op",
          func() {
            Gui$1.gui.patchView.focusSubpatchOp(el.dataset.id);
          },
        });

        if (el.dataset.subpatchver == "2" && el.dataset.blueprintver != 2)
          items.push({
            title: "Create op from subpatch",
            func() {
              Gui$1.gui.serverOps.createBlueprint2Op(el.dataset.id);
              // Gui.gui.patchView.focusSubpatchOp(el.dataset.id);
            },
          });

        if (el.dataset.blueprintver == 2) {
          items.push({
            title: "Save Blueprint Op",
            func() {
              const op = Gui$1.gui.patchView.getSubPatchOuterOp(el.dataset.id);

              Gui$1.gui.serverOps.updateSubPatchOpAttachment(op, {
                oldSubId: el.dataset.id,
              });
              // Gui.gui.patchView.focusSubpatchOp(el.dataset.id);
            },
          });
        }
      }
      contextMenu.show({ items }, el);
    }

    /**
     * @param {HTMLElement} el
     */
    opContextMenu(el) {
      const items = [];

      this._currentOp.objName;
      const opid = this._currentOp.id;

      items.push({
        title: "Set title",
        func: CABLES.CMD.PATCH.setOpTitle,
      });

      items.push({
        title: "Set default values",
        func() {
          Gui$1.gui.patchView.resetOpValues(opid);
        },
      });

      items.push({
        title: "Bookmark",
        func() {
          Gui$1.gui.bookmarks.add();
        },
      });

      items.push({
        title: "Manage Op Code",
        func() {
          CABLES.CMD.OP.manageOp();
        },
      });

      items.push({
        title: "Clone Op",
        func() {
          CABLES.CMD.OP.cloneSelectedOp();
        },
      });

      contextMenu.show({ items }, el);
    }
  }

  /**
   * show a searchable command palette (cmd/ctrl+p)
   *
   * @export
   * @class CommandPallete
   */
  class CommandPallete {
    constructor() {
      this._lastSearch = "";
      this._findTimeoutId = null;
      this._cursorIndex = 0;
      this._numResults = 0;
      this._bookmarkActiveIcon = "icon-pin-filled";
      this._bookmarkInactiveIcon = "icon-pin-outline";
      this._defaultIcon = "square";
      this.dynamicCmds = [];

      this.keyDown = (e) => {
        switch (e.which) {
          case 13:
            const el = ele.byId("result" + this._cursorIndex);
            if (el) el.click();
            break;
          case 27:
            this.close();
            break;

          case 38: // up
            this.navigate(-1);
            break;

          case 40: // down
            this.navigate(1);
            break;

          default:
            return;
        }
        e.preventDefault();
      };
    }

    isVisible() {
      return !ele.byId("cmdpalette").classList.contains("hidden");
    }

    show() {
      this._cursorIndex = 0;
      Gui$1.gui.closeModal();
      document.getElementById("modalbg").style.display = "block";
      ele.show(ele.byId("cmdpalette"));
      ele.byId("cmdinput").focus();
      ele.byId("cmdinput").value = this._lastSearch;
      document
        .getElementById("cmdinput")
        .setSelectionRange(0, this._lastSearch.length);

      clearTimeout(this._findTimeoutId);
      this._findTimeoutId = setTimeout(() => {
        this.doSearch(this._lastSearch);
      }, 100);

      document.addEventListener("keydown", this.keyDown);
    }

    /**
     * @param {MouseEvent} ev
     */
    onBookmarkIconClick(ev) {
      ev.stopPropagation();

      const el = ev.target;
      const cmd = el.closest(".result").dataset.cmd;
      const itemObj = UserSettings.userSettings.get("sidebar_left") || {};

      // replace the pin-icon / set / remove icon from sidebar
      const addToSidebar = !this.isCmdInSidebar(cmd);
      if (addToSidebar) {
        el.classList.remove(this._bookmarkInactiveIcon);
        el.classList.add(this._bookmarkActiveIcon);

        itemObj[cmd] = true;
      } else {
        // remove from sidebar
        el.classList.remove(this._bookmarkActiveIcon);
        el.classList.add(this._bookmarkInactiveIcon);

        itemObj[cmd] = false;
      }

      UserSettings.userSettings.set(
        "sidebar_left",
        JSON.parse(JSON.stringify(itemObj)),
      );

      Gui$1.gui.iconBarLeft.refresh();
    }

    onResultClick(ev) {
      const el = ev.target;
      const cmd = el.dataset.cmd;
      Gui$1.gui.cmdPallet.close();

      if (el.classList.contains("dyn")) {
        this.dynamicCmds[el.dataset.index].func();
      } else {
        CABLES.CMD.exec(cmd);
      }
    }

    isCmdInSidebar(cmdName) {
      const itemObj = UserSettings.userSettings.get("sidebar_left") || {};
      return itemObj.hasOwnProperty(cmdName) && itemObj[cmdName];
    }

    /*
     * Checks if a commad is currently in the sidebar and returns the fitting icon (class name)
     * (filled pin or outline pin)
     */
    /**
     * @param {String} cmdName
     */
    getBookmarkIconForCmd(cmdName) {
      if (this.isCmdInSidebar(cmdName)) return this._bookmarkActiveIcon;
      return this._bookmarkInactiveIcon;
    }

    /**
     * add result
     *
     * @param {Object} cmd
     * @param {Number} num
     * @param {Number} idx
     * @returns {String}
     */
    addResult(cmd, num, idx) {
      let dynclass = "";

      if (cmd.dyn) dynclass = "dyn";

      let html = "";
      html +=
        '<div class="result ' +
        dynclass +
        '" id="result' +
        num +
        '" data-index="' +
        idx +
        '" data-cmd="' +
        cmd.cmd +
        '" onclick=Gui.gui.cmdPallet.onResultClick(event)>';
      html += '<span class="icon icon-' + (cmd.icon || "square") + '"></span>';
      html += '<span class="title">' + cmd.cmd + "</span>";
      html +=
        '<span class="category"> - ' + cmd.category ||
        "unknown category" + "</span>";

      const bookmarkIcon = this.getBookmarkIconForCmd(cmd.cmd);
      html +=
        '<span class="icon ' +
        bookmarkIcon +
        ' bookmark" onclick=Gui.gui.cmdPallet.onBookmarkIconClick(event)></span>';
      if (cmd.hotkey) {
        html += '<span class="hotkey">[ ' + cmd.hotkey + " ]</span>";
      }
      html += "</div>";

      return html;
    }

    /**
     * @param {String} str - String
     * @param {String} searchId
     */
    doSearch(str, searchId) {
      this._lastSearch = str;

      let html = "";
      ele.byId("searchresult_cmd").innerHTML = html;

      str = str.toLowerCase();

      let count = 0;

      for (let i = 0; i < this.dynamicCmds.length; i++) {
        const cmd = this.dynamicCmds[i].cmd;

        if (cmd.toLowerCase().indexOf(str) >= 0) {
          html += this.addResult(this.dynamicCmds[i], count, i);
          count++;
        }
      }

      for (let i = 0; i < CABLES.CMD.commands.length; i++) {
        const cmd = CABLES.CMD.commands[i].cmd;

        let show = true;
        if (CABLES.CMD.commands[i].frontendOption)
          show = platform.frontendOptions[CABLES.CMD.commands[i].frontendOption];

        if (!show) continue;
        if (!str && CABLES.CMD.commands[i].category == "debug") continue;
        if (cmd.toLowerCase().indexOf(str) >= 0) {
          html += this.addResult(CABLES.CMD.commands[i], count);
          count++;
        }
      }

      this._numResults = count;
      ele.byId("searchresult_cmd").innerHTML = html;

      setTimeout(
        function () {
          this._cursorIndex = 0;
          this.navigate();
        }.bind(this),
        10,
      );
    }

    navigate(dir) {
      if (dir) this._cursorIndex += dir;
      if (this._cursorIndex < 0) this._cursorIndex = this._numResults - 1;
      if (this._cursorIndex >= this._numResults) this._cursorIndex = 0;

      ele.forEachClass("result", (e) => {
        e.classList.remove("selected");
      });

      const e = ele.byId("result" + this._cursorIndex);
      if (e) {
        e.classList.add("selected");
        e.scrollIntoView({ block: "end" });
      }
    }

    close() {
      document.removeEventListener("keydown", this.keyDown);
      ele.byId("searchresult_cmd").innerHTML = "";
      document.getElementById("modalbg").style.display = "none";
      ele.hide(ele.byId("cmdpalette"));
    }

    removeDynamic(id) {
      for (let i = this.dynamicCmds.length - 1; i > 0; i--) {
        if (this.dynamicCmds[i].id == id) {
          this.dynamicCmds.splice(i, 1);
        }
      }
    }

    addDynamic(category, title, func, icon) {
      const cmd = {
        cmd: title,
        category: category,
        func: func,
        icon: icon || "cables",
        dyn: true,
        id: CABLES.uuid(),
      };

      this.dynamicCmds.push(cmd);
      return cmd.id;
    }
  }

  /**
   * draw lines on the patchfield
   *
   * @export
   * @class GlLinedrawer
   */
  class GlLinedrawer {
    constructor(cgl, options) {
      if (!cgl) throw new Error("[Linedrawer] no cgl");
      options = options || {};

      this._startTime = performance.now();
      this._counter = 0;

      this._name = options.name || "unknown";
      this._num = options.initNum || 100;
      this._needsUpload = true;

      this._positions = new Float32Array(3 * 2 * this._num);
      this._colors = new Float32Array(4 * 2 * this._num);
      this._dists = new Float32Array(2 * this._num);
      this._speeds = new Float32Array(2 * this._num);

      this._shader = new CGL.Shader(cgl, "SplineDrawer");
      this._shader.ignoreMissingUniforms = true;
      this._shader.glPrimitive = cgl.gl.LINES;
      this._shader.setSource(
        "".endl() +
          "IN vec3 vPosition;".endl() +
          "IN vec4 color;".endl() +
          "IN float vdist;".endl() +
          "IN float speed;".endl() +
          "OUT float speedy;".endl() +
          "OUT float dist;".endl() +
          "OUT vec4 col;".endl() +
          "OUT vec2 pos2d;".endl() +
          "UNI float zoom,resX,resY,scrollX,scrollY;".endl() +
          "void main()".endl() +
          "{".endl() +
          "    float aspect=resX/resY;".endl() +
          "    dist=vdist;".endl() +
          "    speedy=speed;".endl() +
          "    vec3 pos=vPosition;".endl() +
          "    pos.y*=aspect;".endl() +
          "    pos.y=0.0-pos.y;".endl() +
          "    pos2d=pos.xy;".endl() +
          "    col=color;".endl() +
          "    pos*=zoom;".endl() +
          "    pos.x+=scrollX;".endl() +
          "    pos.y+=scrollY;".endl() +
          "    pos.z=0.9;".endl() +
          "    gl_Position = vec4(pos,1.0);".endl() +
          "}",

        "".endl() +
          "UNI float time;".endl() +
          "IN vec2 pos2d;".endl() +
          "IN vec4 col;".endl() +
          "IN float dist;".endl() +
          "IN float speedy;".endl() +
          "UNI float zoom;".endl() +
          "void main()".endl() +
          "{".endl() +
          "   vec4 finalColor=col;".endl() +
          "   if(finalColor.a==0.0) discard;".endl() +
          "   float stepLength=5.0;".endl() +
          "   float showSpeed=clamp(speedy,0.4,1.0);"

            // .endl() + "   float colmul=step(stepLength*0.5,mod(dist+(speedy*time),stepLength))+0.7;"
            // .endl() + "   if(speedy>=1.0) finalColor.rgb *= clamp(speedy,0.5,1.0)*(showSpeed)*clamp(colmul,0.0,1.0)*2.0;"
            // .endl() + "   else finalColor.rgb = finalColor.rgb;"
            // .endl() + "   else finalColor.rgb = finalColor.rgb;"

            .endl() +
          "   finalColor.rgb = finalColor.rgb;".endl() +
          "   finalColor.a = showSpeed;"
            // .endl() + "   finalColor.a = 1.0;"
            // .endl()+'   color.r = 1.0;'

            // .endl()+'   color.rgb += (1.0-showSpeed) * col.rgb;'

            // .endl()+'   if(speedy==0)'

            // .endl()+'  float a=length(gl_FragCoord.xy);'// )+1.0)/2.0+0.5);'
            // .endl()+'  a=sin(a);'
            // .endl()+'  a=(a+1.0)/2.0;'
            // .endl()+'  a=floor(a);'
            .endl() +
          "   #ifdef DEBUG_1".endl() +
          "       finalColor.rgb=vec3((zz+1.0)/2.0);".endl() +
          "       finalColor.a=1.0;".endl() +
          "   #endif".endl() +
          "   #ifdef DEBUG_2".endl() +
          "       finalColor.rg=uv;".endl() +
          "       finalColor.a=1.0;".endl() +
          "   #endif".endl() +
          "   outColor=finalColor;".endl() +
          "}",
      );

      // floor((sin( distance(vec4(0.,0.,0.,1.0),gl_FragCoord

      this._uniZoom = new CGL.Uniform(this._shader, "f", "zoom", 0);
      this._uniResX = new CGL.Uniform(this._shader, "f", "resX", 0);
      this._uniResY = new CGL.Uniform(this._shader, "f", "resY", 0);
      this._uniscrollX = new CGL.Uniform(this._shader, "f", "scrollX", 0);
      this._uniscrollY = new CGL.Uniform(this._shader, "f", "scrollY", 0);
      this._uniTime = new CGL.Uniform(this._shader, "f", "time", 0);

      this._geom = new CGL.Geometry("glpatchLineDrawer");
      this._geom.vertices = new Float32Array([
        10, 10, 0, 60, 60, 0, 10, 0, 0, 0, 0, 0,
      ]);

      this._mesh = new CGL.Mesh(cgl, this._geom);
      this.clear();
    }

    dispose() {
      this._mesh.dispose();
      this._shader.dispose();
    }

    render(resX, resY, scrollX, scrollY, zoom) {
      this._uniResX.set(resX);
      this._uniResY.set(resY);
      this._uniscrollX.set(scrollX);
      this._uniscrollY.set(scrollY);
      this._uniZoom.set(1.0 / zoom);
      this._uniTime.set(((performance.now() - this._startTime) / 1000) * 20.0);

      if (this._needsUpload) this.rebuild();

      this._mesh.render(this._shader);
    }

    clear() {
      for (let i = 0; i < 2 * 3 * this._num; i++) this._positions[i] = 0; // Math.random()*60;
      for (let i = 0; i < 2 * 4 * this._num; i++) this._colors[i] = 1.0;
      for (let i = 0; i < 2 * 1 * this._num; i++) this._dists[i] = 0;
      for (let i = 0; i < 2 * 1 * this._num; i++) this._speeds[i] = 0;
    }

    rebuild() {
      const perf = Gui.gui.uiProfiler.start("[glLineDrawer] rebuild");

      // console.log("reupload lines...",this._num);
      // todo: this is basically ALWAYS! could be optimized
      // todo only update whats needed
      this._mesh.setAttribute(CGL.SHADERVAR_VERTEX_POSITION, this._positions, 3);
      this._mesh.setAttribute("color", this._colors, 4);
      this._mesh.setAttribute("vdist", this._dists, 1);
      this._mesh.setAttribute("speed", this._speeds, 1);

      perf.finish();

      this._needsUpload = false;
    }

    _setupAttribBuffers() {
      const oldAttrPositions = this._positions;
      const oldAttrColors = this._colors;
      const oldAttrDists = this._dists;
      const oldAttrSpeeds = this._speeds;

      this._positions = new Float32Array(2 * 3 * this._num);
      this._colors = new Float32Array(2 * 4 * this._num);
      this._dists = new Float32Array(2 * this._num);
      this._speeds = new Float32Array(2 * this._num);
      this.clear();

      if (oldAttrPositions) this._positions.set(oldAttrPositions);
      if (oldAttrColors) this._colors.set(oldAttrColors);
      if (oldAttrDists) this._dists.set(oldAttrDists);
      if (oldAttrSpeeds) this._speeds.set(oldAttrSpeeds);
      this._needsUpload = true;
    }

    setDebugRenderer(i) {
      this._shader.toggleDefine("DEBUG_1", i == 1);
      this._shader.toggleDefine("DEBUG_2", i == 2);
    }

    getIndex() {
      this._counter++;

      if (this._counter > this._num - 100) {
        this._num += 1000;
        this._setupAttribBuffers();
        this._needsUpload = true;
      }

      return this._counter;
    }

    _distance(x1, y1, x2, y2) {
      const xd = x2 - x1;
      const yd = y2 - y1;
      return Math.sqrt(xd * xd + yd * yd);
    }

    _float32Diff(a, b) {
      return Math.abs(a - b) > 0.0001;
    }

    setLine(idx, x, y, x2, y2) {
      this._dists[idx * 2] = 0;
      this._dists[idx * 2 + 1] = this._distance(x, y, x2, y2);

      if (
        this._float32Diff(this._positions[idx * 6 + 0], x) ||
        this._float32Diff(this._positions[idx * 6 + 1], y) ||
        this._float32Diff(this._positions[idx * 6 + 3], x2) ||
        this._float32Diff(this._positions[idx * 6 + 4], y2)
      ) {
        this._needsUpload = true;
      }

      this._positions[idx * 6 + 0] = x;
      this._positions[idx * 6 + 1] = y;
      this._positions[idx * 6 + 2] = 0;
      this._positions[idx * 6 + 3] = x2;
      this._positions[idx * 6 + 4] = y2;
      this._positions[idx * 6 + 5] = 0;
    }

    setColor(idx, r, g, b, a) {
      if (
        this._float32Diff(this._colors[idx * 8 + 0], r) ||
        this._float32Diff(this._colors[idx * 8 + 1], g) ||
        this._float32Diff(this._colors[idx * 8 + 2], b) ||
        this._float32Diff(this._colors[idx * 8 + 3], a) ||
        this._float32Diff(this._colors[idx * 8 + 4], r) ||
        this._float32Diff(this._colors[idx * 8 + 5], g) ||
        this._float32Diff(this._colors[idx * 8 + 6], b) ||
        this._float32Diff(this._colors[idx * 8 + 7], a)
      ) {
        this._needsUpload = true;
      }

      this._colors[idx * 8 + 0] = r;
      this._colors[idx * 8 + 1] = g;
      this._colors[idx * 8 + 2] = b;
      this._colors[idx * 8 + 3] = a;
      this._colors[idx * 8 + 4] = r;
      this._colors[idx * 8 + 5] = g;
      this._colors[idx * 8 + 6] = b;
      this._colors[idx * 8 + 7] = a;
    }

    setSpeed(idx, speed) {
      if (
        this._float32Diff(this._speeds[idx * 2 + 0], speed) ||
        this._float32Diff(this._speeds[idx * 2 + 1], speed)
      ) {
        this._needsUpload = true;
      }

      this._speeds[idx * 2] = speed;
      this._speeds[idx * 2 + 1] = speed;
    }
  }

  /**
   * @typedef {Object} GlRectOptions
   * @property {Boolean} [interactive]
   * @property {GlRect} [parent]
   */
  /**
   * rectangle data structure for {@link GlRectInstancer}
   *
   * @export
   * @class GlRect
   * @extends {Events}
   */
  class GlRect extends Events {
    color = create$3();
    colorHover = null;
    interactive = true;
    childs = [];

    #parent = null;
    #visible = true;
    #hovering = false;
    #rectInstancer = null;
    #attrIndex = null;
    #texture = null;
    #shape = 0;
    #data = {};

    #w = 110;
    #h = 110;
    #x = 0;
    #y = 0;
    #z = 0;

    #absX = 0;
    #absY = 0;
    #absZ = 0;

    #isDragging = false;
    #draggable = false;
    #dragStartX = 0;
    #dragStartY = 0;
    #dragOffsetX = 0;
    #dragOffsetY = 0;
    draggableX = true;
    draggableY = true;
    draggableMove = false;

    #log = new Logger("GlRect");

    static EVENT_POINTER_HOVER = "hover";
    static EVENT_POINTER_UNHOVER = "unhover";
    static EVENT_POINTER_MOVE = "pointerMove";
    static EVENT_POINTER_UP = "mouseup";
    static EVENT_POINTER_DOWN = "mousedown";

    static EVENT_DRAG = "drag";
    static EVENT_DRAGSTART = "dragStart";
    static EVENT_DRAGEND = "dragEnd";

    static EVENT_POSITIONCHANGED = "positionChanged";
    static EVENT_TEXTURECHANGED = "textureChanged";

    static OPTION_INTERACTIVE = "interactive";
    static OPTION_PARENT = "parent";

    /**
     * @param {GlRectInstancer} instancer
     * @param {GlRectOptions} options
     */
    constructor(instancer, options) {
      super();

      if (!instancer || !instancer.getIndex)
        this.#log.warn("no instancer given!");

      this.#rectInstancer = instancer;
      this.#attrIndex = instancer.getIndex();
      this.#rectInstancer.setSize(this.#attrIndex, this.#w, this.#h);
      options = options || {};

      if (options.hasOwnProperty(GlRect.OPTION_INTERACTIVE))
        this.interactive = options.interactive;
      if (options.hasOwnProperty(GlRect.OPTION_PARENT))
        this.setParent(options.parent);
    }

    get x() {
      return this.#x;
    }
    get y() {
      return this.#y;
    }
    get z() {
      return this.#z;
    }

    get w() {
      return this.#w;
    }
    get h() {
      return this.#h;
    }

    get absX() {
      return this.#absX;
    }
    get absY() {
      return this.#absY;
    }
    get absZ() {
      return this.#absZ;
    }

    get dragOffsetX() {
      return this.#dragOffsetX;
    }
    get dragOffsetY() {
      return this.#dragOffsetY;
    }

    get data() {
      return this.#data;
    }
    set data(r) {
      this.#data = r;
    }

    set draggable(b) {
      this.#draggable = b;
    }
    get draggable() {
      return this.#draggable;
    }
    get isDragging() {
      return this.#isDragging;
    }

    get idx() {
      return this.#attrIndex;
    }

    get parent() {
      return this.#parent;
    }

    /**
     * @param {GlRect} c
     */
    hasChild(c) {
      return this.childs.indexOf(c) > -1;
    }

    /**
     * @param {GlRect} c
     */
    addChild(c) {
      if (!this.hasChild(c)) this.childs.push(c);
    }

    /**
     * @param {number} c
     */
    setShape(c) {
      if (this.#shape != c) {
        this.#shape = c;
        this.#rectInstancer.setShape(this.#attrIndex, c);
      }

      if (this._border != 0) this.#rectInstancer.setBorder(this.#attrIndex, 0);
      if (this._selected != 0)
        this.#rectInstancer.setSelected(this.#attrIndex, 0);
    }

    /**
     * @param {number} c
     */
    setBorder(c) {
      if (this._border != c) {
        this._border = c;
        this.#rectInstancer.setBorder(this.#attrIndex, c);
      }
    }

    /**
     * @param {boolean} c
     */
    setSelected(c) {
      if (this._selected != c) {
        this._selected = c;
        this.#rectInstancer.setSelected(this.#attrIndex, c);
      }
    }

    /**
     * @returns {boolean}
     */
    get visible() {
      return this.#visible;
    }

    /**
     * @param {boolean} v
     */
    set visible(v) {
      const changed = this.#visible != v;
      this.#visible = v;

      if (changed) {
        this._updateSize();

        if (!this.visible) this.#hovering = false;
        for (let i = 0; i < this.childs.length; i++) this.childs[i].visible = v;
      }
    }

    _updateSize() {
      if (!this.#visible) this.#rectInstancer.setSize(this.#attrIndex, 0, 0);
      else this.#rectInstancer.setSize(this.#attrIndex, this.#w, this.#h);
    }

    /**
     * @param {number} w
     * @param {number} h
     */
    setSize(w, h) {
      if (this.#w == w && this.#h == h) return;
      this.#w = w;
      this.#h = h;
      this._updateSize();
    }

    /**
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     */
    setColorHover(r, g, b, a) {
      this.colorHover = create$3();
      set$3(this.colorHover, r, g, b, a);
    }

    /**
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a=1
     */
    setColor(r, g = 1, b = 1, a = 1) {
      if (r === undefined) r = g = b = a = 1.0;
      if (r === null) r = 1.0;
      if (g === null) g = 1.0;
      if (b === null) b = 1.0;
      if (a === null) a = 1.0;
      if (r.length) {
        set$3(this.color, r[0], r[1], r[2], r[3]);
      } else set$3(this.color, r, g, b, a);
      this.#rectInstancer.setColor(this.#attrIndex, this.color);
    }

    /**
     * @param {number[]} arr
     */
    setColorArray(arr) {
      arr = arr || [1, 1, 1, 1];
      if (arr.length == 3) arr[3] = 1;
      set$3(this.color, arr[0], arr[1], arr[2], arr[3]);
      this.#rectInstancer.setColor(this.#attrIndex, this.color);
    }

    /**
     * @param {number} a
     * @param {boolean} childs
     */
    setOpacity(a, childs = false) {
      this.setColor(this.color[0], this.color[1], this.color[2], a);

      if (childs !== false)
        for (let i = 0; i < this.childs.length; i++) this.childs[i].setOpacity(a);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    setTexRect(x, y, w, h) {
      this.#rectInstancer.setTexRect(this.#attrIndex, x, y, w, h);
    }

    /**
     * @param {GlRect} p
     */
    setParent(p) {
      this.#parent = p;
      p.addChild(this);
      this.#visible = p.visible;
      this.updateParentPosition();
    }

    get texture() {
      return this.#texture;
    }

    /**
     * @param {Texture} t
     */
    setTexture(t) {
      if (this.#texture == t) return;
      this.#texture = t;
      this.emitEvent(GlRect.EVENT_TEXTURECHANGED);
    }

    /**
     * @param {number} _x
     * @param {number} _y
     * @param {number} _z
     */
    setPosition(_x, _y, _z = this.#z) {
      this.#x = _x;
      this.#y = _y;
      this.#z = _z;

      this.#absX = this.#x;
      this.#absY = this.#y;
      this.#absZ = this.#z;

      if (this.#parent) {
        this.#absX += this.getParentX();
        this.#absY += this.getParentY();
        this.#absZ += this.getParentZ();
      }

      this.#rectInstancer.setPosition(
        this.#attrIndex,
        this.#absX,
        this.#absY,
        this.#absZ,
      );

      for (let i = 0; i < this.childs.length; i++)
        this.childs[i].updateParentPosition();
      this.emitEvent(GlRect.EVENT_POSITIONCHANGED);
    }

    updateParentPosition() {
      this.setPosition(this.x, this.y, this.z);
    }

    /**
     * Description
     * @param {any} x
     * @param {any} y
     */
    isPointInside(x, y) {
      return (
        x > this.#absX &&
        x < this.#absX + this.#w &&
        y > this.#absY &&
        y < this.#absY + this.#h
      );
    }

    /**
     * @param {MouseEvent} e
     */
    mouseUp(e) {
      if (this.#hovering) this.emitEvent(GlRect.EVENT_POINTER_UP, e, this);
      for (let i = 0; i < this.childs.length; i++) this.childs[i].mouseUp(e);

      if (this.#isDragging) this.mouseDragEnd();
    }

    /**
     * @returns {boolean}
     */
    isHovering() {
      return this.#hovering;
    }

    /**
     * @returns {number}
     */
    getParentX() {
      let px = 0;
      let p = this.#parent;
      while (p) {
        px += p.x;
        p = p.parent;
      }

      return px;
    }

    /**
     * @returns {number}
     */
    getParentY() {
      let py = 0;
      let p = this.#parent;
      while (p) {
        py += p.y;
        p = p.parent;
      }

      return py;
    }

    /**
     * @returns {number}
     */
    getParentZ() {
      // todo: add up all parents
      if (!this.#parent) return 0;
      return this.#parent.absZ;
    }

    /**
     * @param {MouseEvent} e
     * @param {number} x
     * @param {number} y
     */
    mouseDown(e, x, y) {
      if (this.#hovering)
        this.emitEvent(GlRect.EVENT_POINTER_DOWN, e, this, x, y);
      for (let i = 0; i < this.childs.length; i++) this.childs[i].mouseDown(e);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} button
     * * @param {MouseEvent} event
     */
    mouseDrag(x, y, button, event) {
      if (!this.interactive) return;

      this.#dragOffsetX = 0;
      this.#dragOffsetY = 0;
      if (this.draggableX) this.#dragOffsetX = x - this.#dragStartX;
      if (this.draggableY) this.#dragOffsetY = y - this.#dragStartY;

      if (this.draggableMove) {
        this.setPosition(
          this.x + this.#dragOffsetX + this.getParentX(),
          this.y + this.#dragOffsetY + this.getParentY(),
        );
        this.#dragStartX = this.x;
        this.#dragStartY = this.y;
      }

      this.emitEvent(
        GlRect.EVENT_DRAG,
        this,
        this.#dragOffsetX,
        this.#dragOffsetY,
        button,
        event,
        x,
        y,
      );
    }

    mouseDragEnd() {
      if (!this.interactive) return;
      this.emitEvent(GlRect.EVENT_DRAGEND, this);
      this.#isDragging = false;
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} button
     * @param {MouseEvent} e
     */
    mouseMove(x, y, button, e) {
      if (!this.interactive) return;
      if (!this.#visible) return;

      const hovering = this.isPointInside(x, y);
      const isHovered = this.#hovering;

      const hoverChanged = this.#hovering != hovering;
      this.#hovering = hovering;

      if (hovering && !isHovered)
        this.emitEvent(GlRect.EVENT_POINTER_HOVER, this);
      else if (!hovering && isHovered)
        this.emitEvent(GlRect.EVENT_POINTER_UNHOVER, this);

      if (hoverChanged) {
        if (this.colorHover) {
          if (!this.#hovering)
            this.#rectInstancer.setColor(
              this.#attrIndex,
              this.color[0],
              this.color[1],
              this.color[2],
              this.color[3],
            );
          else
            this.#rectInstancer.setColor(
              this.#attrIndex,
              this.colorHover[0],
              this.colorHover[1],
              this.colorHover[2],
              this.colorHover[3],
            );
        } else
          this.#rectInstancer.setColor(
            this.#attrIndex,
            this.color[0],
            this.color[1],
            this.color[2],
            this.color[3],
          );
      }

      for (let i = 0; i < this.childs.length; i++) {
        this.childs[i].mouseMove(x, y, button, e);
        if (this.childs[i].isHovering()) this.#hovering = false;
      }

      if (this.#hovering) {
        if (button == 1 && this.#rectInstancer.allowDragging) {
          if (!this.#isDragging) {
            this.#isDragging = true;
            this.#dragStartX = x;
            this.#dragStartY = y;
            this.emitEvent(GlRect.EVENT_DRAGSTART, this, x, y, button, e);
          }
          this.#dragOffsetX = x;
          this.#dragOffsetY = y;
        }
        this.emitEvent(GlRect.EVENT_POINTER_MOVE, x, y);
      }
    }

    removeChild(child) {
      const idx = this.childs.indexOf(child);
      child._parent = null;
      if (idx >= 0) this.childs.splice(idx, 1);
    }

    dispose() {
      this.visible = false;
      if (this.#parent) this.#parent.removeChild(this);
      this.setShape(0);
      this.setSize(0, 0);
      return null;
    }
  }

  var srcShaderGlRectInstancerFrag = `
 IN vec4 col;
 IN vec4 posSize;
 IN float zz;
 IN highp vec2 uv;
 IN vec4 decoration;
 IN float useTexture;
 UNI float time;
 UNI sampler2D tex;
 UNI float zoom;
 UNI float msdfUnit;

 float median(float r, float g, float b)
 {
    return max(min(r, g), min(max(r, g), b));
 }

 float median(vec3 rgb)
 {
    return max(min(rgb.r, rgb.g), min(max(rgb.r, rgb.g),rgb.b));
 }

float screenPxRange()
{
    float pxRange=4.0;

    #ifdef WEBGL1
    vec2 unitRange = vec2(pxRange)/vec2(1024.0);
    #endif
    #ifdef WEBGL2
        vec2 unitRange = vec2(pxRange)/vec2(textureSize(tex, 0));
    #endif

    vec2 screenTexSize = vec2(1.0)/fwidth(uv);
    return max(0.5*dot(unitRange, screenTexSize), 1.0);
}

float contour(in float d, in float w) {
    // smoothstep(lower edge0, upper edge1, x)
    return smoothstep(0.5 - w, 0.5 + w, d);
}

float samp(in vec2 uv, float w) {
    return contour(median(texture2D(tex, uv).rgb), w);
}


 void main()
 {

    vec4 finalColor;
    finalColor.rgb=col.rgb;
    finalColor.a=1.0;

    if(useTexture>=0.0)
    {
        #ifdef SDF_TEXTURE


    float dist = median(texture2D(tex, uv).rgb);

    // fwidth helps keep outlines a constant width irrespective of scaling
    // GLSL's fwidth = abs(dFdx(uv)) + abs(dFdy(uv))
    float width = fwidth(dist);
    // Stefan Gustavson's fwidth
    //float width = 0.7 * length(vec2(dFdx(dist), dFdy(dist)));

// basic version
    //float alpha = smoothstep(0.5 - width, 0.5 + width, dist);

// supersampled version

    float alpha = contour( dist, width );
    //float alpha = aastep( 0.5, dist );

    // ------- (comment this block out to get your original behavior)
    // Supersample, 4 extra points
    float dscale = 0.354; // half of 1/sqrt2; you can play with this
    vec2 duv = dscale * (dFdx(uv) + dFdy(uv));
    vec4 box = vec4(uv-duv, uv+duv);

    float asum = samp( box.xy, width )
               + samp( box.zw, width )
               + samp( box.xw, width )
               + samp( box.zy, width );

    // weighted average, with 4 extra points having 0.5 weight each,
    // so 1 + 0.5*4 = 3 is the divisor
    float opacity = (alpha + 0.5 * asum) / 3.0;




            // vec4 smpl=texture(tex,uv);
            // float sigDist = median(smpl.r, smpl.g, smpl.b) - 0.5;
            // // vec2 msdfUnit = vec2(1.0/pow(zoom,2.0))/10000.0;//8.0/vec2(1024);
            // // vec2 msdfUnit=vec2(1.0/zoom*200000.0);
            // // vec2 msdfUnit=vec2(8.0/1024.0);

            // // if(1.0/zoom<500.)
            // // msdfUnit=vec2(8.0/200.0);


            // sigDist *= dot(msdfUnit, 0.5/fwidth(uv).x);
            // float opacity = clamp(sigDist + 0.5, 0.0, 1.0);
            finalColor=vec4(finalColor.rgb, opacity);
        #endif

        #ifndef SDF_TEXTURE
            finalColor=texture(tex,uv);
            // if(int(useTexture)==1)finalColor=texture(tex[1],uv);
            // if(int(useTexture)==2)finalColor=texture(tex[2],uv);
            // if(int(useTexture)==3)finalColor=texture(tex[3],uv);
            // if(int(useTexture)==4)finalColor=texture(tex[4],uv);
            // if(int(useTexture)==5)finalColor=texture(tex[5],uv);
        #endif
    }

    float shape=decoration.r;
    float border=decoration.g;
    float selected=decoration.b;


    if(shape==1.0) // circl
    {
        float outer = ((uv.x-0.5)*(uv.x-0.5) + (uv.y-0.5)*(uv.y-0.5));
        float inner = ((uv.x-0.5)*(uv.x-0.5) + (uv.y-0.5)*(uv.y-0.5));
        finalColor.a=smoothstep(0.2+fwidth(uv.x),0.2,outer);
        finalColor.rgb=mix(vec3(0.25,0.25,0.25), vec3(finalColor),1.0-smoothstep(0.1+fwidth(uv.x),0.1,inner));
    }
    else
    if(shape==2.0) // trianglebottom
    {
        if(uv.x+(1.0-uv.y) > 1.0)finalColor.a=1.0;
        else finalColor.a=0.0;
    }
    else
    if(shape==4.0) // frame
    {
        float outlinefrag=0.003;
        float add=(1.0-step(outlinefrag,posSize.x));
        if(add==0.0) add=(1.0-step(outlinefrag,posSize.y));
        if(add==0.0) add=(1.0-step(outlinefrag,posSize.z));
        if(add==0.0) add=(1.0-step(outlinefrag,posSize.w));
        if(add==0.0) finalColor.a=0.0;
    }
    else
    if(shape==5.0) // cursor
    {
        if(1.0-uv.x > uv.y && 1.0-uv.y<0.8-uv.x*0.3)finalColor.a=1.0;
        else finalColor.a=0.0;
    }
    else
    if(shape==6.0) // filled circle
    {
        float outer = ((uv.x-0.5)*(uv.x-0.5) + (uv.y-0.5)*(uv.y-0.5));
        finalColor.a=smoothstep(0.2+fwidth(uv.x),0.2,outer);
        // f(finalColor.a==0.0)discard;
    }
    else
    if(shape==7.0) // cross
    {
        float r = 0.00001;
        float l = 1.0;
        vec2 p = abs((uv)-0.5);
        float a = length(p-clamp(p.x+p.y,0.0,l)*0.5) - r;
        finalColor.a = (1.0-smoothstep(0.0,fwidth(uv.x)+0.1,a));
    }
    else
    if(shape==8.0) // loading indicator...
    {
        float s = sin(time*10.0);
        float c = cos(time*10.0);
        mat2 m = mat2(c, -s, s, c);
        vec2 uvRot=m*(uv-0.5);

        float outer = ((uvRot.x)*(uvRot.x) + (uvRot.y)*(uvRot.y));
        float inner = ((uvRot.x)*(uvRot.x) + (uvRot.y)*(uvRot.y));

        finalColor.a=smoothstep(0.2+fwidth(uvRot.x),0.2,outer);
        float v=1.0-smoothstep(0.1+fwidth(uvRot.x),0.1,inner);

        finalColor.rgb=mix(vec3(0.25,0.25,0.25), vec3(finalColor),v);

        if(uvRot.x>0.0 || uvRot.y>0.0) finalColor.a=0.0;
        finalColor.a*=v;
    }
    else
    if(shape==9.0) // half block top
    {
        if(floor(uv.y*20.0)/20.0<0.5)discard;
    }
    else
    if(shape==10.0) // half block bottom
    {
        // if(uv.y>=0.5)discard;
        if(ceil(uv.y*20.0)/20.0>0.5)
        discard;
    }
    else
    if(shape==11.0) // arrow down
    {
        if((abs(uv.x-0.5))>(uv.y-0.5))finalColor.a=0.0;
        else finalColor.a=1.0;
    }
    else
    if(shape==12.0) // plus
    {
        finalColor.a=1.0-step(0.1,abs(uv.x-0.5))*step(0.1,abs(uv.y-0.5));
    }
    else if (shape==13.0) // rhomb
    {
        vec2 uw=uv;
        uw=clamp(uw,0.0,1.0);

        if(uw.x>0.5)
        {
            if(abs(uw.y-0.5) < abs(mod( (1.0-uw.x)-0.5,0.5))) finalColor.a=1.0;
            else discard;
        }
        else
            if(abs(uw.y-0.5) < abs(mod(uw.x,0.5))) finalColor.a=1.0;
            else discard;
    }



    if(border>=1.0) // border
    {
       float outlinefrag=0.004*zoom*500.0;
       float add=(1.0-step(outlinefrag,posSize.x));
       if(add==0.0)add=(1.0-step(outlinefrag,posSize.y));
       if(add==0.0)add=(1.0-step(outlinefrag,posSize.z));
       if(add==0.0)add=(1.0-step(outlinefrag,posSize.w));

       if(border==2.0)finalColor.rgb+=vec3(add*0.2);
       else finalColor.rgb+=vec3(add*0.5);

    }

    // if(selected==1.0) // stripe
    // {
    //    float w=0.05;
    //    finalColor.rgb+=0.12*vec3( step(w/2.0,mod( time*0.04+posSize.x+posSize.y,w )));
    // }

    finalColor.a*=col.a;

    #ifdef DEBUG_1
        finalColor.rgb=vec3((zz+1.0)/2.0);
        finalColor.a=1.0;
    #endif
    #ifdef DEBUG_2
        finalColor.rg=uv;
        finalColor.a=1.0;
    #endif

    if(finalColor.a==0.0)discard;
    outColor=finalColor;
}
`;

  var srcShaderGlRectInstancerVert = `IN vec3 vPosition;
IN vec3 instPos;
IN vec4 instCol;
IN highp vec2 attrTexCoord;
IN vec4 texRect;
IN vec2 instSize;
IN vec4 instDeco;

OUT vec4 decoration;
OUT vec4 posSize;
OUT vec4 col;
OUT highp vec2 uv;

IN float contentTexture;
OUT float useTexture;
OUT float zz;

UNI highp float zoom,resX,resY,scrollX,scrollY;

void main()
{
    float aspect=resX/resY;

    useTexture=contentTexture;
    decoration=instDeco;

    uv=attrTexCoord*texRect.zw+texRect.xy;
    uv.y=1.0-uv.y;

    vec3 pos=vPosition;
    pos.xy*=instSize;

    posSize=vec4(pos.xy*zoom,instSize*zoom-pos.xy*zoom);

    pos.x+=instPos.x;
    pos.y+=instPos.y;
    pos.z+=instPos.z;

    pos.y*=aspect;
    pos.y=0.0-pos.y;

    col=instCol;

    pos.xy*=zoom;
    pos.x+=scrollX;
    pos.y+=scrollY;

    pos.z=zz=instPos.z;

    gl_Position = vec4(pos,1.0);
 }
`;

  /**
   * @typedef {Object} GlRectInstancerOptions
   * @property {String} [name]
   * @property {Number} [initNum]
   * @property {boolean} [allowDragging]
   */

  /**
   * draw many rectangles quickly using GPU instancing (e.g. patchfield: ops,ports,text)
   *
   * @export
   * @class GlRectInstancer
   * @extends {Events}
   */
  class GlRectInstancer extends Events {
    #counter = 0;
    #num = 0;
    #name = "";
    #needsRebuild = true;
    #needsRebuildReason = "";
    #cgl;
    #interactive = true;
    #needsTextureUpdate = false;
    #reUploadAttribs = true;
    allowDragging = false;
    #debugRenderStyle = 0;
    doBulkUploads = true;
    #updateRangesMin = {};
    #updateRangesMax = {};
    #bounds = null;

    /** @type {Array<GlRect>} */
    #rects = [];

    /** @type {Array<Texture>} */
    #textures = [];

    /** @type {GlRect} */
    #draggingRect = null;

    /** @type {Shader} */
    #shader = null;

    /** @type {Geometry} */
    #geom = null;

    /** @type {Mesh} */
    #mesh = null;

    #meshAttrPos = null;
    #meshAttrCol = null;
    #meshAttrSize = null;
    #meshAttrDeco = null;
    #meshAttrTexRect = null;
    #meshAttrTex = null;

    static DEFAULT_BIGNUM = 999999;
    static ATTR_TEXRECT = "texRect";
    static ATTR_CONTENT_TEX = "contentTexture";
    static ATTR_POS = "instPos";
    static ATTR_COLOR = "instCol";
    static ATTR_SIZE = "instSize";
    static ATTR_DECO = "instDeco";

    /**
     * Description
     * @param {CglContext} cgl
     * @param {GlRectInstancerOptions} options
     */
    constructor(cgl, options) {
      super();
      options = options || {};
      this._log = new Logger("glrectinstancer");

      if (!cgl) {
        this._log.warn("[RectInstancer] no cgl");
        throw new Error("[RectInstancer] no cgl");
      }

      this.#cgl = cgl;
      this.#name = options.name || "unknown";
      this.#num = options.initNum || 5000;

      this.#bounds = {
        minX: GlRectInstancer.DEFAULT_BIGNUM,
        maxX: -999999,
        minY: GlRectInstancer.DEFAULT_BIGNUM,
        maxY: -999999,
        minZ: GlRectInstancer.DEFAULT_BIGNUM,
        maxZ: -999999,
      };

      this._setupAttribBuffers();

      this.#shader = new CglShader(cgl, "rectinstancer " + this.#name);
      this.#shader.setSource(
        srcShaderGlRectInstancerVert,
        srcShaderGlRectInstancerFrag,
      );
      this.#shader.ignoreMissingUniforms = true;

      this._uniTime = new Uniform(this.#shader, "f", "time", 0);
      this._uniZoom = new Uniform(this.#shader, "f", "zoom", 0);
      this._uniResX = new Uniform(this.#shader, "f", "resX", 0);
      this._uniResY = new Uniform(this.#shader, "f", "resY", 0);
      this._uniscrollX = new Uniform(this.#shader, "f", "scrollX", 0);
      this._uniscrollY = new Uniform(this.#shader, "f", "scrollY", 0);
      this._unimsdfUnit = new Uniform(this.#shader, "f", "msdfUnit", 8 / 1024);
      this._uniTexture = new Uniform(this.#shader, "t", "tex", 0);

      this.#geom = new Geometry("rectinstancer " + this.#name);
      this.#geom.vertices = new Float32Array([
        1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0,
      ]);
      this.#geom.verticesIndices = new Uint16Array([2, 1, 0, 3, 1, 2]);
      this.#geom.texCoords = new Float32Array([1, 1, 0, 1, 1, 0, 0, 0]);

      if (this.#cgl.glVersion == 1)
        this.#shader.enableExtension("GL_OES_standard_derivatives");
      this.#mesh = new Mesh(cgl, this.#geom);
      this.#mesh.numInstances = this.#num;

      this.clear();
    }

    set interactive(i) {
      this.#interactive = i;
    }

    get interactive() {
      return this.#interactive;
    }

    dispose() {
      if (this.disposed) return;
      this.disposed = true;

      this.#shader.dispose();
      this.#mesh.dispose();
      return null;
    }

    get bounds() {
      if (this._needsBoundsRecalc) {
        const perf = Gui$1.gui.uiProfiler.start("[glRectInstancer] recalcBounds");

        const defaultMin = GlRectInstancer.DEFAULT_BIGNUM;
        const defaultMax = -999999;
        this._newBounds = {
          minX: defaultMin,
          maxX: defaultMax,
          minY: defaultMin,
          maxY: defaultMax,
          minZ: defaultMin,
          maxZ: defaultMax,
        };
        for (let i = 0; i < this.#rects.length; i++) {
          if (!this.#rects[i].visible) continue;
          if (
            this.#rects[i].x == this.#bounds.minX &&
            this.#rects[i].y == this.#bounds.minY &&
            this.#rects[i].w == this.#bounds.maxX - this.#bounds.minX &&
            this.#rects[i].h == this.#bounds.maxY - this.#bounds.minY
          )
            continue;

          const x = this.#rects[i].x || 0;
          const y = this.#rects[i].y || 0;
          const z = this.#rects[i].z || 0;
          const x2 = x + this.#rects[i].w;
          const y2 = y + this.#rects[i].h;

          this._newBounds.minX = Math.min(x, this._newBounds.minX);
          this._newBounds.maxX = Math.max(x2, this._newBounds.maxX);
          this._newBounds.minY = Math.min(y, this._newBounds.minY);
          this._newBounds.maxY = Math.max(y2, this._newBounds.maxY);

          this._newBounds.minZ = Math.min(z, this._newBounds.minZ);
          this._newBounds.maxZ = Math.max(z, this._newBounds.maxZ);
        }

        this._newBounds.changed =
          this._newBounds.minX != defaultMin ||
          this._newBounds.minY != defaultMin;
        this._needsBoundsRecalc = false;
        perf.finish();
      }

      this.#bounds = this._newBounds;
      return this.#bounds;
    }

    getDebug() {
      return {
        num: this.#num,
        len_attrBuffSizes: this._attrBuffSizes.length,
        len_attrBuffPos: this._attrBuffPos.length,
        len_attrBuffCol: this._attrBuffCol.length,
        len_attrBuffDeco: this._attrBuffDeco.length,
      };
    }

    clear() {
      for (let i = 0; i < 2 * this.#num; i++) this._attrBuffSizes[i] = 0;
      for (let i = 0; i < 3 * this.#num; i++) this._attrBuffPos[i] = 0;
      for (let i = 0; i < 4 * this.#num; i++) this._attrBuffCol[i] = 1;
      for (let i = 0; i < 4 * this.#num; i++) this._attrBuffDeco[i] = 0;
      for (let i = 0; i < this.#num; i++) this._attrBuffTextures[i] = -1;

      for (let i = 0; i < 4 * this.#num; i += 4) {
        this._attrBuffTexRect[i + 0] = this._attrBuffTexRect[i + 1] = 0;
        this._attrBuffTexRect[i + 2] = this._attrBuffTexRect[i + 3] = 1;
      }
    }

    _setupAttribBuffers() {
      const oldAttrPositions = this._attrBuffPos;
      const oldAttrTextures = this._attrBuffTextures;
      const oldAttrColors = this._attrBuffCol;
      const oldAttrSizes = this._attrBuffSizes;
      const oldAttrDeco = this._attrBuffDeco;
      const oldAttrTexRect = this._attrBuffTexRect;

      this._attrBuffPos = new Float32Array(3 * this.#num);
      this._attrBuffTextures = new Float32Array(this.#num);
      this._attrBuffCol = new Float32Array(4 * this.#num);
      this._attrBuffSizes = new Float32Array(2 * this.#num);
      this._attrBuffDeco = new Float32Array(4 * this.#num);
      this._attrBuffTexRect = new Float32Array(4 * this.#num);
      this.clear();

      if (oldAttrPositions) this._attrBuffPos.set(oldAttrPositions);
      if (oldAttrTextures) this._attrBuffTextures.set(oldAttrTextures);
      if (oldAttrColors) this._attrBuffCol.set(oldAttrColors);
      if (oldAttrSizes) this._attrBuffSizes.set(oldAttrSizes);
      if (oldAttrDeco) this._attrBuffDeco.set(oldAttrDeco);
      if (oldAttrTexRect) this._attrBuffTexRect.set(oldAttrTexRect);
    }

    isDragging() {
      return this.#draggingRect != null;
    }

    _setupTextures() {
      this.#needsTextureUpdate = false;
      this.#textures.length = 0;
      let count = 0;

      let minIdx = GlRectInstancer.DEFAULT_BIGNUM;
      let maxIdx = -999999;

      for (let i = 0; i < this.#rects.length; i++) {
        let changed = false;
        const thatRectIdx = this.#rects[i].idx;

        if (this.#rects[i].texture) {
          let found = false;

          for (let j = 0; j < this.#textures.length; j++) {
            if (
              this.#textures[j] &&
              this.#textures[j].texture == this.#rects[i].texture
            ) {
              found = true;

              if (this._attrBuffTextures[thatRectIdx] != this.#textures[j].num)
                changed = true;

              this._attrBuffTextures[thatRectIdx] = this.#textures[j].num;
              minIdx = Math.min(thatRectIdx, minIdx);
              maxIdx = Math.max(thatRectIdx, maxIdx);
            }
          }

          if (!found) {
            this._attrBuffTextures[thatRectIdx] = count;
            this.#textures[count] = {
              texture: this.#rects[i].texture,
              num: count,
            };
            count++;
          }
        } else {
          if (this._attrBuffTextures[thatRectIdx] != -1) changed = true;
          this._attrBuffTextures[thatRectIdx] = -1;
        }

        if (changed) {
          minIdx = Math.min(this.#rects[i].idx, minIdx);
          maxIdx = Math.max(this.#rects[i].idx, maxIdx);
        }
      }

      this.#mesh.setAttributeRange(
        this.#meshAttrTex,
        this._attrBuffCol,
        minIdx,
        maxIdx,
      );
    }

    _bindTextures() {
      for (let i = 0; i < 4; i++)
        if (this.#textures[0])
          this.#cgl.setTexture(i, this.#textures[0].texture.tex);

      if (this.#textures[0])
        this.#cgl.setTexture(0, this.#textures[0].texture.tex);
    }

    /**
     * @param {number} resX
     * @param {number} resY
     * @param {number} scrollX
     * @param {number} scrollY
     * @param {number} zoom
     */
    render(resX, resY, scrollX, scrollY, zoom) {
      // else Gui.gui.patchView._patchRenderer._textWriter._rectDrawer._unimsdfUnit.setValue(0);
      Gui$1.gui.patchView._patchRenderer._textWriter._rectDrawer._unimsdfUnit.setValue(
        8 / zoom,
      );
      // else if (zoom > 800 && zoom < 1100)
      // {
      //     console.log(2);
      //     Gui.gui.patchView._patchRenderer._textWriter._rectDrawer._unimsdfUnit.setValue(8 / 450);
      // }
      // else if (zoom > 1100)
      // {
      //     console.log(3);
      //     Gui.gui.patchView._patchRenderer._textWriter._rectDrawer._unimsdfUnit.setValue(8 / 250);
      // }
      // else Gui.gui.patchView._patchRenderer._textWriter._rectDrawer._unimsdfUnit.setValue(8 / 1000);

      if (this.doBulkUploads) {
        if (
          this.#updateRangesMin[GlRectInstancer.ATTR_POS] !=
          GlRectInstancer.DEFAULT_BIGNUM
        ) {
          this.#mesh.setAttributeRange(
            this.#meshAttrPos,
            this._attrBuffPos,
            this.#updateRangesMin[GlRectInstancer.ATTR_POS],
            this.#updateRangesMax[GlRectInstancer.ATTR_POS],
          );
          this._resetAttrRange(GlRectInstancer.ATTR_POS);
        }

        if (
          this.#updateRangesMin[GlRectInstancer.ATTR_COLOR] !=
          GlRectInstancer.DEFAULT_BIGNUM
        ) {
          // console.log("update colors,", this._updateRangesMax[GlRectInstancer.ATTR_COLOR] - this._updateRangesMin[GlRectInstancer.ATTR_COLOR]);
          this.#mesh.setAttributeRange(
            this.#meshAttrCol,
            this._attrBuffCol,
            this.#updateRangesMin[GlRectInstancer.ATTR_COLOR],
            this.#updateRangesMax[GlRectInstancer.ATTR_COLOR],
          );
          this._resetAttrRange(GlRectInstancer.ATTR_COLOR);
        }

        if (
          this.#updateRangesMin[GlRectInstancer.ATTR_SIZE] !=
          GlRectInstancer.DEFAULT_BIGNUM
        ) {
          this.#mesh.setAttributeRange(
            this.#meshAttrSize,
            this._attrBuffSizes,
            this.#updateRangesMin[GlRectInstancer.ATTR_SIZE],
            this.#updateRangesMax[GlRectInstancer.ATTR_SIZE],
          );
          this._resetAttrRange(GlRectInstancer.ATTR_SIZE);
        }

        if (
          this.#updateRangesMin[GlRectInstancer.ATTR_DECO] !=
          GlRectInstancer.DEFAULT_BIGNUM
        ) {
          this.#mesh.setAttributeRange(
            this.#meshAttrDeco,
            this._attrBuffDeco,
            this.#updateRangesMin[GlRectInstancer.ATTR_DECO],
            this.#updateRangesMax[GlRectInstancer.ATTR_DECO],
          );
          this._resetAttrRange(GlRectInstancer.ATTR_DECO);
        }

        if (
          this.#updateRangesMin[GlRectInstancer.ATTR_TEXRECT] !=
          GlRectInstancer.DEFAULT_BIGNUM
        ) {
          this.#mesh.setAttributeRange(
            this.#meshAttrTexRect,
            this._attrBuffTexRect,
            this.#updateRangesMin[GlRectInstancer.ATTR_TEXRECT],
            this.#updateRangesMax[GlRectInstancer.ATTR_TEXRECT],
          );
          this._resetAttrRange(GlRectInstancer.ATTR_TEXRECT);
        }
      }

      this._uniResX.set(resX);
      this._uniResY.set(resY);
      this._uniscrollX.set(scrollX);
      this._uniscrollY.set(scrollY);
      this._uniZoom.set(1.0 / zoom);

      this._uniTime.set(performance.now() / 1000);

      if (this.#needsTextureUpdate) this._setupTextures();
      this._bindTextures();

      if (this.#needsRebuild) this.rebuild();

      this.emitEvent("render");

      this.#mesh.render(this.#shader);
    }

    rebuild() {
      // this._log.log("rebuild!", this._name, this._attrBuffPos.length / 3, this._needsRebuildReason);
      this.#needsRebuildReason = "";
      // todo only update whats needed

      this.#mesh.numInstances = this.#num;

      if (this.#reUploadAttribs) {
        const perf = Gui$1.gui.uiProfiler.start(
          "[glRectInstancer] _reUploadAttribs",
        );
        this.#meshAttrPos = this.#mesh.setAttribute(
          GlRectInstancer.ATTR_POS,
          this._attrBuffPos,
          3,
          { instanced: true },
        );
        this.#meshAttrCol = this.#mesh.setAttribute(
          GlRectInstancer.ATTR_COLOR,
          this._attrBuffCol,
          4,
          { instanced: true },
        );
        this.#meshAttrSize = this.#mesh.setAttribute(
          GlRectInstancer.ATTR_SIZE,
          this._attrBuffSizes,
          2,
          { instanced: true },
        );
        this.#meshAttrDeco = this.#mesh.setAttribute(
          GlRectInstancer.ATTR_DECO,
          this._attrBuffDeco,
          4,
          { instanced: true },
        );
        this.#meshAttrTexRect = this.#mesh.setAttribute(
          GlRectInstancer.ATTR_TEXRECT,
          this._attrBuffTexRect,
          4,
          { instanced: true },
        );
        this.#meshAttrTex = this.#mesh.setAttribute(
          GlRectInstancer.ATTR_CONTENT_TEX,
          this._attrBuffTextures,
          1,
          { instanced: true },
        );
        this.#reUploadAttribs = false;
        perf.finish();
      }

      this.#needsRebuild = false;
    }

    getNumRects() {
      return this.#counter;
    }

    getIndex() {
      this.#counter++;
      if (this.#counter > this.#num - 100) {
        this.#num += Math.max(5000, Math.ceil(this.#num));
        this._setupAttribBuffers();
        this.#needsRebuild = true;
        this.#needsRebuildReason = "resize";
        this.#needsTextureUpdate = true;
        this.#reUploadAttribs = true;
      }
      return this.#counter;
    }

    _float32Diff(a, b) {
      return Math.abs(a - b) > 0.0001;
    }

    /**
     * @param {number} idx
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    setPosition(idx, x, y, z) {
      const buffIdx = idx * 3;
      if (
        this._float32Diff(this._attrBuffPos[buffIdx + 0], x) ||
        this._float32Diff(this._attrBuffPos[buffIdx + 1], y) ||
        this._float32Diff(this._attrBuffPos[buffIdx + 2], z)
      ) ; else return;

      if (
        this._attrBuffPos[buffIdx + 0] >= this.#bounds.maxX ||
        this._attrBuffPos[buffIdx + 0] <= this.#bounds.minX ||
        this._attrBuffPos[buffIdx + 1] >= this.#bounds.maxY ||
        this._attrBuffPos[buffIdx + 1] <= this.#bounds.minY
      ) {
        this._needsBoundsRecalc = true;
      }

      this._attrBuffPos[buffIdx + 0] = x;
      this._attrBuffPos[buffIdx + 1] = y;
      this._attrBuffPos[buffIdx + 2] = z;

      if (
        this._attrBuffPos[buffIdx + 0] >= this.#bounds.maxX ||
        this._attrBuffPos[buffIdx + 0] <= this.#bounds.minX ||
        this._attrBuffPos[buffIdx + 1] >= this.#bounds.maxY ||
        this._attrBuffPos[buffIdx + 1] <= this.#bounds.minY
      ) {
        this._needsBoundsRecalc = true;
      }

      if (!this._needsBoundsRecalc) {
        this.#bounds.minX = Math.min(
          this._attrBuffPos[buffIdx + 0],
          this.#bounds.minX,
        );
        this.#bounds.maxX = Math.max(
          this._attrBuffPos[buffIdx + 0],
          this.#bounds.maxX,
        );

        this.#bounds.minY = Math.min(
          this._attrBuffPos[buffIdx + 1],
          this.#bounds.minY,
        );
        this.#bounds.maxY = Math.max(
          this._attrBuffPos[buffIdx + 1],
          this.#bounds.maxY,
        );

        this.#bounds.minZ = Math.min(
          this._attrBuffPos[buffIdx + 2],
          this.#bounds.minZ,
        );
        this.#bounds.maxZ = Math.max(
          this._attrBuffPos[buffIdx + 2],
          this.#bounds.maxZ,
        );
      }

      if (this.doBulkUploads)
        this._setAttrRange(GlRectInstancer.ATTR_POS, buffIdx, buffIdx + 3);
      else
        this.#mesh.setAttributeRange(
          this.#meshAttrPos,
          this._attrBuffPos,
          buffIdx,
          buffIdx + 3,
        );

      this._needsBoundsRecalc = true;
    }

    setSize(idx, x, y) {
      if (
        this._float32Diff(this._attrBuffSizes[idx * 2 + 0], x) ||
        this._float32Diff(this._attrBuffSizes[idx * 2 + 1], y)
      ) ; else return;

      this._attrBuffSizes[idx * 2 + 0] = x;
      this._attrBuffSizes[idx * 2 + 1] = y;

      if (this.doBulkUploads)
        this._setAttrRange(GlRectInstancer.ATTR_SIZE, idx * 2, (idx + 1) * 2);
      else
        this.#mesh.setAttributeRange(
          this.#meshAttrSize,
          this._attrBuffSizes,
          idx * 2,
          (idx + 1) * 2,
        );
    }

    setTexRect(idx, x, y, w, h) {
      if (
        this._float32Diff(this._attrBuffTexRect[idx * 4 + 0], x) ||
        this._float32Diff(this._attrBuffTexRect[idx * 4 + 1], y) ||
        this._float32Diff(this._attrBuffTexRect[idx * 4 + 2], w) ||
        this._float32Diff(this._attrBuffTexRect[idx * 4 + 3], h)
      ) ; else return;

      this._attrBuffTexRect[idx * 4 + 0] = x;
      this._attrBuffTexRect[idx * 4 + 1] = y;
      this._attrBuffTexRect[idx * 4 + 2] = w;
      this._attrBuffTexRect[idx * 4 + 3] = h;

      if (this.doBulkUploads)
        this._setAttrRange(GlRectInstancer.ATTR_TEXRECT, idx * 4, idx * 4 + 4);
      else
        this.#mesh.setAttributeRange(
          this.#meshAttrTexRect,
          this._attrBuffTexRect,
          idx * 4,
          idx * 4 + 4,
        );
    }

    setColor(idx, r, g, b, a) {
      if (r.length) {
        a = r[3];
        b = r[2];
        g = r[1];
        r = r[0];
      }
      if (
        this._float32Diff(this._attrBuffCol[idx * 4 + 0], r) ||
        this._float32Diff(this._attrBuffCol[idx * 4 + 1], g) ||
        this._float32Diff(this._attrBuffCol[idx * 4 + 2], b) ||
        this._float32Diff(this._attrBuffCol[idx * 4 + 3], a)
      ) ; else return;

      this._attrBuffCol[idx * 4 + 0] = r;
      this._attrBuffCol[idx * 4 + 1] = g;
      this._attrBuffCol[idx * 4 + 2] = b;
      this._attrBuffCol[idx * 4 + 3] = a;

      if (this.doBulkUploads)
        this._setAttrRange(GlRectInstancer.ATTR_COLOR, idx * 4, idx * 4 + 4);
      else
        this.#mesh.setAttributeRange(
          this.#meshAttrCol,
          this._attrBuffCol,
          idx * 4,
          idx * 4 + 4,
        );
    }

    setShape(idx, o) {
      this._attrBuffDeco[idx * 4 + 0] = o;
      if (this.doBulkUploads)
        this._setAttrRange(GlRectInstancer.ATTR_DECO, idx * 4, idx * 4 + 4);
      else
        this.#mesh.setAttributeRange(
          this.#meshAttrDeco,
          this._attrBuffDeco,
          idx * 4,
          idx * 4 + 4,
        );
    }

    setBorder(idx, o) {
      this._attrBuffDeco[idx * 4 + 1] = o;
      if (this.doBulkUploads)
        this._setAttrRange(GlRectInstancer.ATTR_DECO, idx * 4, idx * 4 + 4);
      else
        this.#mesh.setAttributeRange(
          this.#meshAttrDeco,
          this._attrBuffDeco,
          idx * 4,
          idx * 4 + 4,
        );
    }

    setSelected(idx, o) {
      this._attrBuffDeco[idx * 4 + 2] = o;

      if (this.doBulkUploads)
        this._setAttrRange(GlRectInstancer.ATTR_DECO, idx * 4, idx * 4 + 4);
      else
        this.#mesh.setAttributeRange(
          this.#meshAttrDeco,
          this._attrBuffDeco,
          idx * 4,
          idx * 4 + 4,
        );
    }

    setDebugRenderer(i) {
      this.#shader.toggleDefine("DEBUG_1", i == 1);
      this.#shader.toggleDefine("DEBUG_2", i == 2);
    }

    setAllTexture(tex, sdf) {
      this.#shader.toggleDefine("SDF_TEXTURE", sdf);

      for (let i = 0; i < this.#rects.length; i++) this.#rects[i].setTexture(tex);
    }

    _resetAttrRange(attr) {
      this.#updateRangesMin[attr] = GlRectInstancer.DEFAULT_BIGNUM;
      this.#updateRangesMax[attr] = -999999;
    }

    /**
     * @param {string} attr index
     * @param {number} start
     * @param {number} end
     */
    _setAttrRange(attr, start, end) {
      this.#updateRangesMin[attr] = Math.min(start, this.#updateRangesMin[attr]);
      this.#updateRangesMax[attr] = Math.max(end, this.#updateRangesMax[attr]);
    }

    createRect(options) {
      options = options || {};
      const r = new GlRect(this, options);
      this.#rects.push(r);

      if (options.draggable) {
        this.allowDragging = options.draggable;
        r.on(GlRect.EVENT_DRAGSTART, (rect) => {
          if (this.allowDragging) this.#draggingRect = rect;
        });
        r.on(GlRect.EVENT_DRAGEND, () => {
          this.#draggingRect = null;
        });
      }

      r.on("textureChanged", () => {
        this.#needsTextureUpdate = true;
      });

      return r;
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} button
     * @param {MouseEvent} event
     */
    mouseMove(x, y, button, event) {
      const perf = Gui$1.gui.uiProfiler.start("[glrectinstancer] mousemove");
      if (!this.#interactive) return;
      if (this.allowDragging && this.#draggingRect) {
        this.#draggingRect.mouseDrag(x, y, button, event);
        return;
      }

      for (let i = 0; i < this.#rects.length; i++)
        if (!this.#rects[i].parent) this.#rects[i].mouseMove(x, y, button, event);

      perf.finish();
    }

    /**
     * @param {MouseEvent} e
     * @param {number} x
     * @param {number} y
     */
    mouseDown(e, x, y) {
      if (!this.#interactive) return;

      const perf = Gui$1.gui.uiProfiler.start("[glrectinstancer] mouseDown");
      for (let i = 0; i < this.#rects.length; i++)
        if (!this.#rects[i].parent) this.#rects[i].mouseDown(e, x, y);
      perf.finish();
    }

    /**
     * @param {MouseEvent} e
     */
    mouseUp(e) {
      if (!this.#interactive) return;
      const perf = Gui$1.gui.uiProfiler.start("[glrectinstancer] mouseup");

      for (let i = 0; i < this.#rects.length; i++) this.#rects[i].mouseUp(e);
      perf.finish();

      if (this.#draggingRect) this.#draggingRect.mouseDragEnd();
    }
  }

  var srcShaderGlSplineDrawerFrag = `IN vec2 texCoord;
IN vec4 fcolor;
IN vec4 finactiveColor;
IN vec4 fcolorBorder;
IN float fProgress;
IN float fSplineLength;
IN float fspeed;
IN float zz;

UNI vec4 fadeOutOptions;
UNI vec2 mousePos;

UNI float a;
UNI float time;

UNI float width;
UNI float widthSelected;


// vec4 finactiveColor=vec4(0.0,0.0,0.0,1.0);


{{MODULES_HEAD}}

void main()
{
    vec4 finalColor=fcolor;
    // float darken=1.0;
    // float minOpacity=0.7;


    #ifdef DRAWSPEED
        if(fspeed==0.0)finalColor=finactiveColor;
        if(fspeed==1.0)finalColor=fcolor;
        // if(fspeed==0.0)darken=1.0;
        // if(fspeed==1.0)darken=1.1;
        if(fspeed>=2.0)
        {
            float ffspeed=clamp(fspeed,0.,25.0);
            float darken=step(0.5,mod((time*ffspeed/2.0)+fProgress*0.2*(ffspeed*0.1),1.0));

            if(darken>0.5)finalColor=finactiveColor;
            else finalColor=fcolor;
        }
    #endif

    {{MODULE_COLOR}}
    // finalColor.rgb*=darken;

    // #ifdef LINE_OUTLINE
    //     if(abs(texCoord.y)>0.7) finalColor.rgb*=0.0;
    // #endif

    #ifdef DEBUG_1
        finalColor.rgb=vec3((zz+1.0)/2.0);
        finalColor.a=1.0;
    #endif
    #ifdef DEBUG_2
        finalColor.rg=texCoord;
        finalColor.a=1.0;
    #endif
    finalColor.a=1.0;





    // selected border
    if(fcolorBorder.a>0.0)
    {
        float border=widthSelected/(width+widthSelected)/2.0;

        float fade=0.0;

        fade=
            smoothstep(border+fwidth(texCoord.y),border,texCoord.y)+ // left border
            smoothstep(1.0-border-fwidth(texCoord.y),1.0-border,texCoord.y); // right

        finalColor=mix(finalColor,fcolorBorder,fade);
    }



    #ifdef FADEOUT
        // fade out over distance

        float fadeDistStart=fadeOutOptions.x;
        float fadeDist=fadeOutOptions.y;
        float fadeDistLength=6.0;
        float minOpacity=fadeOutOptions.w;


        if(fcolorBorder.a==0.0 && fSplineLength>fadeDistStart*2.0 && fProgress>fadeDistStart && fProgress<fSplineLength-fadeDistStart)
        {
            finalColor.a=0.0;
            finalColor.a=1.0-smoothstep(fProgress,fadeDistStart,fadeDistStart+fadeDist);
            finalColor.a+=1.0-(smoothstep(fProgress,fSplineLength-fadeDistStart,fSplineLength-fadeDistStart-fadeDist));
            finalColor.a=clamp(finalColor.a,minOpacity,1.0);
        }

    #endif

// finalColor=finactiveColor;
// finalColor.rgb*=fProgress/fSplineLength;

    outColor = finalColor;
}
`;

  var srcShaderGlSplineDrawerVert = `{{MODULES_HEAD}}

IN vec3 vPosition;
IN float attrVertIndex;
IN vec4 vcolor;
OUT vec4 fcolor;

IN vec4 vcolorInactive;
OUT vec4 finactiveColor;

IN vec4 vcolorBorder;
OUT vec4 fcolorBorder;

IN float speed;
OUT float fspeed;

IN float splineProgress;
OUT float fProgress;

IN float splineLength;
OUT float fSplineLength;

UNI float width;
UNI float widthSelected;
UNI float zpos;

IN vec3 spline,spline2,spline3;

OUT vec2 texCoord;
OUT vec3 norm;
OUT float zz;

UNI float zoom,resX,resY,scrollX,scrollY;

float texOffset=0.0;
float sizeAtt=0.0;

#define PI 3.1415926538

vec2 rotate(vec2 v, float a)
{
    float s = sin(a);
    float c = cos(a);
    mat2 m = mat2(c, -s, s, c);
    return m * v;
}

vec2 fix(vec4 i)
{
    vec2 res = i.xy / i.w;
    return res;
}

void main()
{
    if(vcolor.a == 0.0)return;

    float aspect=resX/resY;

    fspeed=speed;
    fcolor=vcolor;
    finactiveColor=vcolorInactive;
    fcolorBorder=vcolorBorder;
    texCoord=vec2(0.0,(vPosition.y+1.0)/2.0);

    vec4 pos=vec4(vPosition, 1.0);
    vec4 finalPosition  =  (vec4(spline2,1.0));
    vec4 finalPosition2 =  (vec4(spline3,1.0));

    if(finalPosition.x==0.0 && finalPosition.y==0.0 && finalPosition.z==0.0)
    {
        finalPosition=vec4(10000.0);
        finalPosition2=vec4(10000.0);
    }

    vec2 screenPos =fix( vec4(spline,1.0));
    vec2 screenPos2=fix( vec4(spline2,1.0));
    vec2 screenPos3=fix( vec4(spline3,1.0));

    float wid=width+(widthSelected*fcolorBorder.a);

    vec2 dir1 = normalize( screenPos2 - screenPos );
    vec2 dir2 = normalize( screenPos3 - screenPos2 );

    if( screenPos2 == screenPos ) dir1 = normalize( screenPos3 - screenPos2 );

    vec2 normal = vec2( -dir1.y, dir1.x ) * 0.5 * wid;
    vec2 normal2 = vec2( -dir2.y, dir2.x ) * 0.5 * wid;
    vec4 offset = vec4( mix(normal,normal2,pos.x) * (pos.y), 0.0, 1.0 );

    finalPosition = mix(finalPosition,finalPosition2,pos.x);

    fProgress=splineProgress;
    fSplineLength=splineLength;

    finalPosition.xy += offset.xy;

    finalPosition.y*=-aspect;
    finalPosition.xy*=zoom;
    finalPosition.x+=scrollX;
    finalPosition.y+=scrollY;
    finalPosition.z=spline.z;


    gl_Position = finalPosition;
}
`;

  /**
   * draw splines, e.g. cables on the patchfield
   *
   * @export
   * @class GlSplineDrawer
   */
  class GlSplineDrawer {
    /**
     * @param {CGState} cgl
     * @param {String} name
     */
    constructor(cgl, name) {
      this.name = name;
      this._cgl = cgl;
      this._count = -1;

      this._rebuildLater = true;
      this.doTessEdges = true;
      this.doCalcProgress = true;
      this._mesh = null;
      this._verts = new Float32Array();

      this._geom = new CGL.Geometry("GlSplineDrawer_" + name);
      this._pointsProgress = new Float32Array();
      this._pointsSplineLength = new Float32Array();
      this._points = new Float32Array();
      this._points2 = new Float32Array();
      this._points3 = new Float32Array();
      this._doDraw = new Float32Array();
      this._speeds = new Float32Array();
      this._thePoints = [];

      this._splineIndex = null;
      this._rebuildReason = "";

      this._splineHidden = [];
      this._splineColors = [];
      this._splines = [];

      this._shader = new CGL.Shader(cgl, "glSplineDrawer " + name);
      this._shader.setSource(
        srcShaderGlSplineDrawerVert,
        srcShaderGlSplineDrawerFrag,
      );

      this._uniTime = new CGL.Uniform(this._shader, "f", "time", 0);
      this._uniZoom = new CGL.Uniform(this._shader, "f", "zoom", 0);
      this._uniResX = new CGL.Uniform(this._shader, "f", "resX", 0);
      this._uniResY = new CGL.Uniform(this._shader, "f", "resY", 0);
      this._uniZpos = new CGL.Uniform(this._shader, "f", "zpos", 0.96);
      this._uniscrollX = new CGL.Uniform(this._shader, "f", "scrollX", 0);
      this._uniscrollY = new CGL.Uniform(this._shader, "f", "scrollY", 0);
      this._uniWidth = new CGL.Uniform(
        this._shader,
        "f",
        "width",
        Gui$1.gui.theme.patch.cablesWidth || 3,
      );
      this._uniWidthSelected = new CGL.Uniform(
        this._shader,
        "f",
        "widthSelected",
        Gui$1.gui.theme.patch.cablesWidthSelected || 3,
      );

      this._uniFadeoutOptions = new CGL.Uniform(
        this._shader,
        "4f",
        "fadeOutOptions",
        [50.0, 40.0, 0.0, 0.2],
      );

      this._uniMousePos = new CGL.Uniform(this._shader, "2f", "mousePos");

      this._shader.toggleDefine(
        "FADEOUT",
        !UserSettings.userSettings.get("fadeOutOptions"),
      );
      this._shader.toggleDefine(
        "DRAWSPEED",
        UserSettings.userSettings.get("glflowmode") != 0,
      );

      UserSettings.userSettings.on("change", (which, val) => {
        if (which == "noFadeOutCables")
          this._shader.toggleDefine("FADEOUT", !val);
        if (which == "glflowmode")
          this._shader.toggleDefine(
            "DRAWSPEED",
            UserSettings.userSettings.get("glflowmode") != 0,
          );
      });

      Gui$1.gui.on("themeChanged", () => {
        this._uniWidth.set(Gui$1.gui.theme.patch.cablesWidth || 3);
        this._uniWidthSelected.set(Gui$1.gui.theme.patch.cablesWidthSelected || 3);
        this._uniFadeoutOptions.set([
          Gui$1.gui.theme.patch.fadeOutDistStart,
          Gui$1.gui.theme.patch.fadeOutFadeDist,
          0.0,
          Gui$1.gui.theme.patch.fadeOutFadeOpacity,
        ]);
      });
    }

    set zPos(v) {
      this._uniZpos.setValue(v);
    }

    /**
     * @param {boolean} b
     */
    setFadeout(b) {
      this._shader.toggleDefine("FADEOUT", b);
    }

    /**
     * @param {number} resX
     * @param {number} resY
     * @param {number} scrollX
     * @param {number} scrollY
     * @param {number} zoom
     * @param {number} mouseX
     * @param {number} mouseY
     */
    render(resX, resY, scrollX, scrollY, zoom, mouseX, mouseY) {
      if (this._splines.length == 0) return;

      if (this._rebuildLater) {
        if (Gui$1.gui.finishedLoading) {
          this.rebuild();
        } else {
          clearTimeout(this._laterTimeout);
          this._laterTimeout = setTimeout(() => {
            this.rebuild();
          }, 100);
          this._rebuildLater = false;
        }
      }

      if (this._mesh) {
        this._cgl.pushShader(this._shader);

        this._uniResX.set(resX);
        this._uniResY.set(resY);
        this._uniscrollX.set(scrollX);
        this._uniscrollY.set(scrollY);
        this._uniZoom.set(1.0 / zoom);
        this._uniTime.set(performance.now() / 1000);

        const fadeOutOpts = [
          Gui$1.gui.theme.patch.fadeOutDistStart,
          Gui$1.gui.theme.patch.fadeOutFadeDist,
          0.0,
          Gui$1.gui.theme.patch.fadeOutFadeOpacity,
        ];
        if (zoom > 1400)
          fadeOutOpts[3] = CABLES.map(
            zoom,
            1400,
            2700,
            Gui$1.gui.theme.patch.fadeOutFadeOpacity,
            1.0,
          );

        this._uniFadeoutOptions.set(fadeOutOpts);

        if (this._points.length > 0) this._mesh.render(this._shader);
        this._cgl.popShader();
      }
    }

    get count() {
      return this._count + 1;
    }

    getSplineIndex(name = "") {
      this._count++;
      this._splines[this._count] = {
        name: name,
        points: [],
        color: [1, 0, 0, 1],
        colorInactive: [0, 1, 0, 1],
        colorBorder: [0, 0, 0, 0],
        speed: 1,
        index: this._count,
        hidden: false,
        pointsNeedProgressUpdate: true,
        deleted: false,
      };

      this._rebuildLater = true;
      this._rebuildReason = "new spline...";

      return this._count;
    }

    _float32Diff(a, b) {
      return Math.abs(a - b) > 0.0001;
    }

    setDebugRenderer(i) {
      this._shader.toggleDefine("DEBUG_1", i == 1);
      this._shader.toggleDefine("DEBUG_2", i == 2);
    }

    setSplineSpeed(idx, speed) {
      if (this._splines[idx].speed != speed) {
        this._splines[idx].speed = speed;
        this._updateAttribsSpeed(idx);
      }
    }

    setSplineColorInactive(idx, rgba) {
      if (
        this._float32Diff(this._splines[idx].colorInactive[0], rgba[0]) ||
        this._float32Diff(this._splines[idx].colorInactive[1], rgba[1]) ||
        this._float32Diff(this._splines[idx].colorInactive[2], rgba[2]) ||
        this._float32Diff(this._splines[idx].colorInactive[3], rgba[3])
      ) {
        this._splines[idx].colorInactive = rgba;
        this._updateAttribsCoordinates(idx, { colorsInactive: true });
      }
    }

    setSplineColorBorder(idx, rgba) {
      if (
        this._float32Diff(this._splines[idx].colorBorder[0], rgba[0]) ||
        this._float32Diff(this._splines[idx].colorBorder[1], rgba[1]) ||
        this._float32Diff(this._splines[idx].colorBorder[2], rgba[2]) ||
        this._float32Diff(this._splines[idx].colorBorder[3], rgba[3])
      ) {
        this._splines[idx].colorBorder = rgba;
        this._updateAttribsCoordinates(idx, { colorsBorder: true });
      }
    }

    setSplineColor(idx, rgba) {
      if (
        this._float32Diff(this._splines[idx].color[0], rgba[0]) ||
        this._float32Diff(this._splines[idx].color[1], rgba[1]) ||
        this._float32Diff(this._splines[idx].color[2], rgba[2]) ||
        this._float32Diff(this._splines[idx].color[3], rgba[3])
      ) {
        this._splines[idx].color = rgba;
        this._updateAttribsCoordinates(idx, { colors: true });
      }
    }

    deleteSpline(idx) {
      const sp = this._splines[idx];

      this.setSplineColor(idx, [0, 0, 0, 0]);
      sp.deleted = true;

      if (sp.origPoints)
        for (let i = 0; i < sp.origPoints.length; i += 3) {
          sp.origPoints[i + 0] = sp.origPoints[i + 1] = sp.origPoints[i + 2] = 0;
        }

      this.setSpline(idx, sp.origPoints);
    }

    showSpline(idx) {
      this._splines[idx].hidden = false;
    }

    hideSpline(idx) {
      this._splines[idx].hidden = true;
      if (this._splines[idx].points)
        for (let i = 0; i < this._splines[idx].points.length; i++)
          this._splines[idx].points[i] = 0;
      this._updateAttribsCoordinates(idx);
    }

    setSpline(idx, points) {
      if (idx === undefined || idx === null) {
        console.log("idx not defined");
        return;
      }

      let isDifferent = true;
      let isDifferentLength = false;

      if (!this._rebuildLater) {
        if (this._splines[idx] && this._splines[idx].origPoints) {
          isDifferent = false;

          if (this._splines[idx].hidden) {
            isDifferent = true;
            this._splines[idx].hidden = false;
          } else if (points.length < this._splines[idx].origPoints.length) {
            // if new num of points is smaller than last one just draw last point multiple times and do not rebuild everything...
            isDifferent = true;
            for (
              let i = points.length / 3;
              i < this._splines[idx].origPoints.length / 3;
              i++
            ) {
              points[i * 3] = points[i * 3];
              points[i * 3 + 1] = points[i * 3 + 1];
              points[i * 3 + 2] = points[i * 3 + 2];
            }

            this._splines[idx].pointsNeedProgressUpdate = true;
          } else if (points.length > this._splines[idx].origPoints.length) {
            // length of spline changed, we need to rebuild the whole buffer....
            isDifferent = true;
            isDifferentLength = true;
            this._splines[idx].pointsNeedProgressUpdate = true;

            // console.log("spline length changed...", points.length, this._splines[idx].origPoints.length);
            this._rebuildLater = true;
            this._rebuildReason =
              "length of spline changed " +
              points.length +
              " vs " +
              this._splines[idx].origPoints.length;
          } else {
            for (let i = 0; i < this._splines[idx].origPoints.length; i++) {
              if (this._splines[idx].origPoints[i] != points[i]) {
                isDifferent = true;
                this._splines[idx].pointsNeedProgressUpdate = true;
                break;
              }
            }
          }
        }
      }

      if (!isDifferent) return; // nothing has changed...

      // if (points.length == 6)points.push(points[3], points[4], points[5]);

      this._splines[idx].origPoints = points;

      if (this.doTessEdges) this._splines[idx].points = this.tessEdges(points);
      else this._splines[idx].points = points;

      this._splines[idx].pointsNeedProgressUpdate = true;

      if (!isDifferentLength) {
        // length is the same, update vertices only
        this._updateAttribsCoordinates(idx);

        // setAttributeRange(attr, array, start, end)
      }
    }

    setWidth(w) {
      this._uniWidth.set(w);
    }

    buildMesh() {
      const perf = Gui$1.gui.uiProfiler.start("[glspline] buildMesh");
      const num = this._thePoints.length / 3;

      if (this._verts.length != num * 18) {
        this._verts = new Float32Array(num * 18);
      }

      const max = 1;
      const min = -1;

      for (let i = 0; i < this._thePoints.length / 3; i++) {
        this._verts.set(
          [
            max,
            min,
            0,
            0,
            min,
            0,
            max,
            max,
            0,
            0,
            min,
            0,
            0,
            max,
            0,
            max,
            max,
            0,
          ],
          i * 18,
        );
      }
      this._geom.vertices = this._verts;

      if (!this._mesh) this._mesh = new CGL.Mesh(this._cgl, this._geom);

      this._mesh.addVertexNumbers = false;
      this._mesh.updateVertices(this._geom);

      perf.finish();

      // console.log("verlen2", this._verts.length / 6, this._thePoints.length);
    }

    _updateAttribsSpeed(idx) {
      if (!this._mesh) {
        this._rebuildLater = true;
        this._rebuildReason = "update speed";

        return;
      }

      let count = 0;
      const off = this._splines[idx].startOffset || 0;
      const points = this._splines[idx].points;

      if (!points) return;

      for (let i = 0; i < points.length / 3; i++) {
        for (let j = 0; j < 6; j++) {
          count += 3;
          this._speeds[(off + count) / 3] = this._splines[idx].speed;
        }
      }
      this._mesh.setAttributeRange(
        this._mesh.getAttribute("speed"),
        this._speeds,
        off / 3,
        (off + count) / 3,
      );
    }

    _dist(x1, y1, x2, y2) {
      const xd = x2 - x1;
      const yd = y2 - y1;
      return Math.sqrt(xd * xd + yd * yd);
    }

    _updateAttribsCoordinates(idx, updateWhat) {
      if (!Gui$1.gui.patchView._patchRenderer) return;
      if (Gui$1.gui.patchView._patchRenderer.debugData)
        Gui$1.gui.patchView._patchRenderer.debugData.splineUpdate++;

      if (!this._mesh || !this._colors) {
        this._rebuildReason = "no mesh/colors";
        this._rebuildLater = true;
        return;
      }

      const off = this._splines[idx].startOffset || 0;
      const points = this._splines[idx].points;
      let count = 0;
      let title = "all";

      if (!points) return;

      if (updateWhat == undefined) title = "all";
      else title = Object.keys(updateWhat).join(".");

      const perf = Gui$1.gui.uiProfiler.start(
        "[glspline] _updateAttribsCoordinates " + title,
      );

      if (updateWhat === undefined) {
        if (this.doCalcProgress && this._splines[idx].pointsNeedProgressUpdate) {
          this._splines[idx].pointsNeedProgressUpdate = false;
          const perf2 = Gui$1.gui.uiProfiler.start(
            "[glspline] _updateAttribsCoordinates progress coords",
          );
          let totalDistance = 0;
          const len = (points.length - 3) / 3;

          for (let i = 0; i < len; i++) {
            const ofc3 = (off + count) / 3;
            const idx3 = i * 3;
            const idx31 = (i + 1) * 3;

            this._pointsProgress[ofc3 + 1] =
              this._pointsProgress[ofc3 + 3] =
              this._pointsProgress[ofc3 + 4] =
                totalDistance;

            if (
              !isNaN(points[idx3 + 0]) &&
              !isNaN(points[idx3 + 1]) &&
              !isNaN(points[idx31 + 0]) &&
              !isNaN(points[idx31 + 1])
            ) {
              const d = this._dist(
                points[idx3 + 0],
                points[idx3 + 1],
                points[idx31 + 0],
                points[idx31 + 1],
              );
              if (d != d) {
                // console.log(points[idx3 + 0], points[idx3 + 1], points[idx31 + 0], points[idx31 + 1]);
                points[idx3 + 0] =
                  points[idx3 + 1] =
                  points[idx31 + 0] =
                  points[idx31 + 1] =
                    0;
              }
              if (d) totalDistance += d;
            }

            this._pointsProgress[ofc3 + 0] = totalDistance;
            this._pointsProgress[ofc3 + 2] = totalDistance;
            this._pointsProgress[ofc3 + 5] = totalDistance;

            count += 6 * 3;
          }

          // if (this._pointsSplineLength.length != this._pointsProgress.length)console.log("wrong length?!");
          for (let i = 0; i < this._pointsProgress.length; i++)
            this._pointsSplineLength[i] = totalDistance;

          perf2.finish();
        }
      }

      const perf4 = Gui$1.gui.uiProfiler.start(
        "[glspline] _updateAttribsCoordinates color values",
      );

      count = 0;
      for (let i = 0; i < points.length / 3; i++) {
        for (let j = 0; j < 6; j++) {
          const idxArr = (off + count) / 3;
          const idxArr4 = idxArr * 4;
          this._speeds[idxArr + 0] = this._splines[idx].speed;

          this._colors[idxArr4 + 0] = this._splines[idx].color[0];
          this._colors[idxArr4 + 1] = this._splines[idx].color[1];
          this._colors[idxArr4 + 2] = this._splines[idx].color[2];
          this._colors[idxArr4 + 3] = this._splines[idx].color[3];

          this._colorsInactive[idxArr4 + 0] = this._splines[idx].colorInactive[0];
          this._colorsInactive[idxArr4 + 1] = this._splines[idx].colorInactive[1];
          this._colorsInactive[idxArr4 + 2] = this._splines[idx].colorInactive[2];
          this._colorsInactive[idxArr4 + 3] = this._splines[idx].colorInactive[3];

          this._colorsBorder[idxArr4 + 0] = this._splines[idx].colorBorder[0];
          this._colorsBorder[idxArr4 + 1] = this._splines[idx].colorBorder[1];
          this._colorsBorder[idxArr4 + 2] = this._splines[idx].colorBorder[2];
          this._colorsBorder[idxArr4 + 3] = this._splines[idx].colorBorder[3];

          for (let k = 0; k < 3; k++) {
            this._points[off + count] = points[Math.max(0, i - 1) * 3 + k];
            this._points2[off + count] = points[(i + 0) * 3 + k];
            this._points3[off + count] = points[(i + 1) * 3 + k];
            count++;
          }
        }
      }
      perf4.finish();

      const perf3 = Gui$1.gui.uiProfiler.start(
        "[glspline] _updateAttribsCoordinates setAttributeRanges",
      );

      if (updateWhat === undefined || updateWhat.colors)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("vcolor"),
          this._colors,
          (off / 3) * 4,
          ((off + count) / 3) * 4,
        );
      if (updateWhat === undefined || updateWhat.colorsInactive)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("vcolorInactive"),
          this._colorsInactive,
          (off / 3) * 4,
          ((off + count) / 3) * 4,
        );
      if (updateWhat === undefined || updateWhat.colorsBorder)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("vcolorBorder"),
          this._colorsBorder,
          (off / 3) * 4,
          ((off + count) / 3) * 4,
        );

      if (updateWhat === undefined)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("spline"),
          this._points,
          off,
          off + count,
        );
      if (updateWhat === undefined)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("spline2"),
          this._points2,
          off,
          off + count,
        );
      if (updateWhat === undefined)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("spline3"),
          this._points3,
          off,
          off + count,
        );

      if (updateWhat === undefined)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("splineProgress"),
          this._pointsProgress,
          off / 3,
          (off + count) / 3,
        );
      if (updateWhat === undefined)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("splineLength"),
          this._pointsSplineLength,
          off / 3,
          (off + count) / 3,
        );
      if (updateWhat === undefined || updateWhat.speed)
        this._mesh.setAttributeRange(
          this._mesh.getAttribute("speed"),
          this._speeds,
          off / 3,
          (off + count) / 3,
        );
      perf3.finish();
      perf.finish();
    }

    rebuild() {
      if (this._splines.length == 0) return;
      this._rebuildReason = "unknown";
      this._splineIndex = [];
      let count = 0;
      let numPoints = 0;

      this._thePoints = []; // todo calc length beforehand

      const perf = Gui$1.gui.uiProfiler.start("[glspline] rebuild");

      for (let i = 0; i < this._splines.length; i++) {
        const spline = this._splines[i];
        if (
          spline.startOffset != count * 6 ||
          this._splineIndex[numPoints] != i
        ) {
          spline.startOffset = count * 6;
          spline.pointsNeedProgressUpdate = true;
        }

        if (spline.points)
          for (let j = 0; j < spline.points.length / 3; j++) {
            const j3 = j * 3;
            this._thePoints[count++] = spline.points[j3 + 0];
            this._thePoints[count++] = spline.points[j3 + 1];
            this._thePoints[count++] = spline.points[j3 + 2];
            this._splineIndex[numPoints] = i;

            numPoints++;
          }
      }

      if (this._thePoints.length === 0) return;

      let newLength = numPoints * 3 * 6;

      this.buildMesh();

      newLength = (this._verts.length / 6) * 6;

      if (newLength == 0) return;

      count = 0;
      let lastIndex = 0;
      let drawable = 0;

      if (this._points.length < newLength) {
        this._colors = new Float32Array((newLength / 3) * 4);
        this._colorsInactive = new Float32Array((newLength / 3) * 4);
        this._colorsBorder = new Float32Array((newLength / 3) * 4);

        this._points = new Float32Array(newLength);
        this._points2 = new Float32Array(newLength);
        this._points3 = new Float32Array(newLength);

        this._doDraw = new Float32Array(newLength / 3);
        this._pointsProgress = new Float32Array(newLength / 3);
        this._pointsSplineLength = new Float32Array(newLength / 3);
        this._speeds = new Float32Array(newLength / 3);
      }

      for (let i = 0; i < this._thePoints.length / 3; i++) {
        if (this._splineIndex) {
          if (i > 1 && lastIndex != this._splineIndex[i]) drawable = 0.0;
          else drawable = 1.0;
          lastIndex = this._splineIndex[i];
        } else drawable = 1.0;

        for (let j = 0; j < 6; j++) {
          this._doDraw[count / 3] = drawable;

          if (this._splines[this._splineIndex[i]]) {
            this._speeds[count / 3] = this._splines[this._splineIndex[i]].speed;
          } else this._speeds[count / 3] = 0;

          for (let k = 0; k < 3; k++) {
            count++;
          }
        }
        // console.log(this._splines[this._splineIndex[i]], this._splineIndex[i]);
      }

      const perfAttribs = Gui$1.gui.uiProfiler.start(
        "[glspline] rebuild set Attribs",
      );

      this._mesh.setAttribute("speed", this._speeds, 1);

      this._mesh.setAttribute("splineDoDraw", this._doDraw, 1);

      this._mesh.setAttribute("vcolor", this._colors, 4);
      this._mesh.setAttribute("vcolorInactive", this._colorsInactive, 4);
      this._mesh.setAttribute("vcolorBorder", this._colorsBorder, 4);

      this._mesh.setAttribute("spline", this._points, 3);
      this._mesh.setAttribute("spline2", this._points2, 3);
      this._mesh.setAttribute("spline3", this._points3, 3);
      this._mesh.setAttribute("splineProgress", this._pointsProgress, 1);
      this._mesh.setAttribute("splineLength", this._pointsSplineLength, 1);

      perfAttribs.finish();

      const perfAttribs2 = Gui$1.gui.uiProfiler.start(
        "[glspline] rebuild _updateAttribsCoordinates",
      );

      for (const i in this._splines)
        this._updateAttribsCoordinates(this._splines[i].index);

      perfAttribs2.finish();

      this._rebuildLater = false;
      perf.finish();

      let l = 0;
      for (let i = 0; i < this._splines.length; i++) {
        if (this._splines[i].points) l += this._splines[i].points.length / 3;
      }
      // console.log(this._splines);
      // console.log("avg spline points", l / this._splines.length);
    }

    ip(a, b, p) {
      return a + p * (b - a);
    }

    tessEdges(oldArr) {
      if (!oldArr) return;
      let count = 0;

      let step = 0.001;
      if (!UserSettings.userSettings.get("straightLines")) step = 0.01;
      const oneMinusStep = 1 - step;
      const l = oldArr.length * 3 - 3;

      if (!l || l < 0) return;

      const perf = Gui$1.gui.uiProfiler.start("[glspline] tessEdges");

      this._arrEdges = [];
      this._arrEdges.length = l;

      for (let i = 0; i < oldArr.length - 3; i += 3) {
        this._arrEdges[count++] = oldArr[i + 0];
        this._arrEdges[count++] = oldArr[i + 1];
        this._arrEdges[count++] = oldArr[i + 2];

        this._arrEdges[count++] = this.ip(oldArr[i + 0], oldArr[i + 3], step);
        this._arrEdges[count++] = this.ip(oldArr[i + 1], oldArr[i + 4], step);
        this._arrEdges[count++] = this.ip(oldArr[i + 2], oldArr[i + 5], step);

        this._arrEdges[count++] = this.ip(
          oldArr[i + 0],
          oldArr[i + 3],
          oneMinusStep,
        );
        this._arrEdges[count++] = this.ip(
          oldArr[i + 1],
          oldArr[i + 4],
          oneMinusStep,
        );
        this._arrEdges[count++] = this.ip(
          oldArr[i + 2],
          oldArr[i + 5],
          oneMinusStep,
        );
      }

      perf.finish();

      return this._arrEdges;
    }

    dispose() {
      if (this._mesh) this._mesh.dispose();
    }
  }

  /**
   * @typedef {Object} GlTextWriterOptions
   * @property {String} [name]
   * @property {Number} [initNum]
   */

  /**
   * draw text using msdf font texture, using {@link GlRectInstancer}
   *
   * @export
   * @class GlTextWriter
   */
  class GlTextWriter {
    /**
     * @param {CglContext} cgl
     * @param {GlTextWriterOptions} options
     */
    constructor(cgl, options) {
      this._cgl = cgl;
      options = options || {};
      this._name = options.name || "unknown";
      if (!cgl) throw new Error("[gltextwriter] no cgl");

      this._rectDrawer = new GlRectInstancer(cgl, {
        initNum: options.initNum,
        name: "textrects_" + this._name,
      });
      this._fontTex = null;
    }

    get rectDrawer() {
      return this._rectDrawer;
    }

    /**
     * @param {Number} resX
     * @param {Number} resY
     * @param {Number} scrollX
     * @param {Number} scrollY
     * @param {Number} zoom
     */
    render(resX, resY, scrollX, scrollY, zoom) {
      if (!this._fontTex) {
        this._fontTex = Texture$1.load(
          this._cgl,
          "img/worksans-regular.png",
          () => {
            this._rectDrawer.setAllTexture(this._fontTex, true);
          },
          { flip: false, filter: Texture$1.FILTER_LINEAR },
        );
      }

      this._rectDrawer.render(resX, resY, scrollX, scrollY, zoom);
    }

    getFontTexture() {
      return this._fontTex;
    }

    setDebugRenderer(i) {
      this._rectDrawer.setDebugRenderer(i);
    }
  }

  var pages = [
  	"WorkSans-Regular.png"
  ];
  var chars = [
  	{
  		id: 338,
  		index: 159,
  		char: "",
  		width: 100,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 108,
  		chnl: 15,
  		x: 0,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 253,
  		index: 542,
  		char: "",
  		width: 54,
  		height: 100,
  		xoffset: -2,
  		yoffset: 21,
  		xadvance: 52,
  		chnl: 15,
  		x: 0,
  		y: 73,
  		page: 0
  	},
  	{
  		id: 40,
  		index: 1045,
  		char: "(",
  		width: 30,
  		height: 98,
  		xoffset: 4,
  		yoffset: 20,
  		xadvance: 35,
  		chnl: 15,
  		x: 0,
  		y: 174,
  		page: 0
  	},
  	{
  		id: 41,
  		index: 1046,
  		char: ")",
  		width: 30,
  		height: 98,
  		xoffset: 1,
  		yoffset: 20,
  		xadvance: 35,
  		chnl: 15,
  		x: 0,
  		y: 273,
  		page: 0
  	},
  	{
  		id: 123,
  		index: 1047,
  		char: "{",
  		width: 32,
  		height: 98,
  		xoffset: 1,
  		yoffset: 20,
  		xadvance: 35,
  		chnl: 15,
  		x: 0,
  		y: 372,
  		page: 0
  	},
  	{
  		id: 125,
  		index: 1048,
  		char: "}",
  		width: 32,
  		height: 98,
  		xoffset: 3,
  		yoffset: 20,
  		xadvance: 35,
  		chnl: 15,
  		x: 31,
  		y: 174,
  		page: 0
  	},
  	{
  		id: 254,
  		index: 480,
  		char: "",
  		width: 51,
  		height: 98,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 63,
  		chnl: 15,
  		x: 31,
  		y: 273,
  		page: 0
  	},
  	{
  		id: 106,
  		index: 417,
  		char: "j",
  		width: 31,
  		height: 97,
  		xoffset: -10,
  		yoffset: 23,
  		xadvance: 27,
  		chnl: 15,
  		x: 55,
  		y: 73,
  		page: 0
  	},
  	{
  		id: 352,
  		index: 174,
  		char: "",
  		width: 58,
  		height: 95,
  		xoffset: 2,
  		yoffset: 5,
  		xadvance: 64,
  		chnl: 15,
  		x: 64,
  		y: 171,
  		page: 0
  	},
  	{
  		id: 210,
  		index: 139,
  		char: "",
  		width: 65,
  		height: 95,
  		xoffset: 5,
  		yoffset: 5,
  		xadvance: 75,
  		chnl: 15,
  		x: 87,
  		y: 73,
  		page: 0
  	},
  	{
  		id: 211,
  		index: 126,
  		char: "",
  		width: 65,
  		height: 95,
  		xoffset: 5,
  		yoffset: 5,
  		xadvance: 75,
  		chnl: 15,
  		x: 0,
  		y: 471,
  		page: 0
  	},
  	{
  		id: 212,
  		index: 128,
  		char: "",
  		width: 65,
  		height: 95,
  		xoffset: 5,
  		yoffset: 5,
  		xadvance: 75,
  		chnl: 15,
  		x: 33,
  		y: 372,
  		page: 0
  	},
  	{
  		id: 91,
  		index: 1049,
  		char: "[",
  		width: 27,
  		height: 94,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 35,
  		chnl: 15,
  		x: 83,
  		y: 267,
  		page: 0
  	},
  	{
  		id: 93,
  		index: 1050,
  		char: "]",
  		width: 27,
  		height: 94,
  		xoffset: 1,
  		yoffset: 22,
  		xadvance: 35,
  		chnl: 15,
  		x: 0,
  		y: 567,
  		page: 0
  	},
  	{
  		id: 124,
  		index: 1240,
  		char: "|",
  		width: 11,
  		height: 94,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 24,
  		chnl: 15,
  		x: 0,
  		y: 662,
  		page: 0
  	},
  	{
  		id: 381,
  		index: 233,
  		char: "",
  		width: 56,
  		height: 94,
  		xoffset: 4,
  		yoffset: 5,
  		xadvance: 63,
  		chnl: 15,
  		x: 0,
  		y: 757,
  		page: 0
  	},
  	{
  		id: 192,
  		index: 18,
  		char: "",
  		width: 65,
  		height: 94,
  		xoffset: 1,
  		yoffset: 5,
  		xadvance: 66,
  		chnl: 15,
  		x: 12,
  		y: 662,
  		page: 0
  	},
  	{
  		id: 193,
  		index: 2,
  		char: "",
  		width: 65,
  		height: 94,
  		xoffset: 1,
  		yoffset: 5,
  		xadvance: 66,
  		chnl: 15,
  		x: 28,
  		y: 567,
  		page: 0
  	},
  	{
  		id: 194,
  		index: 9,
  		char: "",
  		width: 65,
  		height: 94,
  		xoffset: 1,
  		yoffset: 5,
  		xadvance: 66,
  		chnl: 15,
  		x: 66,
  		y: 468,
  		page: 0
  	},
  	{
  		id: 198,
  		index: 26,
  		char: "",
  		width: 94,
  		height: 70,
  		xoffset: -1,
  		yoffset: 29,
  		xadvance: 95,
  		chnl: 15,
  		x: 101,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 200,
  		index: 61,
  		char: "",
  		width: 52,
  		height: 94,
  		xoffset: 9,
  		yoffset: 5,
  		xadvance: 64,
  		chnl: 15,
  		x: 99,
  		y: 362,
  		page: 0
  	},
  	{
  		id: 201,
  		index: 47,
  		char: "",
  		width: 52,
  		height: 94,
  		xoffset: 9,
  		yoffset: 5,
  		xadvance: 64,
  		chnl: 15,
  		x: 111,
  		y: 267,
  		page: 0
  	},
  	{
  		id: 202,
  		index: 51,
  		char: "",
  		width: 52,
  		height: 94,
  		xoffset: 9,
  		yoffset: 5,
  		xadvance: 64,
  		chnl: 15,
  		x: 123,
  		y: 169,
  		page: 0
  	},
  	{
  		id: 204,
  		index: 92,
  		char: "",
  		width: 20,
  		height: 94,
  		xoffset: 1,
  		yoffset: 5,
  		xadvance: 30,
  		chnl: 15,
  		x: 153,
  		y: 71,
  		page: 0
  	},
  	{
  		id: 205,
  		index: 84,
  		char: "",
  		width: 20,
  		height: 94,
  		xoffset: 9,
  		yoffset: 5,
  		xadvance: 30,
  		chnl: 15,
  		x: 174,
  		y: 71,
  		page: 0
  	},
  	{
  		id: 206,
  		index: 86,
  		char: "",
  		width: 35,
  		height: 94,
  		xoffset: -3,
  		yoffset: 5,
  		xadvance: 30,
  		chnl: 15,
  		x: 0,
  		y: 852,
  		page: 0
  	},
  	{
  		id: 255,
  		index: 544,
  		char: "",
  		width: 54,
  		height: 94,
  		xoffset: -2,
  		yoffset: 26,
  		xadvance: 52,
  		chnl: 15,
  		x: 36,
  		y: 852,
  		page: 0
  	},
  	{
  		id: 87,
  		index: 215,
  		char: "W",
  		width: 93,
  		height: 70,
  		xoffset: 2,
  		yoffset: 29,
  		xadvance: 96,
  		chnl: 15,
  		x: 0,
  		y: 947,
  		page: 0
  	},
  	{
  		id: 199,
  		index: 32,
  		char: "",
  		width: 61,
  		height: 93,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 69,
  		chnl: 15,
  		x: 57,
  		y: 757,
  		page: 0
  	},
  	{
  		id: 213,
  		index: 155,
  		char: "",
  		width: 65,
  		height: 93,
  		xoffset: 5,
  		yoffset: 7,
  		xadvance: 75,
  		chnl: 15,
  		x: 78,
  		y: 662,
  		page: 0
  	},
  	{
  		id: 217,
  		index: 198,
  		char: "",
  		width: 56,
  		height: 93,
  		xoffset: 8,
  		yoffset: 7,
  		xadvance: 71,
  		chnl: 15,
  		x: 91,
  		y: 851,
  		page: 0
  	},
  	{
  		id: 218,
  		index: 192,
  		char: "",
  		width: 56,
  		height: 93,
  		xoffset: 8,
  		yoffset: 7,
  		xadvance: 71,
  		chnl: 15,
  		x: 119,
  		y: 756,
  		page: 0
  	},
  	{
  		id: 219,
  		index: 194,
  		char: "",
  		width: 56,
  		height: 93,
  		xoffset: 8,
  		yoffset: 7,
  		xadvance: 71,
  		chnl: 15,
  		x: 94,
  		y: 563,
  		page: 0
  	},
  	{
  		id: 195,
  		index: 25,
  		char: "",
  		width: 65,
  		height: 92,
  		xoffset: 1,
  		yoffset: 7,
  		xadvance: 66,
  		chnl: 15,
  		x: 144,
  		y: 657,
  		page: 0
  	},
  	{
  		id: 209,
  		index: 124,
  		char: "",
  		width: 56,
  		height: 92,
  		xoffset: 9,
  		yoffset: 7,
  		xadvance: 73,
  		chnl: 15,
  		x: 132,
  		y: 457,
  		page: 0
  	},
  	{
  		id: 221,
  		index: 222,
  		char: "",
  		width: 59,
  		height: 92,
  		xoffset: -1,
  		yoffset: 7,
  		xadvance: 57,
  		chnl: 15,
  		x: 152,
  		y: 362,
  		page: 0
  	},
  	{
  		id: 81,
  		index: 162,
  		char: "Q",
  		width: 65,
  		height: 91,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 75,
  		chnl: 15,
  		x: 164,
  		y: 264,
  		page: 0
  	},
  	{
  		id: 214,
  		index: 135,
  		char: "",
  		width: 65,
  		height: 91,
  		xoffset: 5,
  		yoffset: 9,
  		xadvance: 75,
  		chnl: 15,
  		x: 176,
  		y: 166,
  		page: 0
  	},
  	{
  		id: 36,
  		index: 1115,
  		char: "$",
  		width: 56,
  		height: 90,
  		xoffset: 2,
  		yoffset: 19,
  		xadvance: 62,
  		chnl: 15,
  		x: 195,
  		y: 71,
  		page: 0
  	},
  	{
  		id: 64,
  		index: 1230,
  		char: "@",
  		width: 87,
  		height: 90,
  		xoffset: 5,
  		yoffset: 29,
  		xadvance: 96,
  		chnl: 15,
  		x: 151,
  		y: 550,
  		page: 0
  	},
  	{
  		id: 339,
  		index: 478,
  		char: "",
  		width: 90,
  		height: 56,
  		xoffset: 4,
  		yoffset: 44,
  		xadvance: 98,
  		chnl: 15,
  		x: 196,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 196,
  		index: 16,
  		char: "",
  		width: 65,
  		height: 90,
  		xoffset: 1,
  		yoffset: 9,
  		xadvance: 66,
  		chnl: 15,
  		x: 189,
  		y: 455,
  		page: 0
  	},
  	{
  		id: 203,
  		index: 58,
  		char: "",
  		width: 52,
  		height: 90,
  		xoffset: 9,
  		yoffset: 9,
  		xadvance: 64,
  		chnl: 15,
  		x: 212,
  		y: 356,
  		page: 0
  	},
  	{
  		id: 207,
  		index: 88,
  		char: "",
  		width: 33,
  		height: 90,
  		xoffset: -1,
  		yoffset: 9,
  		xadvance: 30,
  		chnl: 15,
  		x: 230,
  		y: 258,
  		page: 0
  	},
  	{
  		id: 197,
  		index: 23,
  		char: "",
  		width: 65,
  		height: 89,
  		xoffset: 1,
  		yoffset: 10,
  		xadvance: 66,
  		chnl: 15,
  		x: 242,
  		y: 162,
  		page: 0
  	},
  	{
  		id: 376,
  		index: 224,
  		char: "",
  		width: 59,
  		height: 88,
  		xoffset: -1,
  		yoffset: 11,
  		xadvance: 57,
  		chnl: 15,
  		x: 264,
  		y: 252,
  		page: 0
  	},
  	{
  		id: 220,
  		index: 196,
  		char: "",
  		width: 56,
  		height: 88,
  		xoffset: 8,
  		yoffset: 12,
  		xadvance: 71,
  		chnl: 15,
  		x: 252,
  		y: 57,
  		page: 0
  	},
  	{
  		id: 229,
  		index: 342,
  		char: "",
  		width: 52,
  		height: 86,
  		xoffset: 4,
  		yoffset: 14,
  		xadvance: 57,
  		chnl: 15,
  		x: 308,
  		y: 146,
  		page: 0
  	},
  	{
  		id: 103,
  		index: 388,
  		char: "g",
  		width: 54,
  		height: 85,
  		xoffset: 2,
  		yoffset: 36,
  		xadvance: 53,
  		chnl: 15,
  		x: 309,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 47,
  		index: 1030,
  		char: "/",
  		width: 42,
  		height: 84,
  		xoffset: 1,
  		yoffset: 22,
  		xadvance: 44,
  		chnl: 15,
  		x: 148,
  		y: 850,
  		page: 0
  	},
  	{
  		id: 92,
  		index: 1031,
  		char: "\\",
  		width: 42,
  		height: 84,
  		xoffset: 1,
  		yoffset: 22,
  		xadvance: 44,
  		chnl: 15,
  		x: 148,
  		y: 935,
  		page: 0
  	},
  	{
  		id: 37,
  		index: 1185,
  		char: "%",
  		width: 82,
  		height: 72,
  		xoffset: 2,
  		yoffset: 28,
  		xadvance: 86,
  		chnl: 15,
  		x: 176,
  		y: 750,
  		page: 0
  	},
  	{
  		id: 119,
  		index: 535,
  		char: "w",
  		width: 82,
  		height: 54,
  		xoffset: 1,
  		yoffset: 45,
  		xadvance: 84,
  		chnl: 15,
  		x: 309,
  		y: 86,
  		page: 0
  	},
  	{
  		id: 167,
  		index: 1233,
  		char: "",
  		width: 58,
  		height: 82,
  		xoffset: 1,
  		yoffset: 28,
  		xadvance: 60,
  		chnl: 15,
  		x: 364,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 230,
  		index: 345,
  		char: "",
  		width: 82,
  		height: 56,
  		xoffset: 4,
  		yoffset: 44,
  		xadvance: 90,
  		chnl: 15,
  		x: 210,
  		y: 641,
  		page: 0
  	},
  	{
  		id: 109,
  		index: 432,
  		char: "m",
  		width: 81,
  		height: 55,
  		xoffset: 7,
  		yoffset: 44,
  		xadvance: 95,
  		chnl: 15,
  		x: 239,
  		y: 546,
  		page: 0
  	},
  	{
  		id: 353,
  		index: 493,
  		char: "",
  		width: 47,
  		height: 80,
  		xoffset: 2,
  		yoffset: 20,
  		xadvance: 53,
  		chnl: 15,
  		x: 255,
  		y: 447,
  		page: 0
  	},
  	{
  		id: 182,
  		index: 1232,
  		char: "",
  		width: 57,
  		height: 80,
  		xoffset: 2,
  		yoffset: 29,
  		xadvance: 66,
  		chnl: 15,
  		x: 265,
  		y: 341,
  		page: 0
  	},
  	{
  		id: 224,
  		index: 337,
  		char: "",
  		width: 52,
  		height: 80,
  		xoffset: 4,
  		yoffset: 20,
  		xadvance: 57,
  		chnl: 15,
  		x: 303,
  		y: 422,
  		page: 0
  	},
  	{
  		id: 225,
  		index: 321,
  		char: "",
  		width: 52,
  		height: 80,
  		xoffset: 4,
  		yoffset: 20,
  		xadvance: 57,
  		chnl: 15,
  		x: 323,
  		y: 341,
  		page: 0
  	},
  	{
  		id: 232,
  		index: 378,
  		char: "",
  		width: 50,
  		height: 80,
  		xoffset: 4,
  		yoffset: 20,
  		xadvance: 58,
  		chnl: 15,
  		x: 324,
  		y: 233,
  		page: 0
  	},
  	{
  		id: 233,
  		index: 364,
  		char: "",
  		width: 50,
  		height: 80,
  		xoffset: 4,
  		yoffset: 20,
  		xadvance: 58,
  		chnl: 15,
  		x: 361,
  		y: 141,
  		page: 0
  	},
  	{
  		id: 242,
  		index: 458,
  		char: "",
  		width: 52,
  		height: 80,
  		xoffset: 4,
  		yoffset: 20,
  		xadvance: 60,
  		chnl: 15,
  		x: 375,
  		y: 222,
  		page: 0
  	},
  	{
  		id: 243,
  		index: 445,
  		char: "",
  		width: 52,
  		height: 80,
  		xoffset: 4,
  		yoffset: 20,
  		xadvance: 60,
  		chnl: 15,
  		x: 412,
  		y: 83,
  		page: 0
  	},
  	{
  		id: 382,
  		index: 553,
  		char: "",
  		width: 46,
  		height: 79,
  		xoffset: 4,
  		yoffset: 20,
  		xadvance: 53,
  		chnl: 15,
  		x: 94,
  		y: 945,
  		page: 0
  	},
  	{
  		id: 223,
  		index: 501,
  		char: "",
  		width: 51,
  		height: 79,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 62,
  		chnl: 15,
  		x: 423,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 226,
  		index: 328,
  		char: "",
  		width: 52,
  		height: 79,
  		xoffset: 4,
  		yoffset: 21,
  		xadvance: 57,
  		chnl: 15,
  		x: 191,
  		y: 823,
  		page: 0
  	},
  	{
  		id: 234,
  		index: 368,
  		char: "",
  		width: 50,
  		height: 79,
  		xoffset: 4,
  		yoffset: 21,
  		xadvance: 58,
  		chnl: 15,
  		x: 191,
  		y: 903,
  		page: 0
  	},
  	{
  		id: 236,
  		index: 410,
  		char: "",
  		width: 20,
  		height: 79,
  		xoffset: -1,
  		yoffset: 20,
  		xadvance: 27,
  		chnl: 15,
  		x: 242,
  		y: 903,
  		page: 0
  	},
  	{
  		id: 237,
  		index: 402,
  		char: "",
  		width: 20,
  		height: 79,
  		xoffset: 6,
  		yoffset: 20,
  		xadvance: 27,
  		chnl: 15,
  		x: 244,
  		y: 823,
  		page: 0
  	},
  	{
  		id: 244,
  		index: 447,
  		char: "",
  		width: 52,
  		height: 79,
  		xoffset: 4,
  		yoffset: 21,
  		xadvance: 60,
  		chnl: 15,
  		x: 263,
  		y: 903,
  		page: 0
  	},
  	{
  		id: 249,
  		index: 518,
  		char: "",
  		width: 48,
  		height: 79,
  		xoffset: 7,
  		yoffset: 21,
  		xadvance: 62,
  		chnl: 15,
  		x: 259,
  		y: 698,
  		page: 0
  	},
  	{
  		id: 250,
  		index: 512,
  		char: "",
  		width: 48,
  		height: 79,
  		xoffset: 7,
  		yoffset: 21,
  		xadvance: 62,
  		chnl: 15,
  		x: 293,
  		y: 602,
  		page: 0
  	},
  	{
  		id: 98,
  		index: 347,
  		char: "b",
  		width: 51,
  		height: 78,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 63,
  		chnl: 15,
  		x: 321,
  		y: 503,
  		page: 0
  	},
  	{
  		id: 100,
  		index: 355,
  		char: "d",
  		width: 51,
  		height: 78,
  		xoffset: 4,
  		yoffset: 22,
  		xadvance: 63,
  		chnl: 15,
  		x: 356,
  		y: 422,
  		page: 0
  	},
  	{
  		id: 102,
  		index: 387,
  		char: "f",
  		width: 39,
  		height: 78,
  		xoffset: 1,
  		yoffset: 22,
  		xadvance: 39,
  		chnl: 15,
  		x: 376,
  		y: 303,
  		page: 0
  	},
  	{
  		id: 108,
  		index: 423,
  		char: "l",
  		width: 25,
  		height: 78,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 31,
  		chnl: 15,
  		x: 265,
  		y: 778,
  		page: 0
  	},
  	{
  		id: 238,
  		index: 404,
  		char: "",
  		width: 36,
  		height: 78,
  		xoffset: -5,
  		yoffset: 21,
  		xadvance: 27,
  		chnl: 15,
  		x: 291,
  		y: 778,
  		page: 0
  	},
  	{
  		id: 240,
  		index: 356,
  		char: "",
  		width: 53,
  		height: 78,
  		xoffset: 4,
  		yoffset: 22,
  		xadvance: 62,
  		chnl: 15,
  		x: 308,
  		y: 682,
  		page: 0
  	},
  	{
  		id: 251,
  		index: 514,
  		char: "",
  		width: 48,
  		height: 78,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 62,
  		chnl: 15,
  		x: 342,
  		y: 582,
  		page: 0
  	},
  	{
  		id: 104,
  		index: 395,
  		char: "h",
  		width: 48,
  		height: 77,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 62,
  		chnl: 15,
  		x: 373,
  		y: 501,
  		page: 0
  	},
  	{
  		id: 107,
  		index: 420,
  		char: "k",
  		width: 49,
  		height: 77,
  		xoffset: 7,
  		yoffset: 22,
  		xadvance: 57,
  		chnl: 15,
  		x: 408,
  		y: 382,
  		page: 0
  	},
  	{
  		id: 227,
  		index: 344,
  		char: "",
  		width: 52,
  		height: 77,
  		xoffset: 4,
  		yoffset: 23,
  		xadvance: 57,
  		chnl: 15,
  		x: 416,
  		y: 303,
  		page: 0
  	},
  	{
  		id: 231,
  		index: 351,
  		char: "",
  		width: 49,
  		height: 77,
  		xoffset: 4,
  		yoffset: 44,
  		xadvance: 56,
  		chnl: 15,
  		x: 428,
  		y: 164,
  		page: 0
  	},
  	{
  		id: 245,
  		index: 474,
  		char: "",
  		width: 52,
  		height: 77,
  		xoffset: 4,
  		yoffset: 23,
  		xadvance: 60,
  		chnl: 15,
  		x: 465,
  		y: 80,
  		page: 0
  	},
  	{
  		id: 105,
  		index: 400,
  		char: "i",
  		width: 16,
  		height: 76,
  		xoffset: 5,
  		yoffset: 23,
  		xadvance: 27,
  		chnl: 15,
  		x: 475,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 112,
  		index: 479,
  		char: "p",
  		width: 51,
  		height: 76,
  		xoffset: 7,
  		yoffset: 44,
  		xadvance: 63,
  		chnl: 15,
  		x: 492,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 113,
  		index: 481,
  		char: "q",
  		width: 51,
  		height: 76,
  		xoffset: 4,
  		yoffset: 44,
  		xadvance: 63,
  		chnl: 15,
  		x: 316,
  		y: 857,
  		page: 0
  	},
  	{
  		id: 121,
  		index: 541,
  		char: "y",
  		width: 54,
  		height: 76,
  		xoffset: -2,
  		yoffset: 45,
  		xadvance: 52,
  		chnl: 15,
  		x: 316,
  		y: 934,
  		page: 0
  	},
  	{
  		id: 216,
  		index: 153,
  		char: "",
  		width: 65,
  		height: 76,
  		xoffset: 5,
  		yoffset: 27,
  		xadvance: 75,
  		chnl: 15,
  		x: 328,
  		y: 761,
  		page: 0
  	},
  	{
  		id: 241,
  		index: 443,
  		char: "",
  		width: 48,
  		height: 76,
  		xoffset: 7,
  		yoffset: 23,
  		xadvance: 62,
  		chnl: 15,
  		x: 368,
  		y: 838,
  		page: 0
  	},
  	{
  		id: 181,
  		index: 1184,
  		char: "",
  		width: 48,
  		height: 75,
  		xoffset: 7,
  		yoffset: 45,
  		xadvance: 62,
  		chnl: 15,
  		x: 362,
  		y: 661,
  		page: 0
  	},
  	{
  		id: 228,
  		index: 335,
  		char: "",
  		width: 52,
  		height: 75,
  		xoffset: 4,
  		yoffset: 25,
  		xadvance: 57,
  		chnl: 15,
  		x: 391,
  		y: 579,
  		page: 0
  	},
  	{
  		id: 235,
  		index: 375,
  		char: "",
  		width: 50,
  		height: 75,
  		xoffset: 4,
  		yoffset: 25,
  		xadvance: 58,
  		chnl: 15,
  		x: 394,
  		y: 737,
  		page: 0
  	},
  	{
  		id: 246,
  		index: 454,
  		char: "",
  		width: 52,
  		height: 75,
  		xoffset: 4,
  		yoffset: 25,
  		xadvance: 60,
  		chnl: 15,
  		x: 411,
  		y: 655,
  		page: 0
  	},
  	{
  		id: 162,
  		index: 1112,
  		char: "",
  		width: 49,
  		height: 74,
  		xoffset: 5,
  		yoffset: 35,
  		xadvance: 57,
  		chnl: 15,
  		x: 371,
  		y: 915,
  		page: 0
  	},
  	{
  		id: 239,
  		index: 406,
  		char: "",
  		width: 31,
  		height: 74,
  		xoffset: -2,
  		yoffset: 25,
  		xadvance: 27,
  		chnl: 15,
  		x: 417,
  		y: 813,
  		page: 0
  	},
  	{
  		id: 252,
  		index: 516,
  		char: "",
  		width: 48,
  		height: 74,
  		xoffset: 7,
  		yoffset: 26,
  		xadvance: 62,
  		chnl: 15,
  		x: 445,
  		y: 731,
  		page: 0
  	},
  	{
  		id: 38,
  		index: 1231,
  		char: "&",
  		width: 62,
  		height: 72,
  		xoffset: 3,
  		yoffset: 28,
  		xadvance: 62,
  		chnl: 15,
  		x: 422,
  		y: 460,
  		page: 0
  	},
  	{
  		id: 48,
  		index: 884,
  		char: "0",
  		width: 53,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 62,
  		chnl: 15,
  		x: 458,
  		y: 381,
  		page: 0
  	},
  	{
  		id: 51,
  		index: 887,
  		char: "3",
  		width: 51,
  		height: 72,
  		xoffset: 2,
  		yoffset: 28,
  		xadvance: 58,
  		chnl: 15,
  		x: 444,
  		y: 533,
  		page: 0
  	},
  	{
  		id: 54,
  		index: 890,
  		char: "6",
  		width: 52,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 61,
  		chnl: 15,
  		x: 485,
  		y: 454,
  		page: 0
  	},
  	{
  		id: 56,
  		index: 892,
  		char: "8",
  		width: 52,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 62,
  		chnl: 15,
  		x: 464,
  		y: 606,
  		page: 0
  	},
  	{
  		id: 57,
  		index: 893,
  		char: "9",
  		width: 52,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 62,
  		chnl: 15,
  		x: 496,
  		y: 527,
  		page: 0
  	},
  	{
  		id: 63,
  		index: 1024,
  		char: "?",
  		width: 49,
  		height: 72,
  		xoffset: 2,
  		yoffset: 28,
  		xadvance: 54,
  		chnl: 15,
  		x: 421,
  		y: 888,
  		page: 0
  	},
  	{
  		id: 67,
  		index: 29,
  		char: "C",
  		width: 61,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 69,
  		chnl: 15,
  		x: 449,
  		y: 806,
  		page: 0
  	},
  	{
  		id: 71,
  		index: 70,
  		char: "G",
  		width: 62,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 72,
  		chnl: 15,
  		x: 494,
  		y: 679,
  		page: 0
  	},
  	{
  		id: 79,
  		index: 125,
  		char: "O",
  		width: 65,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 75,
  		chnl: 15,
  		x: 517,
  		y: 600,
  		page: 0
  	},
  	{
  		id: 83,
  		index: 171,
  		char: "S",
  		width: 58,
  		height: 72,
  		xoffset: 2,
  		yoffset: 28,
  		xadvance: 64,
  		chnl: 15,
  		x: 469,
  		y: 242,
  		page: 0
  	},
  	{
  		id: 163,
  		index: 1130,
  		char: "",
  		width: 58,
  		height: 72,
  		xoffset: 2,
  		yoffset: 28,
  		xadvance: 62,
  		chnl: 15,
  		x: 478,
  		y: 158,
  		page: 0
  	},
  	{
  		id: 8364,
  		index: 1117,
  		char: "",
  		width: 64,
  		height: 72,
  		xoffset: 4,
  		yoffset: 28,
  		xadvance: 70,
  		chnl: 15,
  		x: 518,
  		y: 77,
  		page: 0
  	},
  	{
  		id: 169,
  		index: 1234,
  		char: "",
  		width: 72,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 82,
  		chnl: 15,
  		x: 544,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 174,
  		index: 1235,
  		char: "",
  		width: 72,
  		height: 72,
  		xoffset: 5,
  		yoffset: 28,
  		xadvance: 82,
  		chnl: 15,
  		x: 512,
  		y: 315,
  		page: 0
  	},
  	{
  		id: 191,
  		index: 1025,
  		char: "",
  		width: 49,
  		height: 72,
  		xoffset: 3,
  		yoffset: 44,
  		xadvance: 54,
  		chnl: 15,
  		x: 528,
  		y: 231,
  		page: 0
  	},
  	{
  		id: 33,
  		index: 1022,
  		char: "!",
  		width: 17,
  		height: 71,
  		xoffset: 5,
  		yoffset: 29,
  		xadvance: 27,
  		chnl: 15,
  		x: 537,
  		y: 150,
  		page: 0
  	},
  	{
  		id: 50,
  		index: 886,
  		char: "2",
  		width: 51,
  		height: 71,
  		xoffset: 3,
  		yoffset: 28,
  		xadvance: 58,
  		chnl: 15,
  		x: 555,
  		y: 150,
  		page: 0
  	},
  	{
  		id: 53,
  		index: 889,
  		char: "5",
  		width: 50,
  		height: 71,
  		xoffset: 4,
  		yoffset: 29,
  		xadvance: 58,
  		chnl: 15,
  		x: 583,
  		y: 73,
  		page: 0
  	},
  	{
  		id: 74,
  		index: 98,
  		char: "J",
  		width: 46,
  		height: 71,
  		xoffset: 2,
  		yoffset: 29,
  		xadvance: 57,
  		chnl: 15,
  		x: 617,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 85,
  		index: 191,
  		char: "U",
  		width: 56,
  		height: 71,
  		xoffset: 8,
  		yoffset: 29,
  		xadvance: 71,
  		chnl: 15,
  		x: 578,
  		y: 222,
  		page: 0
  	},
  	{
  		id: 161,
  		index: 1023,
  		char: "",
  		width: 17,
  		height: 71,
  		xoffset: 5,
  		yoffset: 44,
  		xadvance: 26,
  		chnl: 15,
  		x: 607,
  		y: 145,
  		page: 0
  	},
  	{
  		id: 35,
  		index: 1029,
  		char: "#",
  		width: 64,
  		height: 70,
  		xoffset: 0,
  		yoffset: 29,
  		xadvance: 64,
  		chnl: 15,
  		x: 625,
  		y: 145,
  		page: 0
  	},
  	{
  		id: 49,
  		index: 885,
  		char: "1",
  		width: 31,
  		height: 70,
  		xoffset: 0,
  		yoffset: 29,
  		xadvance: 39,
  		chnl: 15,
  		x: 634,
  		y: 72,
  		page: 0
  	},
  	{
  		id: 52,
  		index: 888,
  		char: "4",
  		width: 56,
  		height: 70,
  		xoffset: 2,
  		yoffset: 29,
  		xadvance: 61,
  		chnl: 15,
  		x: 664,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 55,
  		index: 891,
  		char: "7",
  		width: 53,
  		height: 70,
  		xoffset: 2,
  		yoffset: 29,
  		xadvance: 56,
  		chnl: 15,
  		x: 666,
  		y: 71,
  		page: 0
  	},
  	{
  		id: 59,
  		index: 1020,
  		char: ";",
  		width: 19,
  		height: 70,
  		xoffset: 5,
  		yoffset: 44,
  		xadvance: 30,
  		chnl: 15,
  		x: 538,
  		y: 388,
  		page: 0
  	},
  	{
  		id: 65,
  		index: 1,
  		char: "A",
  		width: 65,
  		height: 70,
  		xoffset: 1,
  		yoffset: 29,
  		xadvance: 66,
  		chnl: 15,
  		x: 549,
  		y: 459,
  		page: 0
  	},
  	{
  		id: 66,
  		index: 28,
  		char: "B",
  		width: 52,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 65,
  		chnl: 15,
  		x: 558,
  		y: 388,
  		page: 0
  	},
  	{
  		id: 68,
  		index: 36,
  		char: "D",
  		width: 59,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 72,
  		chnl: 15,
  		x: 585,
  		y: 294,
  		page: 0
  	},
  	{
  		id: 69,
  		index: 46,
  		char: "E",
  		width: 52,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 64,
  		chnl: 15,
  		x: 635,
  		y: 216,
  		page: 0
  	},
  	{
  		id: 70,
  		index: 69,
  		char: "F",
  		width: 50,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 61,
  		chnl: 15,
  		x: 611,
  		y: 365,
  		page: 0
  	},
  	{
  		id: 72,
  		index: 77,
  		char: "H",
  		width: 56,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 73,
  		chnl: 15,
  		x: 645,
  		y: 287,
  		page: 0
  	},
  	{
  		id: 73,
  		index: 82,
  		char: "I",
  		width: 12,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 30,
  		chnl: 15,
  		x: 688,
  		y: 216,
  		page: 0
  	},
  	{
  		id: 75,
  		index: 100,
  		char: "K",
  		width: 56,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 66,
  		chnl: 15,
  		x: 690,
  		y: 142,
  		page: 0
  	},
  	{
  		id: 76,
  		index: 102,
  		char: "L",
  		width: 50,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 60,
  		chnl: 15,
  		x: 720,
  		y: 71,
  		page: 0
  	},
  	{
  		id: 77,
  		index: 112,
  		char: "M",
  		width: 68,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 85,
  		chnl: 15,
  		x: 721,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 78,
  		index: 114,
  		char: "N",
  		width: 56,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 73,
  		chnl: 15,
  		x: 701,
  		y: 213,
  		page: 0
  	},
  	{
  		id: 80,
  		index: 160,
  		char: "P",
  		width: 50,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 61,
  		chnl: 15,
  		x: 747,
  		y: 142,
  		page: 0
  	},
  	{
  		id: 82,
  		index: 163,
  		char: "R",
  		width: 55,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 67,
  		chnl: 15,
  		x: 771,
  		y: 71,
  		page: 0
  	},
  	{
  		id: 84,
  		index: 184,
  		char: "T",
  		width: 58,
  		height: 70,
  		xoffset: 1,
  		yoffset: 29,
  		xadvance: 60,
  		chnl: 15,
  		x: 790,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 86,
  		index: 214,
  		char: "V",
  		width: 63,
  		height: 70,
  		xoffset: 1,
  		yoffset: 29,
  		xadvance: 65,
  		chnl: 15,
  		x: 471,
  		y: 879,
  		page: 0
  	},
  	{
  		id: 88,
  		index: 220,
  		char: "X",
  		width: 58,
  		height: 70,
  		xoffset: 1,
  		yoffset: 29,
  		xadvance: 60,
  		chnl: 15,
  		x: 471,
  		y: 950,
  		page: 0
  	},
  	{
  		id: 89,
  		index: 221,
  		char: "Y",
  		width: 59,
  		height: 70,
  		xoffset: -1,
  		yoffset: 29,
  		xadvance: 57,
  		chnl: 15,
  		x: 530,
  		y: 950,
  		page: 0
  	},
  	{
  		id: 90,
  		index: 231,
  		char: "Z",
  		width: 56,
  		height: 70,
  		xoffset: 4,
  		yoffset: 29,
  		xadvance: 63,
  		chnl: 15,
  		x: 511,
  		y: 752,
  		page: 0
  	},
  	{
  		id: 165,
  		index: 1132,
  		char: "",
  		width: 59,
  		height: 70,
  		xoffset: 1,
  		yoffset: 29,
  		xadvance: 62,
  		chnl: 15,
  		x: 557,
  		y: 673,
  		page: 0
  	},
  	{
  		id: 208,
  		index: 39,
  		char: "",
  		width: 68,
  		height: 70,
  		xoffset: 1,
  		yoffset: 29,
  		xadvance: 74,
  		chnl: 15,
  		x: 535,
  		y: 823,
  		page: 0
  	},
  	{
  		id: 222,
  		index: 161,
  		char: "",
  		width: 51,
  		height: 70,
  		xoffset: 9,
  		yoffset: 29,
  		xadvance: 63,
  		chnl: 15,
  		x: 568,
  		y: 744,
  		page: 0
  	},
  	{
  		id: 116,
  		index: 503,
  		char: "t",
  		width: 41,
  		height: 69,
  		xoffset: 1,
  		yoffset: 31,
  		xadvance: 42,
  		chnl: 15,
  		x: 549,
  		y: 530,
  		page: 0
  	},
  	{
  		id: 177,
  		index: 1170,
  		char: "",
  		width: 53,
  		height: 68,
  		xoffset: 4,
  		yoffset: 31,
  		xadvance: 60,
  		chnl: 15,
  		x: 583,
  		y: 600,
  		page: 0
  	},
  	{
  		id: 248,
  		index: 472,
  		char: "",
  		width: 53,
  		height: 60,
  		xoffset: 4,
  		yoffset: 42,
  		xadvance: 60,
  		chnl: 15,
  		x: 591,
  		y: 530,
  		page: 0
  	},
  	{
  		id: 60,
  		index: 1167,
  		char: "<",
  		width: 52,
  		height: 58,
  		xoffset: 5,
  		yoffset: 38,
  		xadvance: 60,
  		chnl: 15,
  		x: 617,
  		y: 669,
  		page: 0
  	},
  	{
  		id: 62,
  		index: 1166,
  		char: ">",
  		width: 52,
  		height: 58,
  		xoffset: 4,
  		yoffset: 38,
  		xadvance: 60,
  		chnl: 15,
  		x: 637,
  		y: 591,
  		page: 0
  	},
  	{
  		id: 95,
  		index: 1067,
  		char: "_",
  		width: 58,
  		height: 11,
  		xoffset: -2,
  		yoffset: 105,
  		xadvance: 54,
  		chnl: 15,
  		x: 151,
  		y: 641,
  		page: 0
  	},
  	{
  		id: 58,
  		index: 1019,
  		char: ":",
  		width: 17,
  		height: 56,
  		xoffset: 6,
  		yoffset: 44,
  		xadvance: 30,
  		chnl: 15,
  		x: 287,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 97,
  		index: 320,
  		char: "a",
  		width: 52,
  		height: 56,
  		xoffset: 4,
  		yoffset: 44,
  		xadvance: 57,
  		chnl: 15,
  		x: 615,
  		y: 436,
  		page: 0
  	},
  	{
  		id: 99,
  		index: 348,
  		char: "c",
  		width: 49,
  		height: 56,
  		xoffset: 4,
  		yoffset: 44,
  		xadvance: 56,
  		chnl: 15,
  		x: 421,
  		y: 961,
  		page: 0
  	},
  	{
  		id: 101,
  		index: 363,
  		char: "e",
  		width: 50,
  		height: 56,
  		xoffset: 4,
  		yoffset: 44,
  		xadvance: 58,
  		chnl: 15,
  		x: 662,
  		y: 358,
  		page: 0
  	},
  	{
  		id: 111,
  		index: 444,
  		char: "o",
  		width: 52,
  		height: 56,
  		xoffset: 4,
  		yoffset: 44,
  		xadvance: 60,
  		chnl: 15,
  		x: 702,
  		y: 284,
  		page: 0
  	},
  	{
  		id: 115,
  		index: 490,
  		char: "s",
  		width: 47,
  		height: 56,
  		xoffset: 2,
  		yoffset: 44,
  		xadvance: 53,
  		chnl: 15,
  		x: 645,
  		y: 493,
  		page: 0
  	},
  	{
  		id: 247,
  		index: 1163,
  		char: "",
  		width: 53,
  		height: 56,
  		xoffset: 4,
  		yoffset: 37,
  		xadvance: 60,
  		chnl: 15,
  		x: 668,
  		y: 415,
  		page: 0
  	},
  	{
  		id: 94,
  		index: 1174,
  		char: "^",
  		width: 55,
  		height: 42,
  		xoffset: 1,
  		yoffset: 22,
  		xadvance: 56,
  		chnl: 15,
  		x: 535,
  		y: 894,
  		page: 0
  	},
  	{
  		id: 110,
  		index: 434,
  		char: "n",
  		width: 48,
  		height: 55,
  		xoffset: 7,
  		yoffset: 44,
  		xadvance: 62,
  		chnl: 15,
  		x: 713,
  		y: 341,
  		page: 0
  	},
  	{
  		id: 114,
  		index: 482,
  		char: "r",
  		width: 33,
  		height: 55,
  		xoffset: 7,
  		yoffset: 44,
  		xadvance: 41,
  		chnl: 15,
  		x: 755,
  		y: 284,
  		page: 0
  	},
  	{
  		id: 117,
  		index: 511,
  		char: "u",
  		width: 48,
  		height: 55,
  		xoffset: 7,
  		yoffset: 45,
  		xadvance: 62,
  		chnl: 15,
  		x: 758,
  		y: 213,
  		page: 0
  	},
  	{
  		id: 43,
  		index: 1160,
  		char: "+",
  		width: 53,
  		height: 54,
  		xoffset: 4,
  		yoffset: 39,
  		xadvance: 60,
  		chnl: 15,
  		x: 798,
  		y: 142,
  		page: 0
  	},
  	{
  		id: 118,
  		index: 534,
  		char: "v",
  		width: 54,
  		height: 54,
  		xoffset: -1,
  		yoffset: 45,
  		xadvance: 52,
  		chnl: 15,
  		x: 827,
  		y: 71,
  		page: 0
  	},
  	{
  		id: 120,
  		index: 540,
  		char: "x",
  		width: 51,
  		height: 54,
  		xoffset: 1,
  		yoffset: 45,
  		xadvance: 53,
  		chnl: 15,
  		x: 849,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 122,
  		index: 551,
  		char: "z",
  		width: 46,
  		height: 54,
  		xoffset: 4,
  		yoffset: 45,
  		xadvance: 53,
  		chnl: 15,
  		x: 590,
  		y: 937,
  		page: 0
  	},
  	{
  		id: 172,
  		index: 1173,
  		char: "",
  		width: 53,
  		height: 26,
  		xoffset: 4,
  		yoffset: 60,
  		xadvance: 60,
  		chnl: 15,
  		x: 239,
  		y: 602,
  		page: 0
  	},
  	{
  		id: 61,
  		index: 1164,
  		char: "=",
  		width: 52,
  		height: 32,
  		xoffset: 4,
  		yoffset: 51,
  		xadvance: 60,
  		chnl: 15,
  		x: 590,
  		y: 992,
  		page: 0
  	},
  	{
  		id: 42,
  		index: 1028,
  		char: "*",
  		width: 51,
  		height: 48,
  		xoffset: 3,
  		yoffset: 22,
  		xadvance: 57,
  		chnl: 15,
  		x: 901,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 170,
  		index: 879,
  		char: "",
  		width: 38,
  		height: 50,
  		xoffset: 1,
  		yoffset: 29,
  		xadvance: 38,
  		chnl: 15,
  		x: 210,
  		y: 698,
  		page: 0
  	},
  	{
  		id: 186,
  		index: 880,
  		char: "",
  		width: 35,
  		height: 50,
  		xoffset: 0,
  		yoffset: 29,
  		xadvance: 36,
  		chnl: 15,
  		x: 428,
  		y: 242,
  		page: 0
  	},
  	{
  		id: 126,
  		index: 1172,
  		char: "~",
  		width: 49,
  		height: 19,
  		xoffset: 2,
  		yoffset: 57,
  		xadvance: 54,
  		chnl: 15,
  		x: 371,
  		y: 990,
  		page: 0
  	},
  	{
  		id: 215,
  		index: 1162,
  		char: "",
  		width: 48,
  		height: 48,
  		xoffset: 6,
  		yoffset: 41,
  		xadvance: 60,
  		chnl: 15,
  		x: 953,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 179,
  		index: 990,
  		char: "",
  		width: 34,
  		height: 45,
  		xoffset: 0,
  		yoffset: 22,
  		xadvance: 36,
  		chnl: 15,
  		x: 265,
  		y: 857,
  		page: 0
  	},
  	{
  		id: 178,
  		index: 989,
  		char: "",
  		width: 35,
  		height: 44,
  		xoffset: 1,
  		yoffset: 22,
  		xadvance: 37,
  		chnl: 15,
  		x: 469,
  		y: 315,
  		page: 0
  	},
  	{
  		id: 185,
  		index: 988,
  		char: "",
  		width: 22,
  		height: 44,
  		xoffset: -1,
  		yoffset: 22,
  		xadvance: 24,
  		chnl: 15,
  		x: 1002,
  		y: 0,
  		page: 0
  	},
  	{
  		id: 171,
  		index: 1078,
  		char: "",
  		width: 43,
  		height: 43,
  		xoffset: 3,
  		yoffset: 49,
  		xadvance: 49,
  		chnl: 15,
  		x: 604,
  		y: 815,
  		page: 0
  	},
  	{
  		id: 187,
  		index: 1079,
  		char: "",
  		width: 43,
  		height: 43,
  		xoffset: 3,
  		yoffset: 49,
  		xadvance: 49,
  		chnl: 15,
  		x: 604,
  		y: 859,
  		page: 0
  	},
  	{
  		id: 176,
  		index: 1237,
  		char: "",
  		width: 38,
  		height: 37,
  		xoffset: 4,
  		yoffset: 28,
  		xadvance: 46,
  		chnl: 15,
  		x: 645,
  		y: 550,
  		page: 0
  	},
  	{
  		id: 45,
  		index: 1059,
  		char: "-",
  		width: 37,
  		height: 12,
  		xoffset: 7,
  		yoffset: 65,
  		xadvance: 51,
  		chnl: 15,
  		x: 265,
  		y: 422,
  		page: 0
  	},
  	{
  		id: 175,
  		index: 1301,
  		char: "",
  		width: 37,
  		height: 11,
  		xoffset: 7,
  		yoffset: 29,
  		xadvance: 50,
  		chnl: 15,
  		x: 239,
  		y: 629,
  		page: 0
  	},
  	{
  		id: 8217,
  		index: 1077,
  		char: "",
  		width: 19,
  		height: 31,
  		xoffset: 4,
  		yoffset: 25,
  		xadvance: 26,
  		chnl: 15,
  		x: 392,
  		y: 83,
  		page: 0
  	},
  	{
  		id: 44,
  		index: 1018,
  		char: ",",
  		width: 19,
  		height: 31,
  		xoffset: 4,
  		yoffset: 83,
  		xadvance: 27,
  		chnl: 15,
  		x: 444,
  		y: 606,
  		page: 0
  	},
  	{
  		id: 34,
  		index: 1082,
  		char: "\"",
  		width: 30,
  		height: 29,
  		xoffset: 6,
  		yoffset: 26,
  		xadvance: 40,
  		chnl: 15,
  		x: 376,
  		y: 382,
  		page: 0
  	},
  	{
  		id: 39,
  		index: 1083,
  		char: "'",
  		width: 13,
  		height: 29,
  		xoffset: 6,
  		yoffset: 26,
  		xadvance: 23,
  		chnl: 15,
  		x: 408,
  		y: 460,
  		page: 0
  	},
  	{
  		id: 96,
  		index: 1293,
  		char: "`",
  		width: 20,
  		height: 21,
  		xoffset: 15,
  		yoffset: 20,
  		xadvance: 50,
  		chnl: 15,
  		x: 422,
  		y: 533,
  		page: 0
  	},
  	{
  		id: 46,
  		index: 1017,
  		char: ".",
  		width: 17,
  		height: 17,
  		xoffset: 5,
  		yoffset: 83,
  		xadvance: 27,
  		chnl: 15,
  		x: 255,
  		y: 528,
  		page: 0
  	},
  	{
  		id: 183,
  		index: 1026,
  		char: "",
  		width: 17,
  		height: 17,
  		xoffset: 3,
  		yoffset: 53,
  		xadvance: 23,
  		chnl: 15,
  		x: 303,
  		y: 503,
  		page: 0
  	},
  	{
  		id: 32,
  		index: 1105,
  		char: " ",
  		width: 0,
  		height: 0,
  		xoffset: -2,
  		yoffset: 95,
  		xadvance: 34,
  		chnl: 15,
  		x: 57,
  		y: 851,
  		page: 0
  	}
  ];
  var info = {
  	face: "WorkSans-Regular",
  	size: 100,
  	bold: 0,
  	italic: 0,
  	charset: [
  		"!",
  		"\"",
  		"'",
  		"",
  		"`",
  		"#",
  		"$",
  		"%",
  		"&",
  		"(",
  		")",
  		"*",
  		"+",
  		",",
  		"-",
  		".",
  		"/",
  		"0",
  		"1",
  		"2",
  		"3",
  		"4",
  		"5",
  		"6",
  		"7",
  		"8",
  		"9",
  		":",
  		";",
  		"<",
  		"=",
  		">",
  		"?",
  		"@",
  		"A",
  		"B",
  		"C",
  		"D",
  		"E",
  		"F",
  		"G",
  		"H",
  		"I",
  		"J",
  		"K",
  		"L",
  		"M",
  		"N",
  		"O",
  		"P",
  		"Q",
  		"R",
  		"S",
  		"T",
  		"U",
  		"V",
  		"W",
  		"X",
  		"Y",
  		"Z",
  		"[",
  		"]",
  		"^",
  		"_",
  		"a",
  		"b",
  		"c",
  		"d",
  		"e",
  		"f",
  		"g",
  		"h",
  		"i",
  		"j",
  		"k",
  		"l",
  		"m",
  		"n",
  		"o",
  		"p",
  		"q",
  		"r",
  		"s",
  		"t",
  		"u",
  		"v",
  		"w",
  		"x",
  		"y",
  		"z",
  		"{",
  		"|",
  		"}",
  		"~",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"",
  		"\\",
  		" "
  	],
  	unicode: 1,
  	stretchH: 100,
  	smooth: 1,
  	aa: 1,
  	padding: [
  		2,
  		2,
  		2,
  		2
  	],
  	spacing: [
  		0,
  		0
  	],
  	outline: 0
  };
  var common = {
  	lineHeight: 117,
  	base: 95,
  	scaleW: 1024,
  	scaleH: 1024,
  	pages: 1,
  	packed: 0,
  	alphaChnl: 0,
  	redChnl: 0,
  	greenChnl: 0,
  	blueChnl: 0
  };
  var distanceField = {
  	fieldType: "msdf",
  	distanceRange: 4
  };
  var kernings = [
  	{
  		first: 34,
  		second: 38,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 44,
  		amount: -12
  	},
  	{
  		first: 34,
  		second: 45,
  		amount: -9
  	},
  	{
  		first: 34,
  		second: 46,
  		amount: -12
  	},
  	{
  		first: 34,
  		second: 47,
  		amount: -6
  	},
  	{
  		first: 34,
  		second: 52,
  		amount: -9
  	},
  	{
  		first: 34,
  		second: 64,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 65,
  		amount: -10
  	},
  	{
  		first: 34,
  		second: 74,
  		amount: -12
  	},
  	{
  		first: 34,
  		second: 95,
  		amount: -9
  	},
  	{
  		first: 34,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 103,
  		amount: -4
  	},
  	{
  		first: 34,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 34,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 191,
  		amount: -10
  	},
  	{
  		first: 34,
  		second: 192,
  		amount: -10
  	},
  	{
  		first: 34,
  		second: 193,
  		amount: -10
  	},
  	{
  		first: 34,
  		second: 194,
  		amount: -10
  	},
  	{
  		first: 34,
  		second: 195,
  		amount: -10
  	},
  	{
  		first: 34,
  		second: 196,
  		amount: -10
  	},
  	{
  		first: 34,
  		second: 197,
  		amount: -10
  	},
  	{
  		first: 34,
  		second: 198,
  		amount: -14
  	},
  	{
  		first: 34,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 34,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 240,
  		amount: -3
  	},
  	{
  		first: 34,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 34,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 38,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 44,
  		amount: -12
  	},
  	{
  		first: 39,
  		second: 45,
  		amount: -9
  	},
  	{
  		first: 39,
  		second: 46,
  		amount: -12
  	},
  	{
  		first: 39,
  		second: 47,
  		amount: -6
  	},
  	{
  		first: 39,
  		second: 52,
  		amount: -9
  	},
  	{
  		first: 39,
  		second: 64,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 65,
  		amount: -10
  	},
  	{
  		first: 39,
  		second: 74,
  		amount: -12
  	},
  	{
  		first: 39,
  		second: 95,
  		amount: -9
  	},
  	{
  		first: 39,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 103,
  		amount: -4
  	},
  	{
  		first: 39,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 39,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 191,
  		amount: -10
  	},
  	{
  		first: 39,
  		second: 192,
  		amount: -10
  	},
  	{
  		first: 39,
  		second: 193,
  		amount: -10
  	},
  	{
  		first: 39,
  		second: 194,
  		amount: -10
  	},
  	{
  		first: 39,
  		second: 195,
  		amount: -10
  	},
  	{
  		first: 39,
  		second: 196,
  		amount: -10
  	},
  	{
  		first: 39,
  		second: 197,
  		amount: -10
  	},
  	{
  		first: 39,
  		second: 198,
  		amount: -14
  	},
  	{
  		first: 39,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 39,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 240,
  		amount: -3
  	},
  	{
  		first: 39,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 39,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 8217,
  		second: 38,
  		amount: -2
  	},
  	{
  		first: 8217,
  		second: 44,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 45,
  		amount: -8
  	},
  	{
  		first: 8217,
  		second: 46,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 47,
  		amount: -6
  	},
  	{
  		first: 8217,
  		second: 52,
  		amount: -12
  	},
  	{
  		first: 8217,
  		second: 53,
  		amount: -2
  	},
  	{
  		first: 8217,
  		second: 64,
  		amount: -2
  	},
  	{
  		first: 8217,
  		second: 65,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 74,
  		amount: -14
  	},
  	{
  		first: 8217,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 86,
  		amount: 1
  	},
  	{
  		first: 8217,
  		second: 87,
  		amount: 1
  	},
  	{
  		first: 8217,
  		second: 95,
  		amount: -8
  	},
  	{
  		first: 8217,
  		second: 97,
  		amount: -3
  	},
  	{
  		first: 8217,
  		second: 99,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 100,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 101,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 103,
  		amount: -6
  	},
  	{
  		first: 8217,
  		second: 109,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 110,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 111,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 112,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 113,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 114,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 115,
  		amount: -5
  	},
  	{
  		first: 8217,
  		second: 118,
  		amount: 3
  	},
  	{
  		first: 8217,
  		second: 119,
  		amount: 1
  	},
  	{
  		first: 8217,
  		second: 162,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 353,
  		amount: -5
  	},
  	{
  		first: 8217,
  		second: 171,
  		amount: -5
  	},
  	{
  		first: 8217,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 339,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 192,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 193,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 194,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 195,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 196,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 197,
  		amount: -13
  	},
  	{
  		first: 8217,
  		second: 198,
  		amount: -11
  	},
  	{
  		first: 8217,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 224,
  		amount: -3
  	},
  	{
  		first: 8217,
  		second: 225,
  		amount: -3
  	},
  	{
  		first: 8217,
  		second: 226,
  		amount: -3
  	},
  	{
  		first: 8217,
  		second: 227,
  		amount: -3
  	},
  	{
  		first: 8217,
  		second: 228,
  		amount: -3
  	},
  	{
  		first: 8217,
  		second: 229,
  		amount: -3
  	},
  	{
  		first: 8217,
  		second: 230,
  		amount: -3
  	},
  	{
  		first: 8217,
  		second: 231,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 232,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 233,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 234,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 235,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 238,
  		amount: 7
  	},
  	{
  		first: 8217,
  		second: 239,
  		amount: 5
  	},
  	{
  		first: 8217,
  		second: 240,
  		amount: -5
  	},
  	{
  		first: 8217,
  		second: 241,
  		amount: -1
  	},
  	{
  		first: 8217,
  		second: 242,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 243,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 244,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 245,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 246,
  		amount: -4
  	},
  	{
  		first: 8217,
  		second: 248,
  		amount: -4
  	},
  	{
  		first: 36,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 36,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 84,
  		amount: -3
  	},
  	{
  		first: 36,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 36,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 36,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 117,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 36,
  		second: 122,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 382,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 36,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 36,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 36,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 36,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 249,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 250,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 251,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 252,
  		amount: 0
  	},
  	{
  		first: 36,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 36,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 38,
  		second: 34,
  		amount: -4
  	},
  	{
  		first: 38,
  		second: 39,
  		amount: -4
  	},
  	{
  		first: 38,
  		second: 8217,
  		amount: -3
  	},
  	{
  		first: 38,
  		second: 55,
  		amount: -8
  	},
  	{
  		first: 38,
  		second: 74,
  		amount: 3
  	},
  	{
  		first: 38,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 38,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 38,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 38,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 38,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 38,
  		second: 105,
  		amount: 3
  	},
  	{
  		first: 38,
  		second: 106,
  		amount: 3
  	},
  	{
  		first: 38,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 38,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 38,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 38,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 38,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 38,
  		second: 236,
  		amount: 3
  	},
  	{
  		first: 38,
  		second: 237,
  		amount: 3
  	},
  	{
  		first: 38,
  		second: 238,
  		amount: 3
  	},
  	{
  		first: 38,
  		second: 239,
  		amount: 3
  	},
  	{
  		first: 38,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 38,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 36,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 40,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 48,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 49,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 50,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 51,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 52,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 53,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 54,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 56,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 57,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 67,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 71,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 74,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 79,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 81,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 83,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 97,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 99,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 100,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 101,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 106,
  		amount: 7
  	},
  	{
  		first: 40,
  		second: 109,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 110,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 111,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 112,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 113,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 114,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 115,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 117,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 118,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 119,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 122,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 123,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 162,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 352,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 353,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 382,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 338,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 339,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 40,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 199,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 40,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 210,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 211,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 212,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 213,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 214,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 216,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 40,
  		second: 224,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 225,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 226,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 227,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 228,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 229,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 230,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 231,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 232,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 233,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 234,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 235,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 240,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 241,
  		amount: -3
  	},
  	{
  		first: 40,
  		second: 242,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 243,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 244,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 245,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 246,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 248,
  		amount: -5
  	},
  	{
  		first: 40,
  		second: 249,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 250,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 251,
  		amount: -4
  	},
  	{
  		first: 40,
  		second: 252,
  		amount: -4
  	},
  	{
  		first: 41,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 41,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 41,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 44,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 42,
  		second: 46,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 65,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 74,
  		amount: -6
  	},
  	{
  		first: 42,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 42,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 42,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 103,
  		amount: -4
  	},
  	{
  		first: 42,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 115,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 353,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 192,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 193,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 194,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 195,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 196,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 197,
  		amount: -8
  	},
  	{
  		first: 42,
  		second: 198,
  		amount: -11
  	},
  	{
  		first: 42,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 42,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 240,
  		amount: -3
  	},
  	{
  		first: 42,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 42,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 43,
  		second: 49,
  		amount: -1
  	},
  	{
  		first: 43,
  		second: 50,
  		amount: -2
  	},
  	{
  		first: 43,
  		second: 51,
  		amount: -2
  	},
  	{
  		first: 43,
  		second: 55,
  		amount: -4
  	},
  	{
  		first: 44,
  		second: 34,
  		amount: -12
  	},
  	{
  		first: 44,
  		second: 39,
  		amount: -12
  	},
  	{
  		first: 44,
  		second: 8217,
  		amount: -12
  	},
  	{
  		first: 44,
  		second: 42,
  		amount: -12
  	},
  	{
  		first: 44,
  		second: 45,
  		amount: -9
  	},
  	{
  		first: 44,
  		second: 48,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 49,
  		amount: -12
  	},
  	{
  		first: 44,
  		second: 52,
  		amount: -1
  	},
  	{
  		first: 44,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 44,
  		second: 55,
  		amount: -9
  	},
  	{
  		first: 44,
  		second: 65,
  		amount: 1
  	},
  	{
  		first: 44,
  		second: 67,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 71,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 79,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 81,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 44,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 86,
  		amount: -12
  	},
  	{
  		first: 44,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 44,
  		second: 88,
  		amount: 2
  	},
  	{
  		first: 44,
  		second: 89,
  		amount: -13
  	},
  	{
  		first: 44,
  		second: 90,
  		amount: 2
  	},
  	{
  		first: 44,
  		second: 95,
  		amount: -9
  	},
  	{
  		first: 44,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 102,
  		amount: -4
  	},
  	{
  		first: 44,
  		second: 103,
  		amount: 2
  	},
  	{
  		first: 44,
  		second: 108,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 116,
  		amount: -5
  	},
  	{
  		first: 44,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 118,
  		amount: -7
  	},
  	{
  		first: 44,
  		second: 119,
  		amount: -8
  	},
  	{
  		first: 44,
  		second: 121,
  		amount: -7
  	},
  	{
  		first: 44,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 170,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 381,
  		amount: 2
  	},
  	{
  		first: 44,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 44,
  		second: 338,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 376,
  		amount: -13
  	},
  	{
  		first: 44,
  		second: 192,
  		amount: 1
  	},
  	{
  		first: 44,
  		second: 193,
  		amount: 1
  	},
  	{
  		first: 44,
  		second: 194,
  		amount: 1
  	},
  	{
  		first: 44,
  		second: 195,
  		amount: 1
  	},
  	{
  		first: 44,
  		second: 196,
  		amount: 1
  	},
  	{
  		first: 44,
  		second: 197,
  		amount: 1
  	},
  	{
  		first: 44,
  		second: 198,
  		amount: 2
  	},
  	{
  		first: 44,
  		second: 199,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 210,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 211,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 212,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 213,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 214,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 216,
  		amount: -3
  	},
  	{
  		first: 44,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 221,
  		amount: -13
  	},
  	{
  		first: 44,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 44,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 44,
  		second: 253,
  		amount: -7
  	},
  	{
  		first: 44,
  		second: 255,
  		amount: -7
  	},
  	{
  		first: 45,
  		second: 34,
  		amount: -8
  	},
  	{
  		first: 45,
  		second: 39,
  		amount: -8
  	},
  	{
  		first: 45,
  		second: 8217,
  		amount: -7
  	},
  	{
  		first: 45,
  		second: 36,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 45,
  		second: 44,
  		amount: -7
  	},
  	{
  		first: 45,
  		second: 46,
  		amount: -7
  	},
  	{
  		first: 45,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 45,
  		second: 50,
  		amount: -4
  	},
  	{
  		first: 45,
  		second: 51,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 45,
  		second: 57,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 83,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 45,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 45,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 45,
  		second: 88,
  		amount: -6
  	},
  	{
  		first: 45,
  		second: 89,
  		amount: -8
  	},
  	{
  		first: 45,
  		second: 90,
  		amount: -5
  	},
  	{
  		first: 45,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 102,
  		amount: -3
  	},
  	{
  		first: 45,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 45,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 120,
  		amount: -5
  	},
  	{
  		first: 45,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 122,
  		amount: -4
  	},
  	{
  		first: 45,
  		second: 352,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 381,
  		amount: -5
  	},
  	{
  		first: 45,
  		second: 382,
  		amount: -4
  	},
  	{
  		first: 45,
  		second: 376,
  		amount: -8
  	},
  	{
  		first: 45,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 198,
  		amount: -4
  	},
  	{
  		first: 45,
  		second: 221,
  		amount: -8
  	},
  	{
  		first: 45,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 45,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 45,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 34,
  		amount: -12
  	},
  	{
  		first: 46,
  		second: 39,
  		amount: -12
  	},
  	{
  		first: 46,
  		second: 8217,
  		amount: -12
  	},
  	{
  		first: 46,
  		second: 42,
  		amount: -12
  	},
  	{
  		first: 46,
  		second: 45,
  		amount: -9
  	},
  	{
  		first: 46,
  		second: 48,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 49,
  		amount: -12
  	},
  	{
  		first: 46,
  		second: 52,
  		amount: -1
  	},
  	{
  		first: 46,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 46,
  		second: 55,
  		amount: -9
  	},
  	{
  		first: 46,
  		second: 65,
  		amount: 1
  	},
  	{
  		first: 46,
  		second: 67,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 71,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 79,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 81,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 46,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 86,
  		amount: -12
  	},
  	{
  		first: 46,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 46,
  		second: 88,
  		amount: 2
  	},
  	{
  		first: 46,
  		second: 89,
  		amount: -13
  	},
  	{
  		first: 46,
  		second: 90,
  		amount: 2
  	},
  	{
  		first: 46,
  		second: 95,
  		amount: -9
  	},
  	{
  		first: 46,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 102,
  		amount: -4
  	},
  	{
  		first: 46,
  		second: 103,
  		amount: 2
  	},
  	{
  		first: 46,
  		second: 108,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 116,
  		amount: -5
  	},
  	{
  		first: 46,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 118,
  		amount: -7
  	},
  	{
  		first: 46,
  		second: 119,
  		amount: -8
  	},
  	{
  		first: 46,
  		second: 121,
  		amount: -7
  	},
  	{
  		first: 46,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 170,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 381,
  		amount: 2
  	},
  	{
  		first: 46,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 46,
  		second: 338,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 376,
  		amount: -13
  	},
  	{
  		first: 46,
  		second: 192,
  		amount: 1
  	},
  	{
  		first: 46,
  		second: 193,
  		amount: 1
  	},
  	{
  		first: 46,
  		second: 194,
  		amount: 1
  	},
  	{
  		first: 46,
  		second: 195,
  		amount: 1
  	},
  	{
  		first: 46,
  		second: 196,
  		amount: 1
  	},
  	{
  		first: 46,
  		second: 197,
  		amount: 1
  	},
  	{
  		first: 46,
  		second: 198,
  		amount: 2
  	},
  	{
  		first: 46,
  		second: 199,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 210,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 211,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 212,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 213,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 214,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 216,
  		amount: -3
  	},
  	{
  		first: 46,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 221,
  		amount: -13
  	},
  	{
  		first: 46,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 46,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 46,
  		second: 253,
  		amount: -7
  	},
  	{
  		first: 46,
  		second: 255,
  		amount: -7
  	},
  	{
  		first: 47,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 47,
  		amount: -16
  	},
  	{
  		first: 47,
  		second: 48,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 52,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 54,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 56,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 65,
  		amount: -10
  	},
  	{
  		first: 47,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 74,
  		amount: -6
  	},
  	{
  		first: 47,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 97,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 99,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 100,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 101,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 103,
  		amount: -5
  	},
  	{
  		first: 47,
  		second: 109,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 110,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 111,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 112,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 113,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 114,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 115,
  		amount: -3
  	},
  	{
  		first: 47,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 122,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 162,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 353,
  		amount: -3
  	},
  	{
  		first: 47,
  		second: 382,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 339,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 192,
  		amount: -10
  	},
  	{
  		first: 47,
  		second: 193,
  		amount: -10
  	},
  	{
  		first: 47,
  		second: 194,
  		amount: -10
  	},
  	{
  		first: 47,
  		second: 195,
  		amount: -10
  	},
  	{
  		first: 47,
  		second: 196,
  		amount: -10
  	},
  	{
  		first: 47,
  		second: 197,
  		amount: -10
  	},
  	{
  		first: 47,
  		second: 198,
  		amount: -11
  	},
  	{
  		first: 47,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 224,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 225,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 226,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 227,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 228,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 229,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 230,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 231,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 232,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 233,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 234,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 235,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 240,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 241,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 242,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 243,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 244,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 245,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 246,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 248,
  		amount: -4
  	},
  	{
  		first: 47,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 47,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 47,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 48,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 48,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 48,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 48,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 48,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 48,
  		second: 51,
  		amount: -2
  	},
  	{
  		first: 48,
  		second: 55,
  		amount: -2
  	},
  	{
  		first: 48,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 48,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 48,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 48,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 48,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 48,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 48,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 50,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 50,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 50,
  		second: 52,
  		amount: -3
  	},
  	{
  		first: 50,
  		second: 55,
  		amount: -2
  	},
  	{
  		first: 50,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 50,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 50,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 50,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 50,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 50,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 51,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 51,
  		second: 55,
  		amount: -4
  	},
  	{
  		first: 51,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 51,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 51,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 51,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 51,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 52,
  		second: 34,
  		amount: -5
  	},
  	{
  		first: 52,
  		second: 39,
  		amount: -5
  	},
  	{
  		first: 52,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 52,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 52,
  		second: 44,
  		amount: -1
  	},
  	{
  		first: 52,
  		second: 46,
  		amount: -1
  	},
  	{
  		first: 52,
  		second: 49,
  		amount: -2
  	},
  	{
  		first: 52,
  		second: 55,
  		amount: -5
  	},
  	{
  		first: 52,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 52,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 52,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 52,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 52,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 52,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 52,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 52,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 52,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 53,
  		second: 8217,
  		amount: 0
  	},
  	{
  		first: 54,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 54,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 54,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 54,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 54,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 54,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 54,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 35,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 38,
  		amount: -8
  	},
  	{
  		first: 55,
  		second: 43,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 44,
  		amount: -10
  	},
  	{
  		first: 55,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 46,
  		amount: -10
  	},
  	{
  		first: 55,
  		second: 47,
  		amount: -6
  	},
  	{
  		first: 55,
  		second: 48,
  		amount: -2
  	},
  	{
  		first: 55,
  		second: 52,
  		amount: -7
  	},
  	{
  		first: 55,
  		second: 54,
  		amount: -2
  	},
  	{
  		first: 55,
  		second: 56,
  		amount: -2
  	},
  	{
  		first: 55,
  		second: 61,
  		amount: -2
  	},
  	{
  		first: 55,
  		second: 64,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 65,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 74,
  		amount: -6
  	},
  	{
  		first: 55,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 97,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 99,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 100,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 101,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 111,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 113,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 115,
  		amount: -2
  	},
  	{
  		first: 55,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 55,
  		second: 163,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 353,
  		amount: -2
  	},
  	{
  		first: 55,
  		second: 183,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 339,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 192,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 193,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 194,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 195,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 196,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 197,
  		amount: -5
  	},
  	{
  		first: 55,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 215,
  		amount: -2
  	},
  	{
  		first: 55,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 55,
  		second: 224,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 225,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 226,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 227,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 228,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 229,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 230,
  		amount: -3
  	},
  	{
  		first: 55,
  		second: 231,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 232,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 233,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 234,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 235,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 242,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 243,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 244,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 245,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 246,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 247,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 248,
  		amount: -4
  	},
  	{
  		first: 55,
  		second: 32,
  		amount: -3
  	},
  	{
  		first: 56,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 56,
  		second: 51,
  		amount: -2
  	},
  	{
  		first: 56,
  		second: 55,
  		amount: -4
  	},
  	{
  		first: 56,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 56,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 56,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 56,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 56,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 56,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 56,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 57,
  		second: 44,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 46,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 51,
  		amount: -2
  	},
  	{
  		first: 57,
  		second: 55,
  		amount: -2
  	},
  	{
  		first: 57,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 84,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 57,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 57,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 57,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 57,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 57,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 57,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 58,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 58,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 58,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 58,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 58,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 59,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 59,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 59,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 59,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 59,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 61,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 63,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 64,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 64,
  		second: 84,
  		amount: -3
  	},
  	{
  		first: 64,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 64,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 64,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 64,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 64,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 65,
  		second: 34,
  		amount: -10
  	},
  	{
  		first: 65,
  		second: 39,
  		amount: -10
  	},
  	{
  		first: 65,
  		second: 8217,
  		amount: -11
  	},
  	{
  		first: 65,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 42,
  		amount: -8
  	},
  	{
  		first: 65,
  		second: 44,
  		amount: 1
  	},
  	{
  		first: 65,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 46,
  		amount: 1
  	},
  	{
  		first: 65,
  		second: 49,
  		amount: -7
  	},
  	{
  		first: 65,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 65,
  		second: 63,
  		amount: -7
  	},
  	{
  		first: 65,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 65,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 86,
  		amount: -6
  	},
  	{
  		first: 65,
  		second: 87,
  		amount: -4
  	},
  	{
  		first: 65,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 65,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 65,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 115,
  		amount: 0
  	},
  	{
  		first: 65,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 65,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 65,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 65,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 65,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 353,
  		amount: 0
  	},
  	{
  		first: 65,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 186,
  		amount: -3
  	},
  	{
  		first: 65,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 65,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 65,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 65,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 65,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 65,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 65,
  		second: 92,
  		amount: -10
  	},
  	{
  		first: 65,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 66,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 66,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 84,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 87,
  		amount: 0
  	},
  	{
  		first: 66,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 66,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 66,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 66,
  		second: 103,
  		amount: 0
  	},
  	{
  		first: 66,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 66,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 66,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 66,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 66,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 66,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 67,
  		second: 44,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 45,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 46,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 67,
  		second: 95,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 198,
  		amount: -1
  	},
  	{
  		first: 67,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 68,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 68,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 68,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 68,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 68,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 68,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 68,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 68,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 69,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 69,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 69,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 69,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 69,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 69,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 69,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 69,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 70,
  		second: 38,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 44,
  		amount: -11
  	},
  	{
  		first: 70,
  		second: 45,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 46,
  		amount: -11
  	},
  	{
  		first: 70,
  		second: 47,
  		amount: -6
  	},
  	{
  		first: 70,
  		second: 52,
  		amount: -3
  	},
  	{
  		first: 70,
  		second: 58,
  		amount: -3
  	},
  	{
  		first: 70,
  		second: 59,
  		amount: -3
  	},
  	{
  		first: 70,
  		second: 64,
  		amount: -2
  	},
  	{
  		first: 70,
  		second: 65,
  		amount: -7
  	},
  	{
  		first: 70,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 74,
  		amount: -9
  	},
  	{
  		first: 70,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 95,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 97,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 99,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 100,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 101,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 103,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 109,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 110,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 111,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 112,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 113,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 114,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 115,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 117,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 70,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 70,
  		second: 120,
  		amount: -3
  	},
  	{
  		first: 70,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 70,
  		second: 122,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 162,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 353,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 70,
  		second: 382,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 187,
  		amount: -3
  	},
  	{
  		first: 70,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 339,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 192,
  		amount: -7
  	},
  	{
  		first: 70,
  		second: 193,
  		amount: -7
  	},
  	{
  		first: 70,
  		second: 194,
  		amount: -7
  	},
  	{
  		first: 70,
  		second: 195,
  		amount: -7
  	},
  	{
  		first: 70,
  		second: 196,
  		amount: -7
  	},
  	{
  		first: 70,
  		second: 197,
  		amount: -7
  	},
  	{
  		first: 70,
  		second: 198,
  		amount: -11
  	},
  	{
  		first: 70,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 223,
  		amount: -1
  	},
  	{
  		first: 70,
  		second: 224,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 225,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 226,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 227,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 228,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 229,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 230,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 231,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 232,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 233,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 234,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 235,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 238,
  		amount: 1
  	},
  	{
  		first: 70,
  		second: 240,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 241,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 242,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 243,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 244,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 245,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 246,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 248,
  		amount: -5
  	},
  	{
  		first: 70,
  		second: 249,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 250,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 251,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 252,
  		amount: -4
  	},
  	{
  		first: 70,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 70,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 70,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 71,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 71,
  		second: 84,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 71,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 71,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 71,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 72,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 72,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 72,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 73,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 73,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 73,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 97,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 224,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 225,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 226,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 227,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 228,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 229,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 230,
  		amount: -2
  	},
  	{
  		first: 74,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 74,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 74,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 75,
  		second: 36,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 42,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 45,
  		amount: -6
  	},
  	{
  		first: 75,
  		second: 52,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 67,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 71,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 79,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 81,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 83,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 95,
  		amount: -6
  	},
  	{
  		first: 75,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 99,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 100,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 101,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 111,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 113,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 115,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 118,
  		amount: -5
  	},
  	{
  		first: 75,
  		second: 119,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 75,
  		second: 162,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 352,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 353,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 169,
  		amount: -5
  	},
  	{
  		first: 75,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 174,
  		amount: -5
  	},
  	{
  		first: 75,
  		second: 338,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 339,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 199,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 210,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 211,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 212,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 213,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 214,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 216,
  		amount: -3
  	},
  	{
  		first: 75,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 75,
  		second: 231,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 232,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 233,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 234,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 235,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 240,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 242,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 243,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 244,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 245,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 246,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 248,
  		amount: -4
  	},
  	{
  		first: 75,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 75,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 75,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 75,
  		second: 32,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 34,
  		amount: -12
  	},
  	{
  		first: 76,
  		second: 39,
  		amount: -12
  	},
  	{
  		first: 76,
  		second: 8217,
  		amount: -13
  	},
  	{
  		first: 76,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 42,
  		amount: -12
  	},
  	{
  		first: 76,
  		second: 45,
  		amount: -9
  	},
  	{
  		first: 76,
  		second: 49,
  		amount: -5
  	},
  	{
  		first: 76,
  		second: 52,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 55,
  		amount: -4
  	},
  	{
  		first: 76,
  		second: 63,
  		amount: -4
  	},
  	{
  		first: 76,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 84,
  		amount: -13
  	},
  	{
  		first: 76,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 86,
  		amount: -10
  	},
  	{
  		first: 76,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 76,
  		second: 89,
  		amount: -11
  	},
  	{
  		first: 76,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 76,
  		second: 95,
  		amount: -9
  	},
  	{
  		first: 76,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 102,
  		amount: -3
  	},
  	{
  		first: 76,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 116,
  		amount: -4
  	},
  	{
  		first: 76,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 118,
  		amount: -7
  	},
  	{
  		first: 76,
  		second: 119,
  		amount: -7
  	},
  	{
  		first: 76,
  		second: 121,
  		amount: -9
  	},
  	{
  		first: 76,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 76,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 183,
  		amount: -19
  	},
  	{
  		first: 76,
  		second: 186,
  		amount: -6
  	},
  	{
  		first: 76,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 376,
  		amount: -11
  	},
  	{
  		first: 76,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 76,
  		second: 221,
  		amount: -11
  	},
  	{
  		first: 76,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 76,
  		second: 253,
  		amount: -9
  	},
  	{
  		first: 76,
  		second: 255,
  		amount: -9
  	},
  	{
  		first: 76,
  		second: 92,
  		amount: -7
  	},
  	{
  		first: 76,
  		second: 32,
  		amount: -3
  	},
  	{
  		first: 77,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 77,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 77,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 77,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 78,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 78,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 78,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 79,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 79,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 79,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 79,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 79,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 79,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 79,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 79,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 79,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 79,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 79,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 79,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 79,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 79,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 79,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 80,
  		second: 38,
  		amount: -2
  	},
  	{
  		first: 80,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 80,
  		second: 44,
  		amount: -12
  	},
  	{
  		first: 80,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 80,
  		second: 46,
  		amount: -12
  	},
  	{
  		first: 80,
  		second: 47,
  		amount: -4
  	},
  	{
  		first: 80,
  		second: 52,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 65,
  		amount: -5
  	},
  	{
  		first: 80,
  		second: 74,
  		amount: -6
  	},
  	{
  		first: 80,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 80,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 80,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 80,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 103,
  		amount: -2
  	},
  	{
  		first: 80,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 192,
  		amount: -5
  	},
  	{
  		first: 80,
  		second: 193,
  		amount: -5
  	},
  	{
  		first: 80,
  		second: 194,
  		amount: -5
  	},
  	{
  		first: 80,
  		second: 195,
  		amount: -5
  	},
  	{
  		first: 80,
  		second: 196,
  		amount: -5
  	},
  	{
  		first: 80,
  		second: 197,
  		amount: -5
  	},
  	{
  		first: 80,
  		second: 198,
  		amount: -9
  	},
  	{
  		first: 80,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 80,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 81,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 81,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 81,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 81,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 81,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 81,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 81,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 81,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 106,
  		amount: 5
  	},
  	{
  		first: 81,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 81,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 81,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 81,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 81,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 81,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 81,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 81,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 45,
  		amount: -4
  	},
  	{
  		first: 82,
  		second: 52,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 82,
  		second: 95,
  		amount: -4
  	},
  	{
  		first: 82,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 115,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 82,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 353,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 82,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 82,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 82,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 82,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 82,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 83,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 84,
  		amount: -3
  	},
  	{
  		first: 83,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 83,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 83,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 117,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 83,
  		second: 122,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 382,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 83,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 83,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 83,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 83,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 249,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 250,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 251,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 252,
  		amount: 0
  	},
  	{
  		first: 83,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 83,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 84,
  		second: 36,
  		amount: -3
  	},
  	{
  		first: 84,
  		second: 38,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 44,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 45,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 46,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 47,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 52,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 84,
  		second: 58,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 59,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 64,
  		amount: -5
  	},
  	{
  		first: 84,
  		second: 65,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 74,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 83,
  		amount: -3
  	},
  	{
  		first: 84,
  		second: 95,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 97,
  		amount: -10
  	},
  	{
  		first: 84,
  		second: 98,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 99,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 100,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 101,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 102,
  		amount: -5
  	},
  	{
  		first: 84,
  		second: 103,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 104,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 105,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 106,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 107,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 108,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 109,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 110,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 111,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 112,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 113,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 114,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 115,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 116,
  		amount: -5
  	},
  	{
  		first: 84,
  		second: 117,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 118,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 119,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 120,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 121,
  		amount: -8
  	},
  	{
  		first: 84,
  		second: 122,
  		amount: -8
  	},
  	{
  		first: 84,
  		second: 162,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 352,
  		amount: -3
  	},
  	{
  		first: 84,
  		second: 353,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 171,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 183,
  		amount: -4
  	},
  	{
  		first: 84,
  		second: 382,
  		amount: -8
  	},
  	{
  		first: 84,
  		second: 187,
  		amount: -8
  	},
  	{
  		first: 84,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 339,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 192,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 193,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 194,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 195,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 196,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 197,
  		amount: -9
  	},
  	{
  		first: 84,
  		second: 198,
  		amount: -15
  	},
  	{
  		first: 84,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 223,
  		amount: -3
  	},
  	{
  		first: 84,
  		second: 224,
  		amount: -10
  	},
  	{
  		first: 84,
  		second: 225,
  		amount: -10
  	},
  	{
  		first: 84,
  		second: 226,
  		amount: -10
  	},
  	{
  		first: 84,
  		second: 227,
  		amount: -10
  	},
  	{
  		first: 84,
  		second: 228,
  		amount: -10
  	},
  	{
  		first: 84,
  		second: 229,
  		amount: -10
  	},
  	{
  		first: 84,
  		second: 230,
  		amount: -10
  	},
  	{
  		first: 84,
  		second: 231,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 232,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 233,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 234,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 235,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 236,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 237,
  		amount: -3
  	},
  	{
  		first: 84,
  		second: 238,
  		amount: 2
  	},
  	{
  		first: 84,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 84,
  		second: 240,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 241,
  		amount: -7
  	},
  	{
  		first: 84,
  		second: 242,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 243,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 244,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 245,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 246,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 248,
  		amount: -11
  	},
  	{
  		first: 84,
  		second: 249,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 250,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 251,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 252,
  		amount: -6
  	},
  	{
  		first: 84,
  		second: 253,
  		amount: -8
  	},
  	{
  		first: 84,
  		second: 254,
  		amount: -2
  	},
  	{
  		first: 84,
  		second: 255,
  		amount: -8
  	},
  	{
  		first: 84,
  		second: 32,
  		amount: -3
  	},
  	{
  		first: 85,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 97,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 224,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 225,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 226,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 227,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 228,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 229,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 230,
  		amount: -2
  	},
  	{
  		first: 85,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 85,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 85,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 86,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 38,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 44,
  		amount: -12
  	},
  	{
  		first: 86,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 46,
  		amount: -12
  	},
  	{
  		first: 86,
  		second: 47,
  		amount: -7
  	},
  	{
  		first: 86,
  		second: 48,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 52,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 56,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 58,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 59,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 64,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 65,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 74,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 97,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 99,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 100,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 101,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 103,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 109,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 110,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 111,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 112,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 113,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 114,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 115,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 117,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 122,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 162,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 353,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 169,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 171,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 174,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 382,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 187,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 339,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 192,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 193,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 194,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 195,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 196,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 197,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 198,
  		amount: -7
  	},
  	{
  		first: 86,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 86,
  		second: 223,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 224,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 225,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 226,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 227,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 228,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 229,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 230,
  		amount: -6
  	},
  	{
  		first: 86,
  		second: 231,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 232,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 233,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 234,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 235,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 240,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 241,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 242,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 243,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 244,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 245,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 246,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 248,
  		amount: -5
  	},
  	{
  		first: 86,
  		second: 249,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 250,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 251,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 252,
  		amount: -3
  	},
  	{
  		first: 86,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 86,
  		second: 32,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 44,
  		amount: -7
  	},
  	{
  		first: 87,
  		second: 45,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 46,
  		amount: -7
  	},
  	{
  		first: 87,
  		second: 47,
  		amount: -5
  	},
  	{
  		first: 87,
  		second: 52,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 64,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 65,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 74,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 95,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 97,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 99,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 100,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 101,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 103,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 109,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 110,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 111,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 112,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 113,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 114,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 115,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 162,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 353,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 339,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 192,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 193,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 194,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 195,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 196,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 197,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 198,
  		amount: -6
  	},
  	{
  		first: 87,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 87,
  		second: 224,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 225,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 226,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 227,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 228,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 229,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 230,
  		amount: -4
  	},
  	{
  		first: 87,
  		second: 231,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 232,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 233,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 234,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 235,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 240,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 241,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 242,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 243,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 244,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 245,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 246,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 248,
  		amount: -3
  	},
  	{
  		first: 87,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 87,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 38,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 42,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 45,
  		amount: -6
  	},
  	{
  		first: 88,
  		second: 52,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 95,
  		amount: -6
  	},
  	{
  		first: 88,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 99,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 100,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 101,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 109,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 110,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 111,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 112,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 113,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 114,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 162,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 169,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 171,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 174,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 339,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 231,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 232,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 233,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 234,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 235,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 240,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 241,
  		amount: -1
  	},
  	{
  		first: 88,
  		second: 242,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 243,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 244,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 245,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 246,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 248,
  		amount: -4
  	},
  	{
  		first: 88,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 88,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 88,
  		second: 32,
  		amount: -1
  	},
  	{
  		first: 89,
  		second: 36,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 38,
  		amount: -4
  	},
  	{
  		first: 89,
  		second: 44,
  		amount: -13
  	},
  	{
  		first: 89,
  		second: 45,
  		amount: -8
  	},
  	{
  		first: 89,
  		second: 46,
  		amount: -13
  	},
  	{
  		first: 89,
  		second: 47,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 48,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 50,
  		amount: -1
  	},
  	{
  		first: 89,
  		second: 51,
  		amount: -1
  	},
  	{
  		first: 89,
  		second: 52,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 54,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 56,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 57,
  		amount: -1
  	},
  	{
  		first: 89,
  		second: 58,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 59,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 64,
  		amount: -4
  	},
  	{
  		first: 89,
  		second: 65,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 66,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 68,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 69,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 70,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 72,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 73,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 74,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 75,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 76,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 77,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 78,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 80,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 82,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 83,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 95,
  		amount: -8
  	},
  	{
  		first: 89,
  		second: 97,
  		amount: -9
  	},
  	{
  		first: 89,
  		second: 99,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 100,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 101,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 102,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 103,
  		amount: -8
  	},
  	{
  		first: 89,
  		second: 109,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 110,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 111,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 112,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 113,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 114,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 115,
  		amount: -8
  	},
  	{
  		first: 89,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 117,
  		amount: -5
  	},
  	{
  		first: 89,
  		second: 118,
  		amount: -4
  	},
  	{
  		first: 89,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 120,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 122,
  		amount: -5
  	},
  	{
  		first: 89,
  		second: 162,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 352,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 353,
  		amount: -8
  	},
  	{
  		first: 89,
  		second: 169,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 171,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 174,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 183,
  		amount: -1
  	},
  	{
  		first: 89,
  		second: 382,
  		amount: -5
  	},
  	{
  		first: 89,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 89,
  		second: 187,
  		amount: -5
  	},
  	{
  		first: 89,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 339,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 192,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 193,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 194,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 195,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 196,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 197,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 198,
  		amount: -13
  	},
  	{
  		first: 89,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 200,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 201,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 202,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 203,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 204,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 205,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 206,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 207,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 208,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 209,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 222,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 223,
  		amount: -2
  	},
  	{
  		first: 89,
  		second: 224,
  		amount: -9
  	},
  	{
  		first: 89,
  		second: 225,
  		amount: -9
  	},
  	{
  		first: 89,
  		second: 226,
  		amount: -9
  	},
  	{
  		first: 89,
  		second: 227,
  		amount: -9
  	},
  	{
  		first: 89,
  		second: 228,
  		amount: -9
  	},
  	{
  		first: 89,
  		second: 229,
  		amount: -9
  	},
  	{
  		first: 89,
  		second: 230,
  		amount: -9
  	},
  	{
  		first: 89,
  		second: 231,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 232,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 233,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 234,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 235,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 237,
  		amount: -1
  	},
  	{
  		first: 89,
  		second: 240,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 241,
  		amount: -6
  	},
  	{
  		first: 89,
  		second: 242,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 243,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 244,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 245,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 246,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 248,
  		amount: -7
  	},
  	{
  		first: 89,
  		second: 249,
  		amount: -5
  	},
  	{
  		first: 89,
  		second: 250,
  		amount: -5
  	},
  	{
  		first: 89,
  		second: 251,
  		amount: -5
  	},
  	{
  		first: 89,
  		second: 252,
  		amount: -5
  	},
  	{
  		first: 89,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 89,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 90,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 45,
  		amount: -6
  	},
  	{
  		first: 90,
  		second: 52,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 95,
  		amount: -6
  	},
  	{
  		first: 90,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 109,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 110,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 112,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 114,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 90,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 90,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 187,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 241,
  		amount: -1
  	},
  	{
  		first: 90,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 90,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 90,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 36,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 40,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 48,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 49,
  		amount: -1
  	},
  	{
  		first: 91,
  		second: 50,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 51,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 52,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 54,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 56,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 57,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 65,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 67,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 71,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 74,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 79,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 81,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 83,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 97,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 99,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 100,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 101,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 106,
  		amount: 6
  	},
  	{
  		first: 91,
  		second: 109,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 110,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 111,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 112,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 113,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 114,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 115,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 117,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 118,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 119,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 120,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 122,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 123,
  		amount: -1
  	},
  	{
  		first: 91,
  		second: 162,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 352,
  		amount: -2
  	},
  	{
  		first: 91,
  		second: 353,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 382,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 338,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 339,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 192,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 193,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 194,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 195,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 196,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 197,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 198,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 199,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 210,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 211,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 212,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 213,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 214,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 216,
  		amount: -3
  	},
  	{
  		first: 91,
  		second: 224,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 225,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 226,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 227,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 228,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 229,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 230,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 231,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 232,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 233,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 234,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 235,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 240,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 241,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 242,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 243,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 244,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 245,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 246,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 248,
  		amount: -5
  	},
  	{
  		first: 91,
  		second: 249,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 250,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 251,
  		amount: -4
  	},
  	{
  		first: 91,
  		second: 252,
  		amount: -4
  	},
  	{
  		first: 95,
  		second: 34,
  		amount: -8
  	},
  	{
  		first: 95,
  		second: 39,
  		amount: -8
  	},
  	{
  		first: 95,
  		second: 8217,
  		amount: -7
  	},
  	{
  		first: 95,
  		second: 36,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 95,
  		second: 44,
  		amount: -7
  	},
  	{
  		first: 95,
  		second: 46,
  		amount: -7
  	},
  	{
  		first: 95,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 95,
  		second: 50,
  		amount: -4
  	},
  	{
  		first: 95,
  		second: 51,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 95,
  		second: 57,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 83,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 95,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 95,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 95,
  		second: 88,
  		amount: -6
  	},
  	{
  		first: 95,
  		second: 89,
  		amount: -8
  	},
  	{
  		first: 95,
  		second: 90,
  		amount: -5
  	},
  	{
  		first: 95,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 102,
  		amount: -3
  	},
  	{
  		first: 95,
  		second: 103,
  		amount: 3
  	},
  	{
  		first: 95,
  		second: 106,
  		amount: 14
  	},
  	{
  		first: 95,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 95,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 120,
  		amount: -5
  	},
  	{
  		first: 95,
  		second: 121,
  		amount: 7
  	},
  	{
  		first: 95,
  		second: 122,
  		amount: -4
  	},
  	{
  		first: 95,
  		second: 352,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 381,
  		amount: -5
  	},
  	{
  		first: 95,
  		second: 382,
  		amount: -4
  	},
  	{
  		first: 95,
  		second: 376,
  		amount: -8
  	},
  	{
  		first: 95,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 95,
  		second: 198,
  		amount: -4
  	},
  	{
  		first: 95,
  		second: 221,
  		amount: -8
  	},
  	{
  		first: 95,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 95,
  		second: 253,
  		amount: 7
  	},
  	{
  		first: 95,
  		second: 255,
  		amount: 7
  	},
  	{
  		first: 97,
  		second: 34,
  		amount: -5
  	},
  	{
  		first: 97,
  		second: 39,
  		amount: -5
  	},
  	{
  		first: 97,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 97,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 97,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 97,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 97,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 97,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 97,
  		second: 63,
  		amount: -3
  	},
  	{
  		first: 97,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 97,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 97,
  		second: 86,
  		amount: -7
  	},
  	{
  		first: 97,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 97,
  		second: 89,
  		amount: -11
  	},
  	{
  		first: 97,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 97,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 97,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 97,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 97,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 97,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 97,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 97,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 97,
  		second: 179,
  		amount: -2
  	},
  	{
  		first: 97,
  		second: 185,
  		amount: -6
  	},
  	{
  		first: 97,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 97,
  		second: 376,
  		amount: -11
  	},
  	{
  		first: 97,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 97,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 97,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 97,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 97,
  		second: 221,
  		amount: -11
  	},
  	{
  		first: 97,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 97,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 97,
  		second: 92,
  		amount: -5
  	},
  	{
  		first: 97,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 98,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 98,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 98,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 98,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 98,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 98,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 98,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 98,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 98,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 98,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 98,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 98,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 98,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 98,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 98,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 98,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 98,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 99,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 99,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 99,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 99,
  		second: 63,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 99,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 99,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 99,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 99,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 99,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 99,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 99,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 99,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 99,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 99,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 99,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 99,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 99,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 99,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 99,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 99,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 99,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 99,
  		second: 92,
  		amount: -3
  	},
  	{
  		first: 100,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 100,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 90,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 381,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 100,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 101,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 8217,
  		amount: -4
  	},
  	{
  		first: 101,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 101,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 101,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 101,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 101,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 101,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 101,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 101,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 101,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 101,
  		second: 89,
  		amount: -9
  	},
  	{
  		first: 101,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 101,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 101,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 101,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 101,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 101,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 101,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 376,
  		amount: -9
  	},
  	{
  		first: 101,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 221,
  		amount: -9
  	},
  	{
  		first: 101,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 101,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 101,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 101,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 8217,
  		amount: 4
  	},
  	{
  		first: 102,
  		second: 38,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 44,
  		amount: -6
  	},
  	{
  		first: 102,
  		second: 45,
  		amount: -6
  	},
  	{
  		first: 102,
  		second: 46,
  		amount: -6
  	},
  	{
  		first: 102,
  		second: 47,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 65,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 74,
  		amount: -7
  	},
  	{
  		first: 102,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 102,
  		second: 86,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 90,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 95,
  		amount: -6
  	},
  	{
  		first: 102,
  		second: 97,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 116,
  		amount: -5
  	},
  	{
  		first: 102,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 178,
  		amount: 4
  	},
  	{
  		first: 102,
  		second: 179,
  		amount: 3
  	},
  	{
  		first: 102,
  		second: 381,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 192,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 193,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 194,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 195,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 196,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 197,
  		amount: -4
  	},
  	{
  		first: 102,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 102,
  		second: 224,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 225,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 226,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 227,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 228,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 229,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 230,
  		amount: -3
  	},
  	{
  		first: 102,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 239,
  		amount: 3
  	},
  	{
  		first: 102,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 102,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 102,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 103,
  		second: 34,
  		amount: 1
  	},
  	{
  		first: 103,
  		second: 39,
  		amount: 1
  	},
  	{
  		first: 103,
  		second: 8217,
  		amount: 3
  	},
  	{
  		first: 103,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 103,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 103,
  		second: 95,
  		amount: 4
  	},
  	{
  		first: 103,
  		second: 106,
  		amount: 6
  	},
  	{
  		first: 103,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 103,
  		second: 238,
  		amount: 3
  	},
  	{
  		first: 104,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 104,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 104,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 104,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 104,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 55,
  		amount: -5
  	},
  	{
  		first: 104,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 104,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 104,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 104,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 104,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 104,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 104,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 104,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 104,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 104,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 104,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 104,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 105,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 105,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 105,
  		second: 90,
  		amount: 0
  	},
  	{
  		first: 105,
  		second: 381,
  		amount: 0
  	},
  	{
  		first: 105,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 105,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 105,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 105,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 106,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 106,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 106,
  		second: 90,
  		amount: 0
  	},
  	{
  		first: 106,
  		second: 381,
  		amount: 0
  	},
  	{
  		first: 106,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 106,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 106,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 106,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 107,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 107,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 107,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 107,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 107,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 107,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 107,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 107,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 107,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 107,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 107,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 8217,
  		amount: -3
  	},
  	{
  		first: 108,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 42,
  		amount: -3
  	},
  	{
  		first: 108,
  		second: 45,
  		amount: -4
  	},
  	{
  		first: 108,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 84,
  		amount: -5
  	},
  	{
  		first: 108,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 108,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 108,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 108,
  		second: 95,
  		amount: -4
  	},
  	{
  		first: 108,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 108,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 183,
  		amount: -4
  	},
  	{
  		first: 108,
  		second: 186,
  		amount: -3
  	},
  	{
  		first: 108,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 108,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 108,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 108,
  		second: 92,
  		amount: -3
  	},
  	{
  		first: 108,
  		second: 32,
  		amount: -3
  	},
  	{
  		first: 109,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 109,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 109,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 109,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 109,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 55,
  		amount: -5
  	},
  	{
  		first: 109,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 109,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 109,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 109,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 109,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 109,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 109,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 109,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 109,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 109,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 109,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 109,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 110,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 110,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 110,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 110,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 110,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 55,
  		amount: -5
  	},
  	{
  		first: 110,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 110,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 110,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 110,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 110,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 110,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 110,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 110,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 110,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 110,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 110,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 110,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 111,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 111,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 111,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 111,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 111,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 111,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 111,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 111,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 111,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 111,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 111,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 111,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 111,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 111,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 111,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 111,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 111,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 111,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 112,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 112,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 112,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 112,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 112,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 112,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 112,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 112,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 112,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 112,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 112,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 112,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 112,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 112,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 112,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 112,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 112,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 112,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 113,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 113,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 113,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 113,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 113,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 113,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 113,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 113,
  		second: 106,
  		amount: 4
  	},
  	{
  		first: 113,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 113,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 113,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 113,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 113,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 113,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 8217,
  		amount: 2
  	},
  	{
  		first: 114,
  		second: 38,
  		amount: -4
  	},
  	{
  		first: 114,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 114,
  		second: 44,
  		amount: -8
  	},
  	{
  		first: 114,
  		second: 45,
  		amount: -7
  	},
  	{
  		first: 114,
  		second: 46,
  		amount: -8
  	},
  	{
  		first: 114,
  		second: 47,
  		amount: -4
  	},
  	{
  		first: 114,
  		second: 65,
  		amount: -6
  	},
  	{
  		first: 114,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 74,
  		amount: -8
  	},
  	{
  		first: 114,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 114,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 88,
  		amount: -4
  	},
  	{
  		first: 114,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 114,
  		second: 90,
  		amount: -3
  	},
  	{
  		first: 114,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 114,
  		second: 95,
  		amount: -7
  	},
  	{
  		first: 114,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 103,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 115,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 114,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 353,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 114,
  		second: 381,
  		amount: -3
  	},
  	{
  		first: 114,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 114,
  		second: 192,
  		amount: -6
  	},
  	{
  		first: 114,
  		second: 193,
  		amount: -6
  	},
  	{
  		first: 114,
  		second: 194,
  		amount: -6
  	},
  	{
  		first: 114,
  		second: 195,
  		amount: -6
  	},
  	{
  		first: 114,
  		second: 196,
  		amount: -6
  	},
  	{
  		first: 114,
  		second: 197,
  		amount: -6
  	},
  	{
  		first: 114,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 114,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 114,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 240,
  		amount: -3
  	},
  	{
  		first: 114,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 114,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 115,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 8217,
  		amount: -3
  	},
  	{
  		first: 115,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 115,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 55,
  		amount: -5
  	},
  	{
  		first: 115,
  		second: 63,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 65,
  		amount: 0
  	},
  	{
  		first: 115,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 115,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 115,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 115,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 115,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 115,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 115,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 115,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 115,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 115,
  		second: 192,
  		amount: 0
  	},
  	{
  		first: 115,
  		second: 193,
  		amount: 0
  	},
  	{
  		first: 115,
  		second: 194,
  		amount: 0
  	},
  	{
  		first: 115,
  		second: 195,
  		amount: 0
  	},
  	{
  		first: 115,
  		second: 196,
  		amount: 0
  	},
  	{
  		first: 115,
  		second: 197,
  		amount: 0
  	},
  	{
  		first: 115,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 115,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 115,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 115,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 115,
  		second: 92,
  		amount: -3
  	},
  	{
  		first: 116,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 116,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 116,
  		second: 45,
  		amount: -1
  	},
  	{
  		first: 116,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 116,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 116,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 116,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 116,
  		second: 95,
  		amount: -1
  	},
  	{
  		first: 116,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 116,
  		second: 116,
  		amount: -6
  	},
  	{
  		first: 116,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 116,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 117,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 117,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 117,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 117,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 117,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 117,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 117,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 117,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 117,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 117,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 117,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 117,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 117,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 118,
  		second: 8217,
  		amount: 3
  	},
  	{
  		first: 118,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 118,
  		second: 44,
  		amount: -7
  	},
  	{
  		first: 118,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 118,
  		second: 46,
  		amount: -7
  	},
  	{
  		first: 118,
  		second: 47,
  		amount: -4
  	},
  	{
  		first: 118,
  		second: 65,
  		amount: -3
  	},
  	{
  		first: 118,
  		second: 74,
  		amount: -5
  	},
  	{
  		first: 118,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 118,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 88,
  		amount: -4
  	},
  	{
  		first: 118,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 118,
  		second: 90,
  		amount: -4
  	},
  	{
  		first: 118,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 118,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 118,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 118,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 118,
  		second: 381,
  		amount: -4
  	},
  	{
  		first: 118,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 118,
  		second: 192,
  		amount: -3
  	},
  	{
  		first: 118,
  		second: 193,
  		amount: -3
  	},
  	{
  		first: 118,
  		second: 194,
  		amount: -3
  	},
  	{
  		first: 118,
  		second: 195,
  		amount: -3
  	},
  	{
  		first: 118,
  		second: 196,
  		amount: -3
  	},
  	{
  		first: 118,
  		second: 197,
  		amount: -3
  	},
  	{
  		first: 118,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 118,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 118,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 118,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 8217,
  		amount: 1
  	},
  	{
  		first: 119,
  		second: 38,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 119,
  		second: 44,
  		amount: -8
  	},
  	{
  		first: 119,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 46,
  		amount: -8
  	},
  	{
  		first: 119,
  		second: 47,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 65,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 74,
  		amount: -4
  	},
  	{
  		first: 119,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 119,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 90,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 119,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 103,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 381,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 192,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 193,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 194,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 195,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 196,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 197,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 119,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 119,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 119,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 120,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 120,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 120,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 120,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 120,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 120,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 120,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 120,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 120,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 120,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 120,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 120,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 120,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 121,
  		second: 8217,
  		amount: 3
  	},
  	{
  		first: 121,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 121,
  		second: 44,
  		amount: -7
  	},
  	{
  		first: 121,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 121,
  		second: 46,
  		amount: -7
  	},
  	{
  		first: 121,
  		second: 47,
  		amount: -4
  	},
  	{
  		first: 121,
  		second: 65,
  		amount: -3
  	},
  	{
  		first: 121,
  		second: 74,
  		amount: -5
  	},
  	{
  		first: 121,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 121,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 88,
  		amount: -4
  	},
  	{
  		first: 121,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 121,
  		second: 90,
  		amount: -4
  	},
  	{
  		first: 121,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 121,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 121,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 121,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 121,
  		second: 381,
  		amount: -4
  	},
  	{
  		first: 121,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 121,
  		second: 192,
  		amount: -3
  	},
  	{
  		first: 121,
  		second: 193,
  		amount: -3
  	},
  	{
  		first: 121,
  		second: 194,
  		amount: -3
  	},
  	{
  		first: 121,
  		second: 195,
  		amount: -3
  	},
  	{
  		first: 121,
  		second: 196,
  		amount: -3
  	},
  	{
  		first: 121,
  		second: 197,
  		amount: -3
  	},
  	{
  		first: 121,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 121,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 121,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 121,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 122,
  		second: 38,
  		amount: -2
  	},
  	{
  		first: 122,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 122,
  		second: 45,
  		amount: -4
  	},
  	{
  		first: 122,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 122,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 122,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 89,
  		amount: -5
  	},
  	{
  		first: 122,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 122,
  		second: 95,
  		amount: -4
  	},
  	{
  		first: 122,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 122,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 122,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 376,
  		amount: -5
  	},
  	{
  		first: 122,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 221,
  		amount: -5
  	},
  	{
  		first: 122,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 122,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 122,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 36,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 40,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 48,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 49,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 51,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 52,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 54,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 56,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 57,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 74,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 83,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 97,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 99,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 100,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 101,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 106,
  		amount: 5
  	},
  	{
  		first: 123,
  		second: 109,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 110,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 111,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 112,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 113,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 114,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 115,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 122,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 162,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 352,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 353,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 382,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 339,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 123,
  		second: 224,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 225,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 226,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 227,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 228,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 229,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 230,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 231,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 232,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 233,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 234,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 235,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 240,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 241,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 242,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 243,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 244,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 245,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 246,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 248,
  		amount: -3
  	},
  	{
  		first: 123,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 123,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 124,
  		second: 106,
  		amount: 2
  	},
  	{
  		first: 125,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 125,
  		second: 93,
  		amount: -1
  	},
  	{
  		first: 161,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 161,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 161,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 161,
  		second: 106,
  		amount: 1
  	},
  	{
  		first: 161,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 161,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 162,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 162,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 162,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 162,
  		second: 63,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 162,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 162,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 162,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 162,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 162,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 162,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 162,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 162,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 162,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 162,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 162,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 162,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 162,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 162,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 162,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 162,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 162,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 162,
  		second: 92,
  		amount: -3
  	},
  	{
  		first: 163,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 352,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 352,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 84,
  		amount: -3
  	},
  	{
  		first: 352,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 352,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 352,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 117,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 352,
  		second: 122,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 382,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 352,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 352,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 352,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 352,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 249,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 250,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 251,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 252,
  		amount: 0
  	},
  	{
  		first: 352,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 352,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 353,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 8217,
  		amount: -3
  	},
  	{
  		first: 353,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 353,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 55,
  		amount: -5
  	},
  	{
  		first: 353,
  		second: 63,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 65,
  		amount: 0
  	},
  	{
  		first: 353,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 353,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 353,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 353,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 353,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 353,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 353,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 353,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 353,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 353,
  		second: 192,
  		amount: 0
  	},
  	{
  		first: 353,
  		second: 193,
  		amount: 0
  	},
  	{
  		first: 353,
  		second: 194,
  		amount: 0
  	},
  	{
  		first: 353,
  		second: 195,
  		amount: 0
  	},
  	{
  		first: 353,
  		second: 196,
  		amount: 0
  	},
  	{
  		first: 353,
  		second: 197,
  		amount: 0
  	},
  	{
  		first: 353,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 353,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 353,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 353,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 353,
  		second: 92,
  		amount: -3
  	},
  	{
  		first: 169,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 169,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 169,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 169,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 169,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 169,
  		second: 90,
  		amount: -3
  	},
  	{
  		first: 169,
  		second: 381,
  		amount: -3
  	},
  	{
  		first: 169,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 169,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 169,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 169,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 169,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 169,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 169,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 169,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 169,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 171,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 171,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 84,
  		amount: -8
  	},
  	{
  		first: 171,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 171,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 89,
  		amount: -5
  	},
  	{
  		first: 171,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 171,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 171,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 171,
  		second: 376,
  		amount: -5
  	},
  	{
  		first: 171,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 171,
  		second: 221,
  		amount: -5
  	},
  	{
  		first: 171,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 171,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 174,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 174,
  		second: 89,
  		amount: -3
  	},
  	{
  		first: 174,
  		second: 90,
  		amount: -3
  	},
  	{
  		first: 174,
  		second: 381,
  		amount: -3
  	},
  	{
  		first: 174,
  		second: 376,
  		amount: -3
  	},
  	{
  		first: 174,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 174,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 174,
  		second: 221,
  		amount: -3
  	},
  	{
  		first: 176,
  		second: 52,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 45,
  		amount: -6
  	},
  	{
  		first: 381,
  		second: 52,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 95,
  		amount: -6
  	},
  	{
  		first: 381,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 109,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 110,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 112,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 114,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 381,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 171,
  		amount: -3
  	},
  	{
  		first: 381,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 187,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 241,
  		amount: -1
  	},
  	{
  		first: 381,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 381,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 381,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 183,
  		second: 49,
  		amount: -3
  	},
  	{
  		first: 183,
  		second: 50,
  		amount: -4
  	},
  	{
  		first: 183,
  		second: 51,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 183,
  		second: 57,
  		amount: -1
  	},
  	{
  		first: 183,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 84,
  		amount: -4
  	},
  	{
  		first: 183,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 183,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 183,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 183,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 183,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 38,
  		amount: -2
  	},
  	{
  		first: 382,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 382,
  		second: 45,
  		amount: -4
  	},
  	{
  		first: 382,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 382,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 382,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 89,
  		amount: -5
  	},
  	{
  		first: 382,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 382,
  		second: 95,
  		amount: -4
  	},
  	{
  		first: 382,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 382,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 382,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 376,
  		amount: -5
  	},
  	{
  		first: 382,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 221,
  		amount: -5
  	},
  	{
  		first: 382,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 382,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 382,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 187,
  		second: 34,
  		amount: -3
  	},
  	{
  		first: 187,
  		second: 39,
  		amount: -3
  	},
  	{
  		first: 187,
  		second: 8217,
  		amount: -3
  	},
  	{
  		first: 187,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 187,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 187,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 187,
  		second: 88,
  		amount: -4
  	},
  	{
  		first: 187,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 187,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 187,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 120,
  		amount: -3
  	},
  	{
  		first: 187,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 187,
  		second: 122,
  		amount: -2
  	},
  	{
  		first: 187,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 187,
  		second: 382,
  		amount: -2
  	},
  	{
  		first: 187,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 187,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 187,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 187,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 187,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 187,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 338,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 338,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 338,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 338,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 338,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 338,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 338,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 338,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 338,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 339,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 8217,
  		amount: -4
  	},
  	{
  		first: 339,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 339,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 339,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 339,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 339,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 339,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 339,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 339,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 339,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 339,
  		second: 89,
  		amount: -9
  	},
  	{
  		first: 339,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 339,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 339,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 339,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 339,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 339,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 339,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 376,
  		amount: -9
  	},
  	{
  		first: 339,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 221,
  		amount: -9
  	},
  	{
  		first: 339,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 339,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 339,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 339,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 376,
  		second: 36,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 38,
  		amount: -4
  	},
  	{
  		first: 376,
  		second: 44,
  		amount: -13
  	},
  	{
  		first: 376,
  		second: 45,
  		amount: -8
  	},
  	{
  		first: 376,
  		second: 46,
  		amount: -13
  	},
  	{
  		first: 376,
  		second: 47,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 48,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 50,
  		amount: -1
  	},
  	{
  		first: 376,
  		second: 51,
  		amount: -1
  	},
  	{
  		first: 376,
  		second: 52,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 54,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 56,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 57,
  		amount: -1
  	},
  	{
  		first: 376,
  		second: 58,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 59,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 64,
  		amount: -4
  	},
  	{
  		first: 376,
  		second: 65,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 66,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 68,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 69,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 70,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 72,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 73,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 74,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 75,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 76,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 77,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 78,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 80,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 82,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 83,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 95,
  		amount: -8
  	},
  	{
  		first: 376,
  		second: 97,
  		amount: -9
  	},
  	{
  		first: 376,
  		second: 99,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 100,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 101,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 102,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 103,
  		amount: -8
  	},
  	{
  		first: 376,
  		second: 109,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 110,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 111,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 112,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 113,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 114,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 115,
  		amount: -8
  	},
  	{
  		first: 376,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 117,
  		amount: -5
  	},
  	{
  		first: 376,
  		second: 118,
  		amount: -4
  	},
  	{
  		first: 376,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 120,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 122,
  		amount: -5
  	},
  	{
  		first: 376,
  		second: 162,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 352,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 353,
  		amount: -8
  	},
  	{
  		first: 376,
  		second: 169,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 171,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 174,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 183,
  		amount: -1
  	},
  	{
  		first: 376,
  		second: 382,
  		amount: -5
  	},
  	{
  		first: 376,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 376,
  		second: 187,
  		amount: -5
  	},
  	{
  		first: 376,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 339,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 192,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 193,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 194,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 195,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 196,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 197,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 198,
  		amount: -13
  	},
  	{
  		first: 376,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 200,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 201,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 202,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 203,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 204,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 205,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 206,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 207,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 208,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 209,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 222,
  		amount: -2
  	},
  	{
  		first: 376,
  		second: 224,
  		amount: -9
  	},
  	{
  		first: 376,
  		second: 225,
  		amount: -9
  	},
  	{
  		first: 376,
  		second: 226,
  		amount: -9
  	},
  	{
  		first: 376,
  		second: 227,
  		amount: -9
  	},
  	{
  		first: 376,
  		second: 228,
  		amount: -9
  	},
  	{
  		first: 376,
  		second: 229,
  		amount: -9
  	},
  	{
  		first: 376,
  		second: 230,
  		amount: -9
  	},
  	{
  		first: 376,
  		second: 231,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 232,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 233,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 234,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 235,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 240,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 241,
  		amount: -6
  	},
  	{
  		first: 376,
  		second: 242,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 243,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 244,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 245,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 246,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 248,
  		amount: -7
  	},
  	{
  		first: 376,
  		second: 249,
  		amount: -5
  	},
  	{
  		first: 376,
  		second: 250,
  		amount: -5
  	},
  	{
  		first: 376,
  		second: 251,
  		amount: -5
  	},
  	{
  		first: 376,
  		second: 252,
  		amount: -5
  	},
  	{
  		first: 376,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 376,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 191,
  		second: 67,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 71,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 79,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 81,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 191,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 191,
  		second: 85,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 86,
  		amount: -6
  	},
  	{
  		first: 191,
  		second: 87,
  		amount: -5
  	},
  	{
  		first: 191,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 191,
  		second: 99,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 100,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 101,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 191,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 191,
  		second: 111,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 113,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 117,
  		amount: -2
  	},
  	{
  		first: 191,
  		second: 118,
  		amount: -5
  	},
  	{
  		first: 191,
  		second: 119,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 162,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 191,
  		second: 338,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 339,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 191,
  		second: 199,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 210,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 211,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 212,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 213,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 214,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 216,
  		amount: -4
  	},
  	{
  		first: 191,
  		second: 217,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 218,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 219,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 220,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 191,
  		second: 231,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 232,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 233,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 234,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 235,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 191,
  		second: 242,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 243,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 244,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 245,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 246,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 248,
  		amount: -3
  	},
  	{
  		first: 191,
  		second: 249,
  		amount: -2
  	},
  	{
  		first: 191,
  		second: 250,
  		amount: -2
  	},
  	{
  		first: 191,
  		second: 251,
  		amount: -2
  	},
  	{
  		first: 191,
  		second: 252,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 34,
  		amount: -10
  	},
  	{
  		first: 192,
  		second: 39,
  		amount: -10
  	},
  	{
  		first: 192,
  		second: 8217,
  		amount: -11
  	},
  	{
  		first: 192,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 42,
  		amount: -8
  	},
  	{
  		first: 192,
  		second: 44,
  		amount: 1
  	},
  	{
  		first: 192,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 46,
  		amount: 1
  	},
  	{
  		first: 192,
  		second: 49,
  		amount: -7
  	},
  	{
  		first: 192,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 192,
  		second: 63,
  		amount: -7
  	},
  	{
  		first: 192,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 192,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 86,
  		amount: -6
  	},
  	{
  		first: 192,
  		second: 87,
  		amount: -4
  	},
  	{
  		first: 192,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 192,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 192,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 115,
  		amount: 0
  	},
  	{
  		first: 192,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 192,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 192,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 192,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 192,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 353,
  		amount: 0
  	},
  	{
  		first: 192,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 186,
  		amount: -3
  	},
  	{
  		first: 192,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 192,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 192,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 192,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 192,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 192,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 192,
  		second: 92,
  		amount: -10
  	},
  	{
  		first: 192,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 193,
  		second: 34,
  		amount: -10
  	},
  	{
  		first: 193,
  		second: 39,
  		amount: -10
  	},
  	{
  		first: 193,
  		second: 8217,
  		amount: -11
  	},
  	{
  		first: 193,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 42,
  		amount: -8
  	},
  	{
  		first: 193,
  		second: 44,
  		amount: 1
  	},
  	{
  		first: 193,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 46,
  		amount: 1
  	},
  	{
  		first: 193,
  		second: 49,
  		amount: -7
  	},
  	{
  		first: 193,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 193,
  		second: 63,
  		amount: -7
  	},
  	{
  		first: 193,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 193,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 86,
  		amount: -6
  	},
  	{
  		first: 193,
  		second: 87,
  		amount: -4
  	},
  	{
  		first: 193,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 193,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 193,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 115,
  		amount: 0
  	},
  	{
  		first: 193,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 193,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 193,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 193,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 193,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 353,
  		amount: 0
  	},
  	{
  		first: 193,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 186,
  		amount: -3
  	},
  	{
  		first: 193,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 193,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 193,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 193,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 193,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 193,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 193,
  		second: 92,
  		amount: -10
  	},
  	{
  		first: 193,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 194,
  		second: 34,
  		amount: -10
  	},
  	{
  		first: 194,
  		second: 39,
  		amount: -10
  	},
  	{
  		first: 194,
  		second: 8217,
  		amount: -11
  	},
  	{
  		first: 194,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 42,
  		amount: -8
  	},
  	{
  		first: 194,
  		second: 44,
  		amount: 1
  	},
  	{
  		first: 194,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 46,
  		amount: 1
  	},
  	{
  		first: 194,
  		second: 49,
  		amount: -7
  	},
  	{
  		first: 194,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 194,
  		second: 63,
  		amount: -7
  	},
  	{
  		first: 194,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 194,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 86,
  		amount: -6
  	},
  	{
  		first: 194,
  		second: 87,
  		amount: -4
  	},
  	{
  		first: 194,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 194,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 194,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 115,
  		amount: 0
  	},
  	{
  		first: 194,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 194,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 194,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 194,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 194,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 353,
  		amount: 0
  	},
  	{
  		first: 194,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 186,
  		amount: -3
  	},
  	{
  		first: 194,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 194,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 194,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 194,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 194,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 194,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 194,
  		second: 92,
  		amount: -10
  	},
  	{
  		first: 194,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 195,
  		second: 34,
  		amount: -10
  	},
  	{
  		first: 195,
  		second: 39,
  		amount: -10
  	},
  	{
  		first: 195,
  		second: 8217,
  		amount: -11
  	},
  	{
  		first: 195,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 42,
  		amount: -8
  	},
  	{
  		first: 195,
  		second: 44,
  		amount: 1
  	},
  	{
  		first: 195,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 46,
  		amount: 1
  	},
  	{
  		first: 195,
  		second: 49,
  		amount: -7
  	},
  	{
  		first: 195,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 195,
  		second: 63,
  		amount: -7
  	},
  	{
  		first: 195,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 195,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 86,
  		amount: -6
  	},
  	{
  		first: 195,
  		second: 87,
  		amount: -4
  	},
  	{
  		first: 195,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 195,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 195,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 115,
  		amount: 0
  	},
  	{
  		first: 195,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 195,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 195,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 195,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 195,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 353,
  		amount: 0
  	},
  	{
  		first: 195,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 186,
  		amount: -3
  	},
  	{
  		first: 195,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 195,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 195,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 195,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 195,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 195,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 195,
  		second: 92,
  		amount: -10
  	},
  	{
  		first: 195,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 196,
  		second: 34,
  		amount: -10
  	},
  	{
  		first: 196,
  		second: 39,
  		amount: -10
  	},
  	{
  		first: 196,
  		second: 8217,
  		amount: -11
  	},
  	{
  		first: 196,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 42,
  		amount: -8
  	},
  	{
  		first: 196,
  		second: 44,
  		amount: 1
  	},
  	{
  		first: 196,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 46,
  		amount: 1
  	},
  	{
  		first: 196,
  		second: 49,
  		amount: -7
  	},
  	{
  		first: 196,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 196,
  		second: 63,
  		amount: -7
  	},
  	{
  		first: 196,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 196,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 86,
  		amount: -6
  	},
  	{
  		first: 196,
  		second: 87,
  		amount: -4
  	},
  	{
  		first: 196,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 196,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 196,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 115,
  		amount: 0
  	},
  	{
  		first: 196,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 196,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 196,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 196,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 196,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 353,
  		amount: 0
  	},
  	{
  		first: 196,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 186,
  		amount: -3
  	},
  	{
  		first: 196,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 196,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 196,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 196,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 196,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 196,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 196,
  		second: 92,
  		amount: -10
  	},
  	{
  		first: 196,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 197,
  		second: 34,
  		amount: -10
  	},
  	{
  		first: 197,
  		second: 39,
  		amount: -10
  	},
  	{
  		first: 197,
  		second: 8217,
  		amount: -11
  	},
  	{
  		first: 197,
  		second: 36,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 42,
  		amount: -8
  	},
  	{
  		first: 197,
  		second: 44,
  		amount: 1
  	},
  	{
  		first: 197,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 46,
  		amount: 1
  	},
  	{
  		first: 197,
  		second: 49,
  		amount: -7
  	},
  	{
  		first: 197,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 197,
  		second: 63,
  		amount: -7
  	},
  	{
  		first: 197,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 83,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 197,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 86,
  		amount: -6
  	},
  	{
  		first: 197,
  		second: 87,
  		amount: -4
  	},
  	{
  		first: 197,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 197,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 197,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 115,
  		amount: 0
  	},
  	{
  		first: 197,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 197,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 197,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 197,
  		second: 121,
  		amount: -5
  	},
  	{
  		first: 197,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 352,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 353,
  		amount: 0
  	},
  	{
  		first: 197,
  		second: 169,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 171,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 174,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 183,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 186,
  		amount: -3
  	},
  	{
  		first: 197,
  		second: 187,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 197,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 197,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 197,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 197,
  		second: 253,
  		amount: -5
  	},
  	{
  		first: 197,
  		second: 255,
  		amount: -5
  	},
  	{
  		first: 197,
  		second: 92,
  		amount: -10
  	},
  	{
  		first: 197,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 198,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 198,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 198,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 198,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 198,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 198,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 198,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 198,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 198,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 199,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 199,
  		second: 44,
  		amount: -1
  	},
  	{
  		first: 199,
  		second: 45,
  		amount: -1
  	},
  	{
  		first: 199,
  		second: 46,
  		amount: -1
  	},
  	{
  		first: 199,
  		second: 89,
  		amount: -1
  	},
  	{
  		first: 199,
  		second: 93,
  		amount: -2
  	},
  	{
  		first: 199,
  		second: 95,
  		amount: -1
  	},
  	{
  		first: 199,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 199,
  		second: 376,
  		amount: -1
  	},
  	{
  		first: 199,
  		second: 198,
  		amount: -1
  	},
  	{
  		first: 199,
  		second: 221,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 200,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 200,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 200,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 200,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 200,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 200,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 200,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 200,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 201,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 201,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 201,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 201,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 201,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 201,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 201,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 201,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 201,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 202,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 202,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 202,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 202,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 202,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 202,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 202,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 202,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 202,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 203,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 45,
  		amount: -5
  	},
  	{
  		first: 203,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 74,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 95,
  		amount: -5
  	},
  	{
  		first: 203,
  		second: 99,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 100,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 101,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 111,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 113,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 118,
  		amount: -3
  	},
  	{
  		first: 203,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 203,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 203,
  		second: 162,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 339,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 231,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 232,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 233,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 234,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 235,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 242,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 243,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 244,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 245,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 246,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 248,
  		amount: -2
  	},
  	{
  		first: 203,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 203,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 203,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 204,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 204,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 204,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 204,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 205,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 205,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 205,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 41,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 206,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 206,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 206,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 207,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 207,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 207,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 208,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 208,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 208,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 208,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 208,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 208,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 208,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 208,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 208,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 208,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 208,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 208,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 208,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 208,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 208,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 209,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 209,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 209,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 209,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 210,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 210,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 210,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 210,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 210,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 210,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 210,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 210,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 210,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 210,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 210,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 210,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 210,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 210,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 210,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 211,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 211,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 211,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 211,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 211,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 211,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 211,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 211,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 211,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 211,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 211,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 211,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 211,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 211,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 211,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 212,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 212,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 212,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 212,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 212,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 212,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 212,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 212,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 212,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 212,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 212,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 212,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 212,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 212,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 212,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 213,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 213,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 213,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 213,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 213,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 213,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 213,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 213,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 213,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 213,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 213,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 213,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 213,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 213,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 213,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 214,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 214,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 214,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 214,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 214,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 214,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 214,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 214,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 214,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 214,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 214,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 214,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 214,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 214,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 214,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 215,
  		second: 55,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 216,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 216,
  		second: 44,
  		amount: -3
  	},
  	{
  		first: 216,
  		second: 46,
  		amount: -3
  	},
  	{
  		first: 216,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 55,
  		amount: -1
  	},
  	{
  		first: 216,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 216,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 89,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 216,
  		second: 93,
  		amount: -3
  	},
  	{
  		first: 216,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 216,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 216,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 216,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 216,
  		second: 376,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 198,
  		amount: -3
  	},
  	{
  		first: 216,
  		second: 221,
  		amount: -2
  	},
  	{
  		first: 216,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 216,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 97,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 224,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 225,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 226,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 227,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 228,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 229,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 230,
  		amount: -2
  	},
  	{
  		first: 217,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 217,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 217,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 97,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 224,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 225,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 226,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 227,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 228,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 229,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 230,
  		amount: -2
  	},
  	{
  		first: 218,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 218,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 218,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 97,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 224,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 225,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 226,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 227,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 228,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 229,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 230,
  		amount: -2
  	},
  	{
  		first: 219,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 219,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 219,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 41,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 97,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 98,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 103,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 104,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 105,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 106,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 107,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 108,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 109,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 110,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 112,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 114,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 198,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 223,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 224,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 225,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 226,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 227,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 228,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 229,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 230,
  		amount: -2
  	},
  	{
  		first: 220,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 236,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 237,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 238,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 239,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 241,
  		amount: 0
  	},
  	{
  		first: 220,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 220,
  		second: 254,
  		amount: 0
  	},
  	{
  		first: 221,
  		second: 36,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 38,
  		amount: -4
  	},
  	{
  		first: 221,
  		second: 44,
  		amount: -13
  	},
  	{
  		first: 221,
  		second: 45,
  		amount: -8
  	},
  	{
  		first: 221,
  		second: 46,
  		amount: -13
  	},
  	{
  		first: 221,
  		second: 47,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 48,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 50,
  		amount: -1
  	},
  	{
  		first: 221,
  		second: 51,
  		amount: -1
  	},
  	{
  		first: 221,
  		second: 52,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 54,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 56,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 57,
  		amount: -1
  	},
  	{
  		first: 221,
  		second: 58,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 59,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 64,
  		amount: -4
  	},
  	{
  		first: 221,
  		second: 65,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 66,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 68,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 69,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 70,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 72,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 73,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 74,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 75,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 76,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 77,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 78,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 80,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 82,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 83,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 95,
  		amount: -8
  	},
  	{
  		first: 221,
  		second: 97,
  		amount: -9
  	},
  	{
  		first: 221,
  		second: 99,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 100,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 101,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 102,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 103,
  		amount: -8
  	},
  	{
  		first: 221,
  		second: 109,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 110,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 111,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 112,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 113,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 114,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 115,
  		amount: -8
  	},
  	{
  		first: 221,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 117,
  		amount: -5
  	},
  	{
  		first: 221,
  		second: 118,
  		amount: -4
  	},
  	{
  		first: 221,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 120,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 122,
  		amount: -5
  	},
  	{
  		first: 221,
  		second: 162,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 352,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 353,
  		amount: -8
  	},
  	{
  		first: 221,
  		second: 169,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 171,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 174,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 183,
  		amount: -1
  	},
  	{
  		first: 221,
  		second: 382,
  		amount: -5
  	},
  	{
  		first: 221,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 221,
  		second: 187,
  		amount: -5
  	},
  	{
  		first: 221,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 339,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 192,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 193,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 194,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 195,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 196,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 197,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 198,
  		amount: -13
  	},
  	{
  		first: 221,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 200,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 201,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 202,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 203,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 204,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 205,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 206,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 207,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 208,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 209,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 222,
  		amount: -2
  	},
  	{
  		first: 221,
  		second: 224,
  		amount: -9
  	},
  	{
  		first: 221,
  		second: 225,
  		amount: -9
  	},
  	{
  		first: 221,
  		second: 226,
  		amount: -9
  	},
  	{
  		first: 221,
  		second: 227,
  		amount: -9
  	},
  	{
  		first: 221,
  		second: 228,
  		amount: -9
  	},
  	{
  		first: 221,
  		second: 229,
  		amount: -9
  	},
  	{
  		first: 221,
  		second: 230,
  		amount: -9
  	},
  	{
  		first: 221,
  		second: 231,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 232,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 233,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 234,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 235,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 240,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 241,
  		amount: -6
  	},
  	{
  		first: 221,
  		second: 242,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 243,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 244,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 245,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 246,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 248,
  		amount: -7
  	},
  	{
  		first: 221,
  		second: 249,
  		amount: -5
  	},
  	{
  		first: 221,
  		second: 250,
  		amount: -5
  	},
  	{
  		first: 221,
  		second: 251,
  		amount: -5
  	},
  	{
  		first: 221,
  		second: 252,
  		amount: -5
  	},
  	{
  		first: 221,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 221,
  		second: 32,
  		amount: -4
  	},
  	{
  		first: 222,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 222,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 222,
  		second: 44,
  		amount: -6
  	},
  	{
  		first: 222,
  		second: 46,
  		amount: -6
  	},
  	{
  		first: 222,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 65,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 84,
  		amount: -5
  	},
  	{
  		first: 222,
  		second: 86,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 87,
  		amount: -1
  	},
  	{
  		first: 222,
  		second: 88,
  		amount: -5
  	},
  	{
  		first: 222,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 222,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 222,
  		second: 118,
  		amount: 0
  	},
  	{
  		first: 222,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 121,
  		amount: 0
  	},
  	{
  		first: 222,
  		second: 122,
  		amount: 0
  	},
  	{
  		first: 222,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 382,
  		amount: 0
  	},
  	{
  		first: 222,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 222,
  		second: 192,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 193,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 194,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 195,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 196,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 197,
  		amount: -2
  	},
  	{
  		first: 222,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 222,
  		second: 253,
  		amount: 0
  	},
  	{
  		first: 222,
  		second: 255,
  		amount: 0
  	},
  	{
  		first: 222,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 223,
  		second: 41,
  		amount: -2
  	},
  	{
  		first: 223,
  		second: 93,
  		amount: -1
  	},
  	{
  		first: 223,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 223,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 223,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 223,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 223,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 223,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 223,
  		second: 122,
  		amount: 0
  	},
  	{
  		first: 223,
  		second: 125,
  		amount: -1
  	},
  	{
  		first: 223,
  		second: 382,
  		amount: 0
  	},
  	{
  		first: 223,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 223,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 224,
  		second: 34,
  		amount: -5
  	},
  	{
  		first: 224,
  		second: 39,
  		amount: -5
  	},
  	{
  		first: 224,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 224,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 224,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 224,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 224,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 224,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 224,
  		second: 63,
  		amount: -3
  	},
  	{
  		first: 224,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 224,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 224,
  		second: 86,
  		amount: -7
  	},
  	{
  		first: 224,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 224,
  		second: 89,
  		amount: -11
  	},
  	{
  		first: 224,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 224,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 224,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 224,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 224,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 224,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 224,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 224,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 224,
  		second: 179,
  		amount: -2
  	},
  	{
  		first: 224,
  		second: 185,
  		amount: -6
  	},
  	{
  		first: 224,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 224,
  		second: 376,
  		amount: -11
  	},
  	{
  		first: 224,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 224,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 224,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 224,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 224,
  		second: 221,
  		amount: -11
  	},
  	{
  		first: 224,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 224,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 224,
  		second: 92,
  		amount: -5
  	},
  	{
  		first: 224,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 225,
  		second: 34,
  		amount: -5
  	},
  	{
  		first: 225,
  		second: 39,
  		amount: -5
  	},
  	{
  		first: 225,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 225,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 225,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 225,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 225,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 225,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 225,
  		second: 63,
  		amount: -3
  	},
  	{
  		first: 225,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 225,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 225,
  		second: 86,
  		amount: -7
  	},
  	{
  		first: 225,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 225,
  		second: 89,
  		amount: -11
  	},
  	{
  		first: 225,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 225,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 225,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 225,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 225,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 225,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 225,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 225,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 225,
  		second: 179,
  		amount: -2
  	},
  	{
  		first: 225,
  		second: 185,
  		amount: -6
  	},
  	{
  		first: 225,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 225,
  		second: 376,
  		amount: -11
  	},
  	{
  		first: 225,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 225,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 225,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 225,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 225,
  		second: 221,
  		amount: -11
  	},
  	{
  		first: 225,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 225,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 225,
  		second: 92,
  		amount: -5
  	},
  	{
  		first: 225,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 226,
  		second: 34,
  		amount: -5
  	},
  	{
  		first: 226,
  		second: 39,
  		amount: -5
  	},
  	{
  		first: 226,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 226,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 226,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 226,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 226,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 226,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 226,
  		second: 63,
  		amount: -3
  	},
  	{
  		first: 226,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 226,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 226,
  		second: 86,
  		amount: -7
  	},
  	{
  		first: 226,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 226,
  		second: 89,
  		amount: -11
  	},
  	{
  		first: 226,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 226,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 226,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 226,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 226,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 226,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 226,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 226,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 226,
  		second: 179,
  		amount: -2
  	},
  	{
  		first: 226,
  		second: 185,
  		amount: -6
  	},
  	{
  		first: 226,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 226,
  		second: 376,
  		amount: -11
  	},
  	{
  		first: 226,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 226,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 226,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 226,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 226,
  		second: 221,
  		amount: -11
  	},
  	{
  		first: 226,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 226,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 226,
  		second: 92,
  		amount: -5
  	},
  	{
  		first: 226,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 227,
  		second: 34,
  		amount: -5
  	},
  	{
  		first: 227,
  		second: 39,
  		amount: -5
  	},
  	{
  		first: 227,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 227,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 227,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 227,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 227,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 227,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 227,
  		second: 63,
  		amount: -3
  	},
  	{
  		first: 227,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 227,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 227,
  		second: 86,
  		amount: -7
  	},
  	{
  		first: 227,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 227,
  		second: 89,
  		amount: -11
  	},
  	{
  		first: 227,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 227,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 227,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 227,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 227,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 227,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 227,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 227,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 227,
  		second: 179,
  		amount: -2
  	},
  	{
  		first: 227,
  		second: 185,
  		amount: -6
  	},
  	{
  		first: 227,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 227,
  		second: 376,
  		amount: -11
  	},
  	{
  		first: 227,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 227,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 227,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 227,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 227,
  		second: 221,
  		amount: -11
  	},
  	{
  		first: 227,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 227,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 227,
  		second: 92,
  		amount: -5
  	},
  	{
  		first: 227,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 228,
  		second: 34,
  		amount: -5
  	},
  	{
  		first: 228,
  		second: 39,
  		amount: -5
  	},
  	{
  		first: 228,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 228,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 228,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 228,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 228,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 228,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 228,
  		second: 63,
  		amount: -3
  	},
  	{
  		first: 228,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 228,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 228,
  		second: 86,
  		amount: -7
  	},
  	{
  		first: 228,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 228,
  		second: 89,
  		amount: -11
  	},
  	{
  		first: 228,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 228,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 228,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 228,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 228,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 228,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 228,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 228,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 228,
  		second: 179,
  		amount: -2
  	},
  	{
  		first: 228,
  		second: 185,
  		amount: -6
  	},
  	{
  		first: 228,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 228,
  		second: 376,
  		amount: -11
  	},
  	{
  		first: 228,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 228,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 228,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 228,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 228,
  		second: 221,
  		amount: -11
  	},
  	{
  		first: 228,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 228,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 228,
  		second: 92,
  		amount: -5
  	},
  	{
  		first: 228,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 229,
  		second: 34,
  		amount: -5
  	},
  	{
  		first: 229,
  		second: 39,
  		amount: -5
  	},
  	{
  		first: 229,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 229,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 229,
  		second: 42,
  		amount: -5
  	},
  	{
  		first: 229,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 229,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 229,
  		second: 55,
  		amount: -6
  	},
  	{
  		first: 229,
  		second: 63,
  		amount: -3
  	},
  	{
  		first: 229,
  		second: 84,
  		amount: -9
  	},
  	{
  		first: 229,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 229,
  		second: 86,
  		amount: -7
  	},
  	{
  		first: 229,
  		second: 87,
  		amount: -7
  	},
  	{
  		first: 229,
  		second: 89,
  		amount: -11
  	},
  	{
  		first: 229,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 229,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 229,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 229,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 229,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 229,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 229,
  		second: 121,
  		amount: -3
  	},
  	{
  		first: 229,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 229,
  		second: 179,
  		amount: -2
  	},
  	{
  		first: 229,
  		second: 185,
  		amount: -6
  	},
  	{
  		first: 229,
  		second: 186,
  		amount: -1
  	},
  	{
  		first: 229,
  		second: 376,
  		amount: -11
  	},
  	{
  		first: 229,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 229,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 229,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 229,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 229,
  		second: 221,
  		amount: -11
  	},
  	{
  		first: 229,
  		second: 253,
  		amount: -3
  	},
  	{
  		first: 229,
  		second: 255,
  		amount: -3
  	},
  	{
  		first: 229,
  		second: 92,
  		amount: -5
  	},
  	{
  		first: 229,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 230,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 8217,
  		amount: -4
  	},
  	{
  		first: 230,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 230,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 230,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 230,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 230,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 230,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 230,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 230,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 230,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 230,
  		second: 89,
  		amount: -9
  	},
  	{
  		first: 230,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 230,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 230,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 230,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 230,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 230,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 230,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 376,
  		amount: -9
  	},
  	{
  		first: 230,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 221,
  		amount: -9
  	},
  	{
  		first: 230,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 230,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 230,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 230,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 231,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 231,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 231,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 231,
  		second: 63,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 67,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 71,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 79,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 81,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 231,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 231,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 231,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 231,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 231,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 231,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 231,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 231,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 231,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 338,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 231,
  		second: 199,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 210,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 211,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 212,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 213,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 214,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 216,
  		amount: -1
  	},
  	{
  		first: 231,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 231,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 231,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 231,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 231,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 231,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 231,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 231,
  		second: 92,
  		amount: -3
  	},
  	{
  		first: 232,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 8217,
  		amount: -4
  	},
  	{
  		first: 232,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 232,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 232,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 232,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 232,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 232,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 232,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 232,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 232,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 232,
  		second: 89,
  		amount: -9
  	},
  	{
  		first: 232,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 232,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 232,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 232,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 232,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 232,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 232,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 376,
  		amount: -9
  	},
  	{
  		first: 232,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 221,
  		amount: -9
  	},
  	{
  		first: 232,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 232,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 232,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 232,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 233,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 8217,
  		amount: -4
  	},
  	{
  		first: 233,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 233,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 233,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 233,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 233,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 233,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 233,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 233,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 233,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 233,
  		second: 89,
  		amount: -9
  	},
  	{
  		first: 233,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 233,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 233,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 233,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 233,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 233,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 233,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 376,
  		amount: -9
  	},
  	{
  		first: 233,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 221,
  		amount: -9
  	},
  	{
  		first: 233,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 233,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 233,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 233,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 234,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 8217,
  		amount: -4
  	},
  	{
  		first: 234,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 234,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 234,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 234,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 234,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 234,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 234,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 234,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 234,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 234,
  		second: 89,
  		amount: -9
  	},
  	{
  		first: 234,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 234,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 234,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 234,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 234,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 234,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 234,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 376,
  		amount: -9
  	},
  	{
  		first: 234,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 221,
  		amount: -9
  	},
  	{
  		first: 234,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 234,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 234,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 234,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 235,
  		second: 34,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 39,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 8217,
  		amount: -4
  	},
  	{
  		first: 235,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 235,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 235,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 55,
  		amount: -3
  	},
  	{
  		first: 235,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 235,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 235,
  		second: 84,
  		amount: -10
  	},
  	{
  		first: 235,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 235,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 235,
  		second: 88,
  		amount: -2
  	},
  	{
  		first: 235,
  		second: 89,
  		amount: -9
  	},
  	{
  		first: 235,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 235,
  		second: 102,
  		amount: 0
  	},
  	{
  		first: 235,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 235,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 235,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 235,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 235,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 376,
  		amount: -9
  	},
  	{
  		first: 235,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 221,
  		amount: -9
  	},
  	{
  		first: 235,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 235,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 235,
  		second: 255,
  		amount: -2
  	},
  	{
  		first: 235,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 236,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 236,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 236,
  		second: 90,
  		amount: 0
  	},
  	{
  		first: 236,
  		second: 381,
  		amount: 0
  	},
  	{
  		first: 236,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 236,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 236,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 236,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 237,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 237,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 237,
  		second: 90,
  		amount: 0
  	},
  	{
  		first: 237,
  		second: 381,
  		amount: 0
  	},
  	{
  		first: 237,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 237,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 237,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 237,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 238,
  		second: 8217,
  		amount: 5
  	},
  	{
  		first: 238,
  		second: 63,
  		amount: 1
  	},
  	{
  		first: 238,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 238,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 238,
  		second: 90,
  		amount: 0
  	},
  	{
  		first: 238,
  		second: 381,
  		amount: 0
  	},
  	{
  		first: 238,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 238,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 238,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 238,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 239,
  		second: 8217,
  		amount: 4
  	},
  	{
  		first: 239,
  		second: 84,
  		amount: -2
  	},
  	{
  		first: 239,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 239,
  		second: 90,
  		amount: 0
  	},
  	{
  		first: 239,
  		second: 381,
  		amount: 0
  	},
  	{
  		first: 239,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 239,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 239,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 239,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 240,
  		second: 8217,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 240,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 240,
  		second: 47,
  		amount: -2
  	},
  	{
  		first: 240,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 120,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 122,
  		amount: 0
  	},
  	{
  		first: 240,
  		second: 382,
  		amount: 0
  	},
  	{
  		first: 240,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 240,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 241,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 241,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 241,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 241,
  		second: 42,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 55,
  		amount: -5
  	},
  	{
  		first: 241,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 241,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 241,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 86,
  		amount: -4
  	},
  	{
  		first: 241,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 241,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 241,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 241,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 118,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 119,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 241,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 241,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 241,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 241,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 241,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 242,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 242,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 242,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 242,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 242,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 242,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 242,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 242,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 242,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 242,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 242,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 242,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 242,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 242,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 242,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 242,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 242,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 242,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 243,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 243,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 243,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 243,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 243,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 243,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 243,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 243,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 243,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 243,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 243,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 243,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 243,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 243,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 243,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 243,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 243,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 243,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 244,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 244,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 244,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 244,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 244,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 244,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 244,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 244,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 244,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 244,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 244,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 244,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 244,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 244,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 244,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 244,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 244,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 244,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 245,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 245,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 245,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 245,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 245,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 245,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 245,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 245,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 245,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 245,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 245,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 245,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 245,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 245,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 245,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 245,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 245,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 245,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 246,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 246,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 246,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 246,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 246,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 246,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 246,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 246,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 246,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 246,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 246,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 246,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 246,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 246,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 246,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 246,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 246,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 246,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 247,
  		second: 49,
  		amount: -1
  	},
  	{
  		first: 247,
  		second: 50,
  		amount: -2
  	},
  	{
  		first: 247,
  		second: 51,
  		amount: -2
  	},
  	{
  		first: 247,
  		second: 55,
  		amount: -5
  	},
  	{
  		first: 248,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 248,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 248,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 248,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 248,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 248,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 248,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 248,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 248,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 248,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 248,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 248,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 248,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 248,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 248,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 248,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 248,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 248,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 249,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 249,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 249,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 249,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 249,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 249,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 249,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 249,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 249,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 249,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 249,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 249,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 249,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 250,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 250,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 250,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 250,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 250,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 250,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 250,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 250,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 250,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 250,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 250,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 250,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 250,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 251,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 251,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 251,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 251,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 251,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 251,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 251,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 251,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 251,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 251,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 251,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 251,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 251,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 252,
  		second: 41,
  		amount: -3
  	},
  	{
  		first: 252,
  		second: 66,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 67,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 68,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 69,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 70,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 71,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 72,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 73,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 75,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 76,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 77,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 78,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 79,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 80,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 81,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 82,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 84,
  		amount: -7
  	},
  	{
  		first: 252,
  		second: 85,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 252,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 252,
  		second: 89,
  		amount: -6
  	},
  	{
  		first: 252,
  		second: 90,
  		amount: -1
  	},
  	{
  		first: 252,
  		second: 93,
  		amount: -4
  	},
  	{
  		first: 252,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 252,
  		second: 381,
  		amount: -1
  	},
  	{
  		first: 252,
  		second: 338,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 376,
  		amount: -6
  	},
  	{
  		first: 252,
  		second: 199,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 200,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 201,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 202,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 203,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 204,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 205,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 206,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 207,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 208,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 209,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 210,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 211,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 212,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 213,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 214,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 216,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 217,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 218,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 219,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 220,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 221,
  		amount: -6
  	},
  	{
  		first: 252,
  		second: 222,
  		amount: 0
  	},
  	{
  		first: 252,
  		second: 92,
  		amount: -2
  	},
  	{
  		first: 253,
  		second: 8217,
  		amount: 3
  	},
  	{
  		first: 253,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 253,
  		second: 44,
  		amount: -7
  	},
  	{
  		first: 253,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 253,
  		second: 46,
  		amount: -7
  	},
  	{
  		first: 253,
  		second: 47,
  		amount: -4
  	},
  	{
  		first: 253,
  		second: 65,
  		amount: -3
  	},
  	{
  		first: 253,
  		second: 74,
  		amount: -5
  	},
  	{
  		first: 253,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 253,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 88,
  		amount: -4
  	},
  	{
  		first: 253,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 253,
  		second: 90,
  		amount: -4
  	},
  	{
  		first: 253,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 253,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 253,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 253,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 253,
  		second: 381,
  		amount: -4
  	},
  	{
  		first: 253,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 253,
  		second: 192,
  		amount: -3
  	},
  	{
  		first: 253,
  		second: 193,
  		amount: -3
  	},
  	{
  		first: 253,
  		second: 194,
  		amount: -3
  	},
  	{
  		first: 253,
  		second: 195,
  		amount: -3
  	},
  	{
  		first: 253,
  		second: 196,
  		amount: -3
  	},
  	{
  		first: 253,
  		second: 197,
  		amount: -3
  	},
  	{
  		first: 253,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 253,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 253,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 253,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 34,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 39,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 8217,
  		amount: -5
  	},
  	{
  		first: 254,
  		second: 36,
  		amount: 0
  	},
  	{
  		first: 254,
  		second: 41,
  		amount: -5
  	},
  	{
  		first: 254,
  		second: 42,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 44,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 46,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 47,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 254,
  		second: 63,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 65,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 66,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 68,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 69,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 70,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 72,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 73,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 75,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 76,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 77,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 78,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 80,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 82,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 83,
  		amount: 0
  	},
  	{
  		first: 254,
  		second: 84,
  		amount: -11
  	},
  	{
  		first: 254,
  		second: 85,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 86,
  		amount: -5
  	},
  	{
  		first: 254,
  		second: 87,
  		amount: -3
  	},
  	{
  		first: 254,
  		second: 88,
  		amount: -3
  	},
  	{
  		first: 254,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 254,
  		second: 90,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 254,
  		second: 102,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 116,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 121,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 122,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 125,
  		amount: -3
  	},
  	{
  		first: 254,
  		second: 352,
  		amount: 0
  	},
  	{
  		first: 254,
  		second: 381,
  		amount: -2
  	},
  	{
  		first: 254,
  		second: 382,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 254,
  		second: 192,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 193,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 194,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 195,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 196,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 197,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 200,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 201,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 202,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 203,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 204,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 205,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 206,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 207,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 208,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 209,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 217,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 218,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 219,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 220,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 254,
  		second: 222,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 253,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 255,
  		amount: -1
  	},
  	{
  		first: 254,
  		second: 92,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 8217,
  		amount: 3
  	},
  	{
  		first: 255,
  		second: 38,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 41,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 44,
  		amount: -7
  	},
  	{
  		first: 255,
  		second: 45,
  		amount: -2
  	},
  	{
  		first: 255,
  		second: 46,
  		amount: -7
  	},
  	{
  		first: 255,
  		second: 47,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 65,
  		amount: -3
  	},
  	{
  		first: 255,
  		second: 74,
  		amount: -5
  	},
  	{
  		first: 255,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 255,
  		second: 86,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 88,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 90,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 93,
  		amount: -5
  	},
  	{
  		first: 255,
  		second: 95,
  		amount: -2
  	},
  	{
  		first: 255,
  		second: 97,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 115,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 125,
  		amount: -2
  	},
  	{
  		first: 255,
  		second: 353,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 171,
  		amount: -2
  	},
  	{
  		first: 255,
  		second: 381,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 192,
  		amount: -3
  	},
  	{
  		first: 255,
  		second: 193,
  		amount: -3
  	},
  	{
  		first: 255,
  		second: 194,
  		amount: -3
  	},
  	{
  		first: 255,
  		second: 195,
  		amount: -3
  	},
  	{
  		first: 255,
  		second: 196,
  		amount: -3
  	},
  	{
  		first: 255,
  		second: 197,
  		amount: -3
  	},
  	{
  		first: 255,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 255,
  		second: 224,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 225,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 226,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 227,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 228,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 229,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 230,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 240,
  		amount: -2
  	},
  	{
  		first: 255,
  		second: 92,
  		amount: -1
  	},
  	{
  		first: 255,
  		second: 32,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 34,
  		amount: -6
  	},
  	{
  		first: 92,
  		second: 39,
  		amount: -6
  	},
  	{
  		first: 92,
  		second: 8217,
  		amount: -6
  	},
  	{
  		first: 92,
  		second: 48,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 49,
  		amount: -4
  	},
  	{
  		first: 92,
  		second: 54,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 55,
  		amount: -7
  	},
  	{
  		first: 92,
  		second: 67,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 71,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 79,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 81,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 84,
  		amount: -6
  	},
  	{
  		first: 92,
  		second: 85,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 86,
  		amount: -7
  	},
  	{
  		first: 92,
  		second: 87,
  		amount: -5
  	},
  	{
  		first: 92,
  		second: 89,
  		amount: -7
  	},
  	{
  		first: 92,
  		second: 99,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 100,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 101,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 111,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 113,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 116,
  		amount: -3
  	},
  	{
  		first: 92,
  		second: 117,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 118,
  		amount: -4
  	},
  	{
  		first: 92,
  		second: 119,
  		amount: -3
  	},
  	{
  		first: 92,
  		second: 121,
  		amount: -4
  	},
  	{
  		first: 92,
  		second: 162,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 338,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 339,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 376,
  		amount: -7
  	},
  	{
  		first: 92,
  		second: 199,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 210,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 211,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 212,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 213,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 214,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 216,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 217,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 218,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 219,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 220,
  		amount: -2
  	},
  	{
  		first: 92,
  		second: 221,
  		amount: -7
  	},
  	{
  		first: 92,
  		second: 231,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 232,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 233,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 234,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 235,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 240,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 242,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 243,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 244,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 245,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 246,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 248,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 249,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 250,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 251,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 252,
  		amount: -1
  	},
  	{
  		first: 92,
  		second: 253,
  		amount: -4
  	},
  	{
  		first: 92,
  		second: 255,
  		amount: -4
  	},
  	{
  		first: 92,
  		second: 92,
  		amount: -16
  	},
  	{
  		first: 32,
  		second: 49,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 55,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 65,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 74,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 84,
  		amount: -3
  	},
  	{
  		first: 32,
  		second: 86,
  		amount: -3
  	},
  	{
  		first: 32,
  		second: 87,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 88,
  		amount: -1
  	},
  	{
  		first: 32,
  		second: 89,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 102,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 116,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 118,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 119,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 120,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 121,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 376,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 192,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 193,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 194,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 195,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 196,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 197,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 198,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 221,
  		amount: -4
  	},
  	{
  		first: 32,
  		second: 253,
  		amount: -2
  	},
  	{
  		first: 32,
  		second: 255,
  		amount: -2
  	}
  ];
  var font = {
  	pages: pages,
  	chars: chars,
  	info: info,
  	common: common,
  	distanceField: distanceField,
  	kernings: kernings
  };

  /**
   * draw text using msdf font texture, using {@link GlRectInstancer}
   *
   * @export
   * @class GlText
   */
  class GlText {
    /**
     * @param {GlTextWriter} textWriter
     * @param {string} string
     */
    constructor(textWriter, string) {
      if (!textWriter) {
        throw new Error("glgui text constructor without textwriter");
      }

      this._visible = true;
      this._textWriter = textWriter;
      this._string = string || "";
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._rects = [];
      this._width = 0;
      this._height = 0;
      this._color = [1, 1, 1, 1];
      this._align = 0;
      this._scale = 1.2;
      this._parentRect = null;

      this._font = font;
      if (this._font && this._font.chars) {
        this._font.characters = {};

        for (let i = 0; i < this._font.chars.length; i++)
          this._font.characters[this._font.chars[i].char] = this._font.chars[i];
      }

      this.rebuild();
    }

    set x(x) {
      this._x = x;
      this.rebuild();
    }

    set y(y) {
      this._y = y;
      this.rebuild();
    }

    set z(z) {
      this._z = z;
      this.rebuild();
    }

    set text(t) {
      this._string = t;
      this.rebuild();
    }

    get text() {
      return this._string;
    }

    get width() {
      return this._width;
    }

    get height() {
      return this._height * 0.5 * this._scale;
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    setPosition(x, y, z = 0) {
      this._x = x;
      this._y = y;
      this._z = z;

      this.rebuild();
    }

    /**
     * @param {number} s
     */
    set scale(s) {
      this._scale = s;
      this.rebuild();
    }

    /**
     * @param {boolean} v
     */
    set visible(v) {
      if (this._visible === v) return;
      this._visible = v;
      for (let i = 0; i < this._rects.length; i++)
        if (this._rects[i]) this._rects[i].visible = v;
    }

    /**
     * @param {number} x
     */
    _map(x) {
      return x * 0.11 * this._scale;
    }

    /**
     * @param {GlRect} r
     */
    setParentRect(r) {
      if (this._parentRectListener && this._parentRect)
        this._parentRectListener = this._parentRect.off(this._parentRectListener);

      this._parentRect = r;
      if (this._parentRect)
        this._parentRectListener = this._parentRect.on(
          GlRect.EVENT_POSITIONCHANGED,
          this.rebuild.bind(this),
        );
      this.rebuild();
    }

    /**
     * @param {number} a
     */
    setOpacity(a) {
      this.setColor(this._color[0], this._color[1], this._color[2], a);
    }

    /**
     * @param {number|array} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     */
    setColor(r, g = 1, b = 1, a = 1) {
      if (r === undefined) r = g = b = 1.0;
      if (r.length) {
        CABLES.logStack();
        set$3(this._color, r[0], r[1], r[2], a);
      } else set$3(this._color, r, g, b, a);

      for (let i = 0; i < this._rects.length; i++)
        if (this._rects[i]) this._rects[i].setColorArray(this._color);
    }

    /**
     * @param {number[]} r
     */
    setColorArray(r) {
      set$3(this._color, r[0], r[1], r[2], 1);

      for (let i = 0; i < this._rects.length; i++)
        if (this._rects[i]) this._rects[i].setColorArray(this._color);
    }

    rebuild() {
      let w = 0;
      for (let i = 0; i < this._string.length; i++) {
        const ch =
          this._font.characters[this._string[i]] || this._font.characters["?"];
        w += ch.xadvance;
      }

      this._width = this._map(w);

      const lineHeight = this._map(this._font.info.size / 2) + 13;
      let posX = this._x;
      let posY = this._y + lineHeight;
      let posZ = this._z;
      let countLines = 1;

      if (this._parentRect) {
        posX += this._parentRect.x;
        posY += this._parentRect.y;
        posZ += this._parentRect.z;
      }

      if (this._align == 1) posX -= this._width / 2;
      else if (this._align == 2) posX -= this._width;

      let rectCount = 0;
      for (let i = 0; i < this._string.length; i++) {
        const char = this._string.charAt(i);
        const ch = this._font.characters[char] || this._font.characters["?"];
        if (char == "\n") {
          posX = this._x;
          if (this._parentRect) posX = this._x + this._parentRect.x;
          posY += lineHeight;
          countLines++;
          continue;
        }
        rectCount++;
        const rect =
          this._rects[rectCount] || this._textWriter.rectDrawer.createRect();
        rect.visible = this._visible;
        this._rects[rectCount] = rect;

        rect.setPosition(
          posX + this._map(ch.xoffset),
          this._map(ch.yoffset) - -posY - lineHeight + 6.0,
          posZ,
        ); //
        rect.setSize(this._map(ch.width), this._map(ch.height));
        rect.setColorArray(this._color);

        rect.setTexRect(
          ch.x / 1024,
          ch.y / 1024,
          ch.width / 1024,
          ch.height / 1024,
        );
        rect.setTexture(this._textWriter.getFontTexture());

        posX += this._map(ch.xadvance);
      }

      for (let i = rectCount + 1; i < this._rects.length; i++) {
        if (this._rects[i]) {
          this._rects[i].setSize(0, 0);
          this._rects[i].visible = false;
        }
      }

      this._height = countLines * lineHeight;
    }

    dispose() {
      for (let i = 0; i < this._rects.length; i++)
        if (this._rects[i]) this._rects[i].dispose();

      this._rects.length = 0;
      this._string = "";
      return null;
    }
  }

  /**
   * managing mouse states buttons/position/dragging etc
   *
   * @export
   * @class MouseState
   * @extends {Events}
   */
  class MouseState extends Events {
    static BUTTON_NONE = 0;
    static BUTTON_LEFT = 1;
    static BUTTON_RIGHT = 2;
    static BUTTON_WHEEL = 4;
    static BUTTON_4 = 8;
    static BUTTON_5 = 16;

    constructor(canvas) {
      super();
      this._mouseOverCanvas = false;
      this._x = 0;
      this._y = 0;
      this._buttonStates = {};
      this._buttonStates[MouseState.BUTTON_LEFT] = { down: false };
      this._buttonStates[MouseState.BUTTON_RIGHT] = { down: false };
      this._buttonStates[MouseState.BUTTON_WHEEL] = { down: false };
      this._buttonStates[MouseState.BUTTON_4] = { down: false };
      this._buttonStates[MouseState.BUTTON_5] = { down: false };
      this._numFingers = 0;

      this._isDragging = false;
      this._mouseDownX = 0;
      this._mouseDownY = 0;

      this._useDragCablesButton = MouseState.BUTTON_RIGHT;
      this.buttonForScrolling = MouseState.BUTTON_RIGHT;
      this.buttonForSelecting = MouseState.BUTTON_LEFT;

      this._initUserPrefs();

      UserSettings.userSettings.on("change", this._initUserPrefs.bind(this));

      canvas.addEventListener("pointerenter", (/** @type {PointerEvent} */ e) => {
        if (e.pointerType == "touch") this._mouseOverCanvas = true;
        else this._mouseOverCanvas = true;
      });

      canvas.addEventListener("pointerleave", (/** @type {PointerEvent} */ e) => {
        if (e.pointerType == "touch") this._mouseOverCanvas = true;
        else this._mouseOverCanvas = false;
      });

      canvas.addEventListener("pointerdown", this._down.bind(this), {
        passive: false,
      });
      canvas.addEventListener("pointerup", this._up.bind(this), {
        passive: false,
      });
      canvas.addEventListener("pointermove", this.#move.bind(this), {
        passive: false,
      });
      // canvas.addEventListener("touchmove", this._move.bind(this), { "passive": false });

      /*
       * canvas.addEventListener("touchstart", this._down.bind(this), { "passive": false });
       * canvas.addEventListener("touchend", this._up.bind(this), { "passive": false });
       */

      canvas.addEventListener("touchenter", (e) => {
        this._numFingers = e.touches.length;
      });

      canvas.addEventListener("touchleave", (e) => {
        this._numFingers = e.touches.length;
      });
    }

    get x() {
      return this._x;
    }

    get y() {
      return this._y;
    }

    get numFingers() {
      return this._numFingers;
    }

    get mouseOverCanvas() {
      return this._mouseOverCanvas;
    }

    get buttonAny() {
      return (
        this._buttonStates[MouseState.BUTTON_LEFT].down ||
        this._buttonStates[MouseState.BUTTON_RIGHT].down ||
        this._buttonStates[MouseState.BUTTON_WHEEL].down ||
        this._buttonStates[MouseState.BUTTON_4].down ||
        this._buttonStates[MouseState.BUTTON_5].down
      );
    }

    get buttonLeft() {
      return this._buttonStates[MouseState.BUTTON_LEFT].down;
    }

    get buttonRight() {
      return this._buttonStates[MouseState.BUTTON_RIGHT].down;
    }

    get buttonMiddle() {
      return this._buttonStates[MouseState.BUTTON_WHEEL].down;
    }

    get isDragging() {
      return this._isDragging;
    }

    _initUserPrefs() {
      const userSettingScrollButton = UserSettings.userSettings.get(
        "patch_button_scroll",
      );

      if (userSettingScrollButton == 4)
        this.buttonForScrolling = MouseState.BUTTON_WHEEL;
      if (userSettingScrollButton == 1)
        this.buttonForScrolling = MouseState.BUTTON_LEFT;
      if (userSettingScrollButton == 2)
        this.buttonForScrolling = MouseState.BUTTON_RIGHT;
    }

    _updateDebug() {
      let str = "";

      for (let i in this._buttonStates)
        str += i + ":" + (this._buttonStates[i].down ? "X" : "-") + " | ";

      Gui$1.gui.patchView._patchRenderer.debugData.mouseState = str;
    }

    /** @returns {Number} */
    getButton() {
      if (this._buttonStates[MouseState.BUTTON_LEFT].down)
        return MouseState.BUTTON_LEFT;
      if (this._buttonStates[MouseState.BUTTON_RIGHT].down)
        return MouseState.BUTTON_RIGHT;
      if (this._buttonStates[MouseState.BUTTON_WHEEL].down)
        return MouseState.BUTTON_WHEEL;
      if (this._buttonStates[MouseState.BUTTON_4].down)
        return MouseState.BUTTON_4;
      if (this._buttonStates[MouseState.BUTTON_5].down)
        return MouseState.BUTTON_5;
      return MouseState.BUTTON_NONE;
    }

    /** @param {Number} button */
    isButtonDown(button) {
      if (button === undefined) return this.buttonAny;
      return this._buttonStates[button].down;
    }

    /**
     * @private
     */
    _setButtonsUp() {
      for (const i in this._buttonStates) {
        this._buttonUp(i);
      }
    }

    /**
     * @private
     */
    _buttonUp(button) {
      if (this._buttonStates[button]) {
        this._buttonStates[button].down = false;
        this.emitEvent("buttonUp", button);
      }
      this._updateDebug();
    }

    #buttonDown(button) {
      if (!this._buttonStates[button].down) {
        this._buttonStates[button].down = true;
        this.emitEvent("buttonDown", button);
      }
      this._updateDebug();
    }

    #setButton(button, newState) {
      if (button == MouseState.BUTTON_LEFT + MouseState.BUTTON_RIGHT) {
        this.#setButton(MouseState.BUTTON_LEFT, newState);
        this.#setButton(MouseState.BUTTON_RIGHT, newState);
        return;
      }
      if (button == MouseState.BUTTON_LEFT + MouseState.BUTTON_WHEEL) {
        this.#setButton(MouseState.BUTTON_LEFT, newState);
        this.#setButton(MouseState.BUTTON_WHEEL, newState);
        return;
      }
      if (button == MouseState.BUTTON_RIGHT + MouseState.BUTTON_WHEEL) {
        this.#setButton(MouseState.BUTTON_RIGHT, newState);
        this.#setButton(MouseState.BUTTON_WHEEL, newState);
        return;
      }

      if (!button) return;

      if (!this._buttonStates[button]) this._buttonStates[button] = {};

      if (this._buttonStates[button].down != newState) {
        const oldState = this._buttonStates[button].down;
        if (oldState && !newState) this._buttonUp(button);
        if (!oldState && newState) this.#buttonDown(button);
      }
    }

    debug(data) {
      data.mouse_OverCanvas = this._mouseOverCanvas;
      data.mouse_buttonStates = JSON.stringify(this._buttonStates); // .join(",");
    }

    /**
     * @param {PointerEvent} e
     */
    #move(e) {
      if (!e.pointerType) return;
      this._mouseOverCanvas = true;

      if (this.buttonAny) {
        this._isDragging =
          this._mouseDownX != e.offsetX || this._mouseDownY != e.offsetY;
        this.draggingDistance = Math.sqrt(
          (e.offsetX - this._mouseDownX) ** 2 +
            (e.offsetY - this._mouseDownY) ** 2,
        );
      }

      if (e.buttons) {
        for (let i in this._buttonStates) this._buttonStates[i].down = false;
        this.#setButton(e.buttons, true);
      } else this._setButtonsUp();
    }

    /**
     * @private
     */
    _down(e) {
      this._mouseDownX = e.offsetX;
      this._mouseDownY = e.offsetY;
      this._isDragging = false;
      this.draggingDistance = 0;
      this.#setButton(e.buttons, true);
    }

    /**
     * @private
     */
    _up(e) {
      this._isDragging = false;

      /*
       * console.log("up", e.buttons, e);
       * this._setButton(e.buttons, false);
       */
      if (e.buttons == 0) this._setButtonsUp();
    }

    get buttonStateForScrolling() {
      if (
        this.buttonForScrolling == this._useDragCablesButton &&
        Gui$1.gui.patchView.patchRenderer.isDraggingPort()
      )
        return false;
      if (
        this.buttonForScrolling == this._useDragCablesButton &&
        Gui$1.gui.patchView.patchRenderer.isDraggingPort()
      )
        return false;
      return this._buttonStates[this.buttonForScrolling].down;
    }

    get buttonStateForSelecting() {
      return this._buttonStates[this.buttonForSelecting].down;
    }

    get buttonStateForLinkDrag() {
      return this._buttonStates[this._useDragCablesButton].down;
    }

    get buttonStateForSelectionArea() {
      return this._buttonStates[MouseState.BUTTON_LEFT].down;
    }

    get buttonForRemoveLink() {
      return MouseState.BUTTON_RIGHT;
    }

    get buttonForLinkInsertOp() {
      return MouseState.BUTTON_LEFT;
    }
  }

  class GlArea {
    /**
     * @param {GlRectInstancer} instancer
     * @param {GlOp} glop
     */
    constructor(instancer, glop) {
      this._instancer = instancer;

      /**
       * @private
       * @type {GlOp}
       */
      this._glop = glop;
      this._id = CABLES.shortId();

      /**
       * @private
       * @type {Number}
       */
      this._w = 300;

      /**
       * @private
       * @type {Number}
       */
      this._h = 200;

      /**
       * @private
       * @type {Boolean}
       */
      this._visible = true;

      /**
       * @type {GlRect}
       */
      this._rectBg = this._instancer.createRect({ draggable: false });
      this._rectBg.setSize(this._w, this._h);
      this._updateColor();

      /**
       * @type {Number}
       */
      this.resizeCornerSize = 15;

      /**
       * @type {GlRect}
       */
      this._rectResize = this._instancer.createRect({ draggable: true });
      this._rectResize.setShape(2);
      this._rectResize.setSize(this.resizeCornerSize, this.resizeCornerSize);
      this._rectResize.setColor(0, 0, 0, 0.2);
      this._rectResize.setPosition(
        200 - this.resizeCornerSize,
        200 - this.resizeCornerSize,
      );
      this._rectResize.draggable = true;
      this._rectResize.draggableMove = true;

      this._glop.on("drag", () => {
        this._update();
      });

      this._rectResize.on("drag", (_e) => {
        this._w = this._rectResize.x - this._glop.x + this._rectResize.w / 2;
        this._h = this._rectResize.y - this._glop.y + this._rectResize.h / 2;

        if (UserSettings.userSettings.get("snapToGrid2")) {
          this._w = this._glop.glPatch.snap.snapX(this._w);
          this._h = this._glop.glPatch.snap.snapY(this._h);
        }

        Gui$1.gui.savedState.setUnSaved(
          "resizeGlArea",
          this._glop.op.getSubPatch(),
        );
        this._update();
      });

      if (this._glop.op.uiAttribs.area) {
        if (this._glop.op.uiAttribs.area.id)
          this._id = this._glop.op.uiAttribs.area.id;
        this._w = this._glop.op.uiAttribs.area.w;
        this._h = this._glop.op.uiAttribs.area.h;
      }

      this._update();
    }

    /**
     * @param {boolean} v
     */
    set visible(v) {
      this._visible = v;
      this._update();
    }

    /**
     * @private
     */
    _update() {
      if (this._rectBg) {
        this._rectBg.visible = this._visible;
        this._rectResize.visible = this._visible;

        if (!this._visible) return;
        this._rectBg.setPosition(this._glop.x, this._glop.y, 0.1);

        this._rectBg.setSize(this._w, this._h);

        this._rectResize.setPosition(
          this._glop.x + this._w - this._rectResize.w,
          this._glop.y + this._h - this._rectResize.h,
          -0.1,
        );
      }

      this._glop.op.setUiAttrib({
        area: { w: this._w, h: this._h, id: this._id },
      });
    }

    /**
     * @private
     */
    _updateColor() {
      if (this._glop.opUiAttribs.color) {
        const cols = chroma.hex(this._glop.opUiAttribs.color).gl();
        cols[3] = 0.1;
        this._rectBg.setColor(cols);
      } else this._rectBg.setColor(0, 0, 0, 0.08);
    }

    dispose() {
      this._rectBg.dispose();
      this._rectResize.dispose();
      this._rectBg = null;
      this._rectResize = null;
      return null;
    }
  }

  /**
   * rendering of ops on the patchfield {@link GlPatch}
   *
   * @export
   * @class GlOp
   * @extends {Events}
   */
  class GlOp extends Events {
    /**
     * @param {GlPatch} glPatch
     * @param {GlRectInstancer} instancer
     * @param {UiOp} op
     */
    constructor(glPatch, instancer, op) {
      super();

      /**
       * @private
       * @type Logger
       */
      this._log = new Logger("glop");

      this.DISPLAY_DEFAULT = 0;
      this.DISPLAY_COMMENT = 1;
      this.DISPLAY_UI_AREA = 2;
      this.DISPLAY_UI_AREA_INSTANCER = 3;
      this.DISPLAY_SUBPATCH = 3;
      this.DISPLAY_REROUTE_DOT = 4;

      /**
       * @private
       * @type String
       */
      this._id = op.id;

      /**
       * @private
       * @type Boolean
       */
      this._visible = true;

      /**
       * @private
       * @type {GlPatch}
       */
      this._glPatch = glPatch;

      /**
       * @private
       * @type {UiOp}
       */
      this._op = op;

      /**
       * @private
       * @type String
       */
      this._objName = op.objName;

      /**
       * @private
       * @type {Array}
       */
      this._glRectNames = [];

      /**
       * @private
       * @type GlRectInstancer
       */
      this._instancer = instancer;

      /**
       * @private
       * @type {Number}
       */
      this._width = gluiconfig.opWidth;

      /**
       * @private
       * @type {Number}
       */
      this._height = gluiconfig.opHeight;

      /**
       * @private
       * @type {Boolean}
       */
      this._needsUpdate = true;

      /**
       * @private
       * @type {GlTextWriter}
       */
      this._textWriter = null;

      /**
       * @private
       * @type {GlArea}
       */
      this._resizableArea = null;
      this._glRectNames.push("_resizableArea");

      /**
       * @type {GlRect}
       */
      this._glRectSelected = null;

      /**
       * @type {GlRect}
       */
      this._glRectBg = null;

      /**
       * @type {GlRect}
       */
      this._rectResize = null;

      /**
       * @type {GlRect}
       */
      this._glColorIndicator = null;

      /**
       * @type {GlRect}
       */
      this._glRerouteDot = null;

      this.minWidth = 10;

      this._origPosZ = gluiconfig.zPosOpSelected; // + (0.1 + Math.random() * 0.01);

      /**
       * @type {GlRect}
       */
      this._glRectArea = null;

      this._titleExtPortTimeout = null;
      this._titleExtPortLastTime = null;

      /** @type {Port} */
      this._titleExtPort = null;
      this._titleExtPortListener = null;

      /** @type GlText */
      this._titleExt = null;
      this._glRectNames.push("_titleExt");

      /**
       * @type GlText
       */
      this._glTitle = null;
      this._glRectNames.push("_glTitle");

      /**
       * @type GlText
       */
      this._glComment = null;
      this._glRectNames.push("_glComment");

      /**
       * @type {Boolean}
       */
      this._hidePorts = false;

      /**
       * @type {Boolean}
       */
      this._hideBgRect = false;

      this.displayType = 0;

      this._glPorts = [];
      this.opUiAttribs = {};
      this._links = {};

      /**
       * @type {Boolean}
       */
      this._transparent = false;
      this.setUiAttribs({}, op.uiAttribs);
      this._visPort = null;

      /**
       * @type {GlRect}
       */
      this._glRectContent = null;
      this._passiveDragStartX = null;
      this._passiveDragStartY = null;
      this._dragOldUiAttribs = null;
      this._rectBorder = 0;

      /**
       * @type {GlRect}
       */
      this._glLoadingIndicator = null;

      /**
       * @type {GlRect}
       */
      this._glNotWorkingCross = null;

      /**
       * @type {GlRect}
       */
      this._glDotError = null;

      /**
       * @type {GlRect}
       */
      this._glDotWarning = null;

      /**
       * @type {GlRect}
       */
      this._glDotHint = null;

      if (this._op) {
        this._op.on("onStorageChange", () => {
          this._storageChanged();
        });

        this._op.on("portOrderChanged", () => {
          this.refreshPorts();
        });

        this._op.on("onPortRemoved", () => {
          this.refreshPorts();
        });

        if (this._op.objName.indexOf("Ops.Ui.Comment") === 0)
          this.displayType =
            this.DISPLAY_COMMENT; // todo: better use uiattr comment_title
        else if (this._op.objName.indexOf("Ops.Ui.Area") === 0)
          this.displayType = this.DISPLAY_UI_AREA;
      }

      /**
       * @type {Boolean}
       */
      this._wasInited = false;

      /**
       * @type {Boolean}
       */
      this._wasInCurrentSubpatch = false;

      this._initGl();

      this._glPatch.on("selectedOpsChanged", (num) => {
        if (!this._visible) return;
        this._updateSelectedRect();
        if (this._glRectSelected) this.updateSize();
      });
    }

    _storageChanged() {
      if (this._op?.isSubPatchOp()) {
        this.displayType = this.DISPLAY_SUBPATCH;
        this._rectBorder = 1;

        if (this._op.isSubPatchOp())
          this._rectBorder = gluiconfig.subPatchOpBorder;
        this._updateColors();
        this.refreshPorts();

        this._op.patch.on("subpatchExpose", (subpatchid) => {
          if (
            this._op &&
            this._op.patchId &&
            this._op.patchId.get() === subpatchid
          )
            this.refreshPorts();
        });
      }
    }

    _initWhenFirstInCurrentSubpatch() {
      if (this._wasInCurrentSubpatch) return;
      if (!this.isInCurrentSubPatch()) return;

      this._wasInCurrentSubpatch = true;

      this._storageChanged();
      this.refreshPorts();

      if (this._glRectBg) {
        this._glRectBg.on(GlRect.EVENT_DRAG, this._onBgRectDrag.bind(this));
        this._glRectBg.on(GlRect.EVENT_DRAGEND, this._onBgRectDragEnd.bind(this));
        this._glRectBg.on(
          GlRect.EVENT_POINTER_DOWN,
          this._onMouseDown.bind(this),
        );
        this._glRectBg.on(GlRect.EVENT_POINTER_UP, this._onMouseUp.bind(this));
      }

      this._needsUpdate = true;

      this.setHover(false);
      this.updateVisible();
      this.updateSize();
    }

    _initGl() {
      this._glRectBg = this._instancer.createRect({ draggable: true });
      this._glRectBg.setSize(gluiconfig.opWidth, gluiconfig.opHeight);
      this._glRectBg.setColorArray(Gui$1.gui.theme.colors_patch.opBgRect);

      this._glRectNames.push("_glRectBg");

      this._initWhenFirstInCurrentSubpatch();
      this._wasInited = true;
    }

    get objName() {
      return this._objName;
    }

    get glPatch() {
      return this._glPatch;
    }

    get isDragging() {
      if (this._glRectBg) return this._glRectBg.isDragging;
      else return false;
    }

    get x() {
      if (this.opUiAttribs.translate) return this.opUiAttribs.translate.x;
      else return 0;
    }

    get y() {
      if (this.opUiAttribs.translate) return this.opUiAttribs.translate.y;
      else return 0;
    }

    get w() {
      return this._width;
    }

    get h() {
      return this._height;
    }

    get id() {
      return this._id;
    }

    get title() {
      return this.opUiAttribs.title;
    }

    get op() {
      return this._op;
    }

    _onBgRectDrag(e) {
      if (Gui$1.gui.longPressConnector.isActive()) return;
      if (!this._glRectBg) return;
      if (Gui$1.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_FULL) return;

      const glOps = this._glPatch.selectedGlOps;
      const ids = Object.keys(glOps);

      if (!glOps || ids.length == 0) return;
      if (this._glPatch.isDraggingPort()) return;

      if (!glOps[ids[0]].isPassiveDrag())
        for (const i in glOps) glOps[i].startPassiveDrag();

      const offX = this._glRectBg.dragOffsetX;
      const offY = this._glRectBg.dragOffsetY;

      for (const i in glOps) glOps[i].setPassiveDragOffset(offX, offY);

      this._glPatch.opShakeDetector.move(offX);

      if (Gui$1.gui.patchView.getSelectedOps().length == 1) {
        this._glRectBg.setOpacity(0.8, false);
        // this._preDragPosZ = this._glRectBg.z;
        this.updatePosition();
      }
    }

    getPosZ() {
      if (!this.op.isLinked()) return gluiconfig.zPosOpUnlinked;
      if (this.selected) return gluiconfig.zPosOpSelected;
      return gluiconfig.zPosOpUnSelected;
    }

    _onBgRectDragEnd() {
      const glOps = this._glPatch.selectedGlOps;

      const oldUiAttribs = JSON.parse(this._dragOldUiAttribs);

      if (!this._op || !oldUiAttribs || !oldUiAttribs.translate) return;

      let changed =
        oldUiAttribs.translate.x != this._op.uiAttribs.translate.x ||
        oldUiAttribs.translate.y != this._op.uiAttribs.translate.y;

      if (changed) {
        const undoGroup = undo.startGroup();

        for (const i in glOps) glOps[i].endPassiveDrag();

        (function (scope, _oldUiAttribs) {
          if (!scope._op) return;

          const newUiAttr = JSON.stringify(scope._op.uiAttribs);
          undo.add({
            title: "Move op",
            undo() {
              try {
                const u = JSON.parse(_oldUiAttribs);
                // scope._glRectBg.setPosition(u.translate.x, u.translate.y);
                scope._glPatch.patchAPI.setOpUiAttribs(scope._id, "translate", {
                  x: u.translate.x,
                  y: u.translate.y,
                });
              } catch (e) {}
            },
            redo() {
              const u = JSON.parse(newUiAttr);
              scope._glPatch.patchAPI.setOpUiAttribs(scope._id, "translate", {
                x: u.translate.x,
                y: u.translate.y,
              });

              /*
               * scope.op.uiAttribs.translate = { "x": u.translate.x, "y": u.translate.y };
               * scope._glRectBg.setPosition(u.translate.x, u.translate.y);
               */
            },
          });
        })(this, this._dragOldUiAttribs + "");

        Gui$1.gui.patchView.testCollision(this._op);

        undo.endGroup(undoGroup, "Move Ops");
      }
    }

    /**
     * @param {MouseEvent} e
     */
    _onMouseDown(e) {
      if (Gui$1.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_EXPLORER) return;

      if (!this._op) {
        this._log.warn("glop no op", this);
        return;
      }

      const perf = Gui$1.gui.uiProfiler.start("[glop] mouseDown");

      if (this._op.objName == defaultOps.defaultOpNames.uiArea) {
        if (this.opUiAttribs.translate)
          this._glPatch._selectOpsInRect(
            this.opUiAttribs.translate.x,
            this.opUiAttribs.translate.y,
            this.opUiAttribs.translate.x + this.opUiAttribs.area.w,
            this.opUiAttribs.translate.y + this.opUiAttribs.area.h,
          );
      }

      this._glPatch.opShakeDetector.down(e.offsetX, e.offsetY);

      if (!e.shiftKey)
        if (e.touchType == "mouse") {
          if (this.isHovering()) this._glPatch.patchAPI.showOpParams(this._id);
        } else {
          this._glPatch.patchAPI.showOpParams(this._id);
        }

      if (e.altKey || e.metaKey) {
        if (!e.shiftKey) this._glPatch.unselectAll();
        Gui$1.gui.patchView.selectChilds(this.op.id);
        this._glPatch.emitEvent(
          "selectedOpsChanged",
          Gui$1.gui.patchView.getSelectedOps(),
        );
      }

      if (!this.selected) {
        if (!e.shiftKey) this._glPatch.unselectAll();
        this._glPatch.selectOpId(this.id);
      }

      if (this._op && this._op.uiAttribs) {
        this._dragOldUiAttribs = JSON.stringify(this._op.uiAttribs);

        if (this._glPatch.mouseState.buttonMiddle) {
          if (UserSettings.userSettings.get("quickLinkMiddleMouse"))
            Gui$1.gui.longPressConnector.longPressStart(this._op, e, { delay: 10 });
        } else {
          if (UserSettings.userSettings.get("quickLinkLongPress"))
            Gui$1.gui.longPressConnector.longPressStart(this._op, e);
        }
      }

      perf.finish();
    }

    _onMouseUp(e) {
      if (this._glPatch.mouseState.buttonMiddle) {
        if (Gui$1.gui.longPressConnector.isActive())
          Gui$1.gui.longPressConnector.finish(e, this._op);
      }

      this._glPatch.opShakeDetector.up();
      this._glPatch.emitEvent("mouseUpOverOp", e, this._id);

      this.endPassiveDrag();
      this.glPatch.snap.update();
    }

    setUiAttribs(newAttribs, attr) {
      const perf = Gui$1.gui.uiProfiler.start("[glop] setuiattribs");

      if (newAttribs && newAttribs.selected) this._glPatch.selectOpId(this._id);
      if (newAttribs && !this.opUiAttribs.selected && newAttribs.selected)
        this._glPatch.selectOpId(this._id);

      this.opUiAttribs = JSON.parse(JSON.stringify(attr));

      if (
        this.opUiAttribs.extendTitlePort &&
        (!this._titleExtPort ||
          this._titleExtPort.name != this.opUiAttribs.extendTitlePort)
      ) {
        if (this._titleExtPort) {
          this._titleExtPort.off(this._titleExtPortlister);
          this._titleExtPort = null;
        }
        this._titleExtPort = this._op.getPort(this.opUiAttribs.extendTitlePort);
        if (this._titleExtPort) {
          this._titleExtPortlister = this._titleExtPort.on("change", () => {
            clearTimeout(this._titleExtPortTimeout);
            if (performance.now() - this._titleExtPortLastTime < 50) {
              this._titleExtPortTimeout = setTimeout(() => {
                this.update();
              }, 50);
            }
            this.update();
            this._titleExtPortLastTime = performance.now();
          });
        }
      }

      if (this.opUiAttribs.display == "reroute") {
        this.displayType = this.DISPLAY_REROUTE_DOT;
        this._hideBgRect = true;
      }

      if (newAttribs.hasOwnProperty("hidden")) this.updateVisible();
      if (newAttribs.color) this._updateColors();

      if (newAttribs.hasOwnProperty("loading")) this._updateIndicators();
      if (newAttribs.hasOwnProperty("translate")) this.updatePosition();

      if (newAttribs.hasOwnProperty("resizable")) {
        for (let i = 0; i < this._glPorts.length; i++)
          this._glPorts[i].updateSize();
        this.updateSize();
      }

      perf.finish();
      this._needsUpdate = true;
    }

    get uiAttribs() {
      return this.opUiAttribs;
    }

    updateIfNeeded() {
      if (this._needsUpdate) this.update();
      this._needsUpdate = false;
    }

    setTitle(title, textWriter) {
      const perf = Gui$1.gui.uiProfiler.start("[glop] set title");

      if (!title) title = this._op.getTitle();
      if (textWriter) this._textWriter = textWriter;
      if (title === undefined) title = "";

      if (
        this.displayType != this.DISPLAY_COMMENT &&
        this.displayType != this.DISPLAY_UI_AREA &&
        title != "var set" &&
        title != "var get" &&
        title != "*" &&
        title != "/" &&
        title != "+" &&
        title != "-" &&
        title != this._op.shortName
      )
        title = '"' + title + '"';

      if (this.opUiAttribs.mathTitle) {
        let mathStr = "";

        if (!this._op.portsIn[0].isLinked()) mathStr += this._op.portsIn[0].get();
        else if (!this._op.portsIn[1].isLinked()) mathStr += "x";

        if (this._op.objName.indexOf("Ops.Math.Sum") == 0) mathStr += "+";
        else if (this._op.objName.indexOf("Ops.Math.Multiply") == 0)
          mathStr += "*";
        else if (this._op.objName.indexOf("Ops.Math.Divide") == 0) mathStr += "/";
        else if (this._op.objName.indexOf("Ops.Math.Subtract") == 0)
          mathStr += "-";
        else if (this._op.objName.indexOf("Ops.Math.Compare.GreaterThan") == 0)
          mathStr += ">";
        else if (this._op.objName.indexOf("Ops.Math.Compare.LessThan") == 0)
          mathStr += "<";
        else mathStr += "?";

        if (!this._op.portsIn[1].isLinked()) mathStr += this._op.portsIn[1].get();
        else if (!this._op.portsIn[0].isLinked()) mathStr += "x";

        title = mathStr;
      }

      if (!this._glTitle) {
        this._glTitle = new GlText(this._textWriter, title);
        this._glTitle.setParentRect(this._glRectBg);
        this._OpNameSpaceColor = GlPatch.getOpNamespaceColor(this._op.objName);

        if (this._op.objName.indexOf("Ops.Ui.Comment") === 0) {
          this.displayType = this.DISPLAY_COMMENT;
          this._hidePorts = true;
          this._hideBgRect = true;
          this._transparent = true;
        }

        if (this.opUiAttribs.comment_title) {
          // this._op.objName.indexOf("Ops.Ui.Comment") === 0
          this._hidePorts = true;
          this._glTitle.scale = 4;
        }
        this._updateColors();
      } else {
        if (this._glTitle.text != String(title))
          this._glTitle.text = String(title);
      }

      perf.finish();
      this.updateSize();
    }

    _updateCommentPosition() {
      if (this._glComment) {
        let x = this.w + gluiconfig.portWidth;
        if (this._rectResize) x += this._rectResize.w;

        if (!this._hideBgRect)
          this._glComment.setPosition(x, 0, 0); // normal op comment
        else this._glComment.setPosition(12, this._height, 0); // comment op (weird hardcoded values because of title scaling)
      }
    }

    _updateSelectedRect() {
      if (!this._visible || (!this.selected && this._glRectSelected)) {
        this._glRectSelected.visible = false;
        return;
      }

      if (this.selected) {
        if (!this._glRectSelected) {
          if (!this._instancer) return; // how?

          this._glRectSelected = this._instancer.createRect({
            parent: this._glRectBg,
            interactive: false,
          });
          this._glRectSelected.setColorArray(Gui$1.gui.theme.colors_patch.selected);

          this.updateSize();
          this.updatePosition();
        }
        this._glRectSelected.visible = true;
      }
    }

    updateSize() {
      let portsWidthIn = 0;
      let portsWidthOut = 0;

      if (!this._glRectBg) return;

      const perf = Gui$1.gui.uiProfiler.start("[glop] updatesize");

      let oldGroup = "";
      let groupIndex = 0;
      for (let i = 0; i < this._glPorts.length; i++) {
        if (this._glPorts[i]._port.uiAttribs.group != oldGroup) {
          oldGroup = this._glPorts[i]._port.uiAttribs.group;
          groupIndex++;
        }
        this._glPorts[i].groupIndex = groupIndex;
      }

      const oldHeight = this._height;
      for (let i = 0; i < this._glPorts.length; i++) {
        if (this._glPorts[i].direction == CABLES.Port.DIR_IN)
          portsWidthIn += this._glPorts[i].width + gluiconfig.portPadding;
        else portsWidthOut += this._glPorts[i].width + gluiconfig.portPadding;
      }

      if (portsWidthIn != 0) portsWidthIn -= gluiconfig.portPadding;
      if (portsWidthOut != 0) portsWidthOut -= gluiconfig.portPadding;

      // this._width = Math.max(this._getTitleWidth(), this._glRectBg.w);
      this._width = this._getTitleWidth();
      this.minWidth = this._width = Math.max(
        this._width,
        Math.max(portsWidthOut, portsWidthIn),
      );
      if (this._glTitle)
        this._height = Math.max(this._glTitle.height + 5, this._glRectBg.h);

      if (this.opUiAttribs.height)
        this._height = this.glPatch.snap.snapY(this.opUiAttribs.height);
      if (this.opUiAttribs.width)
        this._width = this.glPatch.snap.snapX(
          Math.max(this.minWidth, this.opUiAttribs.width),
        );

      if (this._height < gluiconfig.opHeight) this._height = gluiconfig.opHeight;

      // if (this.displayType == this.DISPLAY_UI_AREA) this._width = this._height = 20;
      if (this.opUiAttribs.widthOnlyGrow)
        this._width = Math.max(this._width, this._glRectBg.w);

      if (this.displayType == this.DISPLAY_REROUTE_DOT) {
        this._hidePorts = true;
        this._width = this._height = gluiconfig.opHeight * 0.35;
      }

      if (oldHeight != this._height)
        for (let i = 0; i < this._glPorts.length; i++)
          this._glPorts[i].updateSize();

      if (this._rectResize)
        this._rectResize.setPosition(
          this._width,
          this._height - this._rectResize.h,
        );

      let ext = 0;
      if (this._rectResize) ext = this._rectResize.w;
      this._glRectBg.setSize(this._width + ext, this._height);

      if (this._glColorIndicator) {
        this._glColorIndicator.setPosition(this._width, 0);
        this._glColorIndicator.setSize(this._height * 0.5, this._height);
        this._width += this._height * 0.5;
      }

      if (this._glRectSelected) {
        if (this._glPatch._numSelectedGlOps > 1) {
          this._glRectSelected.setSize(
            this._width + Gui$1.gui.theme.patch.selectedOpBorderX,
            this._height + Gui$1.gui.theme.patch.selectedOpBorderY,
          );
        } else {
          this._glRectSelected.setSize(0, 0);
        }
      }

      perf.finish();
      this._updateCommentPosition();
    }

    addLink(l) {
      if (!this.opUiAttribs.translate)
        this.opUiAttribs.translate = { x: 0, y: 0 };

      this._links[l.id] = l;
      l.updateVisible();
      this.updatePosition();
    }

    /**
     * @returns {Boolean}
     */
    isHovering() {
      if (this._glRectBg) return this._glRectBg.isHovering();
    }

    /**
     * @param {Boolean} h
     */
    setHover(h) {
      if (!this._isHovering && h) this.emitEvent("hoverStart");
      if (this._isHovering && !h) this.emitEvent("hoverEnd");

      this._isHovering = h;
    }

    _disposeDots() {
      if (this._glDotError) this._glDotError = this._glDotError.dispose();
      if (this._glDotWarning) this._glDotWarning = this._glDotWarning.dispose();
      if (this._glDotHint) this._glDotHint = this._glDotHint.dispose();
      if (this._glLoadingIndicator)
        this._glLoadingIndicator = this._glLoadingIndicator.dispose();
      if (this._glNotWorkingCross)
        this._glNotWorkingCross = this._glNotWorkingCross.dispose();
    }

    dispose() {
      this._disposed = true;

      if (this._glRerouteDot) this._glRerouteDot = this._glRerouteDot.dispose();
      if (this._glRectArea) this._glRectArea = this._glRectArea.dispose();
      if (this._glRectBg) this._glRectBg = this._glRectBg.dispose();
      if (this._glRectSelected)
        this._glRectSelected = this._glRectSelected.dispose();
      if (this._glTitle) this._glTitle = this._glTitle.dispose();
      if (this._glComment) this._glComment = this._glComment.dispose();
      if (this._titleExt) this._titleExt = this._titleExt.dispose();
      // if (this._glRectRightHandle) this._glRectRightHandle = this._glRectRightHandle.dispose();
      if (this._resizableArea)
        this._resizableArea = this._resizableArea.dispose();
      if (this._rectResize) this._rectResize = this._rectResize.dispose();
      if (this._glColorIndicator)
        this._glColorIndicator = this._glColorIndicator.dispose();

      this._disposeDots();

      for (let i = 0; i < this._glPorts.length; i++) this._glPorts[i].dispose();

      this._op = null;
      this._glPorts.length = 0;
      this._instancer = null;
    }

    removeLink(linkId) {
      const l = this._links[linkId];
      if (l) {
        delete this._links[linkId];
        this.update();
      }

      if (
        this.displayType == this.DISPLAY_REROUTE_DOT &&
        Object.keys(this._links).length == 0
      )
        this._glPatch.deleteOp(this._op.id);
    }

    refreshPorts() {
      for (let i = 0; i < this._glPorts.length; i++) this._glPorts[i].dispose();
      this._glPorts.length = 0;

      let portsIn = [];
      let portsOut = [];

      if (!this._op) return;

      portsIn = portsIn.concat(this._op.portsIn);

      if (this.displayType === this.DISPLAY_SUBPATCH) {
        const ports = Gui$1.gui.patchView.getSubPatchExposedPorts(
          this._op.patchId.get(),
          PortDir.in,
        );

        for (let i = 0; i < ports.length; i++)
          if (portsIn.indexOf(ports[i]) == -1) portsIn.push(ports[i]);
      }

      portsOut = portsOut.concat(this._op.portsOut);

      if (this.displayType === this.DISPLAY_SUBPATCH) {
        const ports = portsOut.concat(
          Gui$1.gui.patchView.getSubPatchExposedPorts(
            this._op.patchId.get(),
            PortDir.out,
          ),
        );
        for (let i = 0; i < ports.length; i++)
          if (portsOut.indexOf(ports[i]) == -1) portsOut.push(ports[i]);
      }

      this._setupPorts(portsIn);
      this._setupPorts(portsOut);
      this._initColorIndicators();
    }

    _setPortIndexAttribs(ports) {
      ports = ports.sort((a, b) => {
        return (a.uiAttribs.order || 0) - (b.uiAttribs.order || 0);
      });

      let count = 0;
      let emit = false;
      for (let i = 0; i < ports.length; i++) {
        /*
         * this._log.log(ports[i]);
         * this._log.log("this.op.getSubPatch() != ports[i].op.id", this.op.getSubPatch(), ports[i].op.id);
         */

        if (this.op.getSubPatch() != ports[i].op.getSubPatch()) {
          const key =
            "glPortIndex_" + (ports[i].uiAttribs.order || 0) + this.op.id;
          const o = {};
          o[key] = count;

          if (ports[i].uiAttribs[key] != count) emit = true;

          ports[i].setUiAttribs(o);
        } else {
          // this._log.log("noe");
          if (ports[i].uiAttribs.glPortIndex != count) emit = true;
          ports[i].setUiAttribs({ glPortIndex: count });
        }

        if (ports[i].uiAttribs.display == "dropdown") continue;
        if (ports[i].uiAttribs.display == "readonly") continue;
        if (ports[i].uiAttribs.hidePort) continue;
        count++;
      }

      /*
       * if (ports[0])this._log.log(ports[0].op.objName);
       * for (let i = 0; i < ports.length; i++)
       * {
       *     this._log.log(i, ports[i].name, ports[i].uiAttribs.glPortIndex);
       * }
       */

      if (emit) {
        ports[0].op.emitEvent("glportOrderChanged");
        if (this.op.getSubPatch() != ports[0].op.getSubPatch())
          this._op.emitEvent("glportOrderChanged");
      }
      return ports;
    }

    /**
     * @private
     */
    _initColorIndicators() {
      if (!this._op) return;
      const ports = this._op.portsIn;

      for (let i = 0; i < ports.length; i++) {
        if (ports[i].uiAttribs.colorPick && !this._glColorIndicator) {
          if (!this._glColorIndicator) {
            const colorPorts = [
              ports[i],
              ports[i + 1],
              ports[i + 2],
              ports[i + 3],
            ];

            this._glColorIndicator = this._instancer.createRect({
              parent: this._glRectBg,
            });
            this._glColorIndicator.setShape(0);

            this._glColorIndicator.setColor(
              colorPorts[0].get(),
              colorPorts[1].get(),
              colorPorts[2].get(),
              1,
            );
            this.updateSize();

            const updateColorIndicator = () => {
              this._glColorIndicator?.setColor(
                colorPorts[0]?.get(),
                colorPorts[1]?.get(),
                colorPorts[2]?.get(),
                colorPorts[3]?.get(),
              );
            };

            colorPorts[0].on("onUiAttrChange", (attrs, _port) => {
              if (attrs.hasOwnProperty("greyout")) {
                if (attrs.greyout) {
                  if (this._glColorIndicator)
                    this._glColorIndicator = this._glColorIndicator.dispose();
                } else {
                  this._initColorIndicators();
                }

                this.updateSize();
              }
            });
            colorPorts[0].on("change", updateColorIndicator);
            colorPorts[1].on("change", updateColorIndicator);
            colorPorts[2].on("change", updateColorIndicator);
            if (colorPorts[3]) colorPorts[3].on("change", updateColorIndicator);
          }
        }
      }
    }

    _setupPorts(ports) {
      let count = 0;

      ports = this._setPortIndexAttribs(ports);

      ports = ports.sort((a, b) => {
        return (a.uiAttribs.order || 0) - (b.uiAttribs.order || 0);
      });

      for (let i = 0; i < ports.length; i++) {
        if (ports[i].uiAttribs.display == "dropdown") continue;
        if (ports[i].uiAttribs.display == "readonly") continue;
        if (ports[i].uiAttribs.hidePort) continue;

        this._setupPort(count, ports[i]);
        count++;
      }
    }

    _setupPort(i, p) {
      const glp = new GlPort(
        this._glPatch,
        this,
        this._instancer,
        p,
        i,
        this._glRectBg,
      );
      this._glPorts.push(glp);
    }

    updatePosition() {
      if (!this._glRectBg) return;
      if (!this.opUiAttribs.translate) return;
      if (!this._visible) return;

      this.opUiAttribs.translate.x = this.opUiAttribs.translate.x || 1;
      this.opUiAttribs.translate.y = this.opUiAttribs.translate.y || 1;
      this._glRectBg.setPosition(
        this.opUiAttribs.translate.x,
        this.opUiAttribs.translate.y,
        this.getPosZ(),
      );

      if (this._glRectSelected)
        this._glRectSelected.setPosition(
          -Gui$1.gui.theme.patch.selectedOpBorderX / 2,
          -Gui$1.gui.theme.patch.selectedOpBorderY / 2,
          gluiconfig.zPosGlRectSelected,
        );

      if (this._glTitle)
        this._glTitle.setPosition(
          this._getTitlePosition(),
          0,
          gluiconfig.zPosGlTitle,
        );
      if (this._titleExt)
        this._titleExt.setPosition(
          this._getTitleExtPosition(),
          0,
          gluiconfig.zPosGlTitle,
        );
      this._updateCommentPosition();
      this._updateIndicators();

      if (
        this._oldPosx != this.opUiAttribs.translate.x ||
        this._oldPosy != this.opUiAttribs.translate.y
      ) {
        this._oldPosx = this.opUiAttribs.translate.x;
        this._oldPosy = this.opUiAttribs.translate.y;
        this.emitEvent("move");
      }
    }

    getUiAttribs() {
      return this.opUiAttribs;
    }

    _getTitleWidth() {
      let w = 0;
      if (this._titleExt)
        w += this._titleExt.width + gluiconfig.OpTitlePaddingExtTitle;
      if (this._glTitle) w += this._glTitle.width;

      w += gluiconfig.OpTitlePaddingLeftRight * 2.0;

      return w;
    }

    _getTitlePosition() {
      return gluiconfig.OpTitlePaddingLeftRight;
    }

    _getTitleExtPosition() {
      return (
        gluiconfig.OpTitlePaddingLeftRight +
        this._glTitle.width +
        gluiconfig.OpTitlePaddingExtTitle
      );
    }

    updateVisible() {
      if (!this._wasInCurrentSubpatch && this.isInCurrentSubPatch()) {
        if (!this._wasInited) {
          this._initGl();
        }
        this._initWhenFirstInCurrentSubpatch();
      }
      this._setVisible();
    }

    set visible(v) {
      this._setVisible(v);
    }

    get visible() {
      if (!this.isInCurrentSubPatch()) return false;
      return this._visible;
    }

    getSubPatch() {
      return this.opUiAttribs.subPatch;
    }

    isInCurrentSubPatch() {
      return this.opUiAttribs.subPatch == this._glPatch.subPatch;
    }

    _setVisible(v) {
      let changed = false;
      if (this._visible == v) return;
      if (v !== undefined) {
        changed = true;
        this._visible = v;
      }

      let visi = this._visible;

      if (this.opUiAttribs.hidden || !this.isInCurrentSubPatch()) visi = false;

      for (let i = 0; i < this._glRectNames.length; i++)
        if (this[this._glRectNames[i]]) this[this._glRectNames[i]].visible = visi;

      if (changed) this._updateIndicators();

      if (this._resizableArea) this._resizableArea.visible = visi;
      if (this._glColorIndicator) this._glColorIndicator.visible = visi;

      if (changed) for (const i in this._links) this._links[i].visible = true;

      if (!visi) this._isHovering = false;
    }

    _updateIndicators() {
      if (this._disposed) return;
      if (!this.isInCurrentSubPatch()) ;

      if (this.opUiAttribs.loading) {
        if (!this._glLoadingIndicator && this.isInCurrentSubPatch()) {
          this._glLoadingIndicator = this._instancer.createRect({
            parent: this._glRectBg,
            draggable: false,
          });
          this._glLoadingIndicator.setSize(
            Gui$1.gui.theme.patch.opStateIndicatorSize,
            Gui$1.gui.theme.patch.opStateIndicatorSize,
          );
          this._glLoadingIndicator.setColorArray(
            Gui$1.gui.theme.colors_patch.opErrorHint,
          );
          this._glLoadingIndicator.setShape(8);

          this._glLoadingIndicator.setColor(1, 1, 1, 1);

          this._glLoadingIndicator.setPosition(
            -(this._height * 0.125),
            this._height * 0.375,
            -0.05,
          );
          this._glLoadingIndicator.visible = true;
        }
      }
      if (!this.opUiAttribs.loading && this._glLoadingIndicator)
        this._glLoadingIndicator = this._glLoadingIndicator.dispose();

      if (this.opUiAttribs.uierrors && this.opUiAttribs.uierrors.length > 0) {
        let hasHints = false;
        let hasWarnings = false;
        let hasErrors = false;
        let notworking = false;

        for (let i = 0; i < this.opUiAttribs.uierrors.length; i++) {
          if (this.opUiAttribs.uierrors[i].level == 0) hasHints = true;
          if (this.opUiAttribs.uierrors[i].level == 1) hasWarnings = true;
          if (this.opUiAttribs.uierrors[i].level == 2) hasErrors = true;
          if (this.opUiAttribs.uierrors[i].level == 3) notworking = true;
        }

        let dotX = 0 - Gui$1.gui.theme.patch.opStateIndicatorSize / 2;
        const dotY = this.h / 2 - Gui$1.gui.theme.patch.opStateIndicatorSize / 2;

        if (hasHints && !this._glDotHint) {
          this._glDotHint = this._instancer.createRect({
            parent: this._glRectBg,
            draggable: false,
          });
          this._glDotHint.setSize(
            Gui$1.gui.theme.patch.opStateIndicatorSize,
            Gui$1.gui.theme.patch.opStateIndicatorSize,
          );
          this._glDotHint.setColorArray(Gui$1.gui.theme.colors_patch.opErrorHint);
          this._glDotHint.setShape(6);
        }

        if (hasWarnings && !this._glDotWarning) {
          this._glDotWarning = this._instancer.createRect({
            parent: this._glRectBg,
            draggable: false,
          });
          this._glDotWarning.setSize(
            Gui$1.gui.theme.patch.opStateIndicatorSize,
            Gui$1.gui.theme.patch.opStateIndicatorSize,
          );
          this._glDotWarning.setColorArray(
            Gui$1.gui.theme.colors_patch.opErrorWarning,
          );
          this._glDotWarning.setShape(6);
        }

        if (hasErrors && !this._glDotError) {
          this._glDotError = this._instancer.createRect({
            parent: this._glRectBg,
            draggable: false,
          });
          this._glDotError.setSize(
            Gui$1.gui.theme.patch.opStateIndicatorSize,
            Gui$1.gui.theme.patch.opStateIndicatorSize,
          );
          this._glDotError.setColorArray(Gui$1.gui.theme.colors_patch.opError);
          this._glDotError.setShape(6);
          this._glDotError.interactive = false;
          this._glDotError.visible = this._visible && hasErrors;
        }

        if (notworking && !this._glNotWorkingCross) {
          this._glNotWorkingCross = this._instancer.createRect({
            parent: this._glRectBg,
            draggable: false,
          });
          this._glNotWorkingCross.setSize(
            this._height * 0.25,
            this._height * 0.25,
          );
          this._glNotWorkingCross.setColorArray(
            Gui$1.gui.theme.colors_patch.opNotWorkingCross,
          );
          this._glNotWorkingCross.setShape(7);
          this._glNotWorkingCross.interactive = false;
          this._glNotWorkingCross.visible = this.visible && notworking;
        }

        if (hasHints) {
          this._glDotHint.setPosition(dotX, dotY, 0);
          this._glDotHint.visible = this.visible && hasHints;

          dotX += 2;
        }

        if (hasWarnings) {
          this._glDotWarning.setPosition(dotX, dotY, 0);
          this._glDotWarning.visible = this.visible && hasWarnings;
          dotX += 2;
        }

        if (hasErrors) {
          this._glDotError.setPosition(dotX, dotY, 0);
          this._glDotError.visible = this.visible && hasErrors;
          dotX += 2;
        }

        if (notworking) {
          this._glNotWorkingCross.setPosition(
            -(this._height * 0.125),
            this._height * 0.375,
          );
          this._glNotWorkingCross.visible = this.visible && notworking;
        }

        if (!hasHints && this._glDotHint)
          this._glDotHint = this._glDotHint.dispose();
        if (!hasWarnings && this._glDotWarning)
          this._glDotWarning = this._glDotWarning.dispose();
        if (!hasErrors && this._glDotError)
          this._glDotError = this._glDotError.dispose();
        if (!notworking && this._glNotWorkingCross)
          this._glNotWorkingCross = this._glNotWorkingCross.dispose();
        if (!hasHints && this._glDotHint)
          this._glDotHint = this._glDotHint.dispose();
      } else {
        if (this._glDotHint) this._glDotHint = this._glDotHint.dispose();
        if (this._glDotWarning) this._glDotWarning = this._glDotWarning.dispose();
        if (this._glDotError) this._glDotError = this._glDotError.dispose();
        if (this._glNotWorkingCross)
          this._glNotWorkingCross = this._glNotWorkingCross.dispose();
        if (this._glDotHint) this._glDotHint = this._glDotHint.dispose();
      }

      if (
        (!this.opUiAttribs.uierrors || this.opUiAttribs.uierrors.length == 0) &&
        (this._glDotError || this._glDotWarning || this._glDotHint)
      ) {
        this._disposeDots();
      }
    }

    _shortenExtTitle(str) {
      if (str.startsWith("data:") && str.indexOf(":") > -1) {
        const parts = str.split(";");
        str = parts[0];
      }
      if (str.length > 50) str.slice(0, 50);
      return str;
    }

    update() {
      if (this._disposed) return;
      if (!this._wasInCurrentSubpatch) return this._setVisible();
      let doUpdateSize = false;

      if (
        (this.opUiAttribs.hasArea || this.displayType == this.DISPLAY_UI_AREA) &&
        !this._resizableArea
      )
        this._resizableArea = new GlArea(this._instancer, this);

      // extended title
      if (this.displayType != this.DISPLAY_COMMENT) {
        if (
          !this._titleExt &&
          (this.opUiAttribs.hasOwnProperty("extendTitle") ||
            this.opUiAttribs.hasOwnProperty("extendTitlePort"))
        ) {
          this._titleExt = new GlText(this._textWriter, " ");
          this._titleExt.setParentRect(this._glRectBg);
          this._titleExt.setColorArray(Gui$1.gui.theme.colors_patch.opTitleExt);

          this._titleExt.visible = this.visible;
        }
        if (
          this._titleExt &&
          (!this.opUiAttribs.hasOwnProperty("extendTitle") ||
            !this.opUiAttribs.extendTitle) &&
          (!this.opUiAttribs.hasOwnProperty("extendTitlePort") ||
            !this.opUiAttribs.extendTitlePort)
        ) {
          this._titleExt.dispose();
          this._titleExt = null;
        }
      }

      if (!this.opUiAttribs.resizable && this._rectResize) {
        this._rectResize.dispose();
        this._rectResize = null;

        this._op.setUiAttribs({
          height: 1,
          width: 0,
        });
        this.updateSize();
      }

      if (this.opUiAttribs.hasArea && this._glRectArea) {
        this._glRectArea = this._instancer.createRect({
          parent: this._glRectBg,
          draggable: false,
        });
        this._glRectArea.setColor(0, 0, 0, 0.15);
      }

      if (this.opUiAttribs.resizable && !this._rectResize) {
        this._rectResize = this._instancer.createRect({
          parent: this._glRectBg,
          draggable: true,
        });
        this._rectResize.setShape(2);

        if (this.opUiAttribs.hasOwnProperty("resizableX"))
          this._rectResize.draggableX = this.opUiAttribs.resizableX;
        if (this.opUiAttribs.hasOwnProperty("resizableY"))
          this._rectResize.draggableY = this.opUiAttribs.resizableY;

        this._rectResize.setSize(
          gluiconfig.rectResizeSize,
          gluiconfig.rectResizeSize,
        );
        this._rectResize.setPosition(
          (this.opUiAttribs.width || 0) - this._rectResize.w,
          (this.opUiAttribs.height || 0) - this._rectResize.h,
        );
        this._rectResize.setColor(0.24, 0.24, 0.24, 1);

        this._rectResize.draggable = true;
        this._rectResize.draggableMove = true;
        this._rectResize.interactive = true;

        doUpdateSize = true;

        this._rectResize.on("drag", (_e) => {
          if (this._rectResize) {
            let w = this._rectResize.x - this.x;
            let h = this._rectResize.y - this.y;

            w = Math.max(this.minWidth, w);

            w = this.glPatch.snap.snapX(w);
            h = this.glPatch.snap.snapY(h);

            for (let i = 0; i < this._glPorts.length; i++)
              this._glPorts[i].updateSize();

            if (this._op) this._op.setUiAttrib({ height: h, width: w });
            this.updateSize();
          }
        });
      }

      const comment = this.opUiAttribs.comment || this.opUiAttribs.comment_text;

      if (comment) {
        if (!this._glComment) {
          this._glComment = new GlText(this._textWriter, comment);
          this._glComment.setParentRect(this._glRectBg);
          this._glComment.setColorArray(Gui$1.gui.theme.colors_patch.patchComment);
        }

        if (comment != this._glComment.text) this._glComment.text = comment;
        this._glComment.visible = this.visible;
      } else if (this._glComment) this._glComment = this._glComment.dispose();

      if (this.opUiAttribs.hasOwnProperty("comment_title"))
        this.setTitle(this.opUiAttribs.comment_title);
      else if (this.opUiAttribs.title != this._glTitle.text)
        this.setTitle(this.opUiAttribs.title);

      if (this._titleExt) {
        if (
          this.opUiAttribs.hasOwnProperty("extendTitlePort") &&
          this.opUiAttribs.extendTitlePort
        ) {
          const thePort = this._op.getPort(this.opUiAttribs.extendTitlePort);
          if (thePort) {
            const str = this._shortenExtTitle(
              " " + thePort.getTitle() + ": " + thePort.get(),
            );

            if (str != this._titleExt.text) {
              this._titleExt.text = str;
              doUpdateSize = true;
            }
          }
        } else if (
          this.opUiAttribs.hasOwnProperty("extendTitle") &&
          this.opUiAttribs.extendTitle != this._titleExt.text
        ) {
          const str = this._shortenExtTitle(
            " " + this.opUiAttribs.extendTitle || "!?",
          );

          if (this._titleExt.textOrig != str) {
            this._titleExt.textOrig = str;

            let shortenStr = str;
            if (shortenStr.length > 30) shortenStr = str.substring(0, 30) + "...";
            this._titleExt.text = shortenStr;
            doUpdateSize = true;
          }
        }
      }

      if (this.opUiAttribs.glPreviewTexture) {
        if (!this._glRectContent) {
          this._glRectContent = this._instancer.createRect();
          this._glRectContent.setParent(this._glRectBg);
          this._glRectContent.setPosition(0, this._height);
          this._glRectContent.setColor(255, 0, 220, 1);

          const p = this._op.getPort("Texture");
          this._visPort = p;

          this._visPort.onChange = () => {
            const t = this._visPort.get();

            if (t) {
              const asp = (this._width / t.width) * 2.5;
              this._glRectContent.setSize(t.width * asp, t.height * asp);
              this._glRectContent.setTexture(this._visPort.get());
            }
          };
        }
      }

      if (doUpdateSize) this.updateSize();
      this.updatePosition();
      this._updateColors();
      this._updateIndicators();

      if (this.displayType == this.DISPLAY_REROUTE_DOT) {
        if (!this._glRerouteDot)
          this._glRerouteDot = this._instancer.createRect({
            draggable: false,
            interactive: false,
          });

        this._glTitle.text = "";
        this._glRerouteDot.setSize(this._width, this._height);

        this._glRerouteDot.setPosition(-0.5, 0, 0);
        this._glRerouteDot.setParent(this._glRectBg);

        this._glRerouteDot.setColorArray(
          GlPort.getInactiveColor(this._glPorts[0].port.type),
        );
        this._glRerouteDot.setShape(6);

        this._glRectBg.setColor(0, 0, 0, 0);
        // this._glRectBg.setSize(0.0);
      }

      for (const i in this._links) if (this._links[i]) this._links[i].update();
      this._glPatch.needsRedraw = true;
    }

    /*
     * _updateSizeRightHandle()
     * {
     *     if (!this._glRectRightHandle) return;
     *     this._glRectRightHandle.setPosition(this.w, 0);
     *     this._glRectRightHandle.setSize(5, this.h);
     * }
     */

    _updateColors() {
      if (!this._glRectBg || !this._glTitle) return;

      if (this.opUiAttribs.comment_title) {
        if (this.opUiAttribs.hasOwnProperty("color") && this.opUiAttribs.color)
          this._glTitle.setColor(
            chroma.hex(this.opUiAttribs.color).gl(),
          ); // this._glTitle.setColor(1, 1, 1);
        else this._glTitle.setColorArray(Gui$1.gui.theme.colors_patch.patchComment);
      } else {
        if (this._OpNameSpaceColor)
          this._glTitle.setColor(
            this._OpNameSpaceColor[0],
            this._OpNameSpaceColor[1],
            this._OpNameSpaceColor[2],
          );
        else this._glTitle.setColor(0.8, 0.8, 0.8);
      }

      this._glRectBg.setBorder(this._rectBorder);

      if (this.opUiAttribs.selected) {
        this._glRectBg.setSelected(true);

        if (Gui$1.gui.theme.colors_patch.opBgRectSelected)
          this._glRectBg.setColorArray(
            Gui$1.gui.theme.colors_patch.opBgRectSelected,
          );
      } else {
        this._glRectBg.setSelected(false);

        if (this._transparent) {
          this._glRectBg.setColorArray(Gui$1.gui.theme.colors_patch.transparent);
        } else {
          if (
            this.opUiAttribs.hasOwnProperty("color") &&
            this.opUiAttribs.color
          ) {
            this._glRectBg.setColorArray(
              chroma.hex(this.opUiAttribs.color).darken(3.3).gl(),
            );

            /*
             * if (!this._glRectRightHandle && this.displayType != this.DISPLAY_UI_AREA)
             * {
             *     this._glRectRightHandle = this._instancer.createRect();
             *     this._glRectRightHandle.setParent(this._glRectBg);
             *     this._updateSizeRightHandle();
             * }
             */

            // if (this._glRectRightHandle) this._glRectRightHandle.setColor(chroma.hex(this.opUiAttribs.color).gl());
          } else {
            this._glRectBg.setColorArray(Gui$1.gui.theme.colors_patch.opBgRect);

            /*
             * if (this._glRectRightHandle && this.opUiAttribs.color == null)
             * {
             *     this._glRectRightHandle.dispose();
             *     this._glRectRightHandle = null;
             * }
             */
          }
        }
      }

      if (this.displayType === this.DISPLAY_UI_AREA && !this.selected) {
        this._glRectBg.setColor(0, 0, 0, 0.15);
      } else if (!this._op.enabled) {
        this._glRectBg.setOpacity(0.15, false);
        this._glTitle.setOpacity(0.5);
      } else {
        this._glRectBg.setOpacity(0.9, false);
        this._glTitle.setOpacity(1);
      }

      if (this._glNotWorkingCross) {
        this._glTitle.setOpacity(0.7);
      }

      if (this._hideBgRect && !this.selected) {
        this._glRectBg.setOpacity(0.0, true);
      }

      if (this._hidePorts)
        for (let i = 0; i < this._glPorts.length; i++)
          this._glPorts[i].rect.setOpacity(0);
      if (this._resizableArea) this._resizableArea._updateColor();
    }

    get selected() {
      return this.opUiAttribs.selected;
    }

    set selected(s) {
      if (!this._op) return;
      if (this.selected != s || s != this.opUiAttribs.selected) {
        if (s != this.opUiAttribs.selected) {
          /*
           * if (!s) delete this.opUiAttribs.selected;
           * this.opUiAttribs.selected = s;
           */
          this._op.setUiAttribs({ selected: s });

          for (const i in this._links) this._links[i].updateColor();
          // this._updateColors();

          this._glPatch._updateNumberOfSelectedOps();
          this._glPatch.selectOpId(this._id);
          // this._log.log("_updateNumberOfSelectedOps");
        }

        this.updatePosition();
        this._updateSelectedRect();
      }
    }

    getPortPos(id, center = true) {
      if (!this._op) return;
      this._setPortIndexAttribs(this._op.portsIn);

      if (this.displayType == this.DISPLAY_REROUTE_DOT) ;

      return this._op.getPortPosX(id, null, center, this.w);
    }

    isPassiveDrag() {
      return !(
        this._passiveDragStartX == null && this._passiveDragStartY == null
      );
    }

    endPassiveDrag() {
      if (this._passiveDragStartX !== null && this._passiveDragStartY !== null)
        if (
          this._passiveDragStartX != this.x ||
          this._passiveDragStartY != this.y
        ) {
          (function (scope, newX, newY, oldX, oldY) {
            undo.add({
              title: "Move op",
              undo() {
                try {
                  scope._glPatch.patchAPI.setOpUiAttribs(scope._id, "translate", {
                    x: newX,
                    y: newY,
                  });
                } catch (e) {}
              },
              redo() {
                scope._glPatch.patchAPI.setOpUiAttribs(scope._id, "translate", {
                  x: oldX,
                  y: oldY,
                });
              },
            });
          })(
            this,
            this._passiveDragStartX,
            this._passiveDragStartY,
            this.x,
            this.y,
          );

          Gui$1.gui.savedState.setUnSaved("opDrag", this.op.getSubPatch());
        }

      this._passiveDragStartX = null;
      this._passiveDragStartY = null;
    }

    startPassiveDrag() {
      this._passiveDragStartX = this.x;
      this._passiveDragStartY = this.y;
    }

    setPassiveDragOffset(x, y) {
      if (!this._passiveDragStartX) this.startPassiveDrag();

      x = this._passiveDragStartX + x;
      y = this._passiveDragStartY + y;

      x = this._glPatch.snap.snapOpX(x, this._op);
      y = this._glPatch.snap.snapY(y, this._glPatch._pressedCtrlKey);

      this._glPatch.patchAPI.setOpUiAttribs(this._id, "translate", {
        x: x,
        y: y,
      });
      this.emitEvent("drag");
      this.updatePosition();
    }

    getGlPort(name) {
      for (let i = 0; i < this._glPorts.length; i++)
        if (this._glPorts[i].name == name) return this._glPorts[i];
    }

    getGlPortsLinkedToPort(opid, portname) {
      const ports = [];

      for (const i in this._links) {
        if (
          this._links[i].nameInput == portname &&
          this._links[i].opIdInput == opid
        ) {
          const op = this._glPatch.getOp(this._links[i].opIdOutput);
          ports.push(op.getGlPort(this._links[i].nameOutput));
        }
        if (
          this._links[i].nameOutput == portname &&
          this._links[i].opIdOutput == opid
        ) {
          const op = this._glPatch.getOp(this._links[i].opIdInput);
          if (op) ports.push(op.getGlPort(this._links[i].nameInput));
        }
      }

      return ports;
    }

    updateTheme() {
      this._OpNameSpaceColor = GlPatch.getOpNamespaceColor(this._op.objName);
      this._updateColors();

      for (const i in this._links) this._links[i].updateTheme();

      this.update();
      this.updateSize();
      this._updateIndicators();

      if (this._titleExt)
        this._titleExt.setColor(Gui$1.gui.theme.colors_patch.opTitleExt);
      if (this._glRectSelected)
        this._glRectSelected.setColorArray(Gui$1.gui.theme.colors_patch.selected);

      if (this._glDotHint)
        this._glDotHint.setColor(Gui$1.gui.theme.colors_patch.opErrorHint);
      if (this._glDotWarning)
        this._glDotWarning.setColor(Gui$1.gui.theme.colors_patch.opErrorWarning);
      if (this._glDotError)
        this._glDotError.setColor(Gui$1.gui.theme.colors_patch.opError);
      if (this._glNotWorkingCross)
        this._glNotWorkingCross.setColor(
          Gui$1.gui.theme.colors_patch.opNotWorkingCross,
        );

      if (this._glDotHint)
        this._glDotHint.setSize(
          Gui$1.gui.theme.patch.opStateIndicatorSize,
          Gui$1.gui.theme.patch.opStateIndicatorSize,
        );
      if (this._glDotWarning)
        this._glDotWarning.setSize(
          Gui$1.gui.theme.patch.opStateIndicatorSize,
          Gui$1.gui.theme.patch.opStateIndicatorSize,
        );
      if (this._glDotError)
        this._glDotError.setSize(
          Gui$1.gui.theme.patch.opStateIndicatorSize,
          Gui$1.gui.theme.patch.opStateIndicatorSize,
        );
      if (this._glLoadingIndicator)
        this._glLoadingIndicator.setSize(
          Gui$1.gui.theme.patch.opStateIndicatorSize,
          Gui$1.gui.theme.patch.opStateIndicatorSize,
        );
    }

    updateVizFlowMode(_m) {
      for (let i in this._glPorts) {
        this._glPorts[i]._updateColor();
      }
      for (let i in this._links) this._links[i].setFlowModeActivity(0, 0);
    }
  }

  /**
   * rendering ports on {@link GlOp} on  {@link GlPatch}
   *
   * @export
   * @class GlPort
   */
  class GlPort {
    /**
     * Description
     * @param {GlPatch} glpatch
     * @param {GlOp} glop
     * @param {GlRectInstancer} rectInstancer
     * @param {Port} p
     * @param {number} posCount
     * @param {GlRect} oprect
     */
    constructor(glpatch, glop, rectInstancer, p, posCount, oprect) {
      this._log = new Logger("glPort");

      /** @type {Port} */
      this._port = p;

      /**
       * @type {GlOp}
       */
      this._glop = glop;
      this._type = p.type;
      this._name = p.name;
      this._id = p.id;
      this.groupIndex = 0;

      /**
       * @type {GlRect}
       */
      this._parent = oprect;

      this._direction = p.direction;

      /**
       * @type {GlPatch}
       */
      this._glPatch = glpatch;

      /**
       * @type {GlRectInstancer}
       */
      this._rectInstancer = rectInstancer;

      /**
       * @type {GlRect}
       */
      this._rect = new GlRect(this._rectInstancer, {
        parent: this._parent,
        interactive: true,
      });

      /**
       * @type {GlRect}
       */
      this._longPortRect = null;

      /**
       * @type {GlRect}
       */
      this._dot = null;
      this._rect.colorHoverMultiply = 0.0;
      this._mouseButtonRightTimeDown = 0;
      this._posX = posCount * (gluiconfig.portWidth + gluiconfig.portPadding);
      if (!this._parent) this._log.warn("no parent rect given");
      else this._parent.addChild(this._rect);

      this.portIndex = posCount;

      this._updateColor();
      this._activity = 1;

      this._mouseEvents = [];

      this._mouseEvents.push(
        this._rect.on("mousedown", this._onMouseDown.bind(this)),
      );
      this._mouseEvents.push(
        this._rect.on("mouseup", this._onMouseUp.bind(this)),
      );
      this._mouseEvents.push(this._rect.on("hover", this._onHover.bind(this)));
      this._mouseEvents.push(
        this._rect.on("unhover", this._onUnhover.bind(this)),
      );

      this._port.on("onLinkChanged", this._onLinkChanged.bind(this));
      this._port.on("onValueChangeUi", () => {
        if (this._glop.op && this._glop.op.uiAttribs.mathTitle)
          this._glop.setTitle();
      });

      p.on("onUiAttrChange", this._onUiAttrChange.bind(this));

      this._onUiAttrChange(p.uiAttribs);
      this.setFlowModeActivity(1);
      this.updateSize();
      this._updateColor();
    }

    /**
     * @type {number}
     */
    get posX() {
      return this._posX;
    }

    _onUiAttrChange(attribs) {
      if (this.disposed) return;
      if (
        attribs.hasOwnProperty("isAnimated") ||
        attribs.hasOwnProperty("useVariable") ||
        attribs.hasOwnProperty("notWorking")
      )
        this._updateColor();
      if (attribs.hasOwnProperty("expose")) this._updateColor();

      if (attribs.hasOwnProperty("addPort")) {
        this._updateColor();
      }

      if (
        attribs.hasOwnProperty("longPort") &&
        attribs.longPort == 0 &&
        this._longPortRect
      )
        this._longPortRect = this._longPortRect.dispose();
      if (attribs.hasOwnProperty("longPort") && attribs.longPort > 0) {
        if (!this._rect) return;
        if (!this._longPortRect)
          this._longPortRect = new GlRect(this._rectInstancer, {
            parent: this._parent,
            interactive: false,
          });

        const col = GlPort.getColor(this._type, false, false, false);
        this._longPortRect.setColor([col[0], col[1], col[2], 0.5]);

        this.updateSize();
      }
    }

    updateShape() {
      if (
        this._port.isLinked() &&
        !this._port.isAnimated() &&
        !this._port.isBoundToVar()
      ) {
        this._rect.setShape(0);
      } else {
        if (this._direction == PortDir.out) this._rect.setShape(9);
        else this._rect.setShape(10);
      }
    }

    _updateColor() {
      if (!this._rect) return;

      const isAssigned =
        this._port.uiAttribs.useVariable || this._port.uiAttribs.isAnimated;
      const dotSize = gluiconfig.portHeight * 0.75;

      const showDot =
        isAssigned ||
        this._port.uiAttribs.notWorking ||
        this._port.uiAttribs.addPort;

      if (!this._dot && showDot) {
        this._dot = new GlRect(this._rectInstancer, {
          parent: this._rect,
          interactive: false,
        });
        this._dot.setSize(0, 0);
        this._rect.addChild(this._dot);
      }

      if (this._dot) {
        if (showDot) {
          if (this._port.uiAttribs.notWorking)
            this._dot.setColor(0.8, 0.2, 0.2, 1);
          else this._dot.setColor(0.24, 0.24, 0.24, 1);

          let dotPosY = this._rect.h / 4 - dotSize / 2;
          if (this.direction == PortDir.in) dotPosY += this._rect.h / 2;

          if (this._port.uiAttribs.addPort) this._dot.setShape(12);
          else this._dot.setShape(6);

          this._dot.setSize(dotSize, dotSize);
          this._dot.setPosition(gluiconfig.portWidth / 2 - dotSize / 2, dotPosY);
        } else {
          this._dot = this._dot.dispose();
        }
      }

      let hover = this._hover;

      for (const i in this._glop._links)
        if (
          this._glop._links[i].portIdIn == this._id ||
          this._glop._links[i].portIdOut == this._id
        )
          if (this._glop._links[i].hovering) {
            hover = true;
            break;
          }

      let act = this._activity;
      if (this._glPatch.vizFlowMode == 0) act = 10;

      const col = GlPort.getColor(this._type, hover, false, act);
      this._rect.setColorArray(col);

      if (this._port.uiAttribs.addPort) this._rect.setOpacity(0.7);
      else this._rect.setOpacity(1);

      if (this._port.uiAttribs.hasOwnProperty("opacity"))
        this._rect.setOpacity(this._port.uiAttribs.opacity);
    }

    get direction() {
      return this._direction;
    }

    get width() {
      return this._rect.w;
    }

    updateSize() {
      if (!this._rect) return;

      let h = gluiconfig.portHeight * 2;
      let y = 0;

      if (this._port.direction == PortDir.out) y = this._glop.h;

      if (
        this._port.isLinked() &&
        !this._port.isAnimated() &&
        !this._port.isBoundToVar()
      ) {
        if (this._port.direction == PortDir.in) y += gluiconfig.portHeight * 0.5;
        h = gluiconfig.portHeight * 1.5;
      }

      y -= gluiconfig.portHeight;

      if (this._glop.displayType === this._glop.DISPLAY_REROUTE_DOT) {
        h = 0;
        if (this._port.direction == PortDir.in) y = 0;
        else y = this._glop.h;
      }

      this.updateShape();

      this._posX = this._glop.getPortPos(this._name, false);

      this._rect.setPosition(this._posX, y, -1e-4);
      this._rect.setSize(gluiconfig.portWidth, h);

      if (this._longPortRect) {
        let n = this._port.op.getNumVisiblePortsIn();
        if (this._direction == PortDir.out)
          n = this._port.op.getNumVisiblePortsOut();

        const lastposX = this._port.op.posByIndex(
          this._port.uiAttribs.longPort + this.portIndex - 1,
          n,
        );

        this._longPortRect.setSize(
          lastposX - this._posX,
          gluiconfig.portLongPortHeight,
        );

        let yl = gluiconfig.portHeight - gluiconfig.portLongPortHeight;
        if (this._direction == PortDir.out)
          yl = this._parent.h - gluiconfig.portHeight;

        this._longPortRect.setPosition(this._posX, yl, -1e-4);
      }
    }

    _onLinkChanged() {
      if (this._glop.op && this._glop.op.uiAttribs.mathTitle)
        this._glop.setTitle();
      this.updateSize();
    }

    _onMouseDown(e, _rect) {
      if (e.buttons == MouseState.BUTTON_RIGHT)
        this._mouseButtonRightTimeDown = performance.now();

      this._glPatch.emitEvent(
        "mouseDownOverPort",
        this,
        this._glop.id,
        this._port.name,
        e,
      );
    }

    _onMouseUp(e, _rect) {
      if (this._mouseButtonRightTimeDown) {
        if (
          performance.now() - this._mouseButtonRightTimeDown <
          gluiconfig.clickMaxDuration
        ) {
          this._port.removeLinks();
          this._mouseButtonRightTimeDown = 0;
          return;
        }
      }
      this._glPatch.emitEvent("mouseUpOverPort", this._port.op.id, this._port, e);
    }

    _onHover(_rect) {
      if (!this._glPatch.hasFocus) return;

      this._hover = true;
      const event = {
        clientX: this._glPatch.viewBox.mouseX,
        clientY: this._glPatch.viewBox.mouseY - 25,
      };

      this._glPatch.emitEvent("mouseOverPort", this._glop.id, this._port.name);

      for (const i in this._glop._links)
        if (
          this._glop._links[i].portIdIn == this._id ||
          this._glop._links[i].portIdOut == this._id
        )
          this._glop._links[i].highlight(true);

      updateHoverToolTip(event, this._port, false);
      this._updateColor();
    }

    _onUnhover(_rect) {
      this._hover = false;
      clearInterval(CABLES.UI.hoverInterval);
      CABLES.UI.hoverInterval = -1;
      hideToolTip();

      for (const i in this._glop._links) this._glop._links[i].highlight(false);

      this._updateColor();
    }

    get hovering() {
      return this._hover;
    }

    get type() {
      return this._port.type;
    }

    get port() {
      return this._port;
    }

    get id() {
      return this._id;
    }

    get name() {
      return this._name;
    }

    get glOp() {
      return this._glop;
    }

    get rect() {
      return this._rect;
    }

    setFlowModeActivity(_a) {
      if (this._activity != this._port.apf) {
        this._activity = this._port.apf;
        this._updateColor();
      }
    }

    dispose() {
      this.disposed = true;
      for (const i in this._glop._links)
        if (
          this._glop._links[i].portIdIn == this._id ||
          this._glop._links[i].portIdOut == this._id
        )
          this._glop._links[i].visible = false;

      for (let i = 0; i < this._mouseEvents.length; i++)
        this._rect.off(this._mouseEvents[i]);

      this._mouseEvents.length = 0;
      if (this._rect) this._rect = this._rect.dispose();
      if (this._dot) this._dot = this._dot.dispose();
      if (this._longPortRect) this._longPortRect = this._longPortRect.dispose();
    }
  }

  GlPort.getInactiveColor = (type) => {
    const perf = Gui$1.gui.uiProfiler.start("[glport] getInactiveColor");
    let portname = "";

    if (type == portType.number) portname = "num";
    else if (type == portType.trigger) portname = "trigger";
    else if (type == portType.object) portname = "obj";
    else if (type == portType.array) portname = "array";
    else if (type == portType.string) portname = "string";
    else if (type == portType.dynamic) portname = "dynamic";

    const name = portname + "_inactive";

    let col = Gui$1.gui.theme.colors_types[name] ||
      Gui$1.gui.theme.colors_types[portname] || [0, 0, 0, 1];

    perf.finish();

    return col;
  };

  GlPort.getColorBorder = (type, hovering, selected) => {
    const perf = Gui$1.gui.uiProfiler.start("[glport] getcolorBorder");
    let name = "";
    let portname = "";

    if (type == portType.number) portname = "num";
    else if (type == portType.trigger) portname = "trigger";
    else if (type == portType.object) portname = "obj";
    else if (type == portType.array) portname = "array";
    else if (type == portType.string) portname = "string";
    else if (type == portType.dynamic) portname = "dynamic";

    let coll = [1, 0.9, 0.8, 0];
    if (hovering) {
      name = portname + "_hover";
      coll = Gui$1.gui.theme.colors_types[name] ||
        Gui$1.gui.theme.colors_types[portname] || [1, 0, 0, 1];
    } else if (selected) {
      // name = portname + "_selected";
      coll = Gui$1.gui.theme.colors_patch.selectedCable;
    } else return coll;

    let col = [coll[0], coll[1], coll[2], coll[3]];

    if (!hovering && !selected) col[3] = 0;
    perf.finish();

    return col;
  };

  GlPort.getColor = (type, hovering, _selected, activity) => {
    const perf = Gui$1.gui.uiProfiler.start("[glport] getcolor");

    let name = "";
    let portname = "";

    if (type == portType.number) portname = "num";
    else if (type == portType.trigger) portname = "trigger";
    else if (type == portType.object) portname = "obj";
    else if (type == portType.array) portname = "array";
    else if (type == portType.string) portname = "string";
    else if (type == portType.dynamic) portname = "dynamic";

    if (activity == 0) name = portname + "_inactive";

    if (hovering) name = portname + "_hover";
    // else if (selected)name = portname + "_selected";

    let col = Gui$1.gui.theme.colors_types[name] ||
      Gui$1.gui.theme.colors_types[portname] || [1, 0, 0, 1];

    perf.finish();

    return col;
  };

  /**
   * simple line e.g. when dragging a port
   */
  class GlDragLine {
    /**
     * @param {GlSplineDrawer} splineDrawer
     * @param {GlPatch} glpatch
     */
    constructor(splineDrawer, glpatch) {
      this._log = new Logger("gldragline");

      /**
       * @type {GlRect}
       */
      this._rect = null;

      /**
       * @type {GlSplineDrawer}
       */
      this._splineDrawer = splineDrawer;
      this._splineIdx = this._splineDrawer.getSplineIndex();

      /**
       * @type {GlPatch}
       */
      this._glPatch = glpatch;

      this._startPortOpId = null;
      this._startPortId = null;

      this._startGlPorts = [];
      this._lineIndices = [];
      this._clearSpline();
      this._color = [1, 1, 1, 1];

      this._x = 0;
      this._y = 0;
      this._z = -1;

      glpatch.on("mouseup", (e) => {
        if (!this.isActive) return;

        if (this._button == MouseState.BUTTON_LEFT) ;

        const ele = document.elementFromPoint(e.x, e.y);
        if (!ele) return;

        if (ele.dataset.opid && ele.dataset.portname) {
          if (gui && Gui$1.gui.corePatch()) {
            const op = Gui$1.gui.corePatch().getOpById(ele.dataset.opid);
            if (op) {
              const port = op.getPortByName(ele.dataset.portname);
              if (port) {
                this._glPatch.emitEvent(
                  "mouseUpOverPort",
                  ele.dataset.opid,
                  port,
                  e,
                );
              }
            }
          }
        }

        if (
          (this._button == MouseState.BUTTON_LEFT || e.altKey) &&
          this._glPort &&
          this._glPort.port
        ) {
          // this._button == MouseState.BUTTON_LEFT &&
          let x = this._glPatch.viewBox.mousePatchX;
          let pos = {
            subPatch: this._glPatch.subPatch,
            x: x,
            y: this._glPatch.viewBox.mousePatchY,
          };

          if (Math.abs(this._glPort.glOp.x - x) < 200) {
            pos.x =
              this._glPort.glOp.x +
              this._glPort.glOp.op.getPortPosX(
                this._glPort.port.name,
                this._glPort.glOp.op.id,
              );
            pos.noSnap = true;
          }

          Gui$1.gui.opSelect().show(pos, this._glPort.port.op, this._glPort.port);
        }

        this.stop();
        this._glPatch.showOpCursor(false);
      });

      glpatch.on("mouseDragLink", (glport, _opid, _portName, _e) => {
        this.setPort(glport);
      });

      glpatch.on("mouseDownOverPort", (glport, opid, portName, e) => {
        if (Gui$1.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_FULL) return;

        this._button = e.buttons;

        if (this._button == MouseState.BUTTON_LEFT) {
          this.setPort(glport);
        } else if (this._button == MouseState.BUTTON_RIGHT) {
          this.setPort(glport);
          const glports = this._glPatch.getConnectedGlPorts(opid, portName);

          if (!e.altKey && glport) Gui$1.gui.patchView.unlinkPort(opid, glport.id);

          this._startGlPorts = glports;
        }
      });

      glpatch.on("mouseUpOverOp", (e, opid) => {
        if (!this.isActive) return;

        if (this._startGlPorts.length === 0) {
          // left click
          Gui$1.gui.patchView.linkPortToOp(
            e,
            this._startPortOpId,
            this._startPortId,
            opid,
          );
        } else {
          // right click
          const opids = [];
          const portIds = [];
          for (let i = 0; i < this._startGlPorts.length; i++) {
            if (!this._startGlPorts[i]) continue;
            opids.push(this._startGlPorts[i].glOp.id);
            portIds.push(this._startGlPorts[i].id);
          }

          Gui$1.gui.patchView.linkPortsToOp(e, opid, opids, portIds);
        }
        this.stop();
      });

      glpatch.on("mouseUpOverPort", (opid, port, event) => {
        let portId = port.id;

        /*
         * this._log.log("mouseUpOverPort",
         *     this._startPortOpId,
         *     this._startPortId,
         *     opid,
         *     portName);
         */

        if (!this._startGlPorts) return;
        if (this._startGlPorts.length === 0) {
          // left click
          Gui$1.gui.patchView.linkPorts(
            this._startPortOpId,
            this._startPortId,
            port.op.id,
            portId,
            event,
          );
        } else {
          // right click
          for (let i = 0; i < this._startGlPorts.length; i++) {
            if (this._startGlPorts[i]) {
              if (!this._startGlPorts[i].glOp) {
                this._log.warn(
                  "glop unknown?",
                  this._startGlPorts,
                  this._startGlPorts[i],
                );
                return;
              }
              Gui$1.gui.patchView.linkPorts(
                opid,
                portId,
                this._startGlPorts[i].glOp.id,
                this._startGlPorts[i].name,
                event,
              );
            }
          }
        }

        this.stop();
      });
    }

    get glPort() {
      return this._glPort;
    }

    /**
     * @param {GlPort} glp
     */
    setPort(glp) {
      if (!glp) {
        this._glPort = this._rect = null;
        this._splineDrawer.setSpline(
          this._splineIdx,
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
        );
        return;
      }

      this._startPortOpId = glp.port.op.id;
      this._startPortId = glp.port.id;
      this._rect = glp.rect;
      this._glPort = glp;

      this._glPatch.allowDragging = false;

      this._update();
    }

    _clearSpline() {
      for (let i = 0; i < this._lineIndices.length; i++) {
        this._splineDrawer.setSpline(
          this._lineIndices[i],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
        );
        this._splineDrawer.setSplineColor(this._lineIndices[i], [0, 0, 0, 0]);
      }
      this._splineDrawer.setSplineColor(this._splineIdx, [0, 0, 0, 0]);
      this._splineDrawer.setSpline(this._splineIdx, [0, 0, 0, 0, 0, 0, 0, 0, 0]);
    }

    _update() {
      if (!this.isActive) this._glPatch.showOpCursor(false);
      if (!this.isActive) return;

      if (
        !this._glPatch.isMouseOverOp() &&
        (!this._glPatch._cablesHoverButtonRect ||
          !this._glPatch._cablesHoverButtonRect.isHovering)
      )
        this._glPatch.showOpCursor(true);
      else this._glPatch.showOpCursor(false);

      this._clearSpline();

      if (this._glPort) {
        const col = GlPort.getColor(this._glPort._port.type);

        if (col) this.setColor(col);
      }

      if (this._startGlPorts && this._startGlPorts.length) {
        let count = 0;
        for (let i = 0; i < this._startGlPorts.length; i++) {
          if (!this._startGlPorts[i]) continue;

          /*
           * if (!this._startGlPorts[i].glOp) continue;
           * if (!this._startGlPorts[i].rect) continue;
           */
          if (count > this._lineIndices.length - 1)
            this._lineIndices[count] = this._splineDrawer.getSplineIndex();

          if (this._startGlPorts[i].rect)
            this._splineDrawer.setSpline(this._lineIndices[count], [
              this._startGlPorts[i].glOp.x +
                this._startGlPorts[i].rect.x +
                gluiconfig.portWidth / 2,
              this._startGlPorts[i].glOp.y +
                this._startGlPorts[i].rect.y +
                gluiconfig.portHeight / 2,
              this._z,
              this._x,
              this._y,
              this._z,
              this._x,
              this._y,
              this._z,
            ]);

          count++;
        }
      } else {
        if (this._rect && this._glPort) {
          this._splineDrawer.setSpline(this._splineIdx, [
            this._glPort.glOp.x + this._rect.x + gluiconfig.portWidth / 2,
            this._glPort.glOp.y + this._rect.y + gluiconfig.portHeight / 2,
            this._z,
            this._x,
            this._y,
            this._z,
            this._x,
            this._y,
            this._z,
          ]);

          this._splineDrawer.setSplineColor(this._splineIdx, this._color);
        }
      }
    }

    get isActive() {
      return this._glPort != null;
    }

    stop() {
      if (!this.isActive) return;
      this._startGlPorts.length = 0;
      this.setPort(null);

      this._glPatch.allowDragging = true; // this._patchDragWasAllowed;
      this._clearSpline();
    }

    /**
     * @param {number} x
     * @param {number} y
     */
    setPosition(x, y) {
      this._x = x;
      this._y = y;
      this._update();
    }

    /**
     * @param {Array} rgba
     */
    setColor(rgba) {
      this._color = rgba;
      for (let i = 0; i < this._lineIndices.length; i++)
        this._splineDrawer.setSplineColor(this._lineIndices[i], this._color);

      this._splineDrawer.setSplineColor(this._splineIdx, this._color);
    }
  }

  /**
   * selection area, when dragging the mouse on the patchfield
   *
   * @export
   * @class GlSelectionArea
   */
  class GlSelectionArea {
    /**
     * @param {GlRectInstancer} rectinstancer
     */
    constructor(rectinstancer) {
      this._selectRect = rectinstancer.createRect();

      this.updateTheme();
      this._selectRect.setSize(0, 0);
      this._selectRect.setPosition(0, 0, 1000);
      this.previousOps = [];

      this._w = 0;
      this._h = 0;
    }

    updateTheme() {
      this._selectRect.setColorArray(
        Gui$1.gui.theme.colors_patch.patchSelectionArea,
      );
    }

    get w() {
      return this._w;
    }

    get h() {
      return this._h;
    }

    get active() {
      return this._w != 0 || this._h != 0;
    }

    mouseUp() {
      this._w = this._h = 0;
    }

    /**
     * @param {number[]} rgba
     */
    setColor(rgba) {
      this._selectRect.setColorArray(rgba);
    }

    isVisible() {
      return this._selectRect._w != 0 && this._selectRect._h != 0;
    }

    /** @deprecated */
    setMousePos(_x, _y) {}

    hideArea() {
      this._selectRect.setSize(0, 0);

      this._x += this._w;
      this._y += this._h;
      this._w = this._h = 0;
      Gui$1.gui.emitEvent("hideSelectionArea");
    }

    /**
     * @param {number} x
     * @param {number} y
     */
    setPos(x, y) {
      this._x = x;
      this._y = y;
      this._selectRect.setPosition(x, y, -0.1);
    }

    /**
     * @param {number} w
     * @param {number} h
     */
    setSize(w, h) {
      this._w = w;
      this._h = h;

      this._selectRect.setSize(w, h);
    }
  }

  /**
   * Viewbox of current patch
   *
   * @export
   * @class GlViewBox
   */
  class GlViewBox {
    constructor(cgl, glPatch) {
      this._cgl = cgl;
      this.glPatch = glPatch;

      this.mousePatchNotPredicted = create();
      this._lastPosPixel = create();
      this._mouseSmooth = [];
      this._mouseSmoothCount = 0;
      this._subPatchViewBoxes = {};
      this._currentSubPatchId = 0;
      this._mouseX = 0;
      this._mouseY = 0;
      this._mousePatchX = this._mousePatchY = 0;
      this.cursor = null;
      this._scrollX = 0;
      this._scrollY = 0;
      this._oldScrollX = 0;
      this._oldScrollY = 0;
      this._viewResX = 0;
      this._viewResY = 0;
      this._panStarted = 0;
      this.wheelMode = UserSettings.userSettings.get("patch_wheelmode");
      // this._opsBoundingRect = null;
      this._mouseRightDownStartX = 0;
      this._mouseRightDownStartY = 0;
      this._zoom = gluiconfig.zoomDefault;
      this._spaceDown = false;
      this._outOfBounds = false;

      this._defaultEasing = CABLES.Anim.EASING_EXPO_OUT;
      console.log("CABLES.Anim.EASING_EXPO_OUT", CABLES.Anim.EASING_EXPO_OUT);

      this._animScrollX = new CABLES.Anim({ defaultEasing: this._defaultEasing });
      this._animScrollY = new CABLES.Anim({ defaultEasing: this._defaultEasing });
      this._animZoom = new CABLES.Anim({ defaultEasing: this._defaultEasing });

      cgl.canvas.addEventListener(
        "pointerenter",
        this._onCanvasMouseEnter.bind(this),
        { passive: true },
      );
      cgl.canvas.addEventListener(
        "pointerleave",
        this._onCanvasMouseLeave.bind(this),
        { passive: true },
      );
      cgl.canvas.addEventListener(
        "pointerdown",
        this._onCanvasMouseDown.bind(this),
        { passive: true },
      );
      cgl.canvas.addEventListener(
        "pointermove",
        this._onCanvasMouseMove.bind(this),
        { passive: true },
      );
      cgl.canvas.addEventListener("pointerup", this._onCanvasMouseUp.bind(this), {
        passive: true,
      });
      cgl.canvas.addEventListener("wheel", this._onCanvasWheel.bind(this), {
        passive: true,
      });
      // this.glPatch.on("dblclick", this._onCanvasDblClick.bind(this));

      this.glPatch.addEventListener(
        "spacedown",
        this._onCanvasSpaceDown.bind(this),
      );
      this.glPatch.addEventListener("spaceup", this._onCanvasSpaceUp.bind(this));

      // cgl.canvas.addEventListener("touchmove", this._onCanvasTouchMove.bind(this), { "passive": true });

      this._eleTabs = document.getElementById("splitterMaintabs");

      // this._drawBoundingRect = UserSettings.userSettings.get("glpatch_showboundings");

      UserSettings.userSettings.on("change", (which, _v) => {
        this.wheelMode = UserSettings.userSettings.get("patch_wheelmode");
      });
    }

    /**
     * @param {number} w
     * @param {number} h
     */
    setSize(w, h) {
      const first = this._viewResX === 0 && this._viewResY === 0;
      this._viewResX = w;
      this._viewResY = h;

      if (first)
        this.setMousePos(this._cgl.canvasWidth / 2, this._cgl.canvasHeight / 2);
    }

    /**
     * @param {number} x
     * @param {number} y
     */
    setMousePos(x, y) {
      const dx = 0;
      const dy = 0;

      x = Math.ceil(x);
      y = Math.ceil(y);

      const coord = this.screenToPatchCoord(x + dx, y + dy);
      this.mousePatchNotPredicted = this.screenToPatchCoord(x, y);

      Gui$1.gui.patchView.emitEvent(
        "mouseMove",
        this._mousePatchX,
        this._mousePatchY,
      );
      Gui$1.gui.patchView.emitEvent("viewBoxChange");

      this._mousePatchX = coord[0];
      this._mousePatchY = coord[1];
      this._mouseX = x;
      this._mouseY = y;
    }

    _onCanvasMouseEnter(e) {
      this.setMousePos(e.offsetX, e.offsetY);
    }

    _onCanvasMouseLeave(e) {
      this.setMousePos(e.offsetX, e.offsetY);
    }

    _onCanvasSpaceUp(_e) {
      this._spaceDown = false;
    }

    _onCanvasSpaceDown(_e) {
      if (this._spaceDown) return;
      this._spaceDown = true;
      this._oldScrollX = this._scrollX;
      this._oldScrollY = this._scrollY;
      this._mouseRightDownStartX = this._mouseX;
      this._mouseRightDownStartY = this._mouseY;
    }

    _onCanvasMouseDown(e) {
      this._onCanvasMouseMove(e);
      if (
        this.glPatch.mouseState.buttonStateForScrolling ||
        this.glPatch.spacePressed ||
        this.glPatch.mouseState.numFingers
      ) {
        this._oldScrollX = this._scrollX;
        this._oldScrollY = this._scrollY;
        this._mouseRightDownStartX = e.offsetX;
        this._mouseRightDownStartY = e.offsetY;
      }
    }

    _onCanvasMouseMove(e) {
      this.setMousePos(e.offsetX, e.offsetY);

      this._lastPosPixel[0] = e.offsetX;
      this._lastPosPixel[1] = e.offsetY;

      if (window.Gui.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_EXPLORER)
        return;

      if (
        this.glPatch.mouseState.buttonStateForScrolling ||
        ((this.glPatch.spacePressed || this.glPatch.mouseState.numFingers == 2) &&
          (this.glPatch.mouseState.buttonLeft ||
            this.glPatch.mouseState.buttonRight ||
            this.glPatch.mouseState.buttonStateForScrolling))
      ) {
        this.cursor = "grabbing";
        hideToolTip();
        const pixelMulX =
          ((this._cgl.canvas.width / this._zoom) * 0.5) / this._cgl.pixelDensity;
        const pixelMulY =
          ((this._cgl.canvas.height / this._zoom) * 0.5) / this._cgl.pixelDensity;

        this.scrollTo(
          this._oldScrollX + (this._mouseRightDownStartX - e.offsetX) / pixelMulX,
          this._oldScrollY + (this._mouseRightDownStartY - e.offsetY) / pixelMulY,
          true,
        );
      }
    }

    _onCanvasMouseUp(_e) {
      this._oldScrollX = this._scrollX;
      this._oldScrollY = this._scrollY;
      this.cursor = null;
    }

    // _onCanvasDblClick(e)
    // {
    //     const z = GlUiConfig.zoomDefault;
    //     if (Math.abs(this._zoom - GlUiConfig.zoomDefault) < 200)
    //     {
    //         this.glPatch.unselectAll();
    //         this.centerSelectedOps();
    //     }
    //     else
    //     {
    //         this.animateZoom(z);
    //         this.animateToCenterAtMouseCoords();
    //     }
    // }

    animateToCenterAtMouseCoords() {
      this.animateScrollTo(
        this.mousePatchX,
        this.mousePatchY * (this._viewResX / this._viewResY),
      );
    }

    _onCanvasWheel(event) {
      if (this.glPatch.mouseState.buttonMiddle) return;
      this.setMousePos(event.offsetX, event.offsetY);

      let delta = 5;

      if (event.deltaY < 0) delta *= -1;

      let doPan = this.wheelMode == "pan";
      let doZoom = this.wheelMode == "zoom";

      if (this.wheelMode == "auto") {
        if (
          performance.now() - this._panStarted < 500 ||
          Math.abs(event.deltaX) > 0
        ) {
          this._panStarted = performance.now();
          doPan = true;
        } else doZoom = true;
      }

      if (doPan) {
        let speed =
          parseFloat(UserSettings.userSettings.get("patch_panspeed")) || 0.25;

        this.scrollTo(
          this._scrollX - event.deltaX * speed,
          this._scrollY - event.deltaY * speed,
        );
      }

      if (doZoom) {
        if (event.altKey) this._scrollY -= delta;
        else if (event.shiftKey)
          this.scrollTo(this._scrollX - delta, this._scrollY);

        this.wheelZoom(delta);
      }

      this.setMousePos(this._mouseX, this._mouseY);

      if (this._touchpadMode && event.metaKey) this.wheelZoom(delta);

      Gui$1.gui.on("themeChanged", () => {
        // this._opsBoundingRect.setColor(Gui.gui.theme.colors_patch.opBoundsRect);
      });
    }

    wheelZoom(delta) {
      if (window.Gui.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_FOLLOWER)
        return;

      if (delta == 0) return;

      const wheelMultiplier =
        (UserSettings.userSettings.get("wheelmultiplier") || 1) * 1.5;

      if (delta < 0) delta = 1.0 - 0.2 * wheelMultiplier;
      else delta = 1 + 0.2 * wheelMultiplier;

      const mouse = this.screenToPatchCoord(this._mouseX, this._mouseY, true);

      const newZoom = this._zoom * delta;

      const x = this._scrollX + mouse[0];
      const y = this._scrollY + mouse[1];

      const oldZoom = this._zoom;
      this._zoom = newZoom;

      const mouseAfterZoom = this.screenToPatchCoord(
        this._mouseX,
        this._mouseY,
        true,
      );
      {
        this._zoom = oldZoom;
        const dur = 0.5;
        this.animateZoom(newZoom, dur);
        this.animateScrollTo(
          x - mouseAfterZoom[0],
          y - mouseAfterZoom[1],
          dur,
          true,
        );
      }

      Gui$1.gui.patchView.emitEvent("viewBoxChange");
    }

    get zoom() {
      return this._zoom;
    }

    get scrollX() {
      return -this._scrollX;
    }

    get scrollY() {
      return this._scrollY;
    }

    get scrollXZoom() {
      return -this._scrollX / this._zoom;
    }

    get scrollYZoom() {
      return this._scrollY / this._zoom;
    }

    get mouseX() {
      return this._mouseX;
    }

    get mouseY() {
      return this._mouseY;
    }

    get mousePatchX() {
      return this._mousePatchX;
    }

    get mousePatchY() {
      return this._mousePatchY;
    }

    get width() {
      return this._cgl.canvasWidth;
    }

    get height() {
      return this._cgl.canvasHeight;
    }

    update() {
      const time = this.glPatch.time;
      if (!this._animZoom.isFinished(time))
        this._zoom = this._animZoom.getValue(time);
      this._scrollX = this._animScrollX.getValue(time);
      this._scrollY = this._animScrollY.getValue(time);

      if (this._zoom != this._zoom) this._zoom = 400;

      this.setMousePos(this._mouseX, this._mouseY);
    }

    animateZoom(z, dur) {
      dur = dur || 0.25;

      this._animZoom.clear();
      this._animZoom.setValue(this.glPatch.time, this._zoom);
      this._animZoom.setValue(this.glPatch.time + dur, z);
    }

    animateScrollTo(x, y, dur, userInteraction) {
      let p =
        (this._eleTabs.getBoundingClientRect().left / this._viewResX) *
        this._animZoom.getValue(this.glPatch.time + 10);
      if (userInteraction) p = 0;
      if (p != p) p = 0;

      dur = dur || 0.2;

      this._animScrollX.clear(this.glPatch.time);
      this._animScrollX.setValue(this.glPatch.time + dur, x - p);
      this._animScrollY.clear(this.glPatch.time);
      this._animScrollY.setValue(this.glPatch.time + dur, y);
    }

    scrollTo(x, y, _userInteraction) {
      // let p = this._eleTabs.getBoundingClientRect().left / this._viewResX * this._animZoom.getValue(this.glPatch.time + 10);
      // if (userInteraction)p = 0;
      // if (p != p)p = 0;

      this._animScrollX.clear();
      this._animScrollY.clear();

      this._animScrollX.setValue(this.glPatch.time, x);
      this._animScrollY.setValue(this.glPatch.time, y);

      Gui$1.gui.patchView.emitEvent("viewBoxChange");
    }

    centerSelectedOps(noAnim) {
      let ops = Gui$1.gui.patchView.getSelectedOps();
      if (ops.length == 0) ops = Gui$1.gui.corePatch().ops;

      if (ops.length == 0) {
        // no ops in patch at all
        this._zoom = 400;
        this.scrollTo(0, 0);
        return;
      }

      const bb = new CABLES.CG.BoundingBox();
      const subp = this.glPatch.getCurrentSubPatch();

      for (let i = 0; i < ops.length; i++) {
        if (ops[i].uiAttribs.subPatch != subp) continue;

        if (ops[i].uiAttribs.translate && !ops[i].uiAttribs.hidden) {
          // console.log(ops[i].uiAttribs.translate.x, ops[i].uiAttribs.translate.y);
          bb.applyPos(
            ops[i].uiAttribs.translate.x,
            ops[i].uiAttribs.translate.y,
            0,
          );

          if (this.glPatch.getGlOp(ops[i]))
            bb.applyPos(
              ops[i].uiAttribs.translate.x + this.glPatch.getGlOp(ops[i]).w,
              ops[i].uiAttribs.translate.y + this.glPatch.getGlOp(ops[i]).h,
              0,
            );
        }
      }

      bb.calcCenterSize();
      const padding = 1.05;

      bb.size[0] = Math.max(bb.size[0], 250);
      bb.size[1] = Math.max(bb.size[1], 250);

      bb.size[0] *= padding;
      bb.size[1] *= padding;

      const zx = bb.size[0] / 2; // zoom on x
      const zy = (bb.size[1] / 2) * (this._viewResX / this._viewResY);
      let z = Math.max(400, Math.max(zy, zx));
      if (z > 99999) z = 400;

      if (noAnim) this._zoom = z;
      else this.animateZoom(z);

      let cy = bb.center[1] * (this._viewResX / this._viewResY);

      if (cy != cy) cy = 0;

      Gui$1.gui.patchView.getSubPatchBounds();
      this.animateScrollTo(bb.center[0], cy);
    }

    patchToScreenConv(_x, _y) {
      let x = _x;
      let y = _y;

      // const asp = this._viewResY / this._viewResX;
      const zx = 1 / (this._viewResX / 2 / this.zoom);
      let zy = zx;

      x /= zx;
      y /= zy;

      return [x, y];
    }

    patchToScreenCoords(_x, _y) {
      let x = _x;
      let y = _y;

      const asp = this._viewResY / this._viewResX;
      const zx = 1 / (this._viewResX / 2 / this.zoom);
      let zy = zx;

      x -= this._scrollX;
      y -= this._scrollY * asp;

      x /= zx;
      y /= zy;

      x += this._viewResX / 2;
      y += this._viewResY / 2;

      return [x, y];
    }

    screenToPatchCoord(x, y, aspect) {
      if (this._scrollY != this._scrollY) this._scrollY = 0;
      const zx = 1 / (this._viewResX / 2 / this.zoom);
      let zy = zx;
      if (aspect) zy = 1 / (this._viewResY / 2 / this.zoom);
      const asp = this._viewResY / this._viewResX;

      if (this._scrollX != this._scrollX) this._scrollX = 0;

      const mouseAbsX = (x - this._viewResX / 2) * zx - this.scrollX;
      const mouseAbsY = (y - this._viewResY / 2) * zy + this.scrollY * asp;

      if (isNaN(mouseAbsY)) this.centerSelectedOps(true);

      return [mouseAbsX, mouseAbsY];
    }

    serialize(dataui) {
      this.storeCurrentSubPatch();

      dataui.viewBoxesGl = this._subPatchViewBoxes;
    }

    deSerialize(dataui) {
      dataui = dataui || {};
      if (!dataui.viewBoxesGl) {
        this.centerSelectedOps();
        this.storeCurrentSubPatch();
      } else this._subPatchViewBoxes = dataui.viewBoxesGl;
      this._restoreSubPatch(this._currentSubPatchId);
    }

    storeCurrentSubPatch() {
      const o = { x: this._scrollX, y: this._scrollY, z: this._zoom };
      this._subPatchViewBoxes[this._currentSubPatchId] = o;
    }

    _restoreSubPatch(sub) {
      this._currentSubPatchId = sub;

      if (this._subPatchViewBoxes[sub]) {
        this.scrollTo(
          this._subPatchViewBoxes[sub].x,
          this._subPatchViewBoxes[sub].y,
        );
        this._zoom = this._subPatchViewBoxes[sub].z;
      } else {
        this.storeCurrentSubPatch();
        this.centerSelectedOps(true);
      }
    }

    animSwitchSubPatch(dur, sub, _timeGrey, _timeVisibleAgain, next) {
      this.storeCurrentSubPatch();

      const zoomFactor = 0.1;

      dur = 0.25;

      // this._animZoom.clear();
      // this._animZoom.defaultEasing = CABLES.EASING_LINEAR;
      // this._animZoom.setValue(this.glPatch.time, this._zoom);
      // this._animZoom.setValue(this.glPatch.time + timeGrey, this._zoom - (this._zoom * zoomFactor));

      // this._animZoom.defaultEasing = this._defaultEasing;
      this._restoreSubPatch(sub);

      this._animZoom.clear();
      this._animZoom.setValue(
        this.glPatch.time,
        this._zoom + this._zoom * zoomFactor,
      );
      this._animZoom.setValue(this.glPatch.time + dur, this._zoom);

      if (next) next();
    }

    zoomStep(s) {
      let z = this._zoom + 200 * s;
      z = Math.max(50, z);
      this.animateZoom(z);
    }

    keyScrollX(d) {
      this.animateScrollTo(this._scrollX + d * 100, this._scrollY, 0.15, true);
    }

    keyScrollY(d) {
      this.animateScrollTo(this._scrollX, this._scrollY + d * 100, 0.15, true);
    }
  }

  class GlCursor extends Events {
    /**
     * @param {GlPatch} glPatch
     * @param {GlRectInstancer} instancer
     * @param {number} clientId
     */
    constructor(glPatch, instancer, clientId) {
      super();

      this.isAnimated = clientId !== undefined;
      this._animX = new Anim();
      this._animY = new Anim();

      this._animX.defaultEasing = this._animY.defaultEasing =
        CABLES.Anim.EASING_CUBIC_OUT;

      this._glPatch = glPatch;
      this._instancer = instancer;
      this._cursorRect = this._instancer.createRect();
      this._cursorRect.setSize(10, 10);
      this._cursorRect.setShape(5);
      this._lastMovement = performance.now();

      this._subPatch = 0;
      this._clientId = clientId;
      this._userId = null;

      this._avatarEle = document.createElement("div");
      this._avatarEle.classList.add("cursorAvatar");

      this._avatarEle.style.display = "none";
      this._avatarEle.style["background-size"] = "100%";

      document.body.appendChild(this._avatarEle);

      this._cursorRect.setColor(1, 1, 1, 1);

      Gui$1.gui.on("multiUserSubpatchChanged", (_clientId, _subPatch) => {
        this._subPatch = _subPatch;

        if (_clientId == this._clientId) {
          this.updateAnim();
        }
      });
    }

    setSubpatch(_subPatch) {
      this._subPatch = _subPatch;
      this.updateAnim();
    }

    updateAnim() {
      if (this.isAnimated) {
        let x = this._animX.getValue(this._glPatch.time);
        let y = this._animY.getValue(this._glPatch.time);

        this._cursorRect.setPosition(x, y);

        const coord = this._glPatch.viewBox.patchToScreenCoords(x, y);

        if (
          !this._userId ||
          coord[0] < 0 ||
          coord[1] < 0 ||
          coord[0] > this._glPatch.viewBox.width ||
          coord[1] > this._glPatch.viewBox.height
        )
          this._avatarEle.style.display = "none";

        this._avatarEle.style.top = coord[1] + 4 + "px";
        this._avatarEle.style.left = coord[0] + 15 + "px";
      }

      if (
        performance.now() - this._lastMovement > 10000 ||
        Gui$1.gui.patchView.getCurrentSubPatch() != this._subPatch
      ) {
        this._avatarEle.style.display = "none";
        this._cursorRect.visible = false;
      } else {
        if (this._userId) this._avatarEle.style.display = "block";
        this._cursorRect.visible = true;
      }
    }

    setColor(_r, _g, _b, _a) {
      this._cursorRect.setColor(1, 1, 1, 1);
    }

    get visible() {
      return this._cursorRect.visible;
    }

    set visible(v) {
      this._cursorRect.visible = v;
    }

    setSize(w, h) {
      this._cursorRect.setSize(w, h);
    }

    setPosition(x, y) {
      this._lastMovement = performance.now();
      if (!this.isAnimated) this._cursorRect.setPosition(x, y);
      else {
        this._animX.clear(this._glPatch.time);
        this._animY.clear(this._glPatch.time);
        const netCursorDelay = Gui$1.gui.socket
          ? Gui$1.gui.socket.netMouseCursorDelay / 1000
          : 0;
        this._animX.setValue(this._glPatch.time + netCursorDelay, x);
        this._animY.setValue(this._glPatch.time + netCursorDelay, y);
        this.updateAnim();
      }

      if (Gui$1.gui.socket && !this._userId) {
        this._userId = Gui$1.gui.socket.state.getUserId(this._clientId);
        if (this._userId)
          this._avatarEle.style["background-image"] =
            "url(" +
            platform.getCablesUrl() +
            "/api/avatar/" +
            this._userId +
            ")";
      }
    }

    dispose() {
      if (this._cursorRect) this._cursorRect.dispose();
      if (this._avatarEle) this._avatarEle.remove();
    }
  }

  /**
   * detect shaking of ops to disconnect
   *
   * @export
   * @class ShakeDetector
   * @extends {Events}
   */
  class ShakeDetector extends Events {
    constructor() {
      super();

      this.shakeCountP = 0;
      this.shakeCountN = 0;
      this.shakeLastX = -1;
      this.shakeStartTime = 0;
      this.shakeTimeOut = null;
      this.lastShakeDir = false;
    }

    /**
     * Description
     * @param {Number} __x
     * @param {Number} __y
     */
    down(__x, __y) {
      this.shakeCountP = 0;
      this.shakeCountN = 0;
    }

    move(a) {
      if (this.shakeLastX != -1) {
        if (this.shakeLastX - a > 30 && this.lastShakeDir) {
          this.lastShakeDir = false;
          this.shakeCountP++;
          this.shakeLastX = a;
          clearTimeout(this.shakeTimeOut);
          this.shakeTimeOut = setTimeout(function () {
            this.shakeCountP = 0;
            this.shakeCountN = 0;
          }, 250);
        } else if (this.shakeLastX - a < -30 && !this.lastShakeDir) {
          this.lastShakeDir = true;
          this.shakeCountN++;
          this.shakeLastX = a;
          clearTimeout(this.shakeTimeOut);
          this.shakeTimeOut = setTimeout(function () {
            this.shakeCountP = 0;
            this.shakeCountN = 0;
          }, 250);
        }
        if (this.shakeCountP + this.shakeCountN == 1) {
          this.shakeStartTime = CABLES.now();
        }

        if (
          this.shakeCountP + this.shakeCountN >= 6 &&
          CABLES.now() - this.shakeStartTime > 100
        ) {
          this.emitEvent("shake");
          // opui.op.unLinkTemporary();
          this.shakeLastX = -1;
        }
      }
      this.shakeLastX = a;
    }

    up() {
      this.shakeCountP = 0;
      this.shakeCountN = 0;
    }
  }

  /**
   * managing data vizualizations on the patchfield (e.g. viztexture/vizgraph/vizString ops)
   *
   * @export
   * @class VizLayer
   * @extends {Events}
   */
  class VizLayer extends Events {
    constructor(glPatch) {
      super();

      this._log = new Logger("VizLayer");

      this.renderMs = null;
      this._usingGl = false;
      this._items = [];
      this._itemsLookup = {};
      this._glPatch = glPatch;
      this.paused = UserSettings.userSettings.get("vizlayerpaused") || false;

      Gui$1.gui.on("uiloaded", () => {
        this._updateSize();
      });

      UserSettings.userSettings.on("change", (key, value) => {
        if (key == "vizlayerpaused") this.paused = value;
      });

      this._glPatch.on("resize", this._updateSize.bind(this));

      this._eleCanvas = document.createElement("canvas");

      this._eleCanvas.id = "gluiPreviewLayer";
      this._eleCanvas.classList.add("gluiPreviewLayer");
      // this._eleCanvas.style.zIndex = this._glPatch._cgl.canvas.style.zIndex + 2;

      document.body.appendChild(this._eleCanvas);

      this._updateSize();

      Gui$1.gui.corePatch().cgl.on("beginFrame", () => {
        this._fallBackrendererDisabled = true;
        this._usingGl = true;
        this.renderVizLayer(true);
      });

      Gui$1.gui.corePatch().on(CABLES.Patch.EVENT_OP_ADDED, (a) => {
        if (a.renderVizLayer || a.renderVizLayerGl || a.renderVizLayerGpu) {
          let item = this._itemsLookup[a.id];
          if (item) this._log.log("vizlayer id already exists...");
          if (!item) {
            item = {
              op: a,
              port: a.portsIn[0],
              ports: a.portsIn,
            };

            this._itemsLookup[a.id] = item;

            item.op.on("delete", (op) => {
              this._removeOpItem(op);
            });

            this._items.push(item);
          }
        }
      });
    }

    _updateSize() {
      if (
        this._eleCanvas.width != this._glPatch._cgl.canvasWidth ||
        this._eleCanvas.height != this._glPatch._cgl.canvasHeight
      ) {
        this._eleCanvas.style.width =
          this._glPatch._cgl.canvas.width / window.devicePixelRatio + "px";
        this._eleCanvas.style.height =
          this._glPatch._cgl.canvas.height / window.devicePixelRatio + "px";

        this._eleCanvas.width = this._glPatch._cgl.canvasWidth;
        this._eleCanvas.height = this._glPatch._cgl.canvasHeight;
        this._canvasCtx = this._eleCanvas.getContext("2d");
      }
    }

    render() {}

    /**
     * @param {CgpContext} cgp
     */
    renderWebGpuPreviews(cgp) {
      for (let i = 0; i < this._items.length; i++) {
        const item = this._items[i];
        if (item.op.renderVizLayerGpu) item.op.renderVizLayerGpu(cgp);
      }
    }

    renderVizLayer(gl) {
      if (!gl && this._fallBackrendererDisabled) {
        if (performance.now() - this.lastGlRendering > 500)
          this._fallBackrendererDisabled = false;
        return;
      }
      if (gl && !Gui$1.gui.corePatch().cgl.hasFrameStarted() && this._usingGl) {
        this._usingGl = false;
        return;
      }

      if (gl) this.lastGlRendering = performance.now();

      this._canvasCtx.clearRect(
        0,
        0,
        this._eleCanvas.width,
        this._eleCanvas.height,
      );
      this._canvasCtx.fillStyle =
        Gui$1.gui.theme.colors_vizlayer.colorBackground || "#222";

      const perf = Gui$1.gui.uiProfiler.start("glVizPreviewLayer.renderVizLayer");
      const paddingY = this._glPatch.viewBox.patchToScreenConv(0, 25)[1];

      this._updateSize();

      const w = this._eleCanvas.width;

      let count = 0;
      for (let i = 0; i < this._items.length; i++) {
        const item = this._items[i];
        const port = item.port;
        if (
          !port ||
          !item.op ||
          !item.op.uiAttribs ||
          !item.op.uiAttribs.translate
        )
          continue;

        item.posX = item.op.uiAttribs.translate.x;
        item.posY = item.op.uiAttribs.translate.y;

        const pos = this._glPatch.viewBox.patchToScreenCoords(
          item.posX,
          item.posY,
        );
        pos[1] += paddingY;

        pos[0] *= window.devicePixelRatio;
        pos[1] *= window.devicePixelRatio;

        const glop = this._glPatch.getGlOp(item.op);
        if (!glop || glop.opUiAttribs.subPatch != this._glPatch.subPatch)
          continue;

        let ww = glop.w;
        if (glop.opUiAttribs.resizable) ww += gluiconfig.rectResizeSize;

        const sizeOp = this._glPatch.viewBox.patchToScreenConv(ww, glop.h);
        const size = [sizeOp[0], sizeOp[1] - paddingY - paddingY / 2];

        sizeOp[0] *= window.devicePixelRatio;
        sizeOp[1] *= window.devicePixelRatio;

        size[0] *= window.devicePixelRatio;
        size[1] *= window.devicePixelRatio;

        if (
          pos[0] < -sizeOp[0] ||
          pos[1] < -sizeOp[1] ||
          pos[0] > this._eleCanvas.width ||
          pos[1] > this._eleCanvas.height
        )
          continue;

        this._canvasCtx.save();

        /*
         * this._canvasCtx.clearRect(pos[0] - 1, pos[1] - 1, size[0] + 2, size[1] + 2);
         * this._canvasCtx.strokeStyle = "transparent";
         */

        let region = new Path2D();
        region.rect(pos[0], pos[1], size[0], size[1]);
        this._canvasCtx.clip(region);

        const scale =
          (1000 / Gui$1.gui.patchView._patchRenderer.viewBox.zoom) * 1.5;

        if (count > 10 || this.paused || Math.max(sizeOp[1], sizeOp[0]) < 20) {
          this._canvasCtx.save();
          this._canvasCtx.scale(scale, scale);

          this._canvasCtx.font = "normal 6px sourceCodePro";
          this._canvasCtx.fillStyle =
            Gui$1.gui.theme.colors_vizlayer.colorText || "#FFF";

          this._canvasCtx.textAlign = "center";
          this._canvasCtx.fillText(
            "paused",
            (pos[0] + size[0] / 2) / scale,
            (pos[1] + size[1] / 2) / scale,
          );
          this._canvasCtx.restore();
        } else {
          const layer = {
            x: pos[0],
            y: pos[1],
            width: size[0],
            height: size[1],
            scale: (w / Gui$1.gui.patchView._patchRenderer.viewBox.zoom) * 0.6,
            useGl: this._usingGl,
            vizLayer: this,
            pixelDensity: window.devicePixelRatio,
          };

          if (
            !item.op.uiAttribs.vizLayerMaxZoom ||
            this._glPatch.viewBox.zoom < item.op.uiAttribs.vizLayerMaxZoom
          )
            if (pos[0] === pos[0] && size[0] === size[0]) {
              if (gl && item.op.renderVizLayerGl)
                item.op.renderVizLayerGl(this._canvasCtx, layer, this);
              if (item.op.renderVizLayer)
                item.op.renderVizLayer(this._canvasCtx, layer, this);
            }
        }

        item.oldPos = [pos[0], pos[1], size[0], size[1]];

        this._canvasCtx.restore();
        this.renderMs = performance.now() - this.lastGlRendering;

        count++;
      }

      if (Gui$1.gui.texturePreview().needsVizLayer())
        Gui$1.gui.texturePreview().drawVizLayer(this._canvasCtx);

      this._glPatch.debugData.numVizLayers = count;

      perf.finish();
    }

    _removeOpItem(op) {
      if (!op) {
        this._log.log("unknown vizlayer to remove");
        return;
      }
      const it = this._itemsLookup[op.id];

      let idx = this._items.indexOf(it);

      if (idx > -1) this._items.splice(idx, 1);
      else this._log.warn("could not find item");

      delete this._itemsLookup[op.id];

      if (this._items.length == 0)
        this._canvasCtx.clearRect(
          0,
          0,
          this._eleCanvas.width,
          this._eleCanvas.height,
        );
    }

    pauseInteraction() {
      this._eleCanvas.style["pointer-events"] = "none";
    }

    resumeInteraction() {
      this._eleCanvas.style["pointer-events"] = "none";
    }

    clear(ctx, layer) {
      ctx.fillStyle =
        Gui$1.gui.theme.colors_vizlayer.colorBackground || "#222" || "#222";
      ctx.fillRect(layer.x, layer.y, layer.width, layer.height);
    }

    _textWrap(str, max) {
      const space = " ";
      const lines = str.split("\n");
      const newLines = [];
      const newLinesIdx = [];

      for (let i = 0; i < lines.length; i++) {
        const words = lines[i].split(" ");
        let charCount = 0;
        let lineWords = [];
        for (let j = 0; j < words.length; j++) {
          charCount += words[j].length + 1;

          if (charCount >= max - 2) {
            newLines.push(lineWords.join(space));
            newLinesIdx.push(i);
            charCount = words[j].length + 1;
            lineWords = [];
          }
          lineWords.push(words[j]);
        }
        newLines.push(lineWords.join(space));
        newLinesIdx.push(i);
      }

      return {
        linesIdx: newLinesIdx,
        lines: newLines,
      };
    }

    renderText(ctx, layer, lines, options) {
      let indent = "";

      let fs = Math.max(1, options.fontSize);
      if (options.zoomText) fs *= 1.0 / layer.scale;
      let padding = fs * 0.25;
      const lineHeight = fs + padding;
      let numLines = Math.floor(layer.height / layer.scale / lineHeight);
      let offset = Math.floor(options.scroll * lines.length);

      offset = Math.max(offset, 0);
      offset = Math.min(offset, lines.length - numLines);
      if (lines.length < numLines) offset = 0;

      ctx.font = "normal " + fs + "px sourceCodePro";
      ctx.fillStyle = Gui$1.gui.theme.colors_vizlayer.colorText || "#FFF";

      if (options.showLineNum)
        for (let i = 0; i < (offset + numLines + " ").length; i++) indent += " ";

      let numChars = Math.ceil(layer.width / layer.scale / 6) - indent.length;

      ctx.fillStyle = Gui$1.gui.theme.colors_vizlayer.colorText || "#FFF";

      let hl = options.syntax && options.syntax != "text";

      let linesIdx = null;
      let lb = "\n";
      if (options.showWhitespace) lb = "" + lb;

      if (options.wrap) {
        const r = this._textWrap(lines.join(lb), numChars);
        lines = r.lines;
        linesIdx = r.linesIdx;
      }

      let lastline = "Z";

      for (let i = offset; i < offset + numLines; i += 1) {
        if (i >= lines.length || i < 0) continue;

        if (options.showWhitespace) {
          lines[i] = lines[i].replaceAll(" ", "");
          lines[i] = lines[i].replaceAll("\t", "");
        }

        if (options.showLineNum) {
          let idx = i;
          if (linesIdx) idx = linesIdx[i];

          if (lastline != idx) {
            lastline = idx;
            ctx.fillStyle =
              Gui$1.gui.theme.colors_vizlayer.colorLineNumbers || "#888";
            ctx.fillText(
              idx,
              layer.x / layer.scale + padding,
              layer.y / layer.scale + lineHeight + (i - offset) * lineHeight,
            );
            ctx.fillStyle = Gui$1.gui.theme.colors_vizlayer.colorText || "#FFF";
          }
        }

        if (hl) {
          const data = hljs.highlight(lines[i], { language: options.syntax });

          let fake = "";
          for (let j = 0; j < data._emitter.rootNode.children.length; j++) {
            const child = data._emitter.rootNode.children[j];
            let nextChild = null;
            if (data._emitter.rootNode.children.length >= j + 1)
              nextChild = data._emitter.rootNode.children[j + 1];
            if (typeof child == "string") {
              ctx.fillStyle = Gui$1.gui.theme.colors_vizlayer.colorText || "#888";
              ctx.fillText(
                indent + fake + child,
                layer.x / layer.scale + padding,
                layer.y / layer.scale + lineHeight + (i - offset) * lineHeight,
              );
              for (let k = 0; k < child.length; k++) fake += " ";
            } else {
              if (child.scope && child.children) {
                if (child.scope == "built_in") ctx.fillStyle = "#418ce9"; // blue
                else if (child.scope == "comment")
                  ctx.fillStyle = "#49d6b2"; // green
                else if (child.scope == "number")
                  ctx.fillStyle = "#49d6b2"; // cyan
                else if (
                  options.syntax == "js" &&
                  child.scope == "string" &&
                  nextChild &&
                  nextChild == ": "
                ) {
                  ctx.fillStyle = "#ecce64";
                } else if (child.scope == "string") ctx.fillStyle = "#d57272";
                else if (child.scope == "literal")
                  ctx.fillStyle = "#49d6b2"; // cyan
                else if (
                  child.scope == "meta" ||
                  child.scope == "keyword" ||
                  child.scope == "type"
                )
                  ctx.fillStyle = "#ecce64"; // yello
                else {
                  ctx.fillStyle = "#d00";
                }
                for (let l = 0; l < child.children.length; l++) {
                  ctx.fillText(
                    indent + fake + child.children[l],
                    layer.x / layer.scale + padding,
                    layer.y / layer.scale +
                      lineHeight +
                      (i - offset) * lineHeight,
                  );
                  for (let k = 0; k < child.children[l].length; k++) fake += " ";
                }
              }
            }
          }
        } else {
          ctx.fillText(
            indent + lines[i],
            layer.x / layer.scale + padding,
            layer.y / layer.scale + lineHeight + (i - offset) * lineHeight,
          );
        }
      }

      const gradHeight = 30;

      if (offset > 0) {
        const radGrad = ctx.createLinearGradient(
          0,
          layer.y / layer.scale + 5,
          0,
          layer.y / layer.scale + gradHeight,
        );
        radGrad.addColorStop(
          0,
          Gui$1.gui.theme.colors_vizlayer.colorBackground || "#222",
        );
        radGrad.addColorStop(1, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(
          layer.x / layer.scale,
          layer.y / layer.scale,
          layer.width,
          gradHeight,
        );
      }

      if (offset + numLines < lines.length) {
        const radGrad = ctx.createLinearGradient(
          0,
          layer.y / layer.scale + layer.height / layer.scale - gradHeight + 5,
          0,
          layer.y / layer.scale +
            layer.height / layer.scale -
            gradHeight +
            gradHeight,
        );
        radGrad.addColorStop(
          1,
          Gui$1.gui.theme.colors_vizlayer.colorBackground || "#222",
        );
        radGrad.addColorStop(0, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(
          layer.x / layer.scale,
          layer.y / layer.scale + layer.height / layer.scale - gradHeight,
          layer.width,
          gradHeight,
        );
      }
    }
  }

  /**
   * snapping of ops/ports etc to an invisible grid
   *
   * @export
   * @class Snap
   * @extends {Events}
   */
  class Snap extends Events {
    /**
     * @param {CglContext} cgl
     * @param {GlPatch} glPatch
     * @param {GlRectInstancer} instancer
     */
    constructor(_cgl, glPatch, instancer) {
      super();

      /**
       * @type {GlPatch}
       */
      this._glPatch = glPatch;
      this._xCoords = [];

      /**
       * @type {GlRectInstancer}
       */
      this._instancer = instancer;
      this._timeout = null;
      this._rectWidth = 1;
      this.enabled = true;

      if (this.enabled) {
        this.rect = new GlRect(this._instancer, { interactive: false });
        this.rect.setColor(0, 0, 0, 0.3);
        this.rect.setPosition(0, -3e5);
        this.rect.setSize(this._rectWidth * 2, 1000000);
      }
    }

    update() {
      if (!this.enabled) return;
      this._xCoords.length = 0;
      clearTimeout(this._timeout);
      this._timeout = setTimeout(() => {
        const perf = Gui$1.gui.uiProfiler.start("Snap.update");
        const hashmap = {};
        const ops = gui
          .corePatch()
          .getSubPatchOps(this._glPatch.getCurrentSubPatch());
        const selOps = Gui$1.gui.patchView.getSelectedOps();
        let selOp = null;

        if (selOps.length == 1) selOp = selOps[0];

        for (let i = 0; i < ops.length; i++)
          if (ops[i])
            if (
              selOp != ops[i] &&
              selOps.indexOf(ops[i]) == -1 &&
              ops[i].uiAttribs.translate
            )
              hashmap[ops[i].uiAttribs.translate.x] =
                (hashmap[ops[i].uiAttribs.translate.x] || 0) + 1;

        for (let i in hashmap) {
          const ii = parseInt(i);
          this._xCoords.push(ii);
        }
        perf.finish();
      }, 50);
    }

    /**
     * @param {Boolean} mouseDown
     */
    render(mouseDown) {
      if (!this.enabled) return;
      if (!mouseDown) if (this.rect) this.rect.visible = false;
    }

    /**
     * @param {Number} _x
     */
    snapX(_x) {
      let x = _x;
      if (UserSettings.userSettings.get("snapToGrid2")) x = Snap.snapOpPosX(_x);

      return x;
    }

    /**
     * @param {Number} y
     * @param {boolean} force
     * @returns {Number}
     */
    snapY(y, force = false) {
      if (UserSettings.userSettings.get("snapToGrid2") || force)
        return Snap.snapOpPosY(y);
      else return y;
    }

    /**
     * @param {number} _x
     * @param {Port} port
     * @param {number} index
     * @param {number} dist
     */
    _snapPortX(_x, port, _index, dist) {
      if (UserSettings.userSettings.get("snapToGrid2"))
        return Snap.snapOpPosX(_x);

      for (let i = 0; i < port.links.length; i++) {
        const otherPort = port.links[i].getOtherPort(port);

        if (
          !otherPort ||
          !otherPort.op.uiAttribs.translate ||
          !otherPort.op.uiAttribs
        )
          continue;

        let ports = otherPort.op.portsOut;
        if (otherPort.direction == PortDir.in) ports = otherPort.op.portsIn;
        for (let j = 0; j < ports.length; j++) {
          if (ports[j].uiAttribs.hidePort) continue;
          if (ports[j] == otherPort) break;
        }

        const glOp1 = this._glPatch.getGlOp(port.op);
        const portPosx = glOp1.getGlPort(port.name).posX;

        const glOp = this._glPatch.getGlOp(otherPort.op);
        const otherPortPosx =
          glOp.getGlPort(otherPort.name).posX +
          otherPort.op.uiAttribs.translate.x;

        if (Math.abs(otherPortPosx - _x - portPosx) < dist)
          return otherPortPosx - portPosx;
      }

      return -1;
    }

    snapOpX(_x, op, dist) {
      if (UserSettings.userSettings.get("snapToGrid2"))
        return Snap.snapOpPosX(_x);

      let hasLinks = false;
      dist = dist || gluiconfig.portWidth;
      if (op) {
        let index = 0;
        for (let i = 0; i < op.portsIn.length; i++) {
          if (op.portsIn[i].uiAttribs.hidePort) continue;
          index++;
          if (!op.portsIn[i].isLinked()) continue;
          hasLinks = true;
          const s = this._snapPortX(_x, op.portsIn[i], index, dist);
          if (s != -1) return s;
        }

        index = 0;
        for (let i = 0; i < op.portsOut.length; i++) {
          if (op.portsOut[i].uiAttribs.hidePort) continue;
          index++;
          if (!op.portsOut[i].isLinked()) continue;
          hasLinks = true;
          const s = this._snapPortX(_x, op.portsOut[i], index, dist);
          if (s != -1) return s;
        }
      } else console.warn("snapopx no op");

      if (!hasLinks) {
        if (this.rect) {
          this.rect.visible = false;
          for (let i = 0; i < this._xCoords.length; i++) {
            if (Math.abs(this._xCoords[i] - _x) < dist) {
              this.rect.setPosition(this._xCoords[i] - this._rectWidth, -3e5);
              this.rect.visible = true;
              return this._xCoords[i];
            }
          }
        }
      }

      return _x;
    }
  }

  /**
   * @param {Number} posX
   */
  Snap.snapOpPosX = function (posX) {
    return Math.round(posX / uiConfig.snapX) * uiConfig.snapX || 1;
  };

  /**
   * @param {Number} posY
   */
  Snap.snapOpPosY = function (posY) {
    return Math.round(posY / uiConfig.snapY) * uiConfig.snapY;
  };

  /**
   * rendering the patchfield
   *
   * @export
   * @class GlPatch
   * @extends {Events}
   */
  class GlPatch extends Events {
    /**
     * @param {CglContext} cgl
     */
    constructor(cgl) {
      super();

      this.logEvents(false, "glpatch");
      this._log = new Logger("glpatch");

      if (!cgl) this._log.error("[glpatch] need cgl");

      this.paused = false;
      this.pauseTimeOut = null;
      this.blueprint = false;
      this._cgl = cgl;
      this.mouseState = new MouseState(cgl.canvas);

      this._time = 0;
      this._timeStart = performance.now();
      this.isAnimated = false;

      this._mouseLeaveButtons = 0;

      this._cutLine = [];
      this.cutLineActive = false;

      this._glOpz = {};
      this._hoverOps = [];
      this._ignoreNonExistError = [];
      this._hoverOpLongStartTime = 0;
      this._patchAPI = null;
      this._showRedrawFlash = 0;
      this.debugData = {};

      this.greyOut = false;
      this._greyOutRect = null;
      this.startLinkButtonDrag = null;

      this.frameCount = 0;
      this.vizFlowMode = UserSettings.userSettings.get("glflowmode") || 0;

      this._overlaySplines = new GlSplineDrawer(cgl, "overlaysplines");
      this._overlaySplines.zPos = 0.5;
      // this._splineDrawer = new GlSplineDrawer(cgl, "patchCableSplines");
      this._splineDrawers = { 0: new GlSplineDrawer(cgl, "patchCableSplines_0") };

      this.viewBox = new GlViewBox(cgl, this);

      this._rectInstancer = new GlRectInstancer(cgl, {
        name: "mainrects",
        initNum: 1000,
      });
      this._lines = new GlLinedrawer(cgl, { name: "links", initNum: 100 });
      this._overLayRects = new GlRectInstancer(cgl, { name: "overlayrects" });

      this._textWriter = new GlTextWriter(cgl, {
        name: "mainText",
        initNum: 1000,
      });
      this._textWriterOverlay = new GlTextWriter(cgl, { name: "textoverlay" });
      this._currentSubpatch = 0;
      this._selectionArea = new GlSelectionArea(this._overLayRects);
      this._lastMouseX = this._lastMouseY = -1;
      this._portDragLine = new GlDragLine(this._overlaySplines, this);

      if (UserSettings.userSettings.get("devinfos")) {
        CABLES.UI.showDevInfos = true;
        const idx = this._overlaySplines.getSplineIndex();
        this._overlaySplines.setSpline(idx, [-1e6, 0, 0, 1000000, 0, 0]);
        this._overlaySplines.setSplineColor(idx, [0.25, 0.25, 0.25, 1.0]);

        const idx2 = this._overlaySplines.getSplineIndex();
        this._overlaySplines.setSpline(idx2, [0, -1e6, 0, 0, 1000000, 0]);
        this._overlaySplines.setSplineColor(idx2, [0.25, 0.25, 0.25, 1.0]);
      }

      // this._glTestSpline = new glEditableSpline(this._overlaySplines, this._rectInstancer, this);

      this.cablesHoverText = new GlText(this._textWriter, "");
      this.cablesHoverText.setPosition(0, 0);
      this.cablesHoverText.setColor(1, 1, 1, 0);

      /*
       * this._hoverCable = new GlCable(this, this._overlaySplines, this.rectDrawer.createRect({}), 10);
       * this._hoverCable.setPosition(0, 0, 100, 100);
       * this._hoverCable.setColor(1, 1, 1, 0.5);
       */
      this._showingOpCursor = false;
      this._eleDropOp = ele.byId("drop-op-cursor");

      this._fpsStartTime = 0;

      this.cacheOIRxa = 0;
      this.cacheOIRya = 0;
      this.cacheOIRxb = 0;
      this.cacheOIRyb = 0;
      this.cacheOIRops = null;

      this._subpatchoprect = null;
      this._subpatchAnimFade = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._subpatchAnimOutX = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._subpatchAnimOutY = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._subpatchAnimOutW = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._subpatchAnimOutH = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });

      this._focusRectAnim = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._focusRect = this._overLayRects.createRect();
      this._focusRect.setSize(1, 1);
      this._focusRect.setShape(4);
      this._focusRect.setColor(0, 1, 1, 1);
      this._focusRect.visible = false;

      /*
       * this._testAreaRect = this._overLayRects.createRect();
       * this._testAreaRect.setSize(0, 0);
       * this._testAreaRect.setShape(4);
       * this._testAreaRect.setColor(0, 0, 0, 0.2);
       * this._testAreaRect.visible = true;
       */

      this._glCursors = {};
      this._localGlCursor = new GlCursor(this, this._overLayRects);
      this._localGlCursor.setColor(1, 1, 1, 1);
      this._glCursors[0] = this._localGlCursor;

      this._glSelectionAreas = {};

      this.opShakeDetector = new ShakeDetector();
      this.opShakeDetector.on("shake", () => {
        if (Gui$1.gui.patchView.getSelectedOps().length === 1)
          Gui$1.gui.patchView.unlinkSelectedOps();
      });

      this.snap = new Snap(cgl, this, this._rectInstancer);

      this._redrawFlash = this._overLayRects.createRect();
      this._redrawFlash.setSize(50, 5);
      this._redrawFlash.setColor(0, 1, 0, 1);

      this._fadeOutRectAnim = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_LINEAR,
      });

      this._fadeOutRect = this._overLayRects.createRect();
      this._fadeOutRect.setSize(100000000, 100000000);
      this._fadeOutRect.setPosition(-5e7, -5e7);
      this._fadeOutRect.setColor(0, 0, 0, 0.0);
      this._fadeOutRect.visible = true;

      this._cursor = CABLES.GLGui.gui.CURSOR_NORMAL;

      this._viewZoom = 0;
      this.needsRedraw = false;
      this._selectedGlOps = {};

      this.links = {};

      this._dropInCircleLink = null;
      this._dropInCircleRect = null;

      this._dropInOpBorder = this._overLayRects.createRect();
      this._dropInOpBorder.setSize(100, 100);
      this._dropInOpBorder.setColor(1, 0, 0, 1);
      this._dropInOpBorder.visible = false;

      this._cachedNumSelectedOps = 0;
      this._cachedFirstSelectedOp = null;

      /*
       * cgl.canvas.addEventListener("touchstart", this._onCanvasMouseDown.bind(this), { "passive": false });
       * cgl.canvas.addEventListener("touchend", this._onCanvasMouseUp.bind(this), { "passive": false });
       * cgl.canvas.addEventListener("touchmove", this._onCanvasMouseMove.bind(this), { "passive": false });
       */

      cgl.canvas.addEventListener(
        "pointermove",
        this._onCanvasMouseMove.bind(this),
        { passive: false },
      );
      cgl.canvas.addEventListener("pointerup", this._onCanvasMouseUp.bind(this), {
        passive: false,
      });
      cgl.canvas.addEventListener(
        "pointerdown",
        this._onCanvasMouseDown.bind(this),
        { passive: false },
      );

      cgl.canvas.addEventListener(
        "pointerleave",
        this._onCanvasMouseLeave.bind(this),
        { passive: false },
      );
      cgl.canvas.addEventListener(
        "pointerenter",
        this._onCanvasMouseEnter.bind(this),
        { passive: false },
      );
      cgl.canvas.addEventListener("dblclick", this._onCanvasDblClick.bind(this), {
        passive: false,
      });

      Gui$1.gui.on("themeChanged", this.updateTheme.bind(this));

      Gui$1.gui.keys.key(
        "ArrowLeft",
        "Left",
        "down",
        cgl.canvas.id,
        { cmdCtrl: true },
        () => {
          this.viewBox.keyScrollX(-1);
        },
      );
      Gui$1.gui.keys.key(
        "ArrowRight",
        "Left",
        "down",
        cgl.canvas.id,
        { cmdCtrl: true },
        () => {
          this.viewBox.keyScrollX(1);
        },
      );
      Gui$1.gui.keys.key(
        "ArrowUp",
        "Left",
        "down",
        cgl.canvas.id,
        { cmdCtrl: true },
        () => {
          this.viewBox.keyScrollY(-1);
        },
      );
      Gui$1.gui.keys.key(
        "ArrowDown",
        "Left",
        "down",
        cgl.canvas.id,
        { cmdCtrl: true },
        () => {
          this.viewBox.keyScrollY(1);
        },
      );

      Gui$1.gui.keys.key("ArrowUp", "", "down", cgl.canvas.id, {}, () => {
        Gui$1.gui.patchView.cursorNavOps(0, -1);
      });
      Gui$1.gui.keys.key("ArrowDown", "", "down", cgl.canvas.id, {}, () => {
        Gui$1.gui.patchView.cursorNavOps(0, 1);
      });
      Gui$1.gui.keys.key("ArrowLeft", "", "down", cgl.canvas.id, {}, () => {
        Gui$1.gui.patchView.cursorNavOps(-1, 0);
      });
      Gui$1.gui.keys.key("ArrowRight", "", "down", cgl.canvas.id, {}, () => {
        Gui$1.gui.patchView.cursorNavOps(1, 0);
      });

      Gui$1.gui.keys.key(
        ["Delete", "Backspace"],
        "Delete selected ops",
        "down",
        cgl.canvas.id,
        {},
        this._onKeyDelete.bind(this),
      );
      Gui$1.gui.keys.key(
        "f",
        "Toggle flow visualization",
        "down",
        cgl.canvas.id,
        {},
        (_e) => {
          let fm = this.vizFlowMode || 0;

          fm++;

          if (fm == 3) fm = 0;

          const modes = ["Off", "Highlight Active", "Show Dataflow"];

          notify("Flow Visualization: ", modes[fm]);

          UserSettings.userSettings.set("glflowmode", fm);
        },
      );

      Gui$1.gui.keys.key(
        " ",
        "Drag left mouse button to pan patch",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          this._spacePressed = true;
          this.emitEvent("spacedown");
        },
      );
      Gui$1.gui.keys.key(
        " ",
        "",
        "up",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          this._spacePressed = false;
          this.emitEvent("spaceup");
        },
      );

      Gui$1.gui.keys.key(
        "e",
        "Edit op code",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          CABLES.CMD.OP.editOp(true);
        },
      );
      Gui$1.gui.keys.key(
        "c",
        "Center Selected Ops",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          this.viewBox.centerSelectedOps();
          if (Gui$1.gui.patchView.getSelectedOps().length == 1)
            this.focusOpAnim(Gui$1.gui.patchView.getSelectedOps()[0].id);
        },
      );
      Gui$1.gui.keys.key(
        "x",
        "Unlink selected ops",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          Gui$1.gui.patchView.unlinkSelectedOps();
        },
      );

      Gui$1.gui.keys.key(
        "x",
        "Unlink selected ops first ports only",
        "down",
        cgl.canvas.id,
        { shiftKey: true, displayGroup: "editor" },
        (e) => {
          Gui$1.gui.patchView.unlinkSelectedOps(true);
        },
      );

      Gui$1.gui.keys.key(
        "u",
        "Goto parent subpatch",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          CABLES.CMD.PATCH.gotoParentSubpatch();
        },
      );

      Gui$1.gui.keys.key(
        "a",
        "Select all ops in current subpatch",
        "down",
        cgl.canvas.id,
        { cmdCtrl: true, displayGroup: "editor" },
        (_e) => {
          Gui$1.gui.patchView.selectAllOpsSubPatch(this._currentSubpatch);
        },
      );
      Gui$1.gui.keys.key(
        "a",
        "Align selected ops",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          for (let j = 0; j < 20; j++)
            for (const i in this._selectedGlOps) {
              if (this._selectedGlOps[i].op)
                this._selectedGlOps[i].op.setUiAttribs({
                  translate: {
                    x: this.snap.snapOpX(
                      this._selectedGlOps[i].op.uiAttribs.translate.x,
                      this._selectedGlOps[i].op,
                      1000,
                    ),
                    y: this._selectedGlOps[i].op.uiAttribs.translate.y,
                  },
                });

              Gui$1.gui.patchView.testCollision(this._selectedGlOps[i].op);
            }
        },
      );
      Gui$1.gui.keys.key(
        "a",
        "Compress selected ops vertically",
        "down",
        cgl.canvas.id,
        { shiftKey: true, displayGroup: "editor" },
        (_e) => {
          Gui$1.gui.patchView.compressSelectedOps(
            Gui$1.gui.patchView.getSelectedOps(),
          );
        },
      );

      Gui$1.gui.keys.key(
        "j",
        "Navigate op history back",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          Gui$1.gui.opHistory.back();
        },
      );
      Gui$1.gui.keys.key(
        "k",
        "Navigate op history forward",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          Gui$1.gui.opHistory.forward();
        },
      );

      Gui$1.gui.keys.key(
        "j",
        "Navigate op history back",
        "down",
        cgl.canvas.id,
        { shiftKey: true, displayGroup: "editor" },
        (_e) => {
          Gui$1.gui.opHistory.back();
        },
      );
      Gui$1.gui.keys.key(
        "k",
        "Navigate op history forward",
        "down",
        cgl.canvas.id,
        { shiftKey: true, displayGroup: "editor" },
        (_e) => {
          Gui$1.gui.opHistory.forward();
        },
      );

      Gui$1.gui.keys.key(
        "d",
        "Disable Op",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          this.toggleOpsEnable();
        },
      );
      // Gui.gui.keys.key("d", "Temporary unlink op", "down", cgl.canvas.id, { "shiftKey": true, "displayGroup": "editor" }, (_e) => { Gui.gui.patchView.tempUnlinkOp(); });

      Gui$1.gui.keys.key(
        "!",
        "debug",
        "down",
        cgl.canvas.id,
        { shiftKey: true, displayGroup: "editor" },
        (_e) => {
          this._cycleDebug();
        },
      );

      Gui$1.gui.keys.key(
        "+",
        "Zoom In",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          this.zoomStep(-1);
        },
      );
      Gui$1.gui.keys.key(
        "=",
        "Zoom In",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          this.zoomStep(-1);
        },
      );
      Gui$1.gui.keys.key(
        "-",
        "Zoom Out",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          this.zoomStep(1);
        },
      );

      Gui$1.gui.keys.key(
        "t",
        "Set Title",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        (_e) => {
          CABLES.CMD.PATCH.setOpTitle();
        },
      );

      Gui$1.gui.keys.key(
        "y",
        "Cut Cables",
        "down",
        cgl.canvas.id,
        { displayGroup: "editor" },
        () => {
          if (!this.cutLineActive) this._cutLine = [];
          this.cutLineActive = true;
        },
      );

      Gui$1.gui.keys.key(
        "y",
        "Cut Cables",
        "up",
        cgl.canvas.id,
        { displayGroup: "editor" },
        () => {
          this.cutLineActive = false;
          this._overlaySplines.setSpline(this._cutLineIdx, [0, 0, 0, 0, 0, 0]);
        },
      );

      Gui$1.gui.on("uiloaded", () => {
        this.snap.update();
        // update remote cursor positions
        Gui$1.gui.on("netCursorPos", (msg) => {
          if (!this._glCursors[msg.clientId])
            this._glCursors[msg.clientId] = new GlCursor(
              this,
              this._overLayRects,
              msg.clientId,
            );

          if (msg.hasOwnProperty("subpatch"))
            this._glCursors[msg.clientId].setSubpatch(msg.subpatch);

          /*
           * {
           * this._glCursors[msg.clientId].visible = false;
           * }
           * else
           * {
           * this._glCursors[msg.clientId].visible = true;
           */
          this._glCursors[msg.clientId].setPosition(msg.x, msg.y);
          // }
        });

        Gui$1.gui.on("netSelectionArea", (msg) => {
          if (!this._glSelectionAreas[msg.clientId])
            this._glSelectionAreas[msg.clientId] = new GlSelectionArea(
              this._overLayRects,
              this,
            );
          const area = this._glSelectionAreas[msg.clientId];
          if (msg.hide) {
            area.hideArea();
          } else {
            if (msg.color)
              area.setColor([
                msg.color.r,
                msg.color.g,
                msg.color.b,
                Gui$1.gui.theme.colors_patch.patchSelectionArea[3],
              ]);
            area.setPos(msg.x, msg.y, 1000);
            area.setSize(msg.sizeX, msg.sizeY);
          }
        });

        // jump to client position, aka. follow mode
        Gui$1.gui.on("netGotoPos", (msg) => {
          if (msg.hasOwnProperty("scrollX") && msg.hasOwnProperty("scrollY")) {
            if (msg.hasOwnProperty("subpatch")) {
              /*
               * set subpatch and revert greyout-state to what is appropriate for this
               * client in multiplayer session
               */
              if (msg.subpatch !== this.getCurrentSubPatch()) {
                const mpGreyOut = Gui$1.gui.patchView.patchRenderer.greyOut;
                Gui$1.gui.patchView.setCurrentSubPatch(msg.subpatch, () => {
                  Gui$1.gui.patchView.patchRenderer.greyOut = mpGreyOut;
                });
              }
            }

            if (msg.hasOwnProperty("zoom")) {
              if (Gui$1.gui.patchView.patchRenderer.viewBox) {
                Gui$1.gui.patchView.patchRenderer.viewBox.animateZoom(msg.zoom);
              }
            }

            if (Gui$1.gui.patchView.patchRenderer.viewBox) {
              // why negate X here?
              Gui$1.gui.patchView.patchRenderer.viewBox.scrollTo(
                -msg.scrollX,
                msg.scrollY,
              );
            } else {
              this.center(msg.scrollX, msg.scrollY);
            }
          }
        });

        // remove client on connection lost
        Gui$1.gui.on("netClientRemoved", (msg) => {
          if (this._glCursors[msg.clientId]) {
            this._glCursors[msg.clientId].visible = false;
          }
        });

        Gui$1.gui.on("netLeaveSession", (msg) => {
          if (msg.clients) {
            msg.clients.forEach((client) => {
              if (this._glCursors[client.clientId]) {
                this._glCursors[client.clientId].visible = false;
              }
            });
          }
        });
      });

      Gui$1.gui.on("restrictionChange", (r) => {
        Gui$1.gui.patchView.patchRenderer.greyOut =
          r === Gui$1.gui.RESTRICT_MODE_FOLLOWER;
        this._updateGreyout();
      });

      this.vizLayer = new VizLayer(this);

      UserSettings.userSettings.on("change", (key, value) => {
        this.dblClickAction = UserSettings.userSettings.get("doubleClickAction");
        this.vizFlowMode = UserSettings.userSettings.get("glflowmode");
        this.updateVizFlowMode();

        if (key == "linetype")
          for (let i in this.links) this.links[i].updateLineStyle();
      });

      if (UserSettings.userSettings.get("devinfos")) {
        Gui$1.gui.corePatch().on("subpatchesChanged", () => {
          if (!this.subpatchAreaSpline)
            this.subpatchAreaSpline = this._overlaySplines.getSplineIndex();

          const bounds = Gui$1.gui.patchView.getSubPatchBounds();

          this._overlaySplines.setSpline(this.subpatchAreaSpline, [
            bounds.minX,
            bounds.minY,
            0,
            bounds.maxX,
            bounds.minY,
            0,

            bounds.maxX,
            bounds.minY,
            0,
            bounds.maxX,
            bounds.maxY,
            0,

            bounds.maxX,
            bounds.maxY,
            0,
            bounds.minX,
            bounds.maxY,
            0,

            bounds.minX,
            bounds.maxY,
            0,
            bounds.minX,
            bounds.minY,
            0,
          ]);

          this._overlaySplines.setSplineColor(
            this.subpatchAreaSpline,
            [0.25, 0.25, 0.25, 1],
          );
        });
      }

      this.snap.update();
    }

    get name() {
      return "glpatch";
    }

    get time() {
      return this._time;
    }

    set patchAPI(api) {
      this._patchAPI = api;
    }

    get patchAPI() {
      return this._patchAPI;
    }

    get rectDrawer() {
      return this._rectInstancer;
    }

    get selectedGlOps() {
      return this._selectedGlOps;
    }

    get subPatch() {
      return this._currentSubpatch;
    }

    get isAreaSelecting() {
      return this._selectionArea.active;
    }

    updateVizFlowMode() {
      for (let i in this._glOpz)
        this._glOpz[i].updateVizFlowMode(this.vizFlowMode);
    }

    updateCursor() {
      let cur = "auto";
      if (this.greyOut) {
        cur = "not-allowed";
      } else {
        if (this.viewBox.cursor) cur = this.viewBox.cursor;
        else if (
          this._hoverOps.length > 0 ||
          (this._cablesHoverButtonRect &&
            this._cablesHoverButtonRect.isHovering())
        )
          cur = "pointer";
        else if (this._spacePressed) cur = "grabbing";
      }

      if (this._cursor != cur) this._cgl.setCursor(cur);

      this._cursor = cur;
    }

    setCursor(c) {
      this._cursor = c;

      // this.mouseState.setCursor(this._cgl.canvas, c);
    }

    _removeDropInRect() {
      this._dropInOpBorder.visible = false;
    }

    _onCanvasMouseMove(e) {
      if (this.startLinkButtonDrag) this.startLinkButtonDrag.startDragging(e);

      this._dropInCircleLink = this._dropInCircleRect = null;

      if (e.shiftKey) this._pressedShiftKey = true;
      else this._pressedShiftKey = false;

      if (e.ctrlKey) this._pressedCtrlKey = true;
      else this._pressedCtrlKey = false;

      this.emitEvent("mousemove", e);

      if (this._dropInCircleRect) {
        // console.log("_dropInCircleRect", Gui.gui.patchView.getSelectedOps().length);

        let visible = false;
        if (Gui$1.gui.patchView.getSelectedOps().length == 1) {
          for (const i in this.selectedGlOps) {
            if (
              this.selectedGlOps[i].isHovering() &&
              this.selectedGlOps[i].isDragging
            ) {
              visible = true;

              const border = 5;
              this._dropInOpBorder.setSize(
                this._selectedGlOps[i].w + border * 2,
                this._selectedGlOps[i].h + border * 2,
              );

              // console.log("dragen2222!!!!!!", this._op.uiAttribs.translate.x, this._glPatch.snap.snapOpX(this._op.uiAttribs.translate.x, this._op));

              // this._glPatch.patchAPI.setOpUiAttribs(this._id, "translate", { "x": this._glPatch.snap.snapOpX(this._op.uiAttribs.translate.x, this._op), "y": this._glPatch.snap.snapY(this._op.uiAttribs.translate.y) });

              this._dropInOpBorder.setPosition(
                this._selectedGlOps[i].x - border,
                this._selectedGlOps[i].y - border,
              );

              this._dropInOpBorder.setColor(this._dropInCircleRect.color);
              this._dropInOpBorder.setOpacity(0.35);
            }
          }
        } else visible = false;

        this._dropInOpBorder.visible = visible;
      } else this._dropInOpBorder.visible = false;

      this.debugData._onCanvasMouseMove = this.debugData._onCanvasMouseMove || 0;
      this.debugData._onCanvasMouseMove++;

      this.profileMouseEvents = this.profileMouseEvents || 0;
      this.profileMouseEvents++;

      // if (!Gui.gui.longPressConnector.isActive()) Gui.gui.longPressConnector.longPressCancel();
    }

    _cycleDebug() {
      this._debugRenderStyle = this._debugRenderStyle || 0;

      this._debugRenderStyle++;
      if (this._debugRenderStyle > 3) this._debugRenderStyle = 0;

      for (let i in this._splineDrawers)
        this._splineDrawers[i].setDebugRenderer(this._debugRenderStyle);

      this._rectInstancer.setDebugRenderer(this._debugRenderStyle);
      this._overLayRects.setDebugRenderer(this._debugRenderStyle);

      this._textWriter.setDebugRenderer(this._debugRenderStyle);
      this._textWriterOverlay.setDebugRenderer(this._debugRenderStyle);

      /*
       * if (this._debugRenderStyle == 3) this.clear = false;
       * else this.clear = true;
       */
    }

    _onCanvasDblClick(e) {
      let isOverSubPatchOp = false;
      if (this._hoverOps.length > 0) {
        isOverSubPatchOp =
          this._hoverOps[0].op && this._hoverOps[0].op.isSubPatchOp();
      }

      if (isOverSubPatchOp) {
        const hoverOp = this._hoverOps[0].op;
        Gui$1.gui.patchView.setCurrentSubPatch(hoverOp.patchId.get());
        Gui$1.gui.patchView.updateSubPatchBreadCrumb(hoverOp.patchId.get());
      } else if (!this.dblClickAction || this.dblClickAction == "parentSub") {
        if (this._currentSubpatch != 0) {
          const spOp = Gui$1.gui.patchView.getSubPatchOuterOp(
            Gui$1.gui.patchView.getCurrentSubPatch(),
          );
          if (spOp) Gui$1.gui.patchView.setCurrentSubPatch(spOp.uiAttribs.subPatch);
        }
      } else if (this.dblClickAction == "addOp") {
        CABLES.CMD.PATCH.addOp();
      } else if (this.dblClickAction == "centerPatch") {
        this.viewBox.centerSelectedOps();
      }

      e.preventDefault();
    }

    /**
     * @param {PointerEvent} e
     */
    _onCanvasMouseLeave(e) {
      if (e.pointerType == "touch") return;

      if (this._pauseMouseUntilButtonUp) {
        this._pauseMouseUntilButtonUp = false;
        return;
      }

      if (this._selectionArea.active) {
        this._selectionArea.hideArea();
      }
      hideToolTip();

      this._lastButton = 0;
      this._mouseLeaveButtons = e.buttons;
      this.emitEvent("mouseleave", e);
    }

    /**
     * @param {PointerEvent} e
     */
    _onCanvasMouseEnter(e) {
      if (e.pointerType == "touch") return;
      if (this._mouseLeaveButtons != e.buttons && e.pointerType == "mouse") {
        // reentering with mouse down already - basically block all interaction
        this._pauseMouseUntilButtonUp = true;
        // this._log.log("reenter with different buttons!");
        return;
      }

      this.emitEvent("mouseenter", e);

      if (e.buttons == 0 && this._mouseLeaveButtons != e.buttons) {
        // when left while button down but re-entering button up...
        this._lastButton = 0;
        this._onCanvasMouseUp(e);
      }
    }

    _updateGreyout() {
      if (this.greyOut && !this._greyOutRect) {
        this._greyOutRect = this._overLayRects.createRect();
        this._greyOutRect.setColor(
          Gui$1.gui.theme.colors_patch.background[0],
          Gui$1.gui.theme.colors_patch.background[1],
          Gui$1.gui.theme.colors_patch.background[2],
          0.5,
        );
        this._greyOutRect.setSize(20000000, 20000000);
        this._greyOutRect.setPosition(
          -1e7,
          -1e7,
          gluiconfig.zPosGreyOutRect,
        );
      } else if (!this.greyOut && this._greyOutRect) {
        this._greyOutRect.dispose();
        this._greyOutRect = null;
      }

      /*
       * if (this.greyOutBlue && this._greyOutRect)
       * {
       *     this._greyOutRect.setColor(
       *         Gui.gui.theme.colors_patch.background[0] * 0.8,
       *         Gui.gui.theme.colors_patch.background[1] * 1.5,
       *         Gui.gui.theme.colors_patch.background[2] * 2.5,
       *         0.25);
       * }
       */
    }

    /**
     * @param {PointerEvent} e
     */
    _onCanvasMouseDown(e) {
      if (!e.pointerType) return;
      this._removeDropInRect();

      // this._onCanvasMouseMove(e);
      this.viewBox._onCanvasMouseMove(e);

      if (
        this.mouseState.buttonLeft &&
        !this.isMouseOverOp() &&
        Gui$1.gui.longPressConnector.isActive()
      )
        Gui$1.gui.longPressConnector.longPressCancel();

      try {
        this._cgl.canvas.setPointerCapture(e.pointerId);
      } catch (er) {
        this._log.log(er);
      }

      this.emitEvent("mousedown", e);
      this._rectInstancer.mouseDown(e);
      this._canvasMouseDown = true;
      this._canvasMouseDownSelecting = this.mouseState.buttonStateForSelecting;
    }

    _onCanvasMouseUp(e) {
      this.linkStartedDragging = false;
      this.startLinkButtonDrag = null;

      if (!this._portDragLine.isActive) {
        if (this._pauseMouseUntilButtonUp) {
          this._pauseMouseUntilButtonUp = false;
          return;
        }

        if (!this._canvasMouseDown) return;
      }

      this._canvasMouseDown = false;
      const perf = Gui$1.gui.uiProfiler.start("[glpatch] _onCanvasMouseUp");

      this._removeDropInRect();
      this._rectInstancer.mouseUp(e);

      try {
        this._cgl.canvas.releasePointerCapture(e.pointerId);
      } catch (er) {
        this._log.log(er);
      }

      // Gui.gui.longPressConnector.longPressCancel();
      this._rectInstancer.interactive = true;

      if (
        !this._selectionArea.active &&
        this._canvasMouseDownSelecting &&
        !this.mouseState.buttonStateForSelecting
      ) {
        if (
          Gui$1.gui.patchView.getSelectedOps().length == 0 ||
          this._hoverOps.length == 0
        ) {
          this.unselectAll();
          Gui$1.gui.showInfo(text.patch);
          Gui$1.gui.patchView.showDefaultPanel();
        }
      }

      if (this._selectionArea.active) {
        this._selectionArea.hideArea();
      }
      this.emitEvent("mouseup", e);

      if (
        this._canvasMouseDownSelecting &&
        !this.mouseState.buttonStateForSelecting
      )
        this._canvasMouseDownSelecting = false;

      if (this._dropInCircleLink) {
        if (Gui$1.gui.patchView.getSelectedOps().length == 1) {
          for (const i in this.selectedGlOps) {
            if (this.selectedGlOps[i].isHovering()) {
              // && this.selectedGlOps[i].isDragging
              const coord = this.screenToPatchCoord(e.offsetX, e.offsetY);
              Gui$1.gui.patchView.insertOpInLink(
                this._dropInCircleLink.link,
                this.selectedGlOps[i].op,
                coord[0],
                coord[1],
              );

              this._selectedGlOps[i].op.setUiAttribs({
                translate: {
                  x: this.snap.snapOpX(
                    this._selectedGlOps[i].op.uiAttribs.translate.x,
                    this._selectedGlOps[i].op,
                    100,
                  ),
                  y: coord[1],
                },
              });

              return;
            }
          }
        }
      }

      perf.finish();

      this._dropInCircleLink = this._dropInCircleRect = null;

      this._selectionArea.mouseUp();
    }

    _onKeyDelete(e) {
      Gui$1.gui.patchView.deleteSelectedOps();
      Gui$1.gui.patchView.showDefaultPanel();
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault();
    }

    isFocused() {
      return document.activeElement == this._cgl.canvas;
    }

    isMouseOverOp() {
      return this._hoverOps.length > 0;
    }

    center(x, y) {
      if (x === undefined) this.viewBox.centerSelectedOps();
      else this.viewBox.animateScrollTo(x, y, 0, false);
    }

    get lineDrawer() {
      return this._lines;
    }

    deleteLink(linkId) {
      const l = this.links[linkId];

      if (l) {
        delete this.links[linkId];
        l.dispose();
      } else {
        this._log.log("could not find link to remove!!", linkId);
      }
    }

    deleteOp(
      opid, // should work  th opid...
    ) {
      const glop = this._glOpz[opid];

      if (!glop) {
        this._log.log("could not find op to delete", opid);
        return;
      }

      delete this._glOpz[opid];
      glop.dispose();
    }

    toggleOpsEnable() {
      let willDisable = true;
      const ops = Gui$1.gui.patchView.getSelectedOps();
      for (let i = 0; i < ops.length; i++) {
        if (ops[i].uiAttribs.disabled) willDisable = false;
      }

      for (let i = 0; i < ops.length; i++) {
        ops[i].setUiAttribs({ disabled: willDisable });
      }
      Gui$1.gui.opParams.refresh();
    }

    addLink(l) {
      if (this.links[l.id]) this.links[l.id].dispose();
      this.links[l.id] = l;
    }

    focusOpAnim(opid) {
      this._focusRectOp = this._glOpz[opid];

      this._focusRectAnim.clear();
      this._focusRectAnim.setValue(this._time, 0);
      this._focusRectAnim.setValue(this._time + 0.5, 1);
    }

    /**
     * @param {Opid} opid
     */
    focusOp(opid) {
      Gui$1.gui.opParams.show(opid);
      this.focusOpAnim(opid);
    }

    /**
     * @param {boolean} x
     * @param {boolean} y
     */
    cursorNavOps(_x, _y) {
      const ops = Gui$1.gui.patchView.getSelectedOps();
      if (ops.length == 0) return;
    }

    /**
     * @param {Op} op
     * @param {boolean} fromDeserialize
     */
    addOp(op, fromDeserialize = false) {
      if (!op) this._log.error("no op at addop", op);

      if (!fromDeserialize && !op.uiAttribs.hasOwnProperty("subPatch"))
        op.uiAttribs.subPatch = this._currentSubpatch;

      let glOp = this._glOpz[op.id];
      if (!glOp) {
        glOp = new GlOp(this, this._rectInstancer, op);
        this._glOpz[op.id] = glOp;
      } else {
        glOp.uiAttribs = op.uiAttribs || {};
      }

      op.on("onPortRemoved", () => {
        glOp.refreshPorts();
      });
      op.on("onPortAdd", () => {
        glOp.refreshPorts();
      });
      op.on("onEnabledChange", () => {
        glOp.update();
      });
      op.on("onUiAttribsChange", (newAttribs) => {
        glOp.setUiAttribs(newAttribs, op.uiAttribs);
      });

      if (!op.uiAttribs.translate && op.uiAttribs.createdLocally) {
        if (
          CABLES.UI.OPSELECT.newOpPos.y === 0 &&
          CABLES.UI.OPSELECT.newOpPos.x === 0
        )
          op.uiAttr({
            translate: {
              x: Snap.snapOpPosX(this.viewBox.mousePatchX),
              y: Snap.snapOpPosY(this.viewBox.mousePatchY),
            },
          });
        else {
          if (!CABLES.UI.OPSELECT.newOpPos.noSnap) {
            CABLES.UI.OPSELECT.newOpPos.x = Snap.snapOpPosX(
              CABLES.UI.OPSELECT.newOpPos.x,
            );
            CABLES.UI.OPSELECT.newOpPos.y = Snap.snapOpPosY(
              CABLES.UI.OPSELECT.newOpPos.y,
            );
          }

          op.uiAttr({
            translate: {
              x: CABLES.UI.OPSELECT.newOpPos.x,
              y: CABLES.UI.OPSELECT.newOpPos.y,
            },
          });
        }
      }

      glOp.setTitle(op.uiAttribs.title, this._textWriter);

      if (!fromDeserialize) {
        glOp.update();
        this.unselectAll();

        if (
          Gui$1.gui.finishedLoading() &&
          op.uiAttribs.subPatch == this.getCurrentSubPatch()
        ) {
          this.selectOpId(op.id);
          Gui$1.gui.opParams.show(op.id);
        }

        if (op.uiAttribs.translate && op.uiAttribs.createdLocally) {
          glOp.updatePosition();
        }
      }

      delete op.uiAttribs.createdLocally;
      this._portDragLine.stop();
    }

    /**
     * @param {number} x
     * @param {number} y
     */
    screenToPatchCoord(x, y) {
      return this.viewBox.screenToPatchCoord(x, y);
    }

    _drawCursor() {
      const drawGlCursor = UserSettings.userSettings.get("glpatch_cursor");

      /*
       * if (drawGlCursor) this._cgl.setCursor("none");
       * else
       * {
       *     if (this._cursor == CABLES.GLGui.gui.CURSOR_HAND) this._cgl.setCursor("move");
       *     else if (this._cursor == CABLES.GLGui.gui.CURSOR_POINTER) this._cgl.setCursor("pointer");
       *     else this._cgl.setCursor("auto");
       * }
       */

      this._localGlCursor.visible = drawGlCursor;

      const a = this.viewBox.screenToPatchCoord(0, 0);
      const b = this.viewBox.screenToPatchCoord(20, 20);
      const z = b[0] - a[0];

      if (drawGlCursor) {
        this._localGlCursor.setSize(z, z);
        this._localGlCursor.setPosition(
          this.viewBox.mousePatchX,
          this.viewBox.mousePatchY,
        );
      }

      for (const i in this._glCursors) {
        this._glCursors[i].setSize(z, z);
      }
    }

    updateTime() {
      this._time = (performance.now() - this._timeStart) / 1000;
    }

    /**
     * @param {number} resX
     * @param {number} resY
     */
    render(resX, resY) {
      if (!gui || !Gui$1.gui.canvasManager) return;
      if (
        Gui$1.gui.canvasManager.mode == Gui$1.gui.canvasManager.CANVASMODE_PATCHBG
      ) {
        this._cgl.gl.clearColor(0, 0, 0, 0);
      } else {
        this._cgl.gl.clearColor(
          Gui$1.gui.theme.colors_patch.background[0],
          Gui$1.gui.theme.colors_patch.background[1],
          Gui$1.gui.theme.colors_patch.background[2],
          Gui$1.gui.theme.colors_patch.background[3],
        );
      }

      this.updateSubPatchOpAnim();
      this._cgl.gl.clear(
        this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT,
      );

      if (Object.keys(this._glOpz).length != Gui$1.gui.corePatch().ops.length) {
        for (let j = 0; j < Gui$1.gui.corePatch().ops.length; j++) {
          if (
            !this._glOpz[Gui$1.gui.corePatch().ops[j].id] &&
            this._ignoreNonExistError.indexOf(Gui$1.gui.corePatch().ops[j].id) == -1
          ) {
            this._ignoreNonExistError.push(Gui$1.gui.corePatch().ops[j].id);
            this._log.error(
              "missing glop in glpatch: ",
              Gui$1.gui.corePatch().ops[j].name,
            );
          }
        }
      }

      this.hasFocus = ele.hasFocus(this._cgl.canvas);
      this.debugData.splineUpdate = 0;

      for (const i in this._glOpz) {
        this._glOpz[i].updateIfNeeded();
      }

      this.frameCount++;
      this.isAnimated = false;

      for (const i in this._glCursors) this._glCursors[i].updateAnim();

      this.snap.render(this._canvasMouseDown);

      this._fadeOutRect.visible = !this._fadeOutRectAnim.isFinished(this._time);

      /*
       * if (this._fadeOutRect.visible)
       * {
       *     this.isAnimated = true;
       *     const v = this._fadeOutRectAnim.getValue(this._time);
       */

      // this.subPatchAnim = 1.0 - this._fadeOutRectAnim.getValue(this._time);

      /*
       *     this._fadeOutRect.setColor(
       *         Gui.gui.theme.colors_patch.background[0],
       *         Gui.gui.theme.colors_patch.background[1],
       *         Gui.gui.theme.colors_patch.background[2],
       *         v);
       * }
       */

      this._focusRect.visible = !this._focusRectAnim.isFinished(this._time);
      if (this._focusRect.visible) {
        this.isAnimated = true;
        const v = 1.0 - this._focusRectAnim.getValue(this._time);
        const dist = 20;

        if (this._focusRectOp) {
          this._focusRect.setPosition(
            this._focusRectOp.x - v * dist,
            this._focusRectOp.y - v * dist,
          );
          this._focusRect.setSize(
            this._focusRectOp.w + v * 2 * dist,
            this._focusRectOp.h + v * 2 * dist,
          );
          this._focusRect.setColor(1, 1, 1, v);
        } else {
          this._log.log("no focusrectop");
        }
      }

      this._cgl.pushDepthTest(true);
      this._cgl.pushDepthWrite(true);

      this._showRedrawFlash++;
      this._redrawFlash.setPosition(0, this._showRedrawFlash % 30, 1000);
      this.viewBox.update();

      this._patchAPI.updateFlowModeActivity(this.vizFlowMode);

      this.viewBox.setSize(resX, resY);

      const starttime = performance.now();

      this.mouseMove(this.viewBox.mousePatchX, this.viewBox.mousePatchY);

      this._drawCursor();

      this._portDragLine.setPosition(
        this.viewBox.mousePatchX,
        this.viewBox.mousePatchY,
      );

      const perf = Gui$1.gui.uiProfiler.start("[glpatch] render");

      // this._splineDrawer.render(resX, resY, this.viewBox.scrollXZoom, this.viewBox.scrollYZoom, this.viewBox.zoom, this.viewBox.mouseX, this.viewBox.mouseY);

      this.getSplineDrawer(this._currentSubpatch).render(
        resX,
        resY,
        this.viewBox.scrollXZoom,
        this.viewBox.scrollYZoom,
        this.viewBox.zoom,
        this.viewBox.mouseX,
        this.viewBox.mouseY,
      );
      this._rectInstancer.render(
        resX,
        resY,
        this.viewBox.scrollXZoom,
        this.viewBox.scrollYZoom,
        this.viewBox.zoom,
      );
      this._textWriter.render(
        resX,
        resY,
        this.viewBox.scrollXZoom,
        this.viewBox.scrollYZoom,
        this.viewBox.zoom,
      );
      this._overlaySplines.render(
        resX,
        resY,
        this.viewBox.scrollXZoom,
        this.viewBox.scrollYZoom,
        this.viewBox.zoom,
      );

      this._cgl.popDepthTest();
      this._cgl.pushDepthTest(false);

      this._overLayRects.render(
        resX,
        resY,
        this.viewBox.scrollXZoom,
        this.viewBox.scrollYZoom,
        this.viewBox.zoom,
      );

      this._cgl.popDepthTest();
      this._cgl.pushDepthTest(true);

      this._textWriterOverlay.render(resX, resY, -0.98, 0.94, 600);

      this._cgl.pushDepthTest(false);
      Gui$1.gui.longPressConnector.glRender(
        this,
        this._cgl,
        resX,
        resY,
        this.viewBox.scrollXZoom,
        this.viewBox.scrollYZoom,
        this.viewBox.zoom,
        this.viewBox.mouseX,
        this.viewBox.mouseY,
      );
      this._cgl.popDepthTest();

      if (this._showingOpCursor) {
        this._eleDropOp.style.top = this.viewBox.mouseY - 12 + "px";
        this._eleDropOp.style.left = this.viewBox.mouseX - 37 + "px";
      }

      this.needsRedraw = false;

      if (performance.now() - this._fpsStartTime > 1000) {
        this._fpsStartTime = performance.now();
        this.debugData.mouseMovePS = this.profileMouseEvents;
        this.profileMouseEvents = 0;
      }

      this.debugData["glpatch.allowDragging"] = this.allowDragging;
      this.debugData.rects = this._rectInstancer.getNumRects();
      this.debugData["text rects"] = this._textWriter.rectDrawer.getNumRects();
      this.debugData.viewZoom = this.viewBox.zoom;

      this.debugData._mousePatchX =
        Math.round(this.viewBox._mousePatchX * 100) / 100;
      this.debugData._mousePatchY =
        Math.round(this.viewBox._mousePatchY * 100) / 100;
      this.debugData.mouse_isDragging = this.mouseState.isDragging;

      this.debugData.rectInstancer = JSON.stringify(
        this._rectInstancer.getDebug(),
        false,
        2,
      );

      // this.mouseState.debug(this.debugData);

      this.debugData.renderMs =
        Math.round((performance.now() - starttime) * 10) / 10;

      if (this._cgl.profileData) {
        this.debugData.glPrimitives =
          this._cgl.profileData.profileMeshNumElements;
        this.debugData.glUpdateAttribs =
          this._cgl.profileData.profileMeshAttributes;

        for (let i in this._cgl.profileData.profileSingleMeshAttribute)
          this.debugData["glUpdateAttribs " + i] =
            this._cgl.profileData.profileSingleMeshAttribute[i];

        this._cgl.profileData.clear();
      }

      this._cgl.popDepthTest();
      this._cgl.popDepthWrite();

      this._updateGreyout();
      perf.finish();

      this.updateCursor();

      this._cgl.profileData.clearGlQuery();
    }

    mouseMove(x, y) {
      if (this.cutLineActive) {
        if (
          this.viewBox.mousePatchX == this._cutLine[this._cutLine.length - 3] &&
          this.viewBox.mousePatchY == this._cutLine[this._cutLine.length - 2]
        )
          return;

        for (let i in this.links) {
          if (
            this.links[i].collideLine(
              this._cutLine[this._cutLine.length - 3],
              this._cutLine[this._cutLine.length - 2],
              this.viewBox.mousePatchX,
              this.viewBox.mousePatchY,
            )
          ) {
            this.links[i].unlink();
          }
        }

        this._cutLine.push(this.viewBox.mousePatchX, this.viewBox.mousePatchY, 0);

        if (!this._cutLineIdx) {
          this._cutLineIdx = this._overlaySplines.getSplineIndex();
        }

        this._overlaySplines.setSpline(this._cutLineIdx, [...this._cutLine]); // copy dat array
        this._overlaySplines.setSplineColor(this._cutLineIdx, [1, 0, 0, 1]);

        return;
      }

      if (this._oldMouseMoveX == x && this._oldMouseMoveY == y) return;

      this._oldMouseMoveX = x;
      this._oldMouseMoveY = y;
      if (!this._portDragLine.isActive) if (this._pauseMouseUntilButtonUp) return;

      // if ((this._lastMouseX != x || this._lastMouseY != y) && !Gui.gui.longPressConnector.isActive()) Gui.gui.longPressConnector.longPressCancel();

      let allowSelectionArea = !this._portDragLine.isActive;
      if (this._selectionArea.active) allowSelectionArea = true;

      this._rectInstancer.mouseMove(x, y, this.mouseState.getButton());

      if (this._rectInstancer.isDragging()) return;

      /*
       * if (!this.mouseState.isDragging)
       * else this._hoverOps = [];
       */

      let preId = -1;
      if (this._hoverOps.length) preId = this._hoverOps[0].id;

      this._hoverOps = this._getGlOpsInRect(x, y, x + 1, y + 1);

      if (this._hoverOps.length && this._hoverOps[0].id != preId)
        this._hoverOpLongStartTime = performance.now();
      if (!this._hoverOps.length) this._hoverOpLongStartTime = 0;

      if (this.mouseState.isButtonDown()) ; else {
        this._hoverDragOp = null;
      }

      if (this._cablesHoverButtonRect && this._cablesHoverButtonRect.isHovering())
        allowSelectionArea = false;
      if (this._selectionArea.h == 0 && this._hoverOps.length > 0)
        allowSelectionArea = false;
      if (this._lastButton == 1 && this.mouseState.buttonLeft)
        this._selectionArea.hideArea();

      /*
       *     if (this._hoverOps.length > 0
       * || (this._cablesHoverButtonRect && this._cablesHoverButtonRect.isHovering())) this.setCursor(CABLES.GLGui.gui.CURSOR_POINTER);
       *     else this.setCursor(CABLES.GLGui.gui.CURSOR_NORMAL);
       */

      if (Gui$1.gui.longPressConnector.isActive()) {
        // const ops = this._getGlOpsInRect(xa, ya, xb, yb);

        const ops = this._getGlOpsInRect(x, y, x + 1, y + 1);
        if (
          ops.length > 0 &&
          this._focusRectAnim.isFinished(this._time) &&
          Gui$1.gui.longPressConnector.getStartOp().id != ops[0].id
        )
          this.focusOpAnim(ops[0].id);
      }

      if (
        this.mouseState.buttonStateForSelectionArea &&
        allowSelectionArea &&
        this.mouseState.isDragging &&
        this.mouseState.mouseOverCanvas
      ) {
        if (this._rectInstancer.interactive)
          if (this._pressedShiftKey || this._pressedCtrlKey)
            this._selectionArea.previousOps = Gui$1.gui.patchView.getSelectedOps();

        this._rectInstancer.interactive = false;

        this._selectionArea.setPos(this._lastMouseX, this._lastMouseY, 1000);
        this._selectionArea.setSize(x - this._lastMouseX, y - this._lastMouseY);
        this._selectOpsInRect(x, y, this._lastMouseX, this._lastMouseY);

        if (this._pressedShiftKey) {
          for (let i = 0; i < this._selectionArea.previousOps.length; i++) {
            this._selectionArea.previousOps[i].selected = true;
            this.selectOpId(this._selectionArea.previousOps[i].id);
          }
        }
        if (this._pressedCtrlKey) {
          let unselIds = [];

          for (let i in this._selectedGlOps)
            unselIds.push(this._selectedGlOps[i].id);

          for (let i = 0; i < this._selectionArea.previousOps.length; i++) {
            this._selectionArea.previousOps[i].selected = true;
            this.selectOpId(this._selectionArea.previousOps[i].id);
          }

          for (let i = 0; i < unselIds.length; i++)
            this.unSelectOpId(unselIds[i]);
        }

        Gui$1.gui.emitEvent(
          "drawSelectionArea",
          this._lastMouseX,
          this._lastMouseY,
          x - this._lastMouseX,
          y - this._lastMouseY,
        );

        Gui$1.gui.patchView.showSelectedOpsPanel();

        this._updateNumberOfSelectedOps();
      } else {
        this._numSelectedGlOps = -1;
        if (this._selectionArea.isVisible()) {
          this._selectionArea.previousOps = [];
          this._selectionArea.hideArea();
        }
        this._lastMouseX = x;
        this._lastMouseY = y;
      }

      this._lastButton = this.mouseState.getButton();
    }

    _updateNumberOfSelectedOps() {
      clearTimeout(this._numSelOpsTimeout);
      this._numSelOpsTimeout = setTimeout(() => {
        const numSelectedOps = Object.keys(this._selectedGlOps).length;
        const changedNumOps = this._numSelectedGlOps != numSelectedOps;
        this._numSelectedGlOps = numSelectedOps;
        if (changedNumOps) this.emitEvent("selectedOpsChanged", numSelectedOps);
      }, 20);
    }

    _getGlOpsInRect(xa, ya, xb, yb) {
      if (
        this.cacheOIRxa == xa &&
        this.cacheOIRya == ya &&
        this.cacheOIRxb == xb &&
        this.cacheOIRyb == yb
      )
        return this.cacheOIRops;

      const perf = Gui$1.gui.uiProfiler.start("[glpatch] ops in rect");
      const x = Math.min(xa, xb);
      const y = Math.min(ya, yb);
      const x2 = Math.max(xa, xb);
      const y2 = Math.max(ya, yb);
      const ops = [];

      const cops = Gui$1.gui.corePatch().getSubPatchOps();

      for (let j = 0; j < cops.length; j++) {
        // for (const i in this._glOpz)
        if (cops[j]) {
          const glop = this._glOpz[cops[j].id];
          if (!glop || !glop.visible) continue;

          if (
            glop.x + glop.w >= x && // glop. right edge past r2 left
            glop.x <= x2 && // glop. left edge past r2 right
            glop.y + glop.h >= y && // glop. top edge past r2 bottom
            glop.y <= y2
          ) {
            // r1 bottom edge past r2 top
            ops.push(glop);
          }
        }
        // else console.log("no c op");
      }

      perf.finish();

      this.cacheOIRxa = xa;
      this.cacheOIRya = ya;
      this.cacheOIRxb = xb;
      this.cacheOIRyb = yb;

      this.cacheOIRops = ops;
      return ops;
    }

    unselectAll() {
      const perf = Gui$1.gui.uiProfiler.start("[glpatch] unselectAll");

      for (const i in this._glOpz)
        if (this._glOpz[i].selected) this._glOpz[i].selected = false;
      this._selectedGlOps = {};
      this._cachedNumSelectedOps = 0;
      this._cachedFirstSelectedOp = null;
      this._updateNumberOfSelectedOps();

      perf.finish();
    }

    /**
     * @param {Op} op
     */
    getGlOp(op) {
      return this._glOpz[op.id];
    }

    /**
     * @param {String} id
     */
    setSelectedOpById(id) {
      this.unselectAll();

      if (this._glOpz[id] && !this._glOpz[id].isInCurrentSubPatch())
        this.setCurrentSubPatch(this._glOpz[id].getSubPatch());
      this.selectOpId(id);
    }

    getNumSelectedOps() {
      return this._cachedNumSelectedOps;
    }

    getOnlySelectedOp() {
      if (this._cachedNumSelectedOps == 1 && this._cachedFirstSelectedOp)
        return this._cachedFirstSelectedOp.op;
    }

    isDraggingOps() {
      if (this._cachedFirstSelectedOp)
        return this._cachedFirstSelectedOp.isDragging;
      else return false;
    }

    /**
     * @param {String} id
     */
    selectOpId(id) {
      if (this._glOpz[id] && !this._selectedGlOps[id]) {
        this._selectedGlOps[id] = this._glOpz[id];
        this._cachedNumSelectedOps++;
        if (this._cachedNumSelectedOps == 1)
          this._cachedFirstSelectedOp = this._glOpz[id];

        this._glOpz[id].selected = true;
      }

      if (Gui$1.gui.patchView.getSelectedOps().length > 1)
        Gui$1.gui.patchView.showSelectedOpsPanel();
    }

    /**
     * @param {String} id
     */
    unSelectOpId(id) {
      if (this._glOpz[id]) {
        delete this._selectedGlOps[id];

        this._glOpz[id].selected = false;
        this._cachedNumSelectedOps--;
      }
    }

    updateSubPatchOpAnim() {
      if (this._subpatchoprect) {
        this._subpatchoprect.setPosition(
          this._subpatchAnimOutX.getValue(this._time),
          this._subpatchAnimOutY.getValue(this._time),
          gluiconfig.zPosGlRectSelected,
        );
        this._subpatchoprect.setSize(
          this._subpatchAnimOutW.getValue(this._time),
          this._subpatchAnimOutH.getValue(this._time),
        );
        this._subpatchoprect.setOpacity(
          this._subpatchAnimFade.getValue(this._time),
        );
      }
    }

    subPatchOpAnimStart(bounds, next) {
      this._subpatchAnimFade = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._subpatchAnimOutX = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._subpatchAnimOutY = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._subpatchAnimOutW = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });
      this._subpatchAnimOutH = new CABLES.Anim({
        defaultEasing: CABLES.Anim.EASING_CUBIC_OUT,
      });

      /*
       * this._subpatchAnimFade.clear();
       * this._subpatchAnimFade.setValue(this._time, 0.0);
       * this._subpatchAnimFade.setValue(this._time + 0.25, 1.0);
       */

      if (this._subpatchoprect) this._subpatchoprect.dispose();
      this._subpatchoprect = this._overLayRects.createRect();

      let col = Gui$1.gui.theme.colors_patch.opBgRect;
      this._subpatchoprect.setColor(col);

      let dur = 0.4;

      this._subpatchAnimFade.setValue(this._time, 0.0);
      this._subpatchAnimFade.setValue(this._time + dur, 0.4, () => {
        if (next) {
          this.paused = true;
          next();
        }
      });
      this._subpatchoprect.setBorder(gluiconfig.subPatchOpBorder);
      this._subpatchAnimOutX.setValue(
        this._time,
        bounds.minX - Gui$1.gui.theme.patch.selectedOpBorderX / 2,
      );
      this._subpatchAnimOutY.setValue(
        this._time,
        bounds.minY - Gui$1.gui.theme.patch.selectedOpBorderY / 2,
      );
      this._subpatchAnimOutW.setValue(
        this._time,
        bounds.size[0] + Gui$1.gui.theme.patch.selectedOpBorderX,
      );
      this._subpatchAnimOutH.setValue(
        this._time,
        bounds.size[1] + Gui$1.gui.theme.patch.selectedOpBorderY,
      );

      this.updateSubPatchOpAnim();
    }

    subPatchOpAnimEnd(opid) {
      // clearTimeout(this.pauseTimeOut);
      this.paused = false;
      const dur = 0.25;
      const glop = this._glOpz[opid];

      this._subpatchAnimOutX.clear();
      this._subpatchAnimOutX.setValue(this._time, this._subpatchoprect.x);
      this._subpatchAnimOutX.setValue(
        this._time + dur,
        glop.op.uiAttribs.translate.x,
      );

      this._subpatchAnimOutY.clear();
      this._subpatchAnimOutY.setValue(this._time, this._subpatchoprect.y);
      this._subpatchAnimOutY.setValue(
        this._time + dur,
        glop.op.uiAttribs.translate.y,
      );

      this._subpatchAnimOutW.clear();
      this._subpatchAnimOutW.setValue(this._time, this._subpatchoprect.w);
      this._subpatchAnimOutW.setValue(this._time + dur, glop.w);

      this._subpatchAnimOutH.clear();
      this._subpatchAnimOutH.setValue(this._time, this._subpatchoprect.h);
      this._subpatchAnimOutH.setValue(this._time + dur, glop.h);

      this._subpatchAnimFade.clear();
      this._subpatchAnimFade.setValue(this._time, 1);
      this._subpatchAnimFade.setValue(this._time + dur / 2, 1.0);
      this._subpatchAnimFade.setValue(this._time + dur, 0.0, () => {
        this._subpatchoprect.dispose();
        this._subpatchoprect = null;
      });
    }

    _selectOpsInRect(xa, ya, xb, yb) {
      const ops = this._getGlOpsInRect(xa, ya, xb, yb);

      const perf = Gui$1.gui.uiProfiler.start("[glpatch] _selectOpsInRect");

      const opIds = [];
      for (let i = 0; i < ops.length; i++) opIds.push(ops[i].id);

      for (let i in this._selectedGlOps) {
        if (opIds.indexOf(i) == -1) {
          this._selectedGlOps[i].selected = false;
          delete this._selectedGlOps[i];
        }
      }

      this._cachedNumSelectedOps = Object.keys(this._selectedGlOps).length;

      for (let i = 0; i < ops.length; i++) {
        ops[i].selected = true;
        this.selectOpId(ops[i].id);
      }
      perf.finish();
    }

    getZoomForAllOps() {
      // this._log.log(this.getOpBounds());
      return 1200;
    }

    getOpBounds(ops) {
      return Gui$1.gui.patchView.getOpBounds(ops);
    }

    dispose() {
      for (const i in this._glOpz) {
        this._glOpz[i].dispose();
        delete this._glOpz[i];
      }

      for (let i in this.links) {
        this.links[i].dispose();
      }

      this.links = {};
      this._glOpz = {};

      if (this._rectInstancer) this._rectInstancer.dispose();
      if (this._lines) this._lines.dispose();
    }

    reset() {}

    getOp(opid) {
      return this._glOpz[opid];
    }

    // make static util thing...
    setDrawableColorByType(e, t, diff) {
      if (!e) return;
      diff = diff || gluiconfig.colorMulInActive;

      let col = [0, 0, 0, 0];
      if (!Gui$1.gui.theme.colors.types) return;

      if (t == portType.number)
        if (Gui$1.gui.theme.colors.types.num)
          col = [
            Gui$1.gui.theme.colors.types.num[0] * diff,
            Gui$1.gui.theme.colors.types.num[1] * diff,
            Gui$1.gui.theme.colors.types.num[2] * diff,
            1,
          ];
        else col = [0.7, 0.7, 0.7, 1];
      else if (t == portType.trigger)
        if (Gui$1.gui.theme.colors.types.trigger)
          col = [
            Gui$1.gui.theme.colors.types.trigger[0] * diff,
            Gui$1.gui.theme.colors.types.trigger[1] * diff,
            Gui$1.gui.theme.colors.types.trigger[2] * diff,
            1,
          ];
        else col = [0.7, 0.7, 0.7, 1];
      else if (t == portType.object)
        if (Gui$1.gui.theme.colors.types.obj)
          col = [
            Gui$1.gui.theme.colors.types.obj[0] * diff,
            Gui$1.gui.theme.colors.types.obj[1] * diff,
            Gui$1.gui.theme.colors.types.obj[2] * diff,
            1,
          ];
        else col = [0.7, 0.7, 0.7, 1];
      else if (t == portType.array)
        if (Gui$1.gui.theme.colors.types.arr)
          col = [
            Gui$1.gui.theme.colors.types.arr[0] * diff,
            Gui$1.gui.theme.colors.types.arr[1] * diff,
            Gui$1.gui.theme.colors.types.arr[2] * diff,
            1,
          ];
        else col = [0.7, 0.7, 0.7, 1];
      else if (t == portType.string)
        if (Gui$1.gui.theme.colors.types.str)
          col = [
            Gui$1.gui.theme.colors.types.str[0] * diff,
            Gui$1.gui.theme.colors.types.str[1] * diff,
            Gui$1.gui.theme.colors.types.str[2] * diff,
            1,
          ];
        else col = [0.7, 0.7, 0.7, 1];
      else if (t == portType.dynamic)
        if (Gui$1.gui.theme.colors.types.dynamic)
          col = [
            Gui$1.gui.theme.colors.types.dynamic[0] * diff,
            Gui$1.gui.theme.colors.types.dynamic[1] * diff,
            Gui$1.gui.theme.colors.types.dynamic[2] * diff,
            1,
          ];
        else col = [0.7, 0.7, 0.7, 1];
      else this._log.warn("unknown port color");
      e.setColor(col[0], col[1], col[2], col[3]);
    }

    isDraggingPort() {
      return this._portDragLine.isActive;
    }

    get dragLine() {
      return this._portDragLine;
    }

    get allowDragging() {
      return this._rectInstancer.allowDragging;
    }

    set allowDragging(b) {
      this._rectInstancer.allowDragging = b;
    }

    getConnectedGlPorts(opid, portname) {
      const op = this.getOp(opid);
      return op.getGlPortsLinkedToPort(opid, portname);
    }

    focus() {
      this._cgl.canvas.focus();
    }

    cut(e) {
      Gui$1.gui.patchView.clipboardCutOps(e);
    }

    copy(e) {
      /*
       * todo play copy indicator anim
       * for (const i in selectedOps) selectedOps[i].oprect.showCopyAnim();
       */
      Gui$1.gui.patchView.clipboardCopyOps(e);
    }

    paste(e) {
      Gui$1.gui.patchView.clipboardPaste(
        e,
        this._currentSubpatch,
        this.viewBox.mousePatchX,
        this.viewBox.mousePatchY,
        (ops, _focusSubpatchop) => {
          this.unselectAll();
          for (let i = 0; i < ops.length; i++) {
            this.selectOpId(ops[i].id);
          }

          if (ops[ops.length - 1]) Gui$1.gui.opParams.show(ops[ops.length - 1].id);
          if (ops.length == 1) this.focusOpAnim(ops[0].id);
        },
      );
    }

    getCurrentSubPatch() {
      if (this._currentSubpatch === undefined) {
        this._log.warn("current subpatch undefined");
        this.setCurrentSubPatch(0);
      }
      return this._currentSubpatch;
    }

    setCurrentSubPatch(sub, next) {
      if (this._currentSubpatch == sub) {
        for (const i in this._glOpz) this._glOpz[i].updateVisible();

        if (next) next();
        return;
      }

      if (sub === undefined) {
        this._log.warn("current subpatch undefined");
        return;
        // throw new Error("current subpatch undefined");
      }
      this.unselectAll();
      if (sub != 0 && sub != this._currentSubpatch)
        this._log.log("set subpatch: ", sub);
      this._currentSubpatch = sub;

      /*
       * this._fadeOutRectAnim.clear();
       * this._fadeOutRectAnim.setValue(this._time, 0);
       * this._fadeOutRectAnim.setValue(this._time + timeGrey, 1.0);
       * this._fadeOutRectAnim.setValue(this._time + timeGrey + 2, 1);
       * this._fadeOutRectAnim.setValue(this._time + timeVisibleAgain, 0);
       */

      Gui$1.gui.patchView.updateSubPatchBreadCrumb(sub);

      /*
       * setTimeout(() =>
       * {
       */
      for (const i in this._glOpz) {
        this._glOpz[i].updateVisible();
      }

      for (const i in this.links) {
        this.links[i].updateVisible();
      }

      this.restoreSubPatchViewBox(sub, next);
      this.snap.update();
    }

    restoreSubPatchViewBox(sub, next) {
      const dur = 0.3;
      const timeGrey = dur * 1.5;
      const timeVisibleAgain = dur * 3.0;

      this.viewBox.animSwitchSubPatch(dur, sub, timeGrey, timeVisibleAgain, next);
    }

    storeSubPatchViewBox() {
      this.viewBox.storeCurrentSubPatch();
    }

    serialize(dataUi) {
      this.viewBox.serialize(dataUi);
    }

    setProject(proj) {
      this.viewBox.deSerialize(proj.ui);
    }

    get spacePressed() {
      return this._spacePressed;
    }

    pause() {
      this._cgl.canvas.style["background-color"] = "rgba(61,61,61,1)";
      this.paused = true;
      this.emitEvent("paused");
    }

    resume() {
      this._cgl.canvas.style["background-color"] = "transparent";
      this.paused = false;
      this.emitEvent("resumed");
    }

    setSize(_x, _y, _w, _h) {}

    zoomStep(s) {
      this.viewBox.zoomStep(s);
    }

    showOpCursor(show) {
      if (this._showingOpCursor != show) {
        this._showingOpCursor = show;
        if (show) ele.show(this._eleDropOp);
        else ele.hide(this._eleDropOp);
      }
    }

    pauseInteraction() {
      this._cgl.canvas.style["pointer-events"] = "none";
      this.vizLayer.pauseInteraction();
    }

    resumeInteraction() {
      this._cgl.canvas.style["pointer-events"] = "initial";
      this.vizLayer.resumeInteraction();
    }

    getSplineDrawer(subpatchId) {
      if (this._splineDrawers.hasOwnProperty(subpatchId))
        return this._splineDrawers[subpatchId];
      else {
        this._splineDrawers[subpatchId] = new GlSplineDrawer(
          this._cgl,
          "patchCableSplines_" + subpatchId,
        );
        return this._splineDrawers[subpatchId];
      }
    }

    setHoverLink(e, link) {
      this._hoverLink = link;
      if (link && e) {
        clearTimeout(this._ttTImeout);
        updateHoverToolTip(e, link._link.portOut, link);
      }

      if (!link) {
        clearTimeout(this._ttTImeout);

        this._ttTImeout = setTimeout(() => {
          hideToolTip();
        }, 100);
      }
    }

    updateTheme() {
      this._selectionArea.updateTheme();

      for (let i in this._glOpz) this._glOpz[i].updateTheme();
    }
  }

  // make static util thing...
  GlPatch.getOpNamespaceColor = (ns) => {
    const parts = ns.split(".");
    const nss = parts[0] + "." + parts[1];

    if (!Gui$1.gui.theme.colors_namespaces) return [1, 1, 1, 1];

    if (Gui$1.gui.theme.colors_namespaces[nss])
      return Gui$1.gui.theme.colors_namespaces[nss];
    else return Gui$1.gui.theme.colors_namespaces.unknown || [1, 0, 0, 1];
  };

  /**
   * tree view for namespaces in op select dialog
   *
   * @export
   * @class OpTreeList
   */
  class OpTreeList {
    constructor() {
      this.data = this._serializeOps();
    }

    /**
     * @param {string} txt
     */
    searchFor(txt) {
      const opSearch = document.getElementById("opsearch");
      opSearch.value = txt;

      const event = new Event("input", {
        bubbles: true,
        cancelable: true,
      });

      opSearch.dispatchEvent(event);
    }

    /**
     * Description
     * @param {Object} item
     * @param {string} html
     * @param {number} level
     */
    itemHtml(item, html, level) {
      if (!item) return "";
      html = "";

      for (let i = 0; i < level; i++) html += "&nbsp;&nbsp;&nbsp;";

      const color = GlPatch.getOpNamespaceColor(item.fullname) || [1, 1, 1, 1];

      html +=
        '<a style="color:rgba(' +
        Math.round(color[0] * 255) +
        "," +
        Math.round(color[1] * 255) +
        "," +
        Math.round(color[2] * 255) +
        ',1);" onclick="Gui.gui.opSelect().tree.searchFor(\'' +
        item.fullname +
        ".')\">";
      html += "" + item.name;
      html += "</a>";

      html += "<br/>";

      if (item.childs)
        for (let i = 0; i < item.childs.length; i++)
          html += this.itemHtml(item.childs[i], html, level + 1);

      return html;
    }

    html() {
      const perf = Gui$1.gui.uiProfiler.start("opselect.treelist");

      let html = "";
      for (let i = 0; i < this.data.length; i++)
        html += this.itemHtml(this.data[i], html, 0);

      perf.finish();

      return html;
    }

    _serOpRec(root, prefix) {
      let items = [];

      for (const i in root) {
        if (i != "Deprecated" && i != "Admin" && i != "Dev") {
          items.push({
            name: i,
            fullname: prefix + "." + i,
            childs: this._serOpRec(root[i], prefix + "." + i),
          });
        }
      }
      return items;
    }

    _serializeOps() {
      const ns = { Ops: {} };

      for (let i in CABLES.OPS) {
        const parts = CABLES.OPS[i].objName.split(".");

        parts.length -= 1;

        if (parts.length >= 2)
          ns[parts[0]][parts[1]] = ns[parts[0]][parts[1]] || {};
        if (parts.length >= 3)
          ns[parts[0]][parts[1]][parts[2]] =
            ns[parts[0]][parts[1]][parts[2]] || {};
        if (parts.length >= 4)
          ns[parts[0]][parts[1]][parts[2]][parts[3]] =
            ns[parts[0]][parts[1]][parts[2]][parts[3]] || {};
        if (parts.length >= 5)
          ns[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]] =
            ns[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]] || {};
        if (parts.length >= 6)
          ns[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]] =
            ns[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]] || {};
        if (parts.length > 6)
          ns[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ] =
            ns[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
              parts[6]
            ] || {};
      }

      let items = this._serOpRec(ns.Ops, "Ops");

      items = items.sort(function (a, b) {
        if (a.name < b.name) return -1;
        if (a.name > b.name) return 1;
        return 0;
      });
      return items;
    }
  }

  /**
   * search through opdocs, e.g. for opselect
   *
   * @export
   * @class OpSearch
   * @extends {Events}
   */
  class OpSearch extends Events {
    _newOpOptions = {};
    constructor() {
      super();
      this._list = null;
      this._wordsDb = null;
      this.numPatchops = 0;
      this.originalSearch = "";
      this._hideUserOps = false;
    }

    get list() {
      return this._list;
    }

    resetList() {
      this._list = null;
    }

    _buildList() {
      const perf = Gui$1.gui.uiProfiler.start("opsearch.getlist");

      const codeOpNames = this._getOpsNamesFromCode([], "Ops", Ops, "");
      let items = this._createListItemsByNames(codeOpNames);

      const docOpName = Gui$1.gui.opDocs.getOpDocs().map((ext) => {
        return ext.name;
      });
      items = items.concat(this._createListItemsByNames(docOpName, items));

      const extensionNames = Gui$1.gui.opDocs.getExtensions().map((ext) => {
        return ext.name;
      });
      items = items.concat(this._createListItemsByNames(extensionNames, items));

      const teamNamespaces = Gui$1.gui.opDocs.getTeamNamespaces().map((ext) => {
        return ext.name;
      });
      items = items.concat(this._createListItemsByNames(teamNamespaces, items));

      const ns = platform.getPatchOpsNamespace();
      const patchOpNames = Gui$1.gui.opDocs.getNamespaceDocs(ns).map((ext) => {
        return ext.name;
      });

      this.numPatchops = CABLES.uniqueArray(patchOpNames || []).length;
      items = items.concat(this._createListItemsByNames(patchOpNames, items));

      const newList = {};
      items.forEach((item) => {
        if (!newList.hasOwnProperty(item.opId)) {
          newList[item.opId] = item;
        }
      });

      this._list = Object.values(newList);
      this._list.sort((a, b) => {
        return b.pop - a.pop;
      });
      perf.finish();

      /// --------------

      let maxPop = 0;

      for (let i = 0; i < this._list.length; i++) {
        if (!this._list[i].shortName)
          this._list[i].shortName = this._list[i].name;

        maxPop = Math.max(this._list[i].pop || 0, maxPop);
        this._list[i].id = i;
        this._list[i].summary = this._list[i].summary || "";
        this._list[i]._summary = this._list[i].summary.toLowerCase();
        this._list[i]._shortName = this._list[i].shortName.toLowerCase();
        this._list[i]._lowerCaseName = this._list[i].name.toLowerCase();
        this._list[i]._nameSpace = this._list[i].nameSpace.toLowerCase() + ".";
        this._list[i]._nameSpaceFull =
          this._list[i].nameSpace.toLowerCase() +
          "." +
          this._list[i].shortName.toLowerCase();

        const opdoc = Gui$1.gui.opDocs.getOpDocByName(this._list[i].name);
        if (
          namespace$1.isDeprecatedOp(this._list[i].name) ||
          (opdoc && opdoc.oldVersion)
        )
          this._list[i].old = true;
      }
      this._rebuildWordList();

      CABLES.UI.OPSELECT.maxPop = maxPop;
    }

    _searchWord(wordIndex, orig, list, query) {
      if (!query || query === " " || query === "") return;

      const perf = Gui$1.gui.uiProfiler.start("opsearch._searchWord");

      for (let i = 0; i < list.length; i++) {
        if (wordIndex > 0 && list[i].score === 0) continue; // when second word was found, but first was not

        let scoreDebug = "<b>Query: " + query + " </b><br/>";
        let found = false;
        let points = 0;

        if (list[i].lowercasename.indexOf(query) > -1) {
          if (list[i].name === defaultOps.glMainloop) {
            found = true;
            scoreDebug += "+2 vip op<br/>";
            points += 2;
          }
        }

        if (this.prefereGApi == CgContext.API_WEBGL) {
          if (list[i].name.startsWith(defaultOps.prefixes.webgpu)) {
            found = true;
            scoreDebug += "-5 different graphics api<br/>";
            points -= 5;
          }
        } else if (this.prefereGApi == CgContext.API_WEBGPU) {
          if (list[i].name.startsWith(defaultOps.prefixes.webgl)) {
            found = true;
            scoreDebug += "-5 different graphics api<br/>";
            points -= 5;
          }
        }

        if (list[i].abbrev && list[i].abbrev.indexOf(orig) === 0) {
          found = true;
          let p = 4;
          if (orig.length === 2) p = 12;
          if (orig.length === 3) p = 10;
          if (orig.length === 4) p = 8;

          if (query === query.toUpperCase()) {
            const ppo = 5;
            p += ppo;
            scoreDebug += "+" + ppo + " uppercase abbreviation<br/>";
          }

          scoreDebug += "+" + p + " abbreviation<br/>";

          points += p;
        }

        if (list[i].userOp && this._hideUserOps) continue;

        if (list[i]._summary.indexOf(query) > -1) {
          found = true;
          points += 1;
          scoreDebug += "+1 found in summary (" + query + ")<br/>";
        }

        if (list[i]._nameSpace.indexOf(query) > -1) {
          found = true;
          points += 1;
          scoreDebug += "+1 found in namespace (" + query + ")<br/>";
        }

        if (list[i]._shortName.indexOf(query) > -1) {
          found = true;
          points += 4;
          scoreDebug += "+4 found in shortname (" + query + ")<br/>";
        }

        if (list[i]._shortName == query) {
          found = true;
          points += 5;
          scoreDebug += "+5 query quals shortname<br/>";
        }

        if (orig.length > 1 && list[i]._lowerCaseName.indexOf(orig) > -1) {
          found = true;
          points += 2;
          scoreDebug += "+2 found full namespace (" + query + ")<br/>";
        }

        if (points == 0) {
          if (list[i]._lowerCaseName.indexOf(query) > -1) {
            found = true;
            points += 2;
            scoreDebug += "+2 found full namespace (" + query + ")<br/>";
          }
        }

        if (
          list[i].collectionOpNames &&
          list[i].collectionOpNames.indexOf(orig) > -1
        ) {
          found = true;
          points += 1;
          scoreDebug += "+1 is op in collection (" + query + ")<br/>";
        }

        if (found) {
          if (this._newOpOptions) {
            const firstportfitspoints = 3;
            const firstportfitsText = "+3 First Port fits<br/>";

            const docs = Gui$1.gui.opDocs.getOpDocByName(list[i].name);

            if (docs && docs.hasOwnProperty("version")) {
              const p = docs.version * 0.01;
              points += p;
              scoreDebug += "+" + p + " version<br/>";
            }

            if (
              docs &&
              docs.layout &&
              docs.layout.portsIn &&
              docs.layout.portsOut &&
              docs.layout.portsIn.length > 0 &&
              docs.layout.portsOut.length > 0
            ) {
              // when inserting into link - find fitting ports
              if (this._newOpOptions.linkNewLink) {
                let foundPortTypeIn = false;
                for (let j = 0; j < docs.layout.portsIn.length; j++) {
                  if (
                    docs.layout.portsIn[j] &&
                    this._newOpOptions.linkNewLink.portIn &&
                    docs.layout.portsIn[j].type ==
                      this._newOpOptions.linkNewLink.portIn.type
                  ) {
                    foundPortTypeIn = true;
                    break;
                  }
                }

                let foundPortTypeOut = false;
                for (let j = 0; j < docs.layout.portsOut.length; j++) {
                  if (
                    docs.layout.portsOut[j].type ==
                    this._newOpOptions.linkNewLink.portOut.type
                  ) {
                    foundPortTypeOut = true;
                    break;
                  }
                }

                if (
                  docs.layout.portsIn[0].type ==
                    this._newOpOptions.linkNewLink.portOut.type &&
                  docs.layout.portsOut[0].type ==
                    this._newOpOptions.linkNewLink.portIn.type
                ) {
                  points += firstportfitspoints;
                  scoreDebug += firstportfitsText;
                }

                if (!foundPortTypeOut && !foundPortTypeIn) {
                  points -= 5.0; // seems harsh, but is only used when dragging a port, so it should be fine...
                  scoreDebug += "-5.0 no compatible port found<br/>";
                }
              }

              // when dragging a port - find fitting  input/output port
              if (this._newOpOptions.linkNewOpToPort) {
                let foundPortType = false;
                if (
                  this._newOpOptions.linkNewOpToPort.direction ===
                  CABLES.Port.DIR_OUT
                ) {
                  if (
                    docs.layout.portsIn[0].type ==
                    this._newOpOptions.linkNewOpToPort.type
                  ) {
                    points += firstportfitspoints;
                    scoreDebug += firstportfitsText;
                  }

                  for (let j = 0; j < docs.layout.portsIn.length; j++) {
                    if (
                      docs.layout.portsIn[j].type ==
                      this._newOpOptions.linkNewOpToPort.type
                    ) {
                      foundPortType = true;
                      break;
                    }
                  }
                } else {
                  if (
                    docs.layout.portsOut[0].type ==
                    this._newOpOptions.linkNewOpToPort.type
                  ) {
                    points += firstportfitspoints;
                    scoreDebug += firstportfitsText;
                  }

                  for (let j = 0; j < docs.layout.portsOut.length; j++) {
                    if (
                      docs.layout.portsOut[j].type ==
                      this._newOpOptions.linkNewOpToPort.type
                    ) {
                      foundPortType = true;
                      break;
                    }
                  }
                }

                if (!foundPortType) {
                  points -= 10.0; // seems harsh, but is only used when dragging a port, so it should be fine...
                  scoreDebug += "-10.0 no comparible port found<br/>";
                }
              }
            }
          }

          if (list[i]._shortName.indexOf(orig) === 0) {
            points += 2.5;
            scoreDebug +=
              "+2.5 found in shortname at beginning (" + query + ")<br/>";

            if (list[i]._shortName == orig) {
              points += 2;
              scoreDebug += "+2 exact name (" + query + ")<br/>";
            }
          }

          if (list[i]._nameSpace.indexOf("ops.math") > -1) {
            points += 1;
            scoreDebug += "+1 is math op (" + query + ")<br/>";
          } else if (list[i]._nameSpace.indexOf("ops.patch") > -1) {
            points += 3;
            scoreDebug += "+1 is patch op (" + query + ")<br/>";
          } else if (list[i]._nameSpace.indexOf("ops.team") > -1) {
            points += 2;
            scoreDebug += "+2 is team op (" + query + ")<br/>";
          }

          const shortnessPoints =
            (2 *
              Math.round(
                (1.0 -
                  Math.min(
                    1,
                    (list[i]._nameSpace + list[i]._shortName).length / 100,
                  )) *
                  100,
              )) /
            100;
          points += shortnessPoints;
          scoreDebug += "+" + shortnessPoints + " shortness namespace<br/>";
        }

        if (found && this._list[i].old) {
          points -= 1;
          scoreDebug += "-1 outdated<br/>";
        }

        if (found && list[i].pop > 0) {
          points += (list[i].pop || 2) / CABLES.UI.OPSELECT.maxPop || 1;
        }

        if (found && this._list[i].notUsable) {
          points = 0.1;
          scoreDebug += "0.1 not usable<br/>";
        }

        if (!found) points = 0;

        if (points === 0 && list[i].score > 0) list[i].score = 0;
        else list[i].score += points;

        list[i].scoreDebug =
          (list[i].scoreDebug || "") +
          scoreDebug +
          " (" +
          Math.round(points * 100) / 100 +
          " points)<br/><br/>";
      }

      perf.finish();
    }

    search(query, originalSearch) {
      this.prefereGApi = Gui$1.gui.canvasManager.currentContext().gApi;

      document.getElementById("realsearch").innerHTML = "";
      document.getElementById("opOptions").innerHTML = "";
      if (!query) return;

      const origQuery = query;
      if (this._wordsDb) {
        // search through word db
        let q = query;
        const queryParts = [];
        let found = false;
        do {
          found = false;
          for (let i = 0; i < this._wordsDb.length; i++) {
            const idx = q.indexOf(this._wordsDb[i]);
            if (idx > -1) {
              // && queryParts.indexOf(this._wordsDb[i])==-1
              found = true;
              queryParts.push(this._wordsDb[i]);
              q =
                q.substr(0, idx) +
                " " +
                q.substr(idx + this._wordsDb[i].length, q.length - idx);
              break;
            }
          }
        } while (found);

        if (queryParts.length > 0) {
          let nquery = queryParts.join(" ");
          nquery += " " + q;
          if (nquery.trim() !== query)
            document.getElementById("realsearch").innerHTML =
              "Searching for: <b>" + nquery + "</b>";
          query = nquery;
        } else document.getElementById("realsearch").innerHTML = "";
      }
      if (query.length > 1 && this._list) {
        for (let i = 0; i < this._list.length; i++) {
          this._list[i].score = 0;
          this._list[i].scoreDebug = "";
        }

        if (query.indexOf(" ") > -1) {
          const words = query.split(" ");
          for (let i = 0; i < words.length; i++) {
            this._searchWord(i, origQuery, this._list, words[i]);
          }
        } else {
          this._searchWord(0, query, this._list, originalSearch);
        }
      }
    }

    _rebuildWordList() {
      if (!this._list) return;
      const buildWordDB = {};
      for (let i = 0; i < this._list.length; i++) {
        const res = this._list[i].name.split(/(?=[A-Z,0-9,/.])/);

        for (let j = 0; j < res.length; j++) {
          if (res[j][res[j].length - 2] === "_")
            res[j] = res[j].substr(0, res[j].length - 2);
          if (res[j][0] === ".") res[j] = res[j].substr(1);
          if (res[j].length > 2) buildWordDB[res[j].toLowerCase()] = 1;
        }

        let shortName = "";
        const ccParts = this._list[i].shortName.split(/(?=[A-Z,0-9,/.])/);
        for (let j = 0; j < ccParts.length; j++)
          shortName += ccParts[j].substr(0, 1);
        this._list[i].abbrev = shortName.toLocaleLowerCase();
      }

      this._wordsDb = Object.keys(buildWordDB);
      this._wordsDb.sort((a, b) => {
        return b.length - a.length;
      });
    }

    _getOpsNamesFromCode(opnames, ns, val, parentname) {
      if (Object.prototype.toString.call(val) === "[object Object]") {
        for (const propertyName in val) {
          if (val.hasOwnProperty(propertyName)) {
            const opName = ns + "." + parentname + propertyName;
            if (typeof CABLES.Patch.getOpClass(opName) === "function")
              opnames.push(opName);
            opnames = this._getOpsNamesFromCode(
              opnames,
              ns,
              val[propertyName],
              parentname + propertyName + ".",
            );
          }
        }
      }
      return opnames;
    }

    _createListItemsByNames(_opNames, listItems = []) {
      if (!_opNames) return;
      const items = [];
      for (let i = 0; i < _opNames.length; i++) {
        const opName = _opNames[i];
        if (!opName) continue;
        const parts = opName.split(".");
        const lowerCaseName =
          opName.toLowerCase() + "_" + parts.join("").toLowerCase();
        const opDoc = Gui$1.gui.opDocs.getOpDocByName(opName);
        let shortName = parts[parts.length - 1];
        let hidden = false;
        let opDocHidden = false;
        let opId = null;

        if (opDoc) {
          opId = opDoc.id;
          opDocHidden = opDoc.hidden;
          hidden = opDoc.hidden;
          shortName = opDoc.shortNameDisplay;
        }

        if (namespace$1.isDevOp(opName) && !platform.isDevEnv()) hidden = true;

        parts.length -= 1;
        const nameSpace = parts.join(".");

        if (namespace$1.isCollection(opName)) {
          const inUse =
            listItems &&
            listItems.some((op) => {
              return op.name.startsWith(opName);
            });
          if (inUse) hidden = true;
        }

        if (!hidden) {
          let oldState = "";
          if (hidden) oldState = "OLD";
          if (opDocHidden) oldState = "OLD";
          if (namespace$1.isDeprecatedOp(opName)) oldState = "DEPREC";

          let popularity = -1;
          let summary = Gui$1.gui.opDocs.getSummary(opName);
          let type = "op";
          if (namespace$1.isTeamNamespace(opName)) type = "team";
          if (namespace$1.isExtension(opName)) type = "extension";
          if (namespace$1.isPatchOp(opName)) type = "patchop";

          const isTeamOp = namespace$1.isTeamOp(opName);
          const isCollection = namespace$1.isCollection(opName);

          let collectionOpNames = null;
          if (isCollection) {
            const a = Gui$1.gui.opDocs.getNamespaceDocs(opName);
            if (a && a.length > 0 && a[0].ops)
              collectionOpNames = a[0].ops.join(" ").toLowerCase();
          }

          const op = {
            opId: opId || CABLES.simpleId(),
            name: opName,
            summary: summary,
            collectionOpNames: collectionOpNames,
            nscolor: opNames.getNamespaceClassName(opName),
            isOp: !namespace$1.isCollection(opName),
            userOp: namespace$1.isUserOp(opName),
            devOp: namespace$1.isDevOp(opName),
            extensionOp: namespace$1.isExtensionOp(opName),
            teamOp: namespace$1.isTeamOp(opName),
            patchOp: namespace$1.isPatchOp(opName),
            isExtension: namespace$1.isExtension(opName),
            isTeamNamespace: isTeamOp,
            shortName: shortName,
            nameSpace: nameSpace,
            oldState: oldState,
            lowercasename: lowerCaseName,
            isCollection: isCollection,
            buttonText: isCollection ? "Load" : "Add",
            type: type,
            pop: popularity,
          };
          if (opDoc && opDoc.notUsable) {
            op.notUsable = true;
            op.notUsableReasons = opDoc.notUsableReasons;
          }
          if (namespace$1.isCollection(opName)) {
            op.isOp = false;
            op.pop = 1;
            if (opDoc) {
              op.summary = opDoc.summary;
              op.description = opDoc.description;
              op.teamName = opDoc.teamName;
              op.teamLink = opDoc.teamLink;
              op.numOps = opDoc.numOps;
              op.ops = opDoc.ops || [];
            }
          }
          items.push(op);
        }
      }
      return items;
    }
  }

  CABLES = CABLES || {};
  CABLES.UI = CABLES.UI || {};

  CABLES.UI.OPSELECT = {};
  CABLES.UI.OPSELECT.linkNewLink = null;
  CABLES.UI.OPSELECT.linkNewOpToPort = null;
  CABLES.UI.OPSELECT.newOpPos = { x: 0, y: 0 };
  CABLES.UI.OPSELECT.maxPop = 0;

  const MIN_CHARS_QUERY = 2;

  class OpSelect {
    constructor() {
      this.displayBoxIndex = 0;
      this.itemHeight = 0;
      this.firstTime = true;
      this.tree = null;
      this._eleSearchinfo = null;
      this._newOpOptions = {};
      this._searchInputEle = null;
      this._enterPressedEarly = false;
      this._searching = false;
      this._bg = new ModalBackground();
      this._typedSinceOpening = false;
      this._currentInfo = "";
      this._lastScrollTop = -5711;
      this._eleOpsearchmodal = null;
      this._opSearch = new OpSearch();
      this._keyTimeout = null;
      this._hideUserOps = false;
    }

    close() {
      this._bg.hide();
      this._eleOpsearchmodal.style.zIndex = -9999;

      Gui$1.gui.currentModal = null;
      Gui$1.gui.patchView.focus();
    }

    _getQuery() {
      const el = ele.byId("opsearch");
      if (!el) return "";
      return el.value || "";
    }

    isMathQuery() {
      if (this._getQuery().length > 0) {
        let mathPortType = this._getMathPortType();
        for (let i in defaultOps.defaultMathOps[mathPortType])
          if (this._getQuery().charAt(0) === i) return true;
      }
      return false;
    }

    updateStatusBar() {
      if (!this._eleSearchinfo) return;
      this._hideUserOps = Gui$1.gui.project().isOpExample;

      const perf = Gui$1.gui.uiProfiler.start("opselect.udpateOptions");
      const num = ele.byQueryAll(
        ".searchbrowser .searchable:not(.hidden)",
      ).length;
      const query = this._getQuery();

      this._eleTypeStart = this._eleTypeStart || ele.byId("search_startType");
      this._eleTypeMore = this._eleTypeMore || ele.byId("search_startTypeMore");
      this._eleNoResults = this._eleNoResults || ele.byId("search_noresults");

      if (query.length === 0) {
        ele.show(this._eleTypeStart);
        this._showSuggestionsInfo();

        for (let i = 0; i < this._opSearch.list.length; i++)
          if (
            this._opSearch.list[i].element &&
            !this._opSearch.list[i].elementHidden
          ) {
            this._opSearch.list[i].elementHidden = true;
            ele.hide(this._opSearch.list[i].element);
          }
      } else ele.hide(this._eleTypeStart);

      if (
        query.length > 0 &&
        query.length < MIN_CHARS_QUERY &&
        !this.isMathQuery()
      ) {
        ele.show(this._eleTypeMore);
        for (let i = 0; i < this._opSearch.list.length; i++) {
          if (!this._opSearch.list[i].elementHidden) {
            this._opSearch.list[i].elementHidden = true;
            ele.hide(this._opSearch.list[i].element);
          }
        }
        this._eleSearchinfo.innerHMTL = "";
      } else ele.hide(this._eleTypeMore);

      if (num === 0 && query.length >= MIN_CHARS_QUERY) {
        ele.show(this._eleNoResults);
        this._eleSearchinfo.innerHMTL = "";
      } else {
        ele.hide(this._eleNoResults);
      }

      let optionsHtml = "";

      if (query.length >= MIN_CHARS_QUERY) {
        if (this._hideUserOps) {
          optionsHtml +=
            '<div class="warning">Your user ops are hidden, patch is an op example</div>';
        } else {
          const isOwner = platform.currentUserIsPatchOwner();
          const isFullCollab =
            Gui$1.gui.project().users &&
            Gui$1.gui.project().users.includes(Gui$1.gui.user.id);
          const isReadOnlyCollab =
            Gui$1.gui.project().usersReadOnly &&
            Gui$1.gui.project().usersReadOnly.includes(Gui$1.gui.user.id);

          if (num === 0 && !(isOwner || isFullCollab || isReadOnlyCollab)) {
            optionsHtml +=
              '<div class="warning">Your user ops are hidden, you are not a collaborator of patch </div>';
          }
        }

        if (num > 0) optionsHtml += "&nbsp;Found " + num + " ops.";

        let score = 0;

        /** @type {HTMLCollectionOf<Element>} */
        const selected = document.getElementsByClassName("selected");

        if (query.length > 0 && selected.length > 0)
          score = Math.round(100 * parseFloat(selected[0].dataset.score)) / 100;

        if (score && score === score) {
          let scoredebug = "";

          if (selected.length > 0) scoredebug = selected[0].dataset.scoreDebug;

          optionsHtml +=
            '&nbsp;&nbsp;|&nbsp;&nbsp;<span class="tt" data-tt="' +
            scoredebug +
            '">';
          optionsHtml += "Score: " + score;
          optionsHtml += "</span>";
        }
      }

      document.getElementById("opOptions").innerHTML = optionsHtml;
      perf.finish();
    }

    _showSuggestionsInfo() {
      if (this._minimal) return;

      const perf = Gui$1.gui.uiProfiler.start("opselect.suggestioninfo");

      let ops = opNames.getOpsForPortLink(
        CABLES.UI.OPSELECT.linkNewOpToPort,
        CABLES.UI.OPSELECT.linkNewLink,
      );
      let vizops = opNames.getVizOpsForPortLink(
        CABLES.UI.OPSELECT.linkNewOpToPort,
        CABLES.UI.OPSELECT.linkNewLink,
      );

      if (
        ops.length == 0 &&
        vizops.length == 0 &&
        !CABLES.UI.OPSELECT.linkNewOpToPort &&
        !CABLES.UI.OPSELECT.linkNewLink
      ) {
        if (this._eleSearchinfo) this._eleSearchinfo.innerHTML = this.tree.html();
        return;
      }

      let html = "nope...";
      html = getHandleBarHtml("op_select_sugggest", {
        ops: ops,
        vizops: vizops,
        link: CABLES.UI.OPSELECT.linkNewLink,
        port: CABLES.UI.OPSELECT.linkNewOpToPort,
      });

      if (this._eleSearchinfo) this._eleSearchinfo.innerHTML = html;

      /*
              var helper buttons / shortcuts

              case 1: pressing circle of an existing link on a "typed value" cable - show create button
              case 2: pressing circle of an existing link on a "typed value" cable - show "existing var" button IF a var by that port type exists already
              case 3: dragging out (or clicking title of) a "typed value" input port - show create button
              case 4: dragging out (or clicking title of) a "typed value" input port - show "existing var" button IF a var by that port type exists already
              case 5: pressing circle of an existing link on a trigger cable - show create button
              case 6: pressing circle of an existing link on a trigger cable - show "use existing" button IF already a triggersend exists
              case 7: dragging out (or clicking title of) a trigger input port - show "receive existing trigger" button IF already a triggersend exists
              case 8: dragging out (or clicking title of) a trigger output port - show "send existing trigger" button IF already a triggersend exists

              [case9]: for now we dont set vars when dragging out an output "typed value"-port because the whole discussion if this should be a triggerVar op or not...
          */
      const link = CABLES.UI.OPSELECT.linkNewLink;
      if (link && link.portIn && link.portIn.type == portType.trigger) {
        ele.show(ele.byId("opselect_createTrigger"));
      } else ele.hide(ele.byId("opselect_createTrigger"));

      if (
        CABLES.UI.OPSELECT.linkNewOpToPort &&
        (CABLES.UI.OPSELECT.linkNewOpToPort.type == portType.number ||
          CABLES.UI.OPSELECT.linkNewOpToPort.type == portType.string ||
          CABLES.UI.OPSELECT.linkNewOpToPort.type == portType.array ||
          CABLES.UI.OPSELECT.linkNewOpToPort.type == portType.object)
      ) {
        ele.show(ele.byId("opselect_createVar"));
      } else ele.hide(ele.byId("opselect_createVar"));

      if (
        link &&
        link.portIn &&
        (link.portIn.type == portType.number ||
          link.portIn.type == portType.string ||
          link.portIn.type == portType.array ||
          link.portIn.type == portType.object)
      ) {
        ele.show(ele.byId("opselect_replaceVar"));
      } else ele.hide(ele.byId("opselect_replaceVar"));

      const eleReplaceLinkWithExistingTrigger = ele.byId(
        "replaceLinkTriggerExists",
      );
      if (link && link.portIn && link.portIn.type == portType.trigger) {
        // show "replace with existing var button..."
        const numExistingTriggers = Object.keys(
          CABLES.patch.namedTriggers || {},
        ).length;

        if (numExistingTriggers == 0) ele.hide(eleReplaceLinkWithExistingTrigger);
        else {
          ele.show(eleReplaceLinkWithExistingTrigger);
        }
      } else ele.hide(eleReplaceLinkWithExistingTrigger);

      // case 7 / 8
      const eleCreateWithExistingTrigger = ele.byId(
        "opselect_createTriggerExists",
      );
      if (
        CABLES.UI.OPSELECT.linkNewOpToPort &&
        CABLES.UI.OPSELECT.linkNewOpToPort.type === portType.trigger
      ) {
        const numExistingTriggers = Object.keys(
          CABLES.patch.namedTriggers || {},
        ).length;

        const inPort =
          CABLES.UI.OPSELECT.linkNewOpToPort.direction === CABLES.Port.DIR_IN;
        const eleTitle = ele.byId("createLinkTriggerExists");
        if (eleTitle) {
          if (inPort) eleTitle.innerText = "Receive from TriggerReceive";
          else eleTitle.innerText = "Send into TriggerSend";
        }

        if (inPort && !numExistingTriggers) {
          ele.hide(eleCreateWithExistingTrigger);
        } else {
          ele.show(eleCreateWithExistingTrigger);
        }
      } else ele.hide(eleCreateWithExistingTrigger);

      const eleCreateWithExistingVar = ele.byId("createLinkVariableExists");
      if (CABLES.UI.OPSELECT.linkNewOpToPort) {
        const existingVars = gui
          .corePatch()
          .getVars(CABLES.UI.OPSELECT.linkNewOpToPort.type);
        if (existingVars.length === 0) ele.hide(eleCreateWithExistingVar);
        else {
          ele.show(eleCreateWithExistingVar);
        }
      } else ele.hide(eleCreateWithExistingVar);

      const eleReplaceWithExistingVar = ele.byId("replaceLinkVariableExists");
      if (link && link.portIn) {
        // show "replace with existing var button..."
        const existingVars = Gui$1.gui.corePatch().getVars(link.portIn.type);
        if (existingVars.length === 0) ele.hide(eleReplaceWithExistingVar);
        else {
          ele.show(eleReplaceWithExistingVar);
        }
      } else ele.hide(eleReplaceWithExistingVar);

      perf.finish();
    }

    updateInfo() {
      if (this._minimal) return;
      this._eleSearchinfo = ele.byId("searchinfo");

      let opName = "";
      const selectedEle = ele.byClass("selected");

      if (selectedEle) {
        opName = selectedEle.dataset.opname;
      }

      this.updateStatusBar(opName);

      if (
        !this._typedSinceOpening &&
        (CABLES.UI.OPSELECT.linkNewOpToPort || CABLES.UI.OPSELECT.linkNewLink)
      ) {
        if (selectedEle) {
          if (CABLES.UI.OPSELECT.linkNewOpToPort) {
            if (
              this._currentInfo ==
              "suggest_" + CABLES.UI.OPSELECT.linkNewOpToPort.op.objName
            )
              return;
            this._currentInfo =
              "suggest_" + CABLES.UI.OPSELECT.linkNewOpToPort.op.objName;
          }

          if (CABLES.UI.OPSELECT.linkNewLink) {
            this._currentInfo = "suggest_" + CABLES.UI.OPSELECT.linkNewLink.id;
          }
        }

        this._showSuggestionsInfo();
      } else if (this._getQuery().length < MIN_CHARS_QUERY) {
        this._eleSearchinfo.innerHTML = this.tree.html();
        return;
      } else if (opName) {
        if (selectedEle) {
          if (this._currentInfo == "docs_" + selectedEle.dataset.opname) return;
          this._currentInfo = "docs_" + selectedEle.dataset.opname;
        }
        const perf = Gui$1.gui.uiProfiler.start("opselect.updateInfo");

        this._eleSearchinfo.innerHTML = "??";
        const listItem = this.getListItemByOpName(opName);
        const opDocHtml = Gui$1.gui.opDocs.getHtml(opName, listItem);

        let html = "";
        if (listItem && listItem.isCollection) {
          html += opDocHtml;
        } else {
          html = '<div id="opselect-layout" class="op">';

          const svg = Gui$1.gui.opDocs.getLayoutSvg(opName);
          if (svg) html += svg;
          else
            html +=
              '<img src="' +
              platform.getCablesUrl() +
              "/api/op/layout/" +
              opName +
              '"/>';

          html += "</div>";
          html +=
            '<a target="_blank" href="' +
            platform.getCablesDocsUrl() +
            "/op/" +
            opName +
            '" class="button-small">View Documentation</a>';

          const docs = Gui$1.gui.opDocs.getOpDocByName(opName);

          if (docs) {
            if (docs.allowEdit) {
              html +=
                '<a class="button-small" onkeypress="ele.keyClick(event,this)" tabindex="0" onclick="CABLES.CMD.OP.manageOp(\'' +
                docs.id +
                '\');Gui.gui.pressedEscape();"><span class="icon icon-op"></span></a>';
              if (platform.frontendOptions.hasOpDirectories && docs.opDirFull)
                html +=
                  '<a class="button-small" onkeypress="ele.keyClick(event,this)" tabindex="0" onclick="CABLES.CMD.ELECTRON.openOpDir(\'\', \'' +
                  opName +
                  '\');Gui.gui.pressedEscape();"><span class="icon icon-folder"></span></a>';
            }

            if (
              docs.coreLibs &&
              docs.coreLibs.indexOf("standalone_electron") > -1
            )
              html +=
                '<br/><br/>this is a <a class="link" href="https://cables.gl/standalone" target="_blank">Standalone</a> op, it will not work fully in the web version.';
          } else html += "no opDocs found";

          html += opDocHtml;
        }
        this._eleSearchinfo.innerHTML = html;
        perf.finish();
      } else {
        this._currentInfo = "tree";

        if (this._getQuery().length < MIN_CHARS_QUERY)
          if (this._eleSearchinfo)
            this._eleSearchinfo.innerHTML = this.tree.html();
      }
    }

    _getMathPortType() {
      if (
        CABLES.UI.OPSELECT.linkNewLink &&
        CABLES.UI.OPSELECT.linkNewLink.portIn &&
        CABLES.UI.OPSELECT.linkNewLink.portIn.type === portType.array
      )
        return "array";
      if (
        CABLES.UI.OPSELECT.linkNewLink &&
        CABLES.UI.OPSELECT.linkNewLink.portIn &&
        CABLES.UI.OPSELECT.linkNewLink.portIn.type === portType.string
      )
        return "string";

      if (
        CABLES.UI.OPSELECT.linkNewOpToPort &&
        CABLES.UI.OPSELECT.linkNewOpToPort.type === portType.array
      )
        return "array";
      if (
        CABLES.UI.OPSELECT.linkNewOpToPort &&
        CABLES.UI.OPSELECT.linkNewOpToPort.type === portType.string
      )
        return "string";
      return "default";
    }

    getSearchQuery() {}

    search() {
      if (!this._opSearch.list || !this._html) this.prepare();

      let sq = this._getQuery();
      let mathPortType = this._getMathPortType();
      for (let i in defaultOps.defaultMathOps[mathPortType])
        if (sq.charAt(0) === i) sq = defaultOps.defaultMathOps[mathPortType][i];

      sq = sq || "";
      let query = sq.toLowerCase();
      this.firstTime = false;

      if (
        this._newOpOptions.linkNewOpToOp &&
        this._newOpOptions.linkNewOpToOp.objName
          .toLowerCase()
          .indexOf(".textureeffects") > -1
      )
        ;

      if (this._getQuery().length < MIN_CHARS_QUERY && !this.isMathQuery())
        this._opSearch.search("");
      else this._opSearch.search(query, sq);

      const perf = Gui$1.gui.uiProfiler.start("opselect.searchLoop");

      for (let i = 0; i < this._opSearch.list.length; i++) {
        this._opSearch.list[i].element =
          this._opSearch.list[i].element ||
          ele.byId("result_" + this._opSearch.list[i].id);

        if (this._opSearch.list[i].score > 0) {
          this._opSearch.list[i].element.dataset.score =
            this._opSearch.list[i].score;
          this._opSearch.list[i].element.dataset.scoreDebug =
            this._opSearch.list[i].scoreDebug;
          this._opSearch.list[i].elementHidden = false;
          ele.show(this._opSearch.list[i].element);
        } else {
          this._opSearch.list[i].element.dataset.score = "0.0";
          this._opSearch.list[i].element.dataset.scoreDebug = "???";
          this._opSearch.list[i].elementHidden = true;
          ele.hide(this._opSearch.list[i].element);
        }
      }

      perf.finish();

      const perfTinysort = Gui$1.gui.uiProfiler.start("opselect.tinysort");
      tinysort.defaults.order = "desc";
      tinysort(".searchresult", { data: "score" });
      perfTinysort.finish();

      this.navigate(0);

      const perf2 = Gui$1.gui.uiProfiler.start("opselect.searchLoop2");

      if (this.itemHeight === 0)
        this.itemHeight = ele
          .byClass("searchresult")
          .getBoundingClientRect().height;

      this.updateStatusBar();
      perf2.finish();
    }

    navigate(diff) {
      const perf2 = Gui$1.gui.uiProfiler.start("opselect.navigate");

      this._typedSinceOpening = true;
      this.displayBoxIndex += diff;

      if (this.displayBoxIndex < 0) this.displayBoxIndex = 0;

      const oBoxCollection = ele.byQueryAll(".searchresult:not(.hidden)");

      if (this.displayBoxIndex >= oBoxCollection.length)
        this.displayBoxIndex = oBoxCollection.length - 1;
      if (this.displayBoxIndex < 0)
        this.displayBoxIndex = oBoxCollection.length - 1;

      const cssClass = "selected";

      for (let i = 0; i < oBoxCollection.length; i++)
        oBoxCollection[i].classList.remove(cssClass);

      if (oBoxCollection[this.displayBoxIndex])
        oBoxCollection[this.displayBoxIndex].classList.add(cssClass);

      const perf3 = Gui$1.gui.uiProfiler.start("opselect.navigate.perf3");
      const scrollTop = (this.displayBoxIndex - 5) * (this.itemHeight + 1);

      if (this._lastScrollTop != scrollTop) {
        this._lastScrollTop = scrollTop;
        if (this.displayBoxIndex > 5)
          ele.byClass("searchbrowser").scrollTop =
            scrollTop; // .scrollTop is expensive!
        else ele.byClass("searchbrowser").scrollTop = 1;
      }
      perf3.finish();

      this.updateInfo();
      perf2.finish();
    }

    reload() {
      this._opSearch.resetList();
      this._html = null;
      this._eleSearchinfo = null;
    }

    prepare() {
      this.tree = new OpTreeList();

      if (!this._opSearch.list) {
        const perf = Gui$1.gui.uiProfiler.start("opselect.prepare.list");
        this._opSearch._buildList();
        perf.finish();
      }

      if (!this._html) {
        const perf = Gui$1.gui.uiProfiler.start("opselect.html");

        const head = getHandleBarHtml("op_select");

        this._eleOpsearchmodal =
          this._eleOpsearchmodal || ele.byId("opsearchmodal");
        this._eleOpsearchmodal.innerHTML = head;

        this._html = getHandleBarHtml("op_select_ops", {
          ops: this._opSearch.list,
          texts: text,
          patchOps: this._opSearch.numPatchops,
        });

        ele.byId("searchbrowserContainer").innerHTML = this._html;
        ele.byId("opsearch").addEventListener("input", this.onInput.bind(this));

        ele.forEachClass("addbutton", (e) => {
          e.addEventListener("click", this._onClickAddButton.bind(this));
        });

        perf.finish();
      }
    }

    _onClickAddButton(evt) {
      this.addOp(
        evt.currentTarget.parentNode.dataset.opname,
        evt.shiftKey,
        evt.currentTarget.parentNode.dataset.itemType,
      );
    }

    isOpen() {
      return this._bg.showing;
    }

    show(options, linkOp, linkPort, link) {
      if (Gui$1.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_FULL) return;
      const perf = Gui$1.gui.uiProfiler.start("opselect.show");

      this._eleSearchinfo = ele.byId("searchinfo");

      if (window.gui) Gui$1.gui.currentModal = this;

      this._typedSinceOpening = false;
      this._lastScrollTop = -5711;
      this._minimal = UserSettings.userSettings.get("miniopselect") == true;

      this._options = options;
      hideToolTip();

      this._enterPressedEarly = false;
      CABLES.UI.OPSELECT.linkNewLink = link;
      CABLES.UI.OPSELECT.linkNewOpToPort = linkPort;
      CABLES.UI.OPSELECT.newOpPos = options;

      this._newOpOptions = {
        subPatch: options.subPatch,
        onOpAdd: options.onOpAdd,
        linkNewOpToPort: linkPort,
        linkNewOpToOp: linkOp,
        linkNewLink: link,
      };

      this._searchInputEle = ele.byId("opsearch");

      if (options.search) this._searchInputEle.value = options.search;

      if (this.firstTime || options.search) this.search();

      if (!this._opSearch.list || !this._html) this.prepare();

      ele.hide(ele.byId("search_noresults"));

      this._bg.show();
      this._bg.on("hide", () => {
        this.close();
      });

      ele.show(this._eleOpsearchmodal);
      this._eleOpsearchmodal.style.zIndex = 9999999;

      if (this._minimal)
        document.getElementsByClassName("opsearch")[0].classList.add("minimal");
      else
        document
          .getElementsByClassName("opsearch")[0]
          .classList.remove("minimal");

      const eleOpsearch = ele.byId("opsearch");

      eleOpsearch.removeEventListener("keydown", this._boundKeydown);
      this._boundKeydown = this.keyDown.bind(this);
      eleOpsearch.addEventListener("keydown", this._boundKeydown);

      this.updateStatusBar();

      setTimeout(() => {
        this.updateInfo();

        perf.finish();

        eleOpsearch.select();
        eleOpsearch.focus();
      }, 50);
    }

    selectOp(name) {
      this._typedSinceOpening = true;

      ele.forEachClass("searchresult", (e) => {
        e.classList.remove("selected");
      });

      const el = ele.byQuery('.searchresult[data-opname="' + name + '"]');
      el.classList.add("selected");

      this.updateInfo();
    }

    searchFor(what) {
      ele.byId("opsearch").value = what;
      this.onInput();
    }

    onInput(e) {
      if (this._keyTimeout) clearTimeout(this._keyTimeout);
      this._typedSinceOpening = true;
      this._searching = true;

      let searchDelay = 0;
      if (this._getQuery().length == 2 && !this.isMathQuery()) searchDelay = 250;
      if (this._getQuery().length == 3) searchDelay = 50;

      this._keyTimeout = setTimeout(() => {
        this._keyTimeout = null;
        this._keyTimeout = null;
        this.displayBoxIndex = 0;
        this.updateInfo();
        this.search();

        this._searching = false;
        if (this._enterPressedEarly) this.addSelectedOp();
      }, searchDelay);
    }

    addOp(opname, reopenModal = false, itemType = "op") {
      this._newOpOptions.onOpAdd = null;

      const sq = this._getQuery();
      const mathPortType = this._getMathPortType();

      for (let i in defaultOps.defaultMathOps[mathPortType]) {
        if (sq.charAt(0) === i) {
          let mathNum = parseFloat(sq.substr(1));
          if (mathPortType == "string") mathNum = sq.substr(1);

          this._newOpOptions.onOpAdd = (op) => {
            if (op.portsIn.length > 1 && mathNum == mathNum) {
              op.portsIn[1].set(mathNum);
            }
            op.refreshParams();
          };
        }
      }

      if (opname && opname.length > 2) {
        this._newOpOptions.createdLocally = true;

        if (itemType === "extension" || itemType === "team") {
          Gui$1.gui.opSelect().loadCollection(opname);
        } else if (itemType === "patchop") {
          Gui$1.gui.opSelect().addPatchOp(opname, reopenModal);
        } else {
          if (reopenModal) {
            setTimeout(() => {
              Gui$1.gui.opSelect().show({
                subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
                x: 0,
                y: 0,
              });
            }, 50);
          }

          this.close();
          Gui$1.gui.patchView.addOp(opname, this._newOpOptions);
        }
      }
    }

    loadCollection(name) {
      Gui$1.gui.serverOps.loadCollectionOps(name, () => {
        const q = this._getQuery();
        this.close();
        this.reload();
        this.prepare();
        setTimeout(() => {
          const opts = this._options;

          opts.search = q;
          opts.subPatch = Gui$1.gui.patchView.getCurrentSubPatch();
          this.show(
            opts,
            this._newOpOptions.linkNewOpToOp,
            this._newOpOptions.linkNewOpToPort,
            this._newOpOptions.linkNewLink,
          );
        }, 50);
      });
    }

    addPatchOp(name, reopenModal) {
      Gui$1.gui.serverOps.loadOpDependencies(name, () => {
        if (reopenModal) {
          setTimeout(() => {
            const opts = this._options;
            opts.search = name;
            opts.subPatch = Gui$1.gui.patchView.getCurrentSubPatch();
            this.show(
              opts,
              this._newOpOptions.linkNewOpToOp,
              this._newOpOptions.linkNewOpToPort,
              this._newOpOptions.linkNewLink,
            );
          }, 50);
        }

        this.close();
        Gui$1.gui.patchView.addOp(name, this._newOpOptions);
      });
    }

    addSelectedOp(reopenModal) {
      const selEle = ele.byClass("selected");
      if (selEle) {
        const opname = selEle.dataset.opname;
        const listItem = this.getListItemByOpName(opname);
        // prevent adding of ops that are not usable

        // if (sq.charAt(0) === i)
        //     sq = defaultOps.defaultMathOps[i]+" "+sq.substr(1);

        if (!(listItem && listItem.notUsable)) {
          this.addOp(opname, reopenModal, selEle.dataset.itemType);
        }
      }
    }

    keyDown(e) {
      const eleSelected = ele.byClass("selected");

      switch (e.which) {
        case 13:
          if (e.shiftKey) {
            this.addSelectedOp(true);
            return;
          }

          if (this._searching) {
            this._enterPressedEarly = true;
            return;
          } else {
            this.addSelectedOp();
          }

          e.preventDefault();
          break;

        case 8:
          this.onInput();
          return true;

        case 38: // up
          if (eleSelected) eleSelected.classList.remove("selected");
          e.preventDefault();
          this.navigate(-1);
          break;

        case 40: // down
          if (eleSelected) eleSelected.classList.remove("selected");
          e.preventDefault();
          this.navigate(1);
          break;

        default:
          return true; // exit this handler for other keys
      }
      // prevent the default action (scroll / move caret)
    }

    getListItemByOpName(opName) {
      if (!this._opSearch.list) return null;
      return this._opSearch.list.find((item) => {
        return item.name === opName;
      });
    }
  }

  /**
   * info bar at the bottom of the window, showing context sensitive shortcuts etc.
   *
   * @export
   * @class BottomInfoAreaBar
   * @extends {Events}
   */
  class BottomInfoAreaBar extends Events {
    constructor() {
      super();
      this.showing = true;
      this._SETTINGS_NAME = "closeInfoArea2";
      this.hidden = false;
      this._eleInfoArea = ele.byId("infoArea");
      this._eleInfoAreaParam = ele.byId("infoAreaParam");

      if (!UserSettings.userSettings.get(this._SETTINGS_NAME)) this.openInfo();
      else this.closeInfo();

      this.updateStyles();
    }

    getHeight() {
      if (this.hidden) return 0;
      if (this.showing) return uiConfig.infoAreaHeight;
      else return 0;
    }

    updateStyles() {
      this._eleInfoAreaParam.classList.add("hidden");

      if (this.showing) {
        ele.byQuery("#infoAreaToggle span").classList.add("icon-chevron-down");
        ele.byQuery("#infoAreaToggle span").classList.remove("icon-help");
      } else {
        ele.byQuery("#infoAreaToggle span").classList.remove("icon-chevron-down");
        ele.byQuery("#infoAreaToggle span").classList.add("icon-help");
      }
    }

    toggle() {
      if (UserSettings.userSettings.get(this._SETTINGS_NAME)) this.openInfo();
      else this.closeInfo();

      this.updateStyles();
    }

    openInfo() {
      UserSettings.userSettings.set(this._SETTINGS_NAME, false);
      const wasShowing = this.showing;

      this.showing = true;
      if (wasShowing != this.showing) this.emitEvent("changed");
    }

    closeInfo() {
      UserSettings.userSettings.set(this._SETTINGS_NAME, true);
      const wasShowing = this.showing;
      this.showing = false;
      if (wasShowing != this.showing) this.emitEvent("changed");
    }

    replaceShortcuts(txt) {
      txt = marked.parse(txt || "");

      txt = txt.replaceAll(
        "[DRAG_LMB]",
        '<span class="icon icon-mouse_lmb_drag"></span>',
      );
      txt = txt.replaceAll(
        "[DRAG_RMB]",
        '<span class="icon icon-mouse_rmb_drag"></span>',
      );
      txt = txt.replaceAll(
        "[DRAG_MMB]",
        '<span class="icon icon-mouse_mmb_drag"></span>',
      );
      txt = txt.replaceAll("[RMB]", '<span class="icon icon-mouse_rmb"></span>');
      txt = txt.replaceAll("[LMB]", '<span class="icon icon-mouse_lmb"></span>');
      txt = txt.replaceAll("[MMB]", '<span class="icon icon-mouse_mmb"></span>');
      txt = txt.replaceAll("[MW]", '<span class="icon icon-mouse_wheel"></span>');

      txt = txt.replaceAll("[updown]", '<span class="key_updown"></span>');

      txt = txt.replaceAll("[up]", '<span class="key_up"></span>');
      txt = txt.replaceAll("[down]", '<span class="key_down"></span>');
      txt = txt.replaceAll("[left]", '<span class="key_left"></span>');
      txt = txt.replaceAll("[right]", '<span class="key_right"></span>');

      txt = txt.replaceAll("[shift]", '<span class="key">shift</span>');
      txt = txt.replaceAll("[enter]", '<span class="key">enter</span>');

      if (navigator.appVersion.indexOf("Mac") != -1) {
        txt = txt.replaceAll("[cmd_ctrl]", '<span class="key key_cmd"></span>');
        txt = txt.replaceAll("[alt]", '<span class="key key_option"></span>');
      } else {
        txt = txt.replaceAll("[cmd_ctrl]", '<span class="key">CTRL</span>');
        txt = txt.replaceAll("[alt]", '<span class="key">ALT</span>');
      }

      return txt;
    }

    setVisible(v) {
      const eleContainer = ele.byId("infoAreaContainer");
      if (!eleContainer) return;

      this.hidden = !v;

      if (v) ele.show(this._eleInfoArea);
      else ele.hide(this._eleInfoArea);
    }

    setContentParam(txt) {
      if (!txt) return;
      if (this.showing) {
        this._eleInfoAreaParam.classList.remove("hidden");
        this._eleInfoAreaParam.innerHTML =
          '<div class="infoareaContent">&nbsp;&nbsp;' + txt + "</div>";
      }
    }

    setContent(txt) {
      this._eleInfoAreaParam.classList.add("hidden");
      txt = txt || text.infoArea || "";

      if (this._txt == txt) return;

      this._txt = txt;
      txt = txt.replaceAll("||", "\n\n* ");
      txt = this.replaceShortcuts(txt);

      this._eleInfoArea.classList.remove("hidden");
      this._eleInfoArea.innerHTML =
        '<div class="infoareaContent"> ' + txt + "</div>";
    }

    hoverInfoEle(e) {
      let key = e.target.dataset.info;
      let txt = key;
      if (text[key]) txt = text[key];

      if (e.target.dataset.info && !txt) {
        this._log.warn("element has info class but no info data", key, e.target);
      }

      this.setContent(txt);
    }
  }

  class TransformsIcon {
    constructor(cgl, id) {
      this._cgl = cgl;
      this._pos = vec3.create();
      this._screenPos = vec2.create();
      this._id = id;
      this.lastUpdate = performance.now();

      if (!cgl || !cgl.canvas) return;
      const container = cgl.canvas.parentElement;
      this._eleCenter = document.createElement("div");

      this._eleCenter.classList.add("transformSpot");
      container.appendChild(this._eleCenter);

      this._eleCenter.addEventListener("click", () => {
        Gui$1.gui.transformOverlay.click(this._screenPos);
      });
    }

    get id() {
      return this._id;
    }

    get screenPos() {
      return this._screenPos;
    }

    update() {
      this.lastUpdate = performance.now();
      this._updateScreenPos();
      if (this._eleCenter) {
        this._eleCenter.style.left = this._screenPos[0] + "px";
        this._eleCenter.style.top = this._screenPos[1] + "px";
      }
    }

    setPos(x, y, z) {
      vec3.set(this._pos, x, y, z);
      this.update();
    }

    _updateScreenPos() {
      if (!this._cgl) return;
      this._cgl.pushModelMatrix();

      const m = mat4.create();
      const pos = vec3.create();
      const emptyvec3 = vec3.create();
      const trans = vec3.create();

      mat4.translate(this._cgl.mvMatrix, this._cgl.mMatrix, this._pos);
      mat4.multiply(m, this._cgl.vMatrix, this._cgl.mMatrix);

      vec3.transformMat4(pos, emptyvec3, m);
      vec3.transformMat4(trans, pos, this._cgl.pMatrix);

      this._cgl.popModelMatrix();

      if (pos[2] > 0) {
        this._screenPos[0] = -3e3;
      } else {
        const vp = this._cgl.getViewPort();
        const x = vp[2] - (vp[2] * 0.5 - (trans[0] * vp[2] * 0.5) / trans[2]);
        const y = vp[3] - (vp[3] * 0.5 + (trans[1] * vp[3] * 0.5) / trans[2]);

        this._screenPos[0] = x / this._cgl.pixelDensity;
        this._screenPos[1] = y / this._cgl.pixelDensity;
      }
    }

    dispose() {
      if (this._eleCenter) this._eleCenter.remove();
    }
  }

  class TransformsOverlay {
    constructor() {
      this._transforms = {};
      this._lastCheck = 0;

      setInterval(this._cleanUp.bind(this), 2000);
    }

    _cleanUp(diff) {
      if (!gui || Gui$1.gui.isRemoteClient) return;

      diff = diff || 500;
      for (const i in this._transforms) {
        if (performance.now() - this._transforms[i].lastUpdate > diff) {
          this._transforms[i].dispose();
          delete this._transforms[i];
        }
      }
    }

    click(screenPos) {
      const activateTransform = (op, id) => {
        this._lastClicked = id;
        Gui$1.gui.patchView.setCurrentSubPatch(op.uiAttribs.subPatch || 0);
        Gui$1.gui.patchView.centerSelectOp(id);
        Gui$1.gui.opParams.show(id);
        Gui$1.gui.patchView.focus();
      };

      let found = [];
      let foundIds = [];

      for (const i in this._transforms)
        if (
          Math.abs(this._transforms[i].screenPos[0] - screenPos[0] < 10) &&
          Math.abs(this._transforms[i].screenPos[1] - screenPos[1]) < 10
        ) {
          found.push(i);
          foundIds.push(this._transforms[i].id);
        }

      if (found.length == 0) return;

      let i = 0;
      if (foundIds.indexOf(this._lastClicked) > -1)
        i = foundIds.indexOf(this._lastClicked) + 1;
      if (i == -1) i = 0;
      if (i > found.length - 1) i = 0;

      const trans = this._transforms[found[i]];
      const op = Gui$1.gui.corePatch().getOpById(trans.id);

      activateTransform(op, trans.id);
    }

    /**
     * Description
     * @param {CgContext|CglContext} cgl
     * @param {string} id
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    add(cgl, id, x, y, z) {
      if (Gui$1.gui.isRemoteClient) return;
      this._transforms[id] = this._transforms[id] || new TransformsIcon(cgl, id);
      this._transforms[id].setPos(x, y, z);

      if (performance.now() - this._lastCheck > 50) {
        this._cleanUp(100);

        this._lastCheck = performance.now();
      }
    }

    updateVisibility() {
      this.setVisible(Gui$1.gui.shouldDrawOverlay);
    }

    setVisible(b) {
      if (!b)
        for (const i in this._transforms) {
          this._transforms[i].dispose();
          delete this._transforms[i];
        }
    }
  }

  /**
   * the maintabpanel on the left side of the patchfield, can be minimized
   *
   * @export
   * @class MainTabPanel
   * @extends {Events}
   */
  class MainTabPanel extends Events {
    /**
     * @param {TabPanel} tabs
     */
    constructor(tabs) {
      super();

      /** @type {TabPanel} */
      this._tabs = tabs;
      this._tabs.showTabListButton = true;
      this._visible = false;
      this._ele = document.getElementById("maintabs");
      this._ele.style.display = "none";

      this._tabs.on("onTabAdded", (tab, existedBefore) => {
        const wasVisible = this._visible;
        if (!existedBefore) this.show();

        tabs.activateTab("");
        tabs.activateTab(tab.id);

        if (!wasVisible && window.gui) Gui$1.gui.setLayout();
      });

      this._tabs.on("onTabRemoved", (tab) => {
        if (this._tabs.getNumTabs() == 0) {
          this.hide();
          Gui$1.gui.setLayout();
        }
      });
    }

    get tabs() {
      return this._tabs;
    }

    init() {
      const showMainTabs = UserSettings.userSettings.get("maintabsVisible");
      if (showMainTabs) this.show();
      else this.hide(true);
    }

    isVisible() {
      return this._visible;
    }

    /**
     * @param {boolean} userInteraction
     */
    show(userInteraction = false) {
      if (this._tabs.getNumTabs() == 0) {
        this.hide(true);
        return;
      }

      if (!userInteraction) {
        if (!UserSettings.userSettings.get("maintabsVisible")) {
          return;
        }
      }

      this._visible = true;
      this._ele.style.display = "block";
      document.getElementById("editorminimized").style.display = "none";

      if (Gui$1.gui.finishedLoading() && userInteraction)
        UserSettings.userSettings.set("maintabsVisible", true);

      Gui$1.gui.setLayout();

      this._tabs.updateSize();
      if (this._tabs.getActiveTab()) this._tabs.getActiveTab().activate();
    }

    /**
     * @param {boolean} donotsave
     */
    hide(donotsave = false) {
      this._visible = false;
      document.getElementById("editorminimized").style.display = "block";
      this._ele.style.display = "none";
      if (window.gui) Gui$1.gui.setLayout();

      if (!donotsave && Gui$1.gui.finishedLoading())
        UserSettings.userSettings.set("maintabsVisible", false);
    }

    /**
     * @param {boolean} userInteraction
     */
    toggle(userInteraction = false) {
      if (!Gui$1.gui.finishedLoading()) return;
      if (this._visible) {
        this.hide();
        Gui$1.gui.patchView.focus();
        const actTab = this.tabs.getActiveTab();
        if (actTab) actTab.activate();
      } else this.show(userInteraction);
    }
  }

  /**
   * manage keybindings for hotkeys/shortcuts
   *
   * @export
   * @class KeyBindingsManager
   * @extends {Events}
   */
  class KeyBindingsManager extends Events {
    constructor() {
      super();
      this._log = new Logger("KeyBindingsManager");
      this._keys = [];
      this.shiftKey = false;
      document.addEventListener("keydown", this._onKeyDown.bind(this), false);
      document.addEventListener("keyup", this._onKeyUp.bind(this), false);
      document.addEventListener("keypress", this._onKeyPress.bind(this), false);
    }

    show() {
      this._tab = new CABLES.UI.Tab("keyboard shortcuts", {
        icon: "help",
        infotext: "tab_keys",
        padding: true,
        singleton: true,
      });
      Gui$1.gui.mainTabs.addTab(this._tab, true);

      const k = this._prepareKeysForDisplay(this._keys);

      let showDownloadButton = false;
      if (gui && Gui$1.gui.user && (Gui$1.gui.user.isStaff || Gui$1.gui.user.isAdmin))
        showDownloadButton = true;

      const html = getHandleBarHtml("tab_keys", {
        keys: k,
        showDownloadButton: showDownloadButton,
      });
      this._tab.html(html);

      Gui$1.gui.maintabPanel.show(true);
    }

    download() {
      const k = this._prepareKeysForDisplay(this._keys);

      const markdown = getHandleBarHtml("tab_keys_markdown", { keys: k });

      let element = document.createElement("a");
      element.setAttribute(
        "href",
        "data:text/plain;charset=utf-8," + encodeURIComponent(markdown),
      );
      element.setAttribute("download", "keys.md");
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }

    _prepareKeysForDisplay(keys) {
      let k = JSON.parse(JSON.stringify(keys));

      k.sort(function (a, b) {
        return a.key.localeCompare(b.key);
      });

      k.sort(function (a, b) {
        if (!a.target) a.target = "global";
        if (!b.target) b.target = "global";
        return a.target.localeCompare(b.target);
      });

      // remove double entries
      let lastCombined = "";
      let lines = [];
      for (let i = 0; i < k.length; i++) {
        let combined =
          k[i].title + k[i].key + k[i].options.shiftKey + k[i].options.cmdCtrl;
        if (combined != lastCombined) lines.push(k[i]);
        lastCombined = combined;
      }

      let lastTarget = "";
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].target != lastTarget) {
          const group = lines[i].options.displayGroup
            ? lines[i].options.displayGroup
            : lines[i].target;
          lines[i].group = group;
        }
        lastTarget = lines[i].target;

        if (lines[i].key == " ") lines[i].key = "Space";
      }
      lines = lines.filter((key) => {
        return key.title !== "";
      });
      return lines;
    }

    _onKeyUp(e) {
      this.shiftKey = false;
      for (let i = 0; i < this._keys.length; i++) {
        const k = this._keys[i];

        if (
          !k.options.ignoreInput &&
          document.activeElement &&
          (document.activeElement.tagName == "INPUT" ||
            document.activeElement.tagName == "TEXTAREA")
        )
          continue;

        if (k.key != (e.key + "").toLowerCase() || k.event != "up") continue;

        if (!k.options.ctrlKey) {
          if (k.options.cmdCtrl) if (!e.ctrlKey && !e.metaKey) continue;
          if (!k.options.cmdCtrl) if (e.ctrlKey || e.metaKey) continue;
        }
        if (k.options.shiftKey && !e.shiftKey) continue;
        if (!k.options.shiftKey && e.shiftKey) continue;
        if (!k.options.ctrlKey && e.ctrlKey) continue;

        if (!k.target || k.target == e.target.id) {
          if (k.options.minRestriction > window.Gui.gui.getRestriction()) {
            notifyError("Not allowed");
            if (!e.dontPreventDefault) e.preventDefault();

            continue;
          }

          if (k.cb) k.cb(e);
          else this._log.warn("[keys] key event has no callback", k);

          if (!e.dontPreventDefault) e.preventDefault();

          // return;
        }
      }
    }

    _onKeyPress(e) {}

    _onKeyDown(e) {
      this.shiftKey = e.shiftKey || e.keyCode == 16;

      for (let i = 0; i < this._keys.length; i++) {
        const k = this._keys[i];

        if (k.key != (e.key + "").toLowerCase() || k.event != "down") continue;

        if (!k.options.ctrlKey) {
          if (k.options.cmdCtrl) if (!e.ctrlKey && !e.metaKey) continue;
          if (!k.options.cmdCtrl) if (e.ctrlKey || e.metaKey) continue;
        }
        if (k.options.shiftKey && !e.shiftKey) continue;
        if (k.options.altKey && !e.altKey) continue;
        if (!k.options.shiftKey && e.shiftKey) continue;
        if (k.options.minRestriction > window.Gui.gui.getRestriction()) continue;

        if (!k.target || k.target == e.target.id) {
          if (
            k.options.ignoreInput &&
            document.activeElement &&
            (document.activeElement.tagName == "INPUT" ||
              document.activeElement.tagName == "TEXTAREA")
          )
            continue;

          // Gui.gui.log.userInteraction("pressed " + e.key);

          if (k.cb) k.cb(e);
          else this._log.warn("[keys] key event has no callback", k);

          if (!e.dontPreventDefault) e.preventDefault();

          // return;
        }
      }
    }

    _addKey(key, title, event, target, options, cb) {
      const k = {
        key: key.toLowerCase(),
        title: title,
        event: event,
        target: target,
        options: options,
        cb: cb,
      };

      this._keys.push(k);
    }

    key(key, title, event, target, options, cb) {
      options = options || {};
      if (!options.hasOwnProperty("minRestriction"))
        options.minRestriction = Gui$1.gui.RESTRICT_MODE_FULL;

      if (Array.isArray(key))
        for (let i = 0; i < key.length; i++)
          this._addKey(key[i], title, event, target, options, cb);
      else this._addKey(key, title, event, target, options, cb);
    }
  }

  class ModalPortValue {
    constructor() {
      this._log = new Logger("ModalPortValue");
      this._port = null;
    }

    showJsonStructure(opid, which) {
      const op = Gui$1.gui.corePatch().getOpById(opid);
      if (!op) {
        this._log.warn("opid not found:", opid);
        return;
      }
      const port = op.getPort(which);
      if (!port) {
        this._log.warn("port not found:", which);
        return;
      }

      this._port = port;
      const modal = new ModalDialog({});
      this._showPortStructure(port.name, modal, port);
    }

    _showPortStructure(title, modal, port) {
      function asyncInnerHTML(HTML, callback) {
        const container = document.createElement("div");
        const temp = document.createElement("div");
        const frag = document.createElement("template");
        temp.innerHTML = HTML;
        const _innerHTML = function () {
          if (temp.firstChild) {
            frag.appendChild(temp.firstChild);
            setTimeout(_innerHTML, 0);
          } else {
            const fragmentElms = [...frag.children];
            fragmentElms.forEach((elm) => {
              container.appendChild(elm);
            });
            callback(container, frag);
          }
        };
        _innerHTML();
      }

      function printNode(
        op,
        portName,
        html,
        key,
        node,
        path,
        level,
        inputDataType = "Object",
      ) {
        html += '<tr class="row">';
        let i = 0;
        let ident = "";

        for (i = 0; i < level; i++) {
          let identClass = "identBg";
          if (i == 0) identClass = "identBgLevel0";
          ident +=
            '<td class="ident  ' + identClass + '" ><div style=""></div></td>';
        }
        html += ident;
        html += '<td colspan="' + (20 - level) + '">';
        if (Array.isArray(node)) {
          html += '<span class="icon icon-arrow-down-right">[]</span> &nbsp;';
        } else if (typeof node === "object") {
          html += '<span class="icon icon-arrow-down-right">[]</span> &nbsp;';
        } else {
          html += '<span class="icon icon-circle">[]</span> &nbsp;';
        }
        html += key;
        html += "</td>";

        html +=
          "<td style='max-width: 100px; overflow: hidden; text-overflow: ellipsis;'>";
        if (!Array.isArray(node) && !(typeof node === "object")) {
          html += String(node)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
        }
        html += "</td>";

        html += "<td>";

        let dataType = "Array";
        if (!Array.isArray(node)) {
          switch (typeof node) {
            case "string":
              dataType = "String";
              break;
            case "number":
              dataType = "Number";
              break;
            default:
              dataType = "Object";
              break;
          }
        }
        html +=
          "<a onclick=\"Gui.gui.opPortModal.structureHelper_exposeArray('" +
          op.id +
          "', '" +
          portName +
          "', '" +
          path +
          "', '" +
          inputDataType +
          '\')" class="treebutton">Array</a>';
        html += "&nbsp;";
        html +=
          "<a onclick=\"Gui.gui.opPortModal.structureHelper_exposeNode('" +
          op.id +
          "', '" +
          portName +
          "', '" +
          path +
          "', '" +
          dataType +
          "', '" +
          inputDataType +
          '\')" class="treebutton ' +
          dataType.toLowerCase() +
          '">' +
          dataType +
          "</a>";
        html += "</td>";

        html += "</tr>";

        if (node) {
          if (Array.isArray(node)) {
            for (i = 0; i < node.length; i++) {
              const newPath = path + "." + i;
              html = printNode(
                op,
                portName,
                html,
                i,
                node[i],
                newPath,
                level + 1,
                inputDataType,
              );
            }
          } else if (typeof node === "object") {
            const children = Object.keys(node);
            for (i = 0; i < children.length; i++) {
              const newKey = children[i];
              const newPath = path + "." + newKey;
              html = printNode(
                op,
                portName,
                html,
                newKey,
                node[newKey],
                newPath,
                level + 1,
                inputDataType,
              );
            }
          }
        }

        return html;
      }

      function printJsonInfo(json, op, portName, inputDataType = "Object") {
        if (!json) return;

        let html = '<div style="overflow:scroll;width:100%;height:100%">';

        let elements = [];
        if (Array.isArray(json)) {
          elements = json;
        } else if (typeof json === "object") {
          elements = Object.keys(json);
        }

        html += "<h3>Nodes (" + elements.length + ")</h3>";
        html += '<table class="table treetable">';

        html += "<tr>";
        html += ' <th colspan="20">Name</th>';
        html += " <th>Value</th>";
        html += " <th>Expose</th>";
        html += "</tr>";

        for (let i = 0; i < elements.length; i++) {
          if (Array.isArray(json)) {
            const path = i;
            html = printNode(
              op,
              portName,
              html,
              i,
              json[i],
              path,
              1,
              inputDataType,
            );
          } else if (typeof json === "object") {
            const key = elements[i];
            const path = key;
            html = printNode(
              op,
              portName,
              html,
              key,
              json[key],
              path,
              1,
              inputDataType,
            );
          }
        }
        html += "</table>";
        html += "</div>";

        return html;
      }

      try {
        const thing = this._port.get();
        let inputDataType = "Object";
        if (Array.isArray(thing)) {
          inputDataType = "Array";
        }
        const jsonInfo = printJsonInfo(thing, port.op, port.name, inputDataType);

        let fullHTML = "";
        fullHTML +=
          '<h2 class="splitter"><span class="icon icon-settings"></span>&nbsp;Structure</h2>';
        fullHTML += "port: <b>" + title + "</b> of <b>" + port.op.name + "</b> ";
        fullHTML += "<br/><br/>";
        fullHTML +=
          '<a class="button " onclick="Gui.gui.opPortModal.updatePortStructurePreview(\'' +
          title +
          '\')"><span class="icon icon-refresh"></span>Update</a>';
        fullHTML += "<br/><br/>";
        fullHTML += "<br/><br/>";
        fullHTML +=
          '<pre id="portvalue" class="code hljs json">' + jsonInfo + "</pre>";

        asyncInnerHTML(fullHTML, function (html, fragment) {
          modal.updateHtml(html.innerHTML);
        });
      } catch (ex) {
        let fullHTML = "";
        fullHTML +=
          '<h2><span class="splitter icon icon-settings"></span>&nbsp;Structure</h2>';
        fullHTML += "port: <b>" + title + "</b> of <b>" + port.op.name + "</b> ";
        fullHTML += "<br/><br/>";
        fullHTML +=
          '<pre><code id="portvalue" class="code hljs json">Unable to serialize Array/Object:<br/>' +
          ex.message +
          "</code></pre>";

        modal.updateHtml(fullHTML);
      }
    }

    updatePortValuePreview(title) {
      this._showPortValue(title);
    }

    updatePortStructurePreview(title) {
      this._showPortStructure(title, Gui$1.gui.currentModal, this._port);
    }

    structureHelper_exposeNode(
      opId,
      portName,
      path,
      dataType,
      inputDataType = "Object",
    ) {
      const jsonDataOpName =
        defaultOps.jsonPathOps[inputDataType + "Get" + dataType];
      if (!jsonDataOpName) return;
      const op = Gui$1.gui.corePatch().getOpById(opId);
      Gui$1.gui.patchView.addOp(jsonDataOpName, {
        subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
        onOpAdd: (newop) => {
          newop.setUiAttrib({
            translate: {
              x: op.uiAttribs.translate.x,
              y: op.uiAttribs.translate.y + gluiconfig.newOpDistanceY,
            },
          });

          newop.getPort("Path").set(path);
          op.patch.link(op, portName, newop, inputDataType);
          Gui$1.gui.patchView.centerSelectOp(newop.id);
          Gui$1.gui.closeModal();
        },
      });
    }

    structureHelper_exposeArray(opId, portName, path, inputDataType = "Object") {
      const jsonDataOpName =
        defaultOps.jsonPathOps[inputDataType + "GetArrayValues"];
      if (!jsonDataOpName) return;

      const op = Gui$1.gui.corePatch().getOpById(opId);
      const newop = Gui$1.gui.corePatch().addOp(jsonDataOpName);

      newop.setUiAttrib({
        translate: {
          x: op.uiAttribs.translate.x,
          y: op.uiAttribs.translate.y + gluiconfig.newOpDistanceY,
        },
      });

      newop.getPort("Path").set(path);
      op.patch.link(op, portName, newop, inputDataType);
      Gui$1.gui.patchView.centerSelectOp(newop.id);
      Gui$1.gui.closeModal();
    }
  }

  var srcShaderFragment = `IN vec2 texCoord;
UNI sampler2D tex;
UNI samplerCube cubeMap;
UNI float width;
UNI float height;
UNI float type;
UNI float time;

// float checkerboard()
// {
//     float num=40.0;
//     float h=(height/width)*num;
//     float total = floor(texCoord.x*num) +floor(texCoord.y*h);
//     return mod(total,2.0)*0.1+0.05;
// }
float LinearizeDepth(float d,float zNear,float zFar)
{
    float z_n = 2.0 * d - 1.0;
    return 2.0 * zNear / (zFar + zNear - z_n * (zFar - zNear));
}

void main()
{
    vec4 col=vec4(0.0);
    vec4 colTex=texture2D(tex,texCoord);


    if(type==1.0)
    {
        vec4 depth=vec4(0.);
        vec2 localST=texCoord;
        localST.y = 1. - localST.y;
    //         //Scale Tex coordinates such that each quad has local coordinates from 0,0 to 1,1
        localST.t = mod(localST.t*3.,1.);
        localST.s = mod(localST.s*4.,1.);

        #ifdef WEBGL2
            #define texCube texture
        #endif
        #ifdef WEBGL1
            #define texCube textureCube
        #endif


    //         //Due to the way my depth-cubeMap is rendered, objects to the -x,y,z side is projected to the positive x,y,z side
    //         //Inside where top/bottom is to be drawn?
        if (texCoord.s*4.> 1. && texCoord.s*4.<2.)
        {
            //Bottom (-y) quad
            if (texCoord.t*3. < 1.)
            {
                vec3 dir=vec3(localST.s*2.-1.,-1.,-localST.t*2.+1.);//Due to the (arbitrary) way I choose as up in my depth-viewmatrix, i her emultiply the latter coordinate with -1
                depth = texCube(cubeMap, dir);
            }
            //top (+y) quad
            else if (texCoord.t*3. > 2.)
            {
                vec3 dir=vec3(localST.s*2.-1.,1.,localST.t*2.-1.);//Get lower y texture, which is projected to the +y part of my cubeMap
                depth = texCube(cubeMap, dir);
            }
            else//Front (-z) quad
            {
                vec3 dir=vec3(localST.s*2.-1.,-localST.t*2.+1.,1.);
                depth = texCube(cubeMap, dir);
            }
        }
    //         //If not, only these ranges should be drawn
        else if (texCoord.t*3. > 1. && texCoord.t*3. < 2.)
        {
            if (texCoord.x*4. < 1.)//left (-x) quad
            {
                vec3 dir=vec3(-1.,-localST.t*2.+1.,localST.s*2.-1.);
                depth = texCube(cubeMap, dir);
            }
            else if (texCoord.x*4. < 3.)//right (+x) quad (front was done above)
            {
                vec3 dir=vec3(1,-localST.t*2.+1.,-localST.s*2.+1.);
                depth = texCube(cubeMap, dir);
            }
            else //back (+z) quad
            {
                vec3 dir=vec3(-localST.s*2.+1.,-localST.t*2.+1.,-1.);
                depth = texCube(cubeMap, dir);
            }
        }
        colTex = vec4(vec3(depth),1.);
    }


    if(colTex.r>1.0||colTex.g>1.0||colTex.b>1.0)
    {
        float r=mod( (time*2.0)+(texCoord.x+texCoord.y)*10.0,0.5)+0.5;
        colTex=vec4( 1.0,r,r,1.0);
    }
    if(colTex.r<0.0||colTex.g<0.0||colTex.b<0.0)
    {
        float r=mod( (time*2.0)+(texCoord.x+texCoord.y)*10.0,0.5);
        colTex=vec4( r,0.0,0.0,1.0);
    }

    if(type==2.0)
    {
       float near = 0.1;
       float far = 50.;
       float depth = LinearizeDepth(colTex.r, near, far);
       colTex = vec4(depth,depth,depth,1.0);
    }

    outColor = mix(col,colTex,colTex.a);
}
`;

  var srcShaderVertex = `IN vec3 vPosition;
IN vec2 attrTexCoord;
OUT vec2 texCoord;
UNI mat4 projMatrix;
UNI mat4 modelMatrix;
UNI mat4 viewMatrix;

void main()
{
    texCoord=attrTexCoord;
    vec4 pos = vec4( vPosition, 1. );
    mat4 mvMatrix=viewMatrix * modelMatrix;
    gl_Position = projMatrix * mvMatrix * pos;
}
`;

  const MODE_CORNER = 0;
  const MODE_HOVER = 1;

  /**
   * texturepreview floating over the patchfield
   *
   * @export
   * @class TexturePreviewer
   */
  class TexturePreviewer {
    constructor() {
      this._log = new Logger();

      this._texturePorts = [];
      this._showing = false;
      this._lastTimeActivity = 0;
      this._mode =
        UserSettings.userSettings.get("texpreviewMode") == "corner"
          ? MODE_CORNER
          : MODE_HOVER;
      this._paused = false;
      this._shader = null;
      this._shaderTexUniform = null;
      this._tempTexturePort = null;
      this._hoveringTexPort = false;
      this._listeningFrame = false;
      this._emptyCubemap = null;
      this._timer = new CABLES.Timer();
      this._timer.play();
      this._currentHeight = -1;
      this._currentWidth = -1;
      this._lastClicked = null;
      this.scale = 0.2;

      this._ele = document.getElementById("bgpreview");
      this.setSize();

      UserSettings.userSettings.on("change", (key, v) => {
        if (key == "texpreviewTransparent") this.setSize();
        if (key == "texpreviewSize")
          this.setSize(UserSettings.userSettings.get(key));
        if (key == "bgpreviewMax") this.enableBgPreview();
      });

      this._initListener();
      this.enableBgPreview();

      if (this._mode == MODE_HOVER) {
        this._enabled = false;
        ele.byId("bgpreviewButtonsContainer").classList.add("hidden");
        ele.byId("bgpreview").classList.add("hidden");
      }
    }

    _initListener() {
      if (!window.gui) {
        setTimeout(this._initListener.bind(this), 300);
        return;
      }

      if (this._mode == MODE_HOVER) {
        Gui$1.gui.on("portHovered", (port) => {
          if (port && port.get() && port.get().tex) {
            this._enabled = true;
            this.selectTexturePort(port);

            clearTimeout(this._hoverTimeout);
            this._hoverTimeout = setTimeout(() => {
              this._enabled = false;
            }, 50);
          }
        });
      }

      if (this._mode == MODE_CORNER) {
        Gui$1.gui.opParams.on("opSelected", () => {
          if (!Gui$1.gui.opParams.op) return;
          const ports = Gui$1.gui.opParams.op.portsOut;

          for (let i = 0; i < ports.length; i++) {
            if (ports[i].uiAttribs.preview) {
              this.selectTexturePort(ports[i]);
              return;
            }
          }
        });
      }
    }

    needsVizLayer() {
      return this._mode == MODE_HOVER;
    }

    _renderTexture(tp, element) {
      if (!tp && this._lastClickedP) {
        tp = this.updateTexturePort(this._lastClickedP);
      }
      if (!tp || !this._enabled) {
        return;
      }

      if (!window.gui) return;

      let port = tp;
      if (tp.port) port = tp.port;

      const id = tp.id;
      const texSlot = 5;
      const texSlotCubemap = texSlot + 1;

      let meta = true;
      if (element) meta = false;

      const previewCanvasEle =
        element || document.getElementById("preview_img_" + id);

      if (!previewCanvasEle) {
        this._log.log("no previewCanvasEle");
        return;
      }

      const previewCanvas = previewCanvasEle.getContext("2d");

      if (previewCanvas && port && port.get()) {
        const perf = Gui$1.gui.uiProfiler.start("texpreview");
        const cgl = port.op.patch.cgl;

        if (!this._emptyCubemap)
          this._emptyCubemap = CGL.Texture.getEmptyCubemapTexture(cgl);
        port.op.patch.cgl.profileData.profileTexPreviews++;

        if (!this._mesh) {
          const geom = new CGL.Geometry("tex preview rect");
          geom.vertices = [
            1.0, 1.0, 0.0, -1, 1.0, 0.0, 1.0, -1, 0.0, -1, -1, 0.0,
          ];
          geom.texCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];
          geom.verticesIndices = [0, 1, 2, 3, 1, 2];
          this._mesh = new CGL.Mesh(cgl, geom);
        }
        if (!this._shader) {
          this._shader = new CGL.Shader(cgl, "texPreviewShader");
          this._shader.setModules([
            "MODULE_VERTEX_POSITION",
            "MODULE_COLOR",
            "MODULE_BEGIN_FRAG",
          ]);
          this._shader.setSource(srcShaderVertex, srcShaderFragment);
          this._shaderTexUniform = new CGL.Uniform(
            this._shader,
            "t",
            "tex",
            texSlot,
          );
          this._shaderTexCubemapUniform = new CGL.Uniform(
            this._shader,
            "tc",
            "cubeMap",
            texSlotCubemap,
          );

          this._shaderTexUniformW = new CGL.Uniform(
            this._shader,
            "f",
            "width",
            port.get().width,
          );
          this._shaderTexUniformH = new CGL.Uniform(
            this._shader,
            "f",
            "height",
            port.get().height,
          );
          this._shaderTypeUniform = new CGL.Uniform(this._shader, "f", "type", 0);
          this._shaderTimeUniform = new CGL.Uniform(this._shader, "f", "time", 0);
        }

        cgl.pushPMatrix();

        mat4.ortho(cgl.pMatrix, -1, 1, 1, -1, 0.001, 11);

        const oldTex = cgl.getTexture(texSlot);
        const oldTexCubemap = cgl.getTexture(texSlotCubemap);

        let texType = 0;
        if (!port.get()) return;
        if (port.get().cubemap) texType = 1;
        if (port.get().textureType == CGL.Texture.TYPE_DEPTH) texType = 2;

        this._showInfo(port.get());

        if (texType == 0 || texType == 2) {
          cgl.setTexture(texSlot, port.get().tex);
          cgl.setTexture(
            texSlotCubemap,
            this._emptyCubemap.cubemap,
            cgl.gl.TEXTURE_CUBE_MAP,
          );
        } else if (texType == 1) {
          cgl.setTexture(
            texSlotCubemap,
            port.get().cubemap,
            cgl.gl.TEXTURE_CUBE_MAP,
          );
        }

        this._shaderTypeUniform.setValue(texType);

        this._timer.update();
        this._shaderTimeUniform.setValue(this._timer.get());

        this._mesh.render(this._shader);
        if (texType == 0) cgl.setTexture(texSlot, oldTex);
        if (texType == 1) cgl.setTexture(texSlotCubemap, oldTexCubemap);

        cgl.popPMatrix();
        cgl.resetViewPort();

        const s = this._getCanvasSize(port, port.get(), meta);
        if (s[0] == 0 || s[1] == 0) return;

        if (texType == 1) s[0] *= 1.33;

        if (
          this._currentWidth != s[0] * this.scale ||
          this._currentHeight != s[1] * this.scale
        ) {
          this._currentWidth = previewCanvasEle.width = s[0] * this.scale;
          this._currentHeight = previewCanvasEle.height = s[1] * this.scale;
        }

        const perf2 = Gui$1.gui.uiProfiler.start("texpreview22");

        // if (this._mode == MODE_CORNER)
        // {
        previewCanvas.clearRect(
          0,
          0,
          this._currentWidth,
          previewCanvasEle.height,
        );

        if (
          this._currentWidth > 0 &&
          cgl.canvas.width > 0 &&
          cgl.canvas.height > 0 &&
          previewCanvasEle.width != 0 &&
          previewCanvasEle.height > 0
        )
          previewCanvas.drawImage(
            cgl.canvas,
            0,
            0,
            this._currentWidth,
            previewCanvasEle.height,
          );
        // }

        if (this._mode == MODE_HOVER && this._enabled) {
          const vizCtx =
            Gui$1.gui.patchView.patchRenderer.vizLayer._eleCanvas.getContext("2d");
          vizCtx.save();

          if (UserSettings.userSettings.get("texpreviewTransparent"))
            vizCtx.globalAlpha = 0.5;

          let w = 150;
          let h = Math.min(
            150,
            (150 * previewCanvasEle.height) / this._currentWidth,
          );
          let x = Math.round(
            Gui$1.gui.patchView.patchRenderer.viewBox.mouseX *
              Gui$1.gui.patchView.patchRenderer._cgl.pixelDensity +
              53,
          );
          let y = Math.round(
            Gui$1.gui.patchView.patchRenderer.viewBox.mouseY *
              Gui$1.gui.patchView.patchRenderer._cgl.pixelDensity -
              0,
          );
          vizCtx.translate(x, y);
          if (h <= 1) h = w / 2;

          if (port.get().width < w && port.get().height < h)
            vizCtx.imageSmoothingEnabled = false;

          vizCtx.scale(1, -1);

          if (
            h > 0 &&
            cgl.canvas &&
            cgl.canvas.width > 0 &&
            cgl.canvas.height > 0
          )
            vizCtx.drawImage(cgl.canvas, 0, 0, w, h);
          vizCtx.scale(1, 1);
          vizCtx.globalAlpha = 1;
          vizCtx.restore();
        }

        perf2.finish();

        cgl.gl.clearColor(0, 0, 0, 0);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

        perf.finish();
      }
    }

    drawVizLayer(vizCtx) {
      // vizCtx.drawImage(cgl.canvas, 0, 0, w, h);
      // if (this._mode == MODE_HOVER && this._enabled && this._ele && this._ele.width > 0 && this._ele.height > 0)
      // {
      // // const vizCtx = Gui.gui.patchView.patchRenderer.vizLayer._eleCanvas.getContext("2d");
      //     if (UserSettings.userSettings.get("texpreviewTransparent")) vizCtx.globalAlpha = 0.5;
      //     vizCtx.save();
      //     let w = 150;
      //     let h = Math.min(150, 150 * this._ele.height / this._currentWidth);
      //     let x = Math.round(Gui.gui.patchView.patchRenderer.viewBox.mouseX * Gui.gui.patchView.patchRenderer._cgl.pixelDensity + 53);
      //     let y = Math.round(Gui.gui.patchView.patchRenderer.viewBox.mouseY * Gui.gui.patchView.patchRenderer._cgl.pixelDensity - 0);
      //     vizCtx.translate(x, y);
      //     if (this._ele.width < w && this._ele.height < h)vizCtx.imageSmoothingEnabled = false;
      //     if (w <= 1)w = h / 2;
      //     if (h <= 1)h = w / 2;
      //     vizCtx.scale(1, -1);
      //     vizCtx.drawImage(this._ele, 0, 0, w, h);
      //     vizCtx.strokeStyle = "black";
      //     vizCtx.strokeRect(0, 0, w + 1, h + 1);
      //     vizCtx.scale(1, 1);
      //     vizCtx.globalAlpha = 1;
      //     vizCtx.restore();
      // }
    }

    toggleSize(m) {
      let size = UserSettings.userSettings.get("texpreviewSize");

      if (size == null || size == undefined) size = 30;

      if (size % 10 != 0) size = 30;
      size += m * 10;
      if (size <= 0) size = 10;
      if (size > 100) size = 10;

      this.scale = size / 100;

      UserSettings.userSettings.set("texpreviewSize", this.scale * 100);
    }

    setSize(size) {
      if (!size) size = UserSettings.userSettings.get("texpreviewSize") || 50;

      if (UserSettings.userSettings.get("texpreviewTransparent"))
        this._ele.style.opacity = 0.5;
      else this._ele.style.opacity = 1;

      this.scale = size / 100;

      UserSettings.userSettings.set("texpreviewSize", this.scale * 100);
    }

    _getCanvasSize(port, tex, meta) {
      let maxWidth = 300;
      let maxHeight = 200;

      if (!meta) {
        const patchRect = Gui$1.gui.patchView.element.getBoundingClientRect();
        maxWidth = Math.min(patchRect.width, port.op.patch.cgl.canvasWidth);
        maxHeight = Math.min(patchRect.height, port.op.patch.cgl.canvasHeight);
      }

      const aspect = tex.height / tex.width;
      let w = tex.width;

      if (w > maxWidth) w = maxWidth;
      let h = w * aspect;

      if (h > maxHeight) {
        w = maxHeight / aspect;
        h = maxHeight;
      }

      return [w, h];
    }

    _htmlDataObject(o) {
      if (o.port.get())
        return {
          title: o.port.op.getName() + " - " + o.port.name,
          id: o.id,
          opid: o.opid,
          order: parseInt(o.lastTimeClicked, 10),
          size: o.port.get().width + " x " + o.port.get().height,
        };
    }

    showActivity() {
      for (let i = 0; i < this._texturePorts.length; i++) {
        const activeIndic = document.getElementById(
          "activity" + this._texturePorts[i].id,
        );
        if (activeIndic) {
          if (this._texturePorts[i].activity > 0)
            activeIndic.innerHTML = this._texturePorts[i].activity + " FPS";
          else activeIndic.innerHTML = "";
        }
        this._texturePorts[i].activity = 0;
      }
    }

    enableBgPreview() {
      const enabled = UserSettings.userSettings.get("bgpreviewMax");
      this._enabled = enabled;

      // if (storeSetting)
      // {
      //     UserSettings.userSettings.set("bgpreviewMax", enabled);

      //     this._log.log("store bgpreview max", enabled);
      // }

      // this._log.log("bgpreviewMax", UserSettings.userSettings.get("bgpreviewMax"), enabled);

      if (this._mode == MODE_CORNER) {
        if (!enabled) {
          this.pressedEscape();

          ele.byId("bgpreviewInfo").classList.add("hidden");
          ele.byId("bgpreviewMin").classList.add("hidden");
          ele.byId("bgpreviewMax").classList.remove("hidden");
          ele.byId("texprevSize").classList.add("hidden");
          ele.byId("texprevSize2").classList.add("hidden");

          this._ele.classList.add("hidden");
        } else {
          this.paused = false;
          ele.byId("bgpreviewInfo").classList.remove("hidden");
          ele.byId("bgpreviewMin").classList.remove("hidden");
          ele.byId("bgpreviewMax").classList.add("hidden");
          ele.byId("texprevSize").classList.remove("hidden");
          ele.byId("texprevSize2").classList.remove("hidden");

          this._ele.classList.remove("hidden");

          if (this._lastClicked) this.selectTexturePort(this._lastClickedP);
        }
      }
    }

    hide() {
      this._paused = true;

      if (this._mode == MODE_CORNER) hideToolTip();
    }

    pressedEscape() {
      this.hide();
    }

    render() {
      if (!this.paused) {
        this._ele.style.display = "block";
        this._renderTexture(this._lastClicked, this._ele);

        if (
          this._ele.width + "px" != this._ele.style.width ||
          this._ele.height + "px" != this._ele.style.height
        ) {
          this._ele.style.width = this._ele.width + "px";
          this._ele.style.height = this._ele.height + "px";
        }
      }
    }

    selectTexturePortId(opid, portid) {
      if (!window.gui) return;

      const op = Gui$1.gui.corePatch().getOpById(opid);
      if (!op) return;

      const p = op.getPortById(portid);

      if (!p || p.links.length < 1) return;

      const thePort = p.links[0].getOtherPort(p);
      this.selectTexturePort(thePort);
    }

    hover(p) {
      let thePort = p;
      if (p.direction == CABLES.Port.DIR_IN && p.isLinked())
        thePort = p.links[0].getOtherPort(p);

      if (this._lastClickedP != thePort) {
        this._hoveringTexPort = true;
        this._tempOldTexPort = this._lastClickedP;
        this.selectTexturePort(thePort);
      }
    }

    hoverEnd() {
      if (this._hoveringTexPort) {
        if (!this._tempOldTexPort) this.enableBgPreview(false);
        else this.selectTexturePort(this._tempOldTexPort);
        this._hoveringTexPort = false;
        this._tempOldTexPort = null;
        this._lastClickedP = null;
      }
    }

    selectTexturePort(p) {
      if (!UserSettings.userSettings.get("bgpreview")) {
        this._lastClickedP = p;
        this._lastClicked = this.updateTexturePort(p);

        return;
      }

      if (this._mode == MODE_CORNER)
        ele.byId("bgpreviewButtonsContainer").classList.remove("hidden");

      hideToolTip();

      if (!this._listeningFrame && p) {
        this._listeningFrame = true;
        p.op.patch.cgl.on("beginFrame", () => {
          this.render();
        });
      }

      this._lastClickedP = p;
      this._lastClicked = this.updateTexturePort(p);

      const tp = this.updateTexturePort(p);

      if (!tp) {
        return;
      }

      for (let i = 0; i < this._texturePorts.length; i++) {
        const el = document.getElementById("preview" + this._texturePorts[i].id);
        if (el)
          if (this._texturePorts[i].port.op != p.op)
            el.classList.remove("activePreview");
          else el.classList.add("activePreview");
      }
    }

    updateTexturePort(port) {
      const p = port;
      let idx = -1;

      if (p && p.get() && p.get().tex && port.direction == CABLES.Port.DIR_OUT) {
        const id = port.op.id + port.name;

        idx = -1;
        for (let i = 0; i < this._texturePorts.length; i++)
          if (this._texturePorts[i].id == id) idx = i;

        if (idx == -1) {
          this._texturePorts.push({
            id: id,
            opid: port.op.id,
            port: p,
            lastTimeClicked: -1,
            doShow: false,
            activity: 0,
          });
          idx = this._texturePorts.length - 1;
        }

        this._texturePorts[idx].updated = CABLES.now();
        this._texturePorts[idx].activity++;

        // if (this._mode == CABLES.UI.TexturePreviewer.MODE_ACTIVE) this._texturePorts[idx].doShow = true;
      }

      return this._texturePorts[idx];
    }

    _showInfo(tex) {
      let str = "";
      if (tex) {
        str = tex.width + " x " + tex.height;
        if (tex.textureType === CGL.Texture.TYPE_FLOAT) str += " 32bit";
      }

      if (this._infoStr == str) return;

      this._infoStr = str;
      ele.byId("bgpreviewInfo").innerText = str;
    }

    gotoOp() {
      if (this._lastClickedP)
        Gui$1.gui.patchView.centerSelectOp(this._lastClickedP.op.id);
    }

    deserialize(o) {
      // if (!o) return;
      // this.enableBgPreview(o.enabled);
      // const op = Gui.gui.corePatch().getOpById(o.op);
      // if (!op)
      // {
      //     this._log.log("texpreviewer cant find op");
      //     return;
      // }
      // const p = op.getPort(o.port);
      // this.selectTexturePort(p);
      // this._lastClicked = this.updateTexturePort(p);
      // // this.pin(o.pinned);
      // this.enableBgPreview(o.enabled);
    }

    serialize() {
      const o = {};

      // // o.pinned = Gui.gui.metaTexturePreviewer.pinned;

      // if (this._lastClickedP || this._lastClicked)
      // {
      //     const p = this._lastClicked || this._lastClickedP.port;

      //     if (p)
      //     {
      //         o.port = p.port.name;
      //         o.op = p.port.op.id;
      //         o.enabled = this._enabled;
      //     }

      //     // this._log.log(o);
      // }

      return o;
    }
  }

  /**
   * op documentation loading
   *
   * @export
   * @class OpDocs
   */
  class OpDocs {
    constructor() {
      this._log = new Logger();
      this._opDocs = [];
      this.libs = [];
      this.coreLibs = [];
      this._extensions = [];
      this._teamnamespaces = [];
    }

    addCoreOpDocs() {
      if (window.logStartup) logStartup("Op docs loaded");
      const res = CABLESUILOADER.preload.opDocsAll;
      this._extensions = res.extensions;
      this._teamnamespaces = res.teamNamespaces;
      this.libs = res.libs;
      this.coreLibs = res.coreLibs;

      this.addOpDocs(res.opDocs);

      this.checkDefaultOpsOutdated();
    }

    /**
     * Creates a "typeString" attribute for each port-object in the array (e.g. "Value")
     * @param {array} ports - Array of port objects with a "type" attribute
     */
    addTypeStringToPorts(ports) {
      if (!ports) {
        this._log.warn("addTypeStringToPorts(): ports is not defined");
        return;
      }
      for (let i = 0; i < ports.length; i++) {
        const port = ports[i];
        if (port && typeof port.type !== "undefined") {
          port.typeString = CABLES.Port.portTypeNumberToString(port.type);
        }
      }
    }

    /**
     * Checks for the existence of a documentation text for the port with name `port.name`
     * @param {Object} port - The port-object containing a `name` property to look for
     * @param {Object} opDoc - The doc object of the op
     * @returns {string} - The documeentation for the port as html (markdown parsed)
     */
    getPortDocText(port, opDoc) {
      if (!port || !opDoc || !opDoc.docs || !opDoc.docs.ports) {
        return;
      }

      const perf = Gui$1.gui.uiProfiler.start("[opdocs] portdocs inner");

      for (let i = 0; i < opDoc.docs.ports.length; i++) {
        if (opDoc.docs.ports[i].name === port.name) {
          return opDoc.docs.ports[i].text.trim();
        }
      }
      perf.finish();
    }

    /**
     * Sets a `text` property for each port with the documentation
     * @param {Object} ports - Array-like object with ports
     * @param {Object} opDoc - The op doc
     */
    setPortDocTexts(ports, opDoc) {
      if (!ports) {
        this._log.warn("getPortDocText called with empty argument!");
        return;
      }
      for (let i = 0; i < ports.length; i++) {
        const port = ports[i];
        const portDocText = this.getPortDocText(port, opDoc);
        if (portDocText) {
          port.text = portDocText;
        } else {
          port.text = "";
        }
      }
    }

    getStats() {
      let countTeamOps = 0;
      let countExtensionOps = 0;
      let countUserOps = 0;
      let countCoreOps = 0;
      for (let i = 0; i < this._opDocs.length; i++) {
        if (this._opDocs[i].name.indexOf("Ops.User") == 0) countUserOps++;
        if (this._opDocs[i].name.indexOf("Ops.Team") == 0) countTeamOps++;
        if (this._opDocs[i].name.indexOf("Ops.Extension") == 0)
          countExtensionOps++;
        else {
          countCoreOps++;
        }
        // console.log(this._opDocs[i]);
      }
      return {
        countCoreOps,
        countTeamOps,
        countExtensionOps,
        countUserOps,
      };
    }

    /**
     * Adds some properties to each doc in the op docs array
     * @param {array} _opDocs - The array of op docs
     */
    extendOpDocs(_opDocs) {
      if (!_opDocs) {
        this._log.error("No op docs found!");
        return;
      }
      for (let i = 0; i < _opDocs.length; i++) {
        const opDoc = _opDocs[i];
        opDoc.category = opNames.getNamespaceClassName(opDoc.name);

        if (opDoc.layout) {
          if (opDoc.layout.portsIn) {
            this.addTypeStringToPorts(opDoc.layout.portsIn);
            this.setPortDocTexts(opDoc.layout.portsIn, opDoc);
          }
          if (opDoc.layout.portsOut) {
            this.addTypeStringToPorts(opDoc.layout.portsOut);
            this.setPortDocTexts(opDoc.layout.portsOut, opDoc);
          }
        }
        if (namespace$1.isCollection(opDoc.name)) ;
      }
    }

    /**
     * @param {string} opname
     */
    getSummary(opname) {
      for (let i = 0; i < this._opDocs.length; i++)
        if (this._opDocs[i].name == opname) return this._opDocs[i].summary || "";

      return 0;
    }

    getAll() {
      return this._opDocs;
    }

    getExtensions() {
      return this._extensions;
    }

    getTeamNamespaces() {
      return this._teamnamespaces;
    }

    /**
     * @param {string} ns
     */
    getNamespaceDocs(ns) {
      let docs = this._opDocs.filter((opDoc) => {
        return opDoc.name && opDoc.name.startsWith(ns);
      });
      docs = docs.concat(
        this._extensions.filter((opDoc) => {
          return opDoc.name && opDoc.name.startsWith(ns);
        }),
      );
      docs = docs.concat(
        this._teamnamespaces.filter((opDoc) => {
          return opDoc.name && opDoc.name.startsWith(ns);
        }),
      );
      return docs;
    }

    /**
     * @param {string} opname
     */
    getAttachmentFiles(opname) {
      for (let i = 0; i < this._opDocs.length; i++)
        if (this._opDocs[i].name == opname)
          return this._opDocs[i].attachmentFiles || [];
      return [];
    }

    /**
     * @param {Object} op_docs
     * @param {string} portname
     * @param {number} type
     */
    getPortDoc(op_docs, portname, type) {
      let html = "";

      const className = opNames.getPortTypeClassHtml(type);
      html += "<li>";
      html += '<span class="' + className + '">' + portname + "</span>";

      for (let j = 0; j < op_docs.ports.length; j++) {
        if (op_docs.ports[j].name == portname) {
          html += ":<br/> " + op_docs.ports[j].text;
        }
      }
      html += "</li>";

      return html;
    }

    /**
     * Returns the op documentation object for an op
     * @param {string} opName - Complete op name (long form), e.g. "Ops.Value"
     */
    getOpDocByName(opName) {
      if (!opName) return null;
      for (let i = 0; i < this._opDocs.length; i++) {
        if (this._opDocs[i].name === opName) {
          return this._opDocs[i];
        }
      }
      for (let i = 0; i < this._extensions.length; i++) {
        if (this._extensions[i].name === opName) {
          return this._extensions[i];
        }
      }
      for (let i = 0; i < this._teamnamespaces.length; i++) {
        if (this._teamnamespaces[i].name === opName) {
          return this._teamnamespaces[i];
        }
      }

      return this.getOpDocById(opName);
    }

    /**
     * Returns the op documentation object for an op
     * @param {string} opId
     */
    getOpDocById(opId) {
      let doc = this._opDocs.find((d) => {
        return d.id == opId;
      });
      if (doc) return doc;

      doc = this._extensions.find((d) => {
        return d.id == opId;
      });
      if (doc) return doc;

      doc = this._teamnamespaces.find((d) => {
        return d.id == opId;
      });
      if (doc) return doc;

      return null;
    }

    /**
     * Returns the documentation for an op as Html
     * @param {string} opName - The name of the op to get the documentation as Html for
     * @param collectionInfo
     */
    getHtml(opName, collectionInfo = {}) {
      let opDoc = this.getOpDocByName(opName);

      let template = "op-doc-template";
      if (namespace$1.isExtension(opName))
        template = "op-doc-collection-template-extension";
      if (namespace$1.isTeamNamespace(opName))
        template = "op-doc-collection-template-teamnamespace";
      if (!opDoc) {
        if (namespace$1.isCollection(opName)) {
          opDoc = {
            name: "",
            summary: "",
            userOp: false,
          };
        } else {
          opDoc = {
            name: opName,
            summary: "No Op Documentation found",
            userOp: namespace$1.isUserOp(opName),
          };
        }
      }

      if (!opDoc.isExtended) {
        this.extendOpDocs([opDoc]);
        opDoc.isExtended = true;
      }

      return getHandleBarHtml(template, {
        opDoc: opDoc,
        collectionInfo: collectionInfo,
      });
    }

    showPortDoc(opname, portname) {
      const perf = Gui$1.gui.uiProfiler.start("opdocs.portdoc");

      for (let i = 0; i < this._opDocs.length; i++) {
        if (this._opDocs[i].name == opname && this._opDocs[i].layout) {
          if (!this._opDocs[i].layout) return;

          let group = null;

          if (this._opDocs[i].layout.portsIn)
            for (let k = 0; k < this._opDocs[i].layout.portsIn.length; k++)
              if (this._opDocs[i].layout.portsIn[k].name == portname)
                group = this._opDocs[i].layout.portsIn[k].group;

          if (group) group += " - ";
          else group = "";

          if (this._opDocs[i].docs && this._opDocs[i].docs.ports) {
            for (let j = 0; j < this._opDocs[i].docs.ports.length; j++) {
              if (this._opDocs[i].docs.ports[j].name == portname) {
                Gui$1.gui.showInfoParam(
                  "<b>" +
                    group +
                    portname +
                    "</b>: " +
                    this._opDocs[i].docs.ports[j].text,
                );
                perf.finish();
                return;
              }
            }
          }

          Gui$1.gui.showInfoParam("<b>" + group + portname + "</b> ");
          perf.finish();
          return;
        }
      }

      perf.finish();
    }

    addOpDocs(opDocs = []) {
      const perf = Gui$1.gui.uiProfiler.start("[opdocs] addOpDocs");
      const newOpDocs = [];

      opDocs.forEach((doc) => {
        let oldDoc = this._opDocs.findIndex((d) => {
          return d.id === doc.id;
        });
        if (oldDoc === -1) {
          newOpDocs.push(doc);
        } else {
          this._opDocs[oldDoc] = doc;
        }

        if (defaultOps.hideInOpSelect.indexOf(doc.name) > -1) {
          doc.hidden = true;
        }
      });
      this._opDocs = this._opDocs.concat(newOpDocs);
      perf.finish();
    }

    removeOpDoc(opDoc) {
      let i = this._opDocs.length;
      while (i--) {
        const doc = this._opDocs[i];
        if (doc.id === opDoc.id) {
          this._opDocs.splice(i, 1);
        }
      }
    }

    getOpDocs() {
      return this._opDocs;
    }

    checkDefaultOpsOutdated() {
      const perf = Gui$1.gui.uiProfiler.start("[opdocs] checkDefaultOpsOutdated");
      for (const i in defaultOps.defaultOpNames) {
        const doc = this.getOpDocByName(defaultOps.defaultOpNames[i]);

        if (!doc)
          this._log.warn(
            "default op " +
              i +
              " " +
              defaultOps.defaultOpNames[i] +
              " not found... outdated ?",
          );
      }

      perf.finish();
    }

    /**
     * @param {string} opname
     */
    getLayoutSvg(opname) {
      function glColorToHtml(glCol) {
        const r = Math.round(glCol[0] * 255);
        const g = Math.round(glCol[1] * 255);
        const b = Math.round(glCol[2] * 255);

        return "rgb(" + r + ", " + g + ", " + b + ")";
      }

      let svgStr = "";

      const doc = this.getOpDocByName(opname);
      if (doc && doc.layout) {
        let width = 200;
        if (doc.layout.portsIn)
          width = Math.max(
            width,
            doc.layout.portsIn.length *
              (gluiconfig.portWidth + gluiconfig.portPadding),
          );

        svgStr += '<?xml version="1.0"?>';
        svgStr +=
          '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="' +
          width +
          '" height="' +
          gluiconfig.opHeight +
          '">';

        svgStr +=
          '<rect width="' +
          width +
          '" height="' +
          gluiconfig.opHeight +
          '" fill="' +
          glColorToHtml(Gui$1.gui.theme.colors_patch.opBgRect) +
          '"/>';

        let svgOver = "";

        if (doc.layout.portsIn)
          for (let i = 0; i < doc.layout.portsIn.length; i++) {
            if (!doc.layout.portsIn[i]) continue;
            let posx = i * (gluiconfig.portWidth + gluiconfig.portPadding);

            const pcol = GlPort.getColor(doc.layout.portsIn[i].type);
            const cssCol = glColorToHtml(pcol);

            if (doc.layout.portsIn[i].longPort) {
              svgOver =
                '<rect x="' +
                (posx + gluiconfig.portWidth) +
                '" width="' +
                (gluiconfig.portPadding + gluiconfig.portWidth) *
                  (doc.layout.portsIn[i].longPort - 1) +
                '" height="' +
                gluiconfig.portHeight +
                '" fill="' +
                glColorToHtml(Gui$1.gui.theme.colors_patch.opBgRect) +
                '" opacity="0.76"/>';
              svgOver +=
                '<rect x="' +
                (posx + gluiconfig.portWidth) +
                '" width="' +
                (gluiconfig.portPadding + gluiconfig.portWidth) *
                  (doc.layout.portsIn[i].longPort - 1) +
                '" height="' +
                gluiconfig.portHeight +
                '" fill="' +
                cssCol +
                '" opacity="0.5"/>';
            }

            svgStr +=
              '<rect x="' +
              posx +
              '" width="' +
              gluiconfig.portWidth +
              '" height="' +
              gluiconfig.portHeight +
              '" fill="' +
              cssCol +
              '"/>';
          }

        svgStr += svgOver;

        svgOver = "";

        if (doc.layout.portsOut)
          for (let i = 0; i < doc.layout.portsOut.length; i++) {
            if (!doc.layout.portsOut[i]) continue;
            let posx = i * (gluiconfig.portWidth + gluiconfig.portPadding);
            const pcol = GlPort.getColor(doc.layout.portsOut[i].type);
            const cssCol = glColorToHtml(pcol);

            if (doc.layout.portsOut[i].longPort) {
              svgOver =
                '<rect y="' +
                (gluiconfig.opHeight - gluiconfig.portHeight) +
                '" x="' +
                (posx + gluiconfig.portWidth) +
                '" width="' +
                (gluiconfig.portPadding + gluiconfig.portWidth) *
                  (doc.layout.portsOut[i].longPort - 1) +
                '" height="' +
                gluiconfig.portHeight +
                '" fill="' +
                glColorToHtml(Gui$1.gui.theme.colors_patch.opBgRect) +
                '" opacity="0.76"/>';
              svgOver +=
                '<rect y="' +
                (gluiconfig.opHeight - gluiconfig.portHeight) +
                '" x="' +
                (posx + gluiconfig.portWidth) +
                '" width="' +
                (gluiconfig.portPadding + gluiconfig.portWidth) *
                  (doc.layout.portsOut[i].longPort - 1) +
                '" height="' +
                gluiconfig.portHeight +
                '" fill="' +
                cssCol +
                '" opacity="0.5"/>';
            }

            svgStr +=
              '<rect y="' +
              (gluiconfig.opHeight - gluiconfig.portHeight) +
              '" x="' +
              posx +
              '" width="' +
              gluiconfig.portWidth +
              '" height="' +
              gluiconfig.portHeight +
              '" fill="' +
              cssCol +
              '"/>';
          }

        svgStr += svgOver;

        const nsCol = GlPatch.getOpNamespaceColor(opname);
        const cssCol = glColorToHtml(nsCol);

        svgStr +=
          '<text x="' +
          gluiconfig.portWidth +
          '" y="' +
          gluiconfig.opHeight * 0.63 +
          '" style="font-family:roboto, arial;font-size:12px;" fill="' +
          cssCol +
          '">' +
          (doc.shortNameDisplay || opname) +
          "</text>";

        svgStr += "</svg>";
      }

      return svgStr;
    }
  }

  class IconBar {
    constructor(which) {
      this._items = [];
      this._id = which;
      this._eleContainer = null;
      this.vertical = true;

      this._updateItems();

      if (this._id === "sidebar_bottom" && gui) {
        Gui$1.gui.on("canvasModeChange", (_mode) => {
          this.refresh();
        });
      }
    }

    refresh() {
      this._updateItems();
    }

    _updateItems() {
      this._items = [];
      const items = [];

      if (this._id == "sidebar_bottom") {
        this.vertical = false;
        items.push("Center patch", "Zoom out", "Zoom in");
        if (
          gui &&
          Gui$1.gui.canvasManager.mode === Gui$1.gui.canvasManager.CANVASMODE_PATCHBG
        ) {
          items.push("Patch background renderer");
          items.push("Hide patchfield");
        }
      }

      if (this._id == "sidebar_left") {
        const defaultItems = [
          "Save patch",
          "Add op",
          "Show settings",
          "Maximize canvas",
        ];
        const itemObj = UserSettings.userSettings.get(this._id) || {};

        for (let i = 0; i < defaultItems.length; i++)
          if (!itemObj.hasOwnProperty(defaultItems[i]))
            itemObj[defaultItems[i]] = true;

        UserSettings.userSettings.set(this._id, itemObj);

        for (const i in itemObj) if (itemObj[i]) items.push(i);
      }

      if (this._id == "sidebar_timeline") {
        this.vertical = false;

        items.push(
          "timeline rewind to 0",
          "timeline rewind",
          "timeline play",
          "timeline pause",
          "timeline forward",
          "toggle timeline",
        );
      }

      for (let i = 0; i < items.length; i++)
        for (let j = 0; j < CABLES.CMD.commands.length; j++)
          if (CABLES.CMD.commands[j].cmd == items[i])
            this.addItem(CABLES.CMD.commands[j]);

      this._buildHtml();
    }

    _buildHtml() {
      if (this._eleContainer) this._eleContainer.innerHTML = "";
      else this._eleContainer = document.createElement("div");

      this._eleContainer.id = "iconbar_" + this._id;
      this._eleContainer.classList.add("cbl_iconbarContainer");
      if (!this.vertical) this._eleContainer.classList.add("cbl_iconbar_hor");

      const html = getHandleBarHtml("iconbar", {
        items: this._items,
        id: this._id,
        vertical: this.vertical,
      });

      this._eleContainer.innerHTML = html;

      ele.byId("mainContainer").appendChild(this._eleContainer);
    }

    addItem(item) {
      this._items.push(item);
    }

    setVisible(b) {
      if (!this._eleContainer) return;
      if (b) {
        ele.show(this._eleContainer);
      } else {
        ele.hide(this._eleContainer);
      }
    }
  }

  /**
   * Opens a modal dialog and shows info about given exception
   *
   * options:
   * - title - will replace title
   * - text
   * - codeText - will be shown as monospace font
   * - op: will add an "edit op" button
   * - opname: will show opname
   * - exception: will show stacktrace and exception message. etc.
   *
   * @param {Object} option option object
   * @class
   */
  class ModalError {
    constructor(options) {
      this._options = options;

      const s =
        typeof gui !== "undefined" ? Gui$1.gui.corePatch()._triggerStack : [];
      let stackStr = "";
      for (let i = 0; i < s.length; i++) {
        stackStr += "[" + s[i].op.objName + " - " + s[i].name + "] ";
        if (i != s.length - 1) stackStr += " -> \n";
      }

      this.opDoc = null;

      if (
        this._options.exception &&
        this._options.exception.cause &&
        this._options.exception.cause.indexOf("opId:") == 0
      ) {
        const opid = this._options.exception.cause.substring("opId:".length);

        this.opDoc = Gui$1.gui.opDocs.getOpDocById(opid);

        if (this.opDoc.forbidden) this._options.title = "Forbidden Op";
        if (this.opDoc) this._options.opname = this.opDoc.name;

        if (this.opDoc.forbidden) this._options.exception = null;
      }

      let info = null;
      let stack = null;
      if (this._options.exception) {
        try {
          if (this._options.exception.error) {
            info = stackinfo(this._options.exception.error);
            stack = this._options.exception.error.stack;
          } else {
            info = stackinfo(this._options.exception);
            stack = this._options.exception.stack;
          }
          if (info && info[0].file) {
            console.log("This is line " + (info[0].line + 1));
            console.log("This is file " + info[0].file);

            this._getFileSnippet(info[0].file, info[0].line, function (html) {
              const el = ele.byId("stackFileContent");

              if (el) {
                ele.show(el);
                el.innerHTML = html;
              }
            });
          }
        } catch (e) {
          // browser not supported, we don't care at this point
        }

        console.log("exception:", this._options.exception, info);
        if (
          this._options.exception &&
          this._options.exception.error &&
          this._options.exception.error.message
        )
          this._options.title = this._options.exception.error.message;
      }

      // try to get opname:
      // try to get opname from stracktrace, if given
      // if an acual op is given use the objName of that op
      // otherwise try to use the opname given in options, if set
      this.opName = "";
      if (stack && stack.startsWith(defaultOps.prefixes.op)) {
        this.opName = stack.split("/", 1)[0];
        this.opName = this.opName.substring(0, 128);
      }
      if (this._options.opname) this.opName = this._options.opname;
      if (this._options.op && this._options.op.objName)
        this.opName = this._options.op.objName;

      if (this.opName) {
        // do not track errors in patchops/userops/teamops
        if (namespace$1.isPrivateOp(this.opName)) ;
        if (window.gui) {
          const ops = Gui$1.gui.corePatch().getOpsByObjName(this.opName);
          for (let i = 0; i < ops.length; i++) {
            ops[i].uiAttr({
              error: "exception occured - op stopped - reload to run again",
            });
          }
        }
      }

      CABLES.lastError = {
        title: this._options.title,
        exception: this._options.exception || this._options.codeText,
        opName: this.opName,
        opTriggerStack: stackStr,
        stackInfo: info,
        triggerStack: this._options.triggerStack,
      };

      if (this._options.op) CABLES.lastError.opName = this.opName;

      const modalOptions = {
        title: this._options.title || "cablefail :/",
        html: this.getHtml(),
      };

      this._dialog = new ModalDialog(modalOptions);
      ele.clickable(ele.byId("sendErrorReport"), () => {
        Gui$1.gui.patchView.store.sendErrorReport(CABLES.lastError, true);
      });
    }

    _getFileSnippet(url, line, cb) {
      CABLES.ajax(url, (err, _data, xhr) => {
        if (err) {
          cb("err");
        }
        const lines = _data.split("\n");
        const linesAround = 4;
        const sliced = lines.slice(line - (linesAround + 1), line + linesAround);
        let html = "";
        for (const i in sliced) {
          if (i === linesAround) {
            html += '<span class="error">';
            CABLES.lastError.errorLine = sliced[i];
          }
          html += sliced[i];
          html += "</span>";
          html += "<br/>";
        }
        cb(html);
      });
    }

    getHtml() {
      let str = "";

      if (this.opName) {
        if (this.opDoc && this.opDoc.forbidden) {
          str += "Op is forbidden op: <b>" + this.opName + "</b><br/>";
          str +=
            "Please check if you have the access rights to this op.<br/><br/>";
        } else if (
          gui &&
          Gui$1.gui.serverOps.canEditOp(Gui$1.gui.user, this.opName) &&
          platform
        ) {
          const url = platform.getCablesUrl() + "/op/edit/" + this.opName;
          str +=
            "Error in op: <b><a href='" +
            url +
            "' target='_blank'>" +
            this.opName +
            "</a></b><br/><br/>";
        } else {
          str += "Error in op: <b>" + this.opName + "</b><br/><br/>";
        }
      }

      const isSameHost = platform.isPatchSameHost();

      if (!isSameHost) {
        str +=
          '<br/><br/>Patch was last saved on a different environment: <a class="link" href="https://' +
          Gui$1.gui.project().buildInfo.host +
          "/edit/" +
          Gui$1.gui.patchId +
          '" target="top">' +
          Gui$1.gui.project().buildInfo.host +
          "</a>";
        str += "<br/><br/>";
      }

      if (this._options.text) str += this._options.text + "<br/><br/>";

      if (this._options.codeText)
        str +=
          '<pre><code class="hljs language-json">' +
          this._options.codeText +
          "</code></pre>";

      if (this._options.exception) {
        str += this._options.exception.message + "<br/>";
        if (this._options.exception.stack) {
          const stackClean = document.createElement("div");
          stackClean.innerHTML = this._options.exception.stack;
          str += "<br/>stacktrace:<br/>";
          str +=
            '<div class="shaderErrorCode">' +
            stackClean.innerText +
            "</div><br/>";
          stackClean.remove();
        }
        if (this._options.exception.customMessage) {
          str += "<br/><br/>";
          str +=
            '<div class="shaderErrorCode">' +
            this._options.exception.customMessage +
            "</div><br/>";
        }
      }
      str +=
        '<div class="shaderErrorCode hidden" id="stackFileContent"></div><br/>';

      let isPrivateOp = false;
      if (this.opName) {
        isPrivateOp = namespace$1.isPrivateOp(this.opName);
        if (
          window.gui &&
          (Gui$1.gui.user.isStaff || namespace$1.isCurrentUserOp(this.opName))
        ) {
          str +=
            '<a class="button " onclick="Gui.gui.serverOps.edit(\'' +
            this.opName +
            '\',false,null,true);Gui.gui.closeModal();"><span class="icon icon-edit"></span>Edit op</a> &nbsp;&nbsp;';
        }
      }

      str +=
        '<a class="button" onclick="CABLES.CMD.PATCH.reload();"><span class="icon icon-refresh"></span>Reload patch</a>&nbsp;&nbsp;';
      if (CABLES && platform && platform.getIssueTrackerUrl()) {
        str +=
          '<a class="button" target="_blankk" href="' +
          platform.getIssueTrackerUrl() +
          '"><span class="icon icon-message"></span>Report a problem</a>&nbsp;&nbsp;';
      }

      let ignoreErrorReport = false;

      if (
        this._options.exception &&
        this._options.exception.message &&
        this._options.exception.message.indexOf("Script Error.") > -1
      )
        ignoreErrorReport = true;

      if (CABLES.lastError && CABLES.lastError.opTriggerStack) {
        if (
          CABLES.lastError.opTriggerStack.indexOf(
            "Ops.Gl.Shader.CustomShader_",
          ) >= 0 ||
          CABLES.lastError.opTriggerStack.indexOf("Ops.User.") >= 0 ||
          CABLES.lastError.opTriggerStack.indexOf("Ops.Team.") >= 0 ||
          CABLES.lastError.opTriggerStack.indexOf("Ops.Patch.") >= 0
        ) {
          console.log("suppressed error report...");
          ignoreErrorReport = true;
        }
      }

      let showSendButton = true;
      if (CABLES && platform && !platform.frontendOptions.sendErrorReports) {
        ignoreErrorReport = true;
        showSendButton = false;
      }

      if (!isPrivateOp) {
        if (
          CABLES &&
          platform &&
          platform.isDevEnv() &&
          gui &&
          Gui$1.gui.user &&
          !Gui$1.gui.user.isStaff &&
          !ignoreErrorReport
        ) {
          Gui$1.gui.patchView.store.sendErrorReport(CABLES.lastError, false);
          str +=
            "<br/><br/>Dev Environment: An automated error report has been created. We will look into it!";
        } else if (showSendButton) {
          str +=
            '<a class="button" id="sendErrorReport">Send Error Report</a>&nbsp;&nbsp;';
        }
      }

      return str;
    }

    close() {
      this._dialog.close();
      this._dialog = null;
    }
  }

  class MetaOpParams {
    constructor(tabs) {
      this._tabs = tabs;
      this._tab = new Tab("op", {
        icon: "op",
        infotext: "tab_op",
        showTitle: false,
        hideToolbar: true,
        padding: false,
      });

      this._tab.addEventListener("onActivate", () => {
        this.show();
      });

      this.updateVisibility();
    }

    updateVisibility(b) {
      if (!gui) return;

      if (this._tabs.getActiveTab() != this._tab)
        this._prevTab = this._tabs.getActiveTab();
      this._tabs.closeTab(this._tab.id);

      if (this._prevTab) this._tabs.activateTab(this._prevTab.id);

      if (b === undefined) b = !Gui$1.gui.showTwoMetaPanels();

      if (b === false) {
        this._prevTab = this._tabs.getActiveTab();
        this._tabs.addTab(this._tab);
        this._tabs.activateTab(this._tab.id);
      }
    }

    init() {}

    show() {
      this._tab.html('<div id="options_meta"></div>');
      if (window.gui) Gui$1.gui.opParams.refresh();
    }
  }

  /**
   * debug: show content of an array in a tab
   *
   * @export
   * @class WatchArrayTab
   * @extends {Events}
   */
  class WatchArrayTab extends Events {
    constructor(tabs, op, port, options) {
      super();
      this._tabs = tabs;
      this._log = new Logger("watcharray");

      this._numCols = 1;
      if (op.name.indexOf("Array3") > -1 || op.name.indexOf("Points") > -1)
        this._numCols = 3;
      if (op.name.indexOf("glArray") > -1 || port.type == portType.object)
        this._numCols = 4;

      this._rows = 40;

      this.cells = [];
      this._inputs = [];
      this._options = options;
      this.colNames = [];

      this.port = port;
      this.data = null;

      this.data = this._getData();

      this.portListenerId = this.port.on(
        "change",
        this._updatePortValue.bind(this),
      );

      this._tab = new CABLES.UI.Tab(
        options.title || "watch " + port.name + port.id,
        {
          icon: "spreadsheet",
          infotext: "tab_spreadsheet",
          padding: true,
          singleton: "true",
        },
      );

      this._tab.on("close", () => {
        this.port.off(this.portListenerId);
      });

      this._tabs.addTab(this._tab, true);

      this._id = "spread" + CABLES.uuid();
      this._tab.html("<div id='" + this._id + "'></div>");

      this._ele = document.getElementById(this._id);

      if (!this._ele) {
        if (this.port) this.port.off(this.portListenerId);
        this._tab.remove();
        this._log.warn("ele is null");
        this._log.warn(this);
        return;
      }

      this._ele.classList.add("editor_spreadsheet");

      this._eleIconbar = ele.create("div");
      this._ele.appendChild(this._eleIconbar);

      this._eleInfo = ele.create("div");
      this._ele.appendChild(this._eleInfo);

      if (this.port.type == portType.array) {
        this._eleIconMinus = ele.create("a");
        this._eleIconMinus.innerHTML = "-";
        this._eleIconMinus.classList.add("button");
        this._eleIconMinus.addEventListener("click", () => {
          this._changeColumns(-1);
        });
        this._eleIconbar.appendChild(this._eleIconMinus);

        this._eleIconPlus = ele.create("a");
        this._eleIconPlus.innerHTML = "+";
        this._eleIconPlus.classList.add("button");
        this._eleIconPlus.addEventListener("click", () => {
          this._changeColumns(1);
        });
        this._eleIconbar.appendChild(this._eleIconPlus);
      }

      // this._eleIconbar.innerHTML='<a href="http://localhost:5711/op/Ops.Array.RandomNumbersArray3_v2" class="button ">+</a>';

      this._eleTable = ele.create("table");
      this._ele.appendChild(this._eleTable);

      /*
       * if (!this.cells)
       *     for (let y = 0; y < this._rows; y++)
       *         for (let x = 0; x < this._numCols; x++)
       *             this.set(x, y, "");
       */

      this._html();
    }

    getColName(_c) {
      _c = parseFloat(_c);

      if (this.colNames.length > _c && this.colNames[_c]) {
        return this.colNames[_c];
      }

      let str = "";

      let c = parseFloat(_c);

      if (c < 0) throw new Error("col invalid");

      while (c >= 0) {
        if (this.port.type == portType.object)
          str = "RGBAabcdefghijklmnopqrstuvwxyz"[c % 26] + str;
        else str = "abcdefghijklmnopqrstuvwxyz"[c % 26] + str;
        c = Math.floor(c / 26) - 1;
      }

      this.colNames[_c] = str;

      return str;
    }

    _getData() {
      if (!this.port) return [];
      if (this.port.type == portType.array) {
        return this.port.get();
      }

      if (this.port.type == portType.object) {
        const realTexture = this.port.get(),
          gl = this.port.op.patch.cgl.gl;

        if (!realTexture) return [];
        if (!this._fb) this._fb = gl.createFramebuffer();

        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fb);

        let channels = gl.RGBA;
        let numChannels = 4;

        let texChanged = true;
        let channelType = gl.UNSIGNED_BYTE;

        if (texChanged) {
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D,
            realTexture.tex,
            0,
          );

          let isFloatingPoint = realTexture.textureType == CGL.Texture.TYPE_FLOAT;
          if (isFloatingPoint) channelType = gl.FLOAT;

          if (
            this._lastFloatingPoint != isFloatingPoint ||
            this._lastWidth != realTexture.width ||
            this._lastHeight != realTexture.height
          ) {
            const size = realTexture.width * realTexture.height * numChannels;
            if (isFloatingPoint) this._pixelData = new Float32Array(size);
            else this._pixelData = new Uint8Array(size);

            this._lastFloatingPoint = isFloatingPoint;
            this._lastWidth = realTexture.width;
            this._lastHeight = realTexture.height;
          }

          texChanged = false;
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fb);

        gl.readPixels(
          0,
          0,
          Math.min(90, realTexture.width),
          1,
          channels,
          channelType,
          this._pixelData,
        );

        return this._pixelData;
      }
    }

    _changeColumns(n) {
      this._numCols += n;
      this._updatePortValue();
    }

    _updatePortValue() {
      if (!this.port || !this.port.get()) return;
      this.data = this._getData();
      if (this._eleTable) this._eleTable.remove();
      this._eleTable = ele.create("table");
      this._ele.appendChild(this._eleTable);

      this._html();
    }

    _html() {
      for (let i = 0; i < this._inputs.length; i++) this._inputs[i].remove();

      this._inputs.length = 0;
      const table = this._eleTable;

      const tr1 = ele.create("tr");
      for (let x = -1; x < this._numCols; x++) {
        const tdr = ele.create("td");
        if (x > -1) {
          tdr.innerHTML = "&nbsp;" + this.getColName(x);
          tdr.classList.add("colnum");
          tdr.style.width = 90 / this._numCols + "%";
        } else {
          tdr.style.width = "10%";
        }
        tr1.appendChild(tdr);
      }
      table.appendChild(tr1);

      for (let y = 0; y < this._rows; y++) {
        const tr = ele.create("tr");
        table.appendChild(tr);

        const tdr = ele.create("td");
        if (y >= 0) {
          tdr.innerHTML = y;
          tdr.classList.add("rownum");
        }
        tr.appendChild(tdr);

        for (let x = 0; x < this._numCols; x++) {
          const td = ele.create("td");
          tr.appendChild(td);

          const input = ele.create("span");
          input.style.fontFamily = "Monospace";
          input.dataset.x = x;
          input.dataset.y = y;
          this._inputs[x + y * this._numCols] = input;

          let str = String(this.get(x, y));
          if (str.indexOf("-") == -1) str = "&nbsp;" + str;
          input.innerHTML = str || "";

          td.appendChild(input);
        }
      }

      if (this.port.type == portType.array) {
        let showNum = 0;
        let showLength = 0;
        if (this.data && this.data.length) {
          showNum = this._rows * this._numCols;
          showLength = this.data.length;
        }

        this._eleInfo.innerHTML =
          "showing " + showNum + " of " + showLength + " values ";
      }
      if (this.port.type == portType.object) {
        this._eleInfo.innerHTML =
          this.port.get().width +
          "x" +
          this.port.get().height +
          " - " +
          this.port.get().height * this.port.get().width +
          " Pixels";
      }
    }

    _focusCell(x, y) {
      const inp = this._inputs[y * this._numCols + x];

      if (inp) {
        inp.focus();

        setTimeout(() => {
          inp.select();
        }, 50);
      }
    }

    get(x, y) {
      if (!this.data) return "???";
      if (this.data[x + y * this._numCols] === undefined) return "-";
      return this.data[x + y * this._numCols];
    }

    show() {}
  }

  class Gizmo {
    constructor(cgl) {
      this._cgl = cgl;
      this._eleCenter = null;
      this._eleX = null;
      this._eleY = null;
      this._eleZ = null;
      this._eleXZ = null;
      this._eleXY = null;
      this._eleYZ = null;
      this.lineX = null;
      this.lineY = null;
      this.lineZ = null;

      this._params = null;
      this._origValue = 0;
      this._dragSum = 0;
      this._dragSumY = 0;
      this._dir = 1;
      this.hidden = true;
    }

    dispose() {
      this.hidden = true;
      if (this._eleCenter) this._eleCenter.remove();
      if (this._eleX) this._eleX.remove();
      if (this._eleY) this._eleY.remove();
      if (this._eleZ) this._eleZ.remove();
      if (this._eleXZ) this._eleXZ.remove();
      if (this._eleXY) this._eleXY.remove();
      if (this._eleYZ) this._eleYZ.remove();
      if (this.lineX) this.lineX.remove();
      if (this.lineY) this.lineY.remove();
      if (this.lineZ) this.lineZ.remove();
    }

    getDir(x2, y2) {
      const xd = this._params.x - x2;
      const yd = this._params.y - y2;
      const dist = (xd + yd) / 2;

      if (dist < 0) return 1;
      return -1;
    }

    set(params) {
      if (!params) return this.setParams(params);

      const cgl = this._cgl;
      if (!cgl) return;
      cgl.pushModelMatrix();
      function toScreen(trans) {
        const vp = cgl.getViewPort();
        let x = vp[2] - (vp[2] * 0.5 - (trans[0] * vp[2] * 0.5) / trans[2]);
        let y = vp[3] - (vp[3] * 0.5 + (trans[1] * vp[3] * 0.5) / trans[2]);

        if (cgl.canvas.styleMarginLeft) x += cgl.canvas.styleMarginLeft;
        if (cgl.canvas.styleMarginTop) y += cgl.canvas.styleMarginTop;

        x /= cgl.pixelDensity;
        y /= cgl.pixelDensity;
        return { x: x, y: y };
      }

      function distance(x1, y1, x2, y2) {
        const xd = x2 - x1;
        const yd = y2 - y1;
        return Math.sqrt(xd * xd + yd * yd);
      }

      const m = create$5();
      const pos = create$4();
      const trans = create$4();
      const transX = create$4();
      const transY = create$4();
      const transZ = create$4();
      const identVec = create$4();

      translate$1(cgl.mvMatrix, cgl.mvMatrix, [
        params.posX.get(),
        params.posY.get(),
        params.posZ.get(),
      ]);
      multiply$5(m, cgl.vMatrix, cgl.mvMatrix);

      transformMat4$2(pos, identVec, m);

      let tempParams = {};

      if (pos[2] > 0) {
        tempParams = null;
      } else {
        transformMat4$2(trans, pos, cgl.pMatrix);
        const zero = toScreen(trans);

        // normalize distance to gizmo handles
        transformMat4$2(pos, [1, 0, 0], m);
        transformMat4$2(transX, pos, cgl.pMatrix);
        let screenDist = toScreen(transX);
        const d1 = distance(zero.x, zero.y, screenDist.x, screenDist.y);

        transformMat4$2(pos, [0, 1, 0], m);
        transformMat4$2(transX, pos, cgl.pMatrix);
        screenDist = toScreen(transX);
        const d2 = distance(zero.x, zero.y, screenDist.x, screenDist.y);

        transformMat4$2(pos, [0, 0, 1], m);
        transformMat4$2(transX, pos, cgl.pMatrix);
        screenDist = toScreen(transX);
        const d3 = distance(zero.x, zero.y, screenDist.x, screenDist.y);

        const d = Math.max(d3, Math.max(d1, d2));
        const w = (1 / (d + 0.00000001)) * 50;
        this._multi = w;

        transformMat4$2(pos, [w, 0, 0], m);
        transformMat4$2(transX, pos, cgl.pMatrix);

        transformMat4$2(pos, [0, w, 0], m);
        transformMat4$2(transY, pos, cgl.pMatrix);

        transformMat4$2(pos, [0, 0, w], m);
        transformMat4$2(transZ, pos, cgl.pMatrix);

        const screenX = toScreen(transX);
        const screenY = toScreen(transY);
        const screenZ = toScreen(transZ);

        // console.log(screenZ);

        tempParams.x = zero.x;
        tempParams.y = zero.y;
        tempParams.xx = screenX.x;
        tempParams.xy = screenX.y;
        tempParams.yx = screenY.x;
        tempParams.yy = screenY.y;
        tempParams.zx = screenZ.x;
        tempParams.zy = screenZ.y;

        tempParams.coord = trans;
        tempParams.coordX = transX;
        tempParams.coordY = transY;
        tempParams.coordZ = transZ;

        tempParams.posX = params.posX;
        tempParams.posY = params.posY;
        tempParams.posZ = params.posZ;
        tempParams.dist = w;
      }

      cgl.popModelMatrix();

      this.setParams(tempParams);
    }

    setParams(params) {
      this._params = params;
      if (!this._cgl) return;
      if (!this._eleCenter) {
        const container = this._cgl.canvas.parentElement;
        if (!container) return;

        this._eleCenter = document.createElement("div");
        this._eleCenter.id = "gizmo";

        this._eleCenter.style.background = "#fff";
        this._eleCenter.style.display = "none";
        this._eleCenter.style.opacity = "0.9";
        this._eleCenter.style.pointerEvents = "none";
        // this._eleCenter.style['border-radius']="1130px";
        // this._eleCenter.style.transform='scale(2)';
        this._eleCenter.classList.add("gizmo");
        container.appendChild(this._eleCenter);

        this._eleX = document.createElement("div");
        this._eleX.id = "gizmoX";
        this._eleX.style.background = "#f00";
        this._eleX.style.display = "none";
        this._eleX.classList.add("gizmo");
        container.appendChild(this._eleX);

        this._eleXZ = document.createElement("div");
        this._eleXZ.id = "gizmoXZ";
        this._eleXZ.style.background = "#f0f";
        this._eleXZ.style.display = "none";
        this._eleXZ.style.opacity = "0.5";
        this._eleXZ.style.borderRadius = "0";
        this._eleXZ.classList.add("gizmo");
        container.appendChild(this._eleXZ);

        this._eleXY = document.createElement("div");
        this._eleXY.id = "gizmoXY";
        this._eleXY.style.background = "#ff0";
        this._eleXY.style.display = "none";
        this._eleXY.style.opacity = "0.5";
        this._eleXY.style.borderRadius = "0";
        this._eleXY.classList.add("gizmo");
        container.appendChild(this._eleXY);

        this._eleYZ = document.createElement("div");
        this._eleYZ.id = "gizmoYZ";
        this._eleYZ.style.background = "#0ff";
        this._eleYZ.style.display = "none";
        this._eleYZ.style.opacity = "0.5";
        this._eleYZ.style.borderRadius = "0";
        this._eleYZ.classList.add("gizmo");
        container.appendChild(this._eleYZ);

        this._eleY = document.createElement("div");
        this._eleY.id = "gizmoY";
        this._eleY.style.background = "#0f0";
        this._eleY.style.display = "none";
        this._eleY.classList.add("gizmo");
        container.appendChild(this._eleY);

        this._eleZ = document.createElement("div");
        this._eleZ.id = "gizmoZ";
        this._eleZ.style.background = "#00f";
        this._eleZ.style.display = "none";

        this._eleZ.classList.add("gizmo");
        container.appendChild(this._eleZ);

        this.lineX = new htmlLine(container, "#f00");
        this.lineY = new htmlLine(container, "#0f0");
        this.lineZ = new htmlLine(container, "#00f");

        this._eleX.addEventListener("pointerdown", () => {
          if (!this._params) return;
          this._draggingPort = this._params.posX;
          this._draggingPortY = null;
          this._origValue = this._params.posX.get();
          this._dragSum = 0;
          this.dragger(this._eleCenter);

          this._dir = this.getDir(this._params.xx, this._params.xy);
        });

        this._eleY.addEventListener("pointerdown", () => {
          if (!this._params) return;
          this._draggingPort = this._params.posY;
          this._draggingPortY = null;
          this._origValue = this._params.posY.get();
          this._dragSum = 0;
          this.dragger(this._eleCenter);

          this._dir = this.getDir(this._params.yx, this._params.yy);
        });

        this._eleZ.addEventListener("pointerdown", () => {
          if (!this._params) return;
          this._draggingPort = this._params.posZ;
          this._draggingPortY = null;
          this._origValue = this._params.posZ.get();
          this._dragSum = 0;
          this.dragger(this._eleCenter);
          this._dir = this.getDir(this._params.zx, this._params.zy);
        });

        this._eleXZ.addEventListener("pointerdown", () => {
          if (!this._params) return;
          this._draggingPort = this._params.posX;
          this._draggingPortY = this._params.posZ;

          this._origValue = this._params.posX.get();
          this._origValueY = this._params.posZ.get();
          this._dragSum = 0;
          this._dragSumY = 0;
          this.dragger(this._eleCenter);
        });

        this._eleXY.addEventListener("pointerdown", () => {
          if (!this._params) return;
          this._draggingPort = this._params.posX;
          this._draggingPortY = this._params.posY;

          this._origValue = this._params.posX.get();
          this._origValueY = this._params.posY.get();

          this._dragSum = 0;
          this._dragSumY = 0;

          // this.flipX = true;
          this.flipY = true;

          this.dragger(this._eleCenter);
        });
        this._eleYZ.addEventListener("pointerdown", () => {
          if (!this._params) return;
          this._draggingPort = this._params.posZ;
          this._draggingPortY = this._params.posY;

          this._origValue = this._params.posZ.get();
          this._origValueY = this._params.posY.get();
          this._dragSum = 0;
          this._dragSumY = 0;

          this.flipY = true;
          this.flipX = true;

          this.dragger(this._eleCenter);
        });
      }

      if (!params) {
        if (this.hidden) return;
        setTimeout(() => {
          this.hidden = true;
          this._eleCenter.style.display = "none";
          this._eleXZ.style.display = "none";
          this._eleXY.style.display = "none";
          this._eleYZ.style.display = "none";
          this._eleX.style.display = "none";
          this._eleZ.style.display = "none";
          this._eleY.style.display = "none";

          this.lineX.hide();
          this.lineZ.hide();
          this.lineY.hide();
        }, 1);
        return;
      }

      this.hidden = false;
      this.lineX.show();
      this.lineZ.show();
      this.lineY.show();

      this._eleCenter.style.display = "block";
      this._eleCenter.style.left = params.x + "px";
      this._eleCenter.style.top = params.y + "px";

      this._eleXZ.style.display = "block";
      this._eleXZ.style.left = (params.xx + params.zx) / 2 + "px";
      this._eleXZ.style.top = (params.xy + params.zy) / 2 + "px";

      this._eleXY.style.display = "block";
      this._eleXY.style.left = (params.xx + params.yx) / 2 + "px";
      this._eleXY.style.top = (params.xy + params.yy) / 2 + "px";

      this._eleYZ.style.display = "block";
      this._eleYZ.style.left = (params.zx + params.yx) / 2 + "px";
      this._eleYZ.style.top = (params.zy + params.yy) / 2 + "px";

      this._eleX.style.display = "block";
      this._eleX.style.left = params.xx + "px";
      this._eleX.style.top = params.xy + "px";

      this._eleY.style.display = "block";
      this._eleY.style.left = params.yx + "px";
      this._eleY.style.top = params.yy + "px";

      this._eleZ.style.display = "block";
      this._eleZ.style.left = params.zx + "px";
      this._eleZ.style.top = params.zy + "px";

      this.lineX.set(params.x, params.y, params.xx, params.xy);
      this.lineY.set(params.x, params.y, params.yx, params.yy);
      this.lineZ.set(params.x, params.y, params.zx, params.zy);
    }

    dragger(el) {
      const self = this;

      function keydown(e) {}

      const down = (e) => {
        if (CABLES.UI)
          Gui$1.gui.savedState.setUnSaved(
            "transformDown",
            this._params.posX.op.getSubPatch(),
          );
        document.addEventListener("pointerlockchange", lockChange, false);
        document.addEventListener("mozpointerlockchange", lockChange, false);
        document.addEventListener("webkitpointerlockchange", lockChange, false);
        document.addEventListener("keydown", keydown, false);
        el.requestPointerLock =
          el.requestPointerLock ||
          el.mozRequestPointerLock ||
          el.webkitRequestPointerLock;
        if (el.requestPointerLock) el.requestPointerLock();
      };

      const up = (e) => {
        self.flipY = false;
        self.flipX = false;
        if (self._draggingPort) {
          ((function (patch, p1Name, op1Id, oldValue, newValue) {
            const op = patch.getOpById(op1Id);
            const p = op.getPortByName(p1Name);

            undo.add({
              title: "move gizmo " + p.name,
              undo() {
                p.set(oldValue);
                Gui$1.gui.emitEvent("portValueEdited", op, p, oldValue);
              },
              redo() {
                p.set(newValue);
                Gui$1.gui.emitEvent("portValueEdited", op, p, newValue);
              },
            });
          }))(
            self._draggingPort.op.patch,
            self._draggingPort.getName(),
            self._draggingPort.op.id,
            self._origValue,
            self._draggingPort.get(),
          );
        }

        if (CABLES.UI)
          Gui$1.gui.savedState.setUnSaved(
            "transformUp",
            this._params.posX.op.getSubPatch(),
          );
        document.removeEventListener("pointerlockchange", lockChange, false);
        document.removeEventListener("mozpointerlockchange", lockChange, false);
        document.removeEventListener(
          "webkitpointerlockchange",
          lockChange,
          false,
        );
        document.removeEventListener("keydown", keydown, false);

        if (document.exitPointerLock) document.exitPointerLock();

        document.removeEventListener("mouseup", up);
        document.removeEventListener("pointerdown", down);

        document.removeEventListener("pointermove", move, false);

        if (CABLES.UI) Gui$1.gui.opParams.show(self._draggingPort.op);
      };

      const move = (e) => {
        if (CABLES.UI)
          Gui$1.gui.savedState.setUnSaved(
            "transformMove",
            this._params.posX.op.getSubPatch(),
          );

        if (self._draggingPortY) {
          let vX = e.movementX * ((self._multi || 1) / 100);
          let vY = e.movementY * ((self._multi || 1) / 100);

          let p = [vX, vY];
          vec2.rotate(p, p, [0, 0], -self.lineX.angle);
          vX = p[0];
          vY = p[1];

          if (self.flipY) vY *= -1;
          if (self.flipX) vX *= -1;

          if (e.shiftKey) vX *= 0.025;
          if (e.shiftKey) vY *= 0.025;
          self._dragSum += vX;
          self._dragSumY += vY;
          const newValue = self._origValue + self._dragSum;
          const newValueY = self._origValueY + self._dragSumY;
          self._draggingPort.set(newValue);
          self._draggingPortY.set(newValueY);
          if (CABLES.UI)
            Gui$1.gui.emitEvent(
              "gizmoMove",
              self._draggingPort.op.id,
              self._draggingPort.getName(),
              newValue,
            );
          if (CABLES.UI)
            Gui$1.gui.emitEvent(
              "gizmoMove",
              self._draggingPortY.op.id,
              self._draggingPortY.getName(),
              newValueY,
            );
        } else {
          // one axis...
          let v =
            (e.movementY + e.movementX) *
            (self._dir * ((self._multi || 1) / 100));
          if (e.shiftKey) v *= 0.025;
          self._dragSum += v;
          const newValue = self._origValue + self._dragSum;
          self._draggingPort.set(newValue);
          if (CABLES.UI)
            Gui$1.gui.emitEvent(
              "gizmoMove",
              self._draggingPort.op.id,
              self._draggingPort.getName(),
              newValue,
            );
        }
      };

      function lockChange(e) {
        if (
          document.pointerLockElement === el ||
          document.mozPointerLockElement === el ||
          document.webkitPointerLockElement === el
        ) {
          document.addEventListener("pointermove", move, false);
        } else {
          // escape clicked...
          self._draggingPort.set(self._origValue);
          up();
        }
      }

      document.addEventListener("mouseup", up);
      document.addEventListener("pointerdown", down);
    }
  }

  const htmlLine = function (parentElement, color) {
    let line = null;
    this.angle = 0;

    function createLineElement(x, y, length, angle) {
      line = document.createElement("div");
      const styles =
        "border: 1px solid " +
        color +
        "; " +
        "width: " +
        length +
        "px; " +
        "height: 0px; " +
        "transform: rotate(" +
        angle +
        "rad); " +
        "position: absolute; " +
        "top: " +
        y +
        "px; " +
        "left: " +
        x +
        "px; ";
      line.setAttribute("style", styles);
      line.classList.add("gizmoline");
      return line;
    }

    function setPos(x, y, length, angle) {
      line.style.width = length + "px";
      line.style.top = y + "px";
      line.style.left = x + "px";
      line.style.transform = "rotate(" + angle + "rad)";
      line.style["z-index"] = "9999";
    }

    this.set = function (x1, y1, x2, y2) {
      let a = x1 - x2,
        b = y1 - y2,
        c = Math.sqrt(a * a + b * b);

      let sx = (x1 + x2) / 2,
        sy = (y1 + y2) / 2;

      let x = sx - c / 2,
        y = sy;

      const alpha = Math.PI - Math.atan2(-b, a);
      this.angle = alpha;

      setPos(x, y, c, alpha);
    };

    this.remove = function () {
      line.remove();
    };

    this.hide = function () {
      if (line) line.style.display = "none";
    };

    this.show = function () {
      if (line) line.style.display = "block";
    };

    parentElement.appendChild(createLineElement(100, 100, 200, 200));
    this.hide();
  };

  /** @typedef SuggestionItem
   * @property {String} name
   * @property {String} class
   * @property {Number} id
   *
   * @property {Number} rot - internal: do not set manually
   * @property {Number} top - internal: do not set manually
   * @property {Number} left - internal: do not set manually
   * @property {String} shortName - internal: do not set manually
   */

  /**
   * show suggestion dialog (rotary mouse select menu)
   *
   * @export
   * @class SuggestionDialog
   */
  class SuggestionDialog {
    /**
     * @param {Array<SuggestionItem>} suggestions
     * @param {CABLES.Op} op
     * @param {MouseEvent} mouseEvent
     * @param {Function} cb
     * @param {Function} _action
     * @param {boolean} _showSelect
     * @param {Function} cbCancel
     */
    constructor(suggestions, op, mouseEvent, cb, _action, _showSelect, cbCancel) {
      this._cb = cb;
      this._action = _action;
      this._eleDialog = ele.byId("suggestionDialog");
      this._bg = new ModalBackground();
      this._bg.on("hide", () => {
        this.close();
        if (cbCancel) cbCancel();
      });

      this.doShowSelect = _showSelect;

      if (!suggestions) {
        if (cb) cb();
        return;
      }

      CABLES.UI.suggestions = this;

      let sugDegree = 6;
      const sugHeight = 23;

      if (suggestions.length > 10) sugDegree = 3;

      for (let i = 0; i < suggestions.length; i++) {
        suggestions[i].id = i;
        suggestions[i].rot = (i - suggestions.length / 2) * sugDegree;
        suggestions[i].left =
          15 - Math.abs((i - (suggestions.length - 1) / 2) * 3) / 2;
        suggestions[i].top =
          i * sugHeight - (suggestions.length * sugHeight) / 2 - sugHeight;
        suggestions[i].shortName = suggestions[i].name.substr(
          4,
          suggestions[i].name.length,
        );
        if (suggestions[i].name) suggestions[i].shortName = suggestions[i].name;
      }

      this._eleDialog.innerHTML = getHandleBarHtml("suggestions", {
        suggestions,
        _showSelect,
      });
      this._bg.show();

      ele.show(this._eleDialog);

      this._eleDialog.style.left = mouseEvent.clientX + "px";
      this._eleDialog.style.top = mouseEvent.clientY + "px";

      for (let i = 0; i < suggestions.length; i++) {
        suggestions[i].rot = (i - suggestions.length / 2) * sugDegree;
        const left = 15 - Math.abs((i - (suggestions.length - 1) / 2) * 3);

        suggestions[i].shortName = suggestions[i].name.substr(
          4,
          suggestions[i].name.length,
        );

        const sugEle = ele.byId("suggestion" + i);

        if (suggestions[i].class) sugEle.classList.add(suggestions[i].class);

        sugEle.animate(
          [
            { left: -left + "px", opacity: 0 },
            { left: 0 + "px", opacity: 1 },
          ],
          {
            duration: 150 + i * 50,
            easing: "ease-out",
            iterations: 1,
          },
        );

        suggestions[i].id = i;
      }
    }

    close() {
      this._eleDialog.innerHTML = "";

      ele.hide(this._eleDialog);
      this._bg.hide();

      CABLES.UI.suggestions = null;
      Gui$1.gui.patchView.focus();
    }

    showSelect() {
      if (this._cb) this._cb();
      else this.close();
    }

    action(id) {
      this.close();
      this._action(id);
    }
  }

  /** Your class description */
  class LongPressConnector extends Events {
    /**
     * @constructor
     * @params
     */
    constructor() {
      super();

      this._glOp = null;
      this._longPressTimeout = null;
      this._quickAddOpStart = null;
      this._longPressOp = null;
      this._longPress = false;
      this._longPressStartTime = 0;
      this._glLineDrawer = null;
      this._glLineIdx = -1;
      this._startX = 0;
      this._startY = 0;
      this._delay = 500;
      this._enabled =
        UserSettings.userSettings.get("quickLinkLongPress") ||
        UserSettings.userSettings.get("quickLinkMiddleMouse");
    }

    getStartOp() {
      return this._longPressOp;
    }

    isActive() {
      return this._longPress;
    }

    longPressStart(op, e, options) {
      options = options || {};
      if (!this._enabled) return;
      if (this.isActive()) {
        this.finish(e, op);
        return;
      }
      this._removelisteners();
      this._startX = e.offsetX;
      this._startY = e.offsetY;

      // clearTimeout(this._longPressTimeout);
      this._quickAddOpStart = op;

      this._canceled = false;
      this._longPressOp = op;
      this._glOp = null;

      this._longPressStartTime = performance.now();

      setTimeout(() => {
        if (this._canceled) return;

        this._removelisteners();

        this._longPress = true;
        Gui$1.gui.patchView.focusOp(op.id);

        Gui$1.gui.patchView.showDefaultPanel();
      }, options.delay || this._delay);

      this._listenerUp = this._longpressup.bind(this);
      document.addEventListener("pointerup", this._listenerUp);
      this._listenerDown = this._longpressmove.bind(this);
      document.addEventListener("pointermove", this._listenerDown);
    }

    _removelisteners() {
      if (!this._enabled) return;
      if (this._listenerUp) {
        document.removeEventListener("pointerup", this._listenerUp);
        this._listenerUp = null;
      }
      if (this._listenerDown) {
        document.removeEventListener("pointermove", this._listenerDown);
        this._listenerDown = null;
      }
    }

    _longpressmove(e) {
      if (!this._enabled) return;
      if (
        Math.abs(this._startY - e.offsetY) > 2 ||
        Math.abs(this._startX - e.offsetX) > 2
      )
        return this.longPressCancel();
    }

    _longpressup() {
      if (!this._enabled) return;
      this._removelisteners();
      if (performance.now() - this._longPressStartTime > this._delay) ; else {
        this._longPressStartTime = 0;
        this._canceled = true;
        this.longPressCancel();
      }
    }

    longPressCancel() {
      this._canceled = true;
      this._removelisteners();

      if (!this._longPress) return;
      let wasActive = this._longPress;

      this._longPressOp = null;
      if (this._longPress) Gui$1.gui.setCursor();
      clearTimeout(this._longPressTimeout);
      this._longPress = false;

      if (wasActive) Gui$1.gui.patchView.showDefaultPanel();
    }

    getParamPanelHtml() {
      if (!this.isActive()) return "nah";
      let html = "here we go! <br/>now select any other op!";

      html +=
        '<a onclick="Gui.gui.longPressConnector.longPressCancel();" class="icon-button button-small ">Cancel</a>';
      return html;
    }

    finish(mouseEvent, op2) {
      const op1 = this._longPressOp;
      const suggestions = [];

      this._longPressStartTime = 0;

      if (!op1 || !op2) return;

      this.longPressCancel();

      for (let j = 0; j < op1.portsOut.length; j++) {
        const p = op1.portsOut[j];

        const numFitting = op2.countFittingPorts(p);
        let addText = "...";
        if (numFitting > 0) {
          if (numFitting == 1) {
            const p2 = op2.findFittingPort(p);
            addText = p2.title;
          }

          suggestions.push({
            p,
            name:
              p.title + '<span class="icon icon-arrow-right"></span>' + addText,
            classname: "port_text_color_" + p.getTypeString().toLowerCase(),
          });
        }
      }

      if (suggestions.length === 0) {
        notify("can not link!");
        return;
      }

      function showSuggestions2(id) {
        const p = suggestions[id].p;
        const sugIn = [];

        for (let i = 0; i < op2.portsIn.length; i++) {
          if (CABLES.Link.canLink(op2.portsIn[i], p)) {
            sugIn.push({
              p: op2.portsIn[i],
              name:
                '<span class="icon icon-arrow-right"></span>' +
                op2.portsIn[i].title,
              classname:
                "port_text_color_" + op2.portsIn[i].getTypeString().toLowerCase(),
            });
          }
        }

        if (sugIn.length == 1) {
          Gui$1.gui.corePatch().link(p.op, p.name, sugIn[0].p.op, sugIn[0].p.name);
          return;
        }

        new SuggestionDialog(sugIn, op2, mouseEvent, null, function (sid) {
          Gui$1.gui
            .corePatch()
            .link(p.op, p.name, sugIn[sid].p.op, sugIn[sid].p.name);
        });
      }

      if (suggestions.length == 1) showSuggestions2(0);
      else
        new SuggestionDialog(
          suggestions,
          op1,
          mouseEvent,
          null,
          showSuggestions2,
          false,
        );
    }

    glRender(glpatch, cgl, resX, resY, scrollX, scrollY, zoom, mouseX, mouseY) {
      if (!this._longPress) return;

      if (!this._glLineDrawer) {
        this._glLineDrawer = new GlSplineDrawer(cgl);
        this._glLineIdx = this._glLineDrawer.getSplineIndex();
      }

      if (this._glOp === null) this._glOp = glpatch.getGlOp(this._longPressOp);
      const coord = glpatch.viewBox.screenToPatchCoord(mouseX, mouseY);

      this._glLineDrawer.setSpline(this._glLineIdx, [
        this._longPressOp.uiAttribs.translate.x + this._glOp._width / 2,
        this._longPressOp.uiAttribs.translate.y + this._glOp._height / 2,
        0,
        coord[0],
        coord[1],
        -1111.1,
      ]);
      this._glLineDrawer.setSplineColor(this._glLineIdx, [1, 1, 1, 1]);
      this._glLineDrawer.render(resX, resY, scrollX, scrollY, zoom);
    }
  }

  class CanvasUi {
    constructor(cg) {
      this._cg = cg;

      this.isCanvasFocussed = false;
      this.minimized = false;

      this._elCanvasIconbarContainer =
        this._elCanvasIconbarContainer || ele.byId("canvasicons");
      this._elCanvasIconbar = this._elCanvasIconbar || ele.byId("canvasIconBar");
      this._elcanvasCtxSwitcher =
        this._elcanvasCtxSwitcher || ele.byId("canvasCtxSwitcher");
      this._elCanvasInfoSize =
        this._elCanvasInfoSize || ele.byId("canvasInfoSize");
      this._elSplitterPatch = this._elSplitterPatch || ele.byId("splitterPatch");
      this._elCanvasInfoFps =
        this._elCanvasInfoFps || document.getElementById("canvasInfoFPS");
      this._elCtxSwitcher =
        this._elCtxSwitcher || document.getElementById("canvasCtxSwitcher");

      this._elCanvasInfoMs =
        this._elCanvasInfoMs || document.getElementById("canvasInfoMS");
      this._elInfoVersion = ele.byId("canvasInfoVersion");

      this._elCanvasInfoSizeOverlay = ele.byId("canvasInfoOverlay");

      this._elCanvasIconbarContainer.addEventListener("click", () => {
        this.canvasEle.focus();
      });

      this._elCanvasInfoSize.addEventListener("pointerenter", () => {
        this._elCanvasInfoSizeOverlay.style.top =
          this._elCanvasInfoSize.getBoundingClientRect().y + 30 + "px";
        this._elCanvasInfoSizeOverlay.style.left =
          this._elCanvasInfoSize.getBoundingClientRect().x + "px";
        // this._elCanvasInfoSizeOverlay.innerHTML = "";
        this._elCanvasInfoSizeOverlay.classList.remove("hidden");
      });
      this._elCanvasInfoSize.addEventListener("pointerleave", () => {
        this._elCanvasInfoSizeOverlay.classList.add("hidden");
      });

      if (this._elInfoVersion) {
        if (this._cg.glVersion == 1) {
          this._elCanvasInfoVer =
            this._elCanvasInfoVer || document.getElementById("canvasInfoVersion");
          this._elCanvasInfoVer.innerHTML = "WebGL 1";
        } else this._elInfoVersion.remove();
      }

      this.canvasEle = this._cg.canvas;

      cg.on("resize", () => {
        this.updateSizeDisplay();
      });

      cg.fpsCounter.on("performance", (perf) => {
        const p = Gui$1.gui.uiProfiler.start("[canvasUi] on performance");

        // if (this.isCanvasFocussed)
        // {
        if (this._oldFps != perf.fps)
          this._elCanvasInfoFps.innerHTML = perf.fps + " FPS";
        this._oldFps = perf.fps;

        if (this._cg.profileData) {
          let ms =
            (Math.round(this._cg.profileData.profileOnAnimFrameOps * 100) / 100 ||
              "0.0") + "ms";

          if (
            window.gui &&
            Gui$1.gui.patchView.patchRenderer.vizLayer &&
            Gui$1.gui.patchView.patchRenderer.vizLayer.renderMs > 3
          ) {
            ms +=
              " vizLayer: " +
              Math.round(Gui$1.gui.patchView.patchRenderer.vizLayer.renderMs) +
              "ms";
          }

          if (this._oldMs != ms) this._elCanvasInfoMs.innerHTML = ms;
          this._oldMs = ms;
        }
        // }

        p.finish();
      });

      this.canvasEle.setAttribute("tabindex", 0);

      this.canvasEle.addEventListener("focus", () => {
        const p = Gui$1.gui.uiProfiler.start("[canvasUi] on focus");

        this.showCanvasModal(true);
        Gui$1.gui.canvasManager.setCurrentCanvas(this.canvasEle);
        p.finish();
      });

      document.body.addEventListener(
        "pointerdown",
        (e) => {
          if (
            this.isCanvasFocussed &&
            !e.target.classList.contains("item") &&
            !e.target.classList.contains("icon") &&
            e.target != this.canvasEle
          )
            this.showCanvasModal(false);
        },
        true,
      );
    }

    get canvasMode() {
      return Gui$1.gui._canvasMode;
    }

    updateCanvasIconBar() {
      if (!this._elCanvasIconbarContainer) return;

      const perf = Gui$1.gui.uiProfiler.start("[canvasUi] updateCanvasIconBar");

      this._elSplitterPatch.getBoundingClientRect();
      document.body.getBoundingClientRect();

      perf.finish();
    }

    updateSizeDisplay() {
      if (!Gui$1.gui.corePatch().cgl) return;

      const canvas = Gui$1.gui.canvasManager.currentCanvas();

      const ctx = Gui$1.gui.canvasManager.currentContext();

      this._elCanvasInfoAspect =
        this._elCanvasInfoAspect || document.getElementById("canvasInfoAspect");

      let sizeStr = canvas.width + "x" + canvas.height;
      if (ctx.pixelDensity != 1)
        sizeStr += " (" + Math.round(ctx.pixelDensity * 100) / 100 + "x)";

      Gui$1.gui.canvasManager.updateCanvasUi();

      if (this._oldSizeStr != sizeStr) this._elCanvasInfoSize.innerHTML = sizeStr;
      this._oldSizeStr = sizeStr;

      this.updateIconState();

      let str = "<table>";
      str += "<tr><td>Canvas API</td><td>" + ctx.getGApiName() + "</td></tr>";
      str += "<tr><td>Canvas id</td><td>" + canvas.id + "</td></tr>";
      str +=
        "<tr><td>Canvas CSS Size:</td><td><code>" +
        canvas.clientWidth +
        "&nbsp;x&nbsp;" +
        canvas.clientHeight +
        "</td></tr>";
      str +=
        "<tr><td>Canvas Pixel Size:</td><td><code>" +
        canvas.width +
        " x " +
        canvas.height +
        "</td></tr>";
      str +=
        "<tr><td>Device Pixel Ratio/Density:</td><td><code>" +
        window.devicePixelRatio +
        "</td></tr>";
      str +=
        "<tr><td>Canvas Pixel Ratio/Density:</td><td><code>" +
        ctx.pixelDensity +
        "</td></tr>";
      str += "</table>";
      this._elCanvasInfoSizeOverlay.innerHTML = str;

      return sizeStr;
    }

    updateIconState() {
      const act = UserSettings.userSettings.get("overlaysShow");
      const icon = ele.byId("canvUitoggleOverlay");
      if (icon)
        if (act) icon.style.backgroundColor = "var(--color-special)";
        else icon.style.backgroundColor = "var(--color-07)";
    }

    showCanvasModal(_show) {
      if (UserSettings.userSettings.get("hideCanvasUi")) return;

      const perf = Gui$1.gui.uiProfiler.start("[canvasUi] showCanvasModal");

      this._elCanvasModalDarkener =
        this._elCanvasModalDarkener || document.getElementById("canvasmodal");

      this.updateSizeDisplay();
      this.updateCanvasIconBar();

      this.isCanvasFocussed = _show;
      if (this.isCanvasFocussed) this._elCanvasIconbar.classList.remove("hidden");
      else this._elCanvasIconbar.classList.add("hidden");

      if (_show) {
        if (
          Gui$1.gui.canvasManager.mode == Gui$1.gui.canvasManager.CANVASMODE_PATCHBG
        ) {
          ele.hide(this._elCanvasModalDarkener);
        } else {
          if (!this._showing) ele.show(this._elCanvasModalDarkener);
        }

        // if (!this._showing) ele.show(this._elCanvasIconbarContainer);

        // const sizeStr = this.getCanvasSizeString();

        // if (sizeStr != this._oldSizeStr) this._elCanvasInfoSize.innerHTML = sizeStr;
        // this._oldSizeStr = sizeStr;
      } else {
        setTimeout(() => {
          // ele.hide(this._elCanvasIconbarContainer);
          ele.hide(this._elCanvasModalDarkener);
        }, 100);
      }

      this._showing = _show;

      perf.finish();
    }
  }

  class CanvasManager {
    constructor() {
      this._curContextIdx = 0;
      this._contexts = [];
      this.subWindow = null;
      this._menuEle = null;

      this.CANVASMODE_NORMAL = 0;
      this.CANVASMODE_PATCHBG = 1;
      this.CANVASMODE_FULLSCREEN = 2;
      this.CANVASMODE_POPOUT = 3;

      this._canvasMode = this.CANVASMODE_NORMAL;

      window.addEventListener("beforeunload", () => {
        if (this.subWindow) this.subWindow.close();
      });
    }

    set mode(m) {
      const hasChanged = m != this._canvasMode;
      this._canvasMode = m;

      if (m == this.CANVASMODE_POPOUT) {
        this.popOut();
      } else {
        Gui$1.gui.emitEvent("canvasModeChange", this._canvasMode);
        if (hasChanged) Gui$1.gui.setLayout();
        Gui$1.gui.corePatch().cgl.updateSize();
      }
    }

    get mode() {
      return this._canvasMode;
    }

    /**
     * @returns {CgContext}
     */
    currentContext() {
      return this._contexts[this._curContextIdx];
    }

    currentCanvas() {
      if (!this._contexts[this._curContextIdx]) return null;
      return this._contexts[this._curContextIdx].canvas;
    }

    /**
     * @param {CgContext} c
     */
    addContext(c) {
      for (let i = 0; i < this._contexts.length; i++)
        if (this._contexts[i] == c) return;

      if (!c.canvasUi) c.canvasUi = new CanvasUi(c);

      this._contexts.push(c);
      this._curContextIdx = this._contexts.length - 1;

      const ctx = c;
      Gui$1.gui.cmdPallet.addDynamic(
        "canvas",
        "canvas " + ctx.getGApiName(),
        () => {
          ctx.canvas.focus();
        },
        "cables",
      );
    }

    getCanvasUiBar() {
      if (!this._contexts[this._curContextIdx]) return null;
      return this._contexts[this._curContextIdx].canvasUi;
    }

    blur() {
      if (this.currentCanvas()) this.currentCanvas().blur();
    }

    focus() {
      if (this.currentCanvas()) this.currentCanvas().focus();
      this.updateCanvasUi();
    }

    updateCanvasUi() {
      if (!this._menuEle) this._menuEle = ele.byId("canvasCtxSwitcher");

      if (this._menuEle) {
        for (let i = 0; i < this._contexts.length; i++) {
          if (this._contexts[i].canvas == this.currentCanvas()) {
            this._menuEle.innerText = this._contexts[i].getGApiName();
          }
        }
      }
    }

    setCurrentCanvas(canv) {
      for (let i = 0; i < this._contexts.length; i++) {
        if (this._contexts[i].canvas == canv) {
          this._curContextIdx = i;
          this._contexts[i].canvas.style["z-index"] = 0;
        } else this._contexts[i].canvas.style["z-index"] = -1;
      }

      this.updateCanvasUi();
    }

    setSize(w, h) {
      for (let i = 0; i < this._contexts.length; i++) {
        this._contexts[i].pixelDensity;
        this._contexts[i].canvas;

        this._contexts[i].setSize(w, h);
      }
    }

    screenShot(cb, mimeType = "image/png", quality = 1) {
      if (this.currentCanvas() && this.currentCanvas().toBlob) {
        const url = this.currentCanvas().toDataURL();
        console.log(url);
        //         (blob) =>//
        //         {
        //             if (cb) cb(blob);
        //             else this._log.log("no screenshot callback...");
        //         }, mimeType, quality);
      } else {
        console.log("canvasmanager no current canvas");
        cb(null);
      }
    }

    menu(ele) {
      let items = [];

      for (let i = 0; i < this._contexts.length; i++) {
        const ctx = this._contexts[i];
        items.push({
          title: i + ": " + ctx.getGApiName(),
          func: () => {
            ctx.canvas.focus();
            this.updateCanvasUi();
          },
        });
      }

      this._menuEle = ele;
      this.updateCanvasUi();

      contextMenu.show({ items: items }, ele);
    }

    popOut() {
      if (this._canvasMode === this.CANVASMODE_POPOUT) {
        if (this.subWindow) {
          this.subWindow.focus();
        }
        return;
      }
      if (this.subWindow) {
        // this leads to problems with internally registered electron listeners
        // so we close and ignore errors (as that works, even in electron)
        try {
          this.subWindow.close();
        } catch (e) {}
        this.subWindow = null;
      }
      let id = CABLES.uuid();
      this.subWindow = window.open(
        "",
        "view#" + id,
        "width=" +
          500 +
          ",height=" +
          500 +
          ",directories=0,titlebar=0,toolbar=0,location=0,status=0,menubar=0,scrollbars=no,resizable=yes,popup=true",
      );
      if (!this.subWindow) return;
      let nDocument = this.subWindow.document;
      nDocument.title = "cables";

      let nBody = nDocument.body;

      Gui$1.gui.corePatch().emitEvent("windowChanged", this.subWindow);

      const style = document.createElement("style");
      style.innerHTML =
        "body{padding:0;margin:0;background-color:black;overflow:hidden;color:#aaa;font-family:arial;}" +
        "#glcanvas{position:absolute;}" +
        ":focus{outline:unset;}";
      nBody.appendChild(style);

      // <link rel="stylesheet" type="text/css" media="all" href="css/style-dark.css">

      nBody.classList.add("cablesCssUi");

      const containerEle = nDocument.createElement("div");

      containerEle.classList.add("bgpatternDark");
      containerEle.classList.add("bgPatternDark");
      containerEle.style.width = "100%";
      containerEle.style.height = "100%";
      nBody.appendChild(containerEle);

      containerEle.id = "cablescanvas";

      // const base = document.createElement("base");
      // base.setAttribute("href", "https://meineSeite.de/");
      // document.head.appendChild(base);

      const p = Gui$1.gui.corePatch().cgl.canvas.parentElement;

      while (p.childNodes.length > 0) {
        containerEle.appendChild(p.childNodes[0]);
      }

      // const cablesEles = document.body.getElementsByClassName("cablesEle");
      // for (let i = 0; i < cablesEles.length; i++)nBody.appendChild(cablesEles[i]);

      while (document.body.getElementsByClassName("cablesEle").length > 0) {
        nBody.appendChild(document.body.getElementsByClassName("cablesEle")[0]);
      }

      this.subWindow.addEventListener("resize", () => {
        // console.log(this.subWindow.innerWidth, this.subWindow.innerHeight);
        gui
          .corePatch()
          .cgl.setSize(this.subWindow.innerWidth, this.subWindow.innerHeight);
        Gui$1.gui.corePatch().cgl.updateSize();
      });

      this.subWindow.addEventListener("beforeunload", () => {
        while (containerEle.childNodes.length > 0) {
          p.appendChild(containerEle.childNodes[0]);
        }

        while (nBody.getElementsByClassName("cablesEle").length > 0) {
          document.body.appendChild(nBody.getElementsByClassName("cablesEle")[0]);
        }
        // for (let i = 0; i < ncablesEles.length; i++)

        Gui$1.gui.corePatch().cgl.updateSize();
        this._canvasMode = this.CANVASMODE_NORMAL;
        Gui$1.gui.setLayout();
      });

      this._canvasMode = this.CANVASMODE_POPOUT;
      Gui$1.gui.emitEvent("canvasModeChange", this._canvasMode);

      Gui$1.gui.setLayout();
    }
  }

  /**
   * gui restrictions,e.g. show an editor to the user, the user can  make changes etc.
   *
   * @export
   * @class GuiRestrictions
   */
  class GuiRestrictions {
    constructor() {
      this._restrictionMultiplayer = 0;
      this._restrictionBlueprint = 0;
      this._messages = {};

      this._restrictionDialog = ele.byId("restriction_container");
      this._messageBox = ele.byId("restriction_message");

      ele.clickable(ele.byId("restriction_close"), () => {
        this._restrictionDialog.classList.add("hidden");
      });
    }

    hide() {
      this._restrictionDialog.classList.add("hidden");
    }

    get visible() {
      return Object.keys(this._messages).length > 0;
    }

    /**
     * @param {String} id
     * @param {String} msg
     */
    setMessage(id, msg = null) {
      if (!msg) {
        delete this._messages[id];
        const hasKeys = Object.keys(this._messages);

        if (hasKeys.length > 0) {
          msg = this._messages[Object.keys(this._messages)];
        }
      } else this._messages[id] = msg;

      this._messageBox.innerHTML = msg;

      if (msg) this._restrictionDialog.classList.remove("hidden");
      else this._restrictionDialog.classList.add("hidden");
    }
  }

  /**
   * treeview, e.g. for patch outline
   *
   * @export
   * @class TreeView
   * @extends {Events}
   */
  class TreeView extends Events {
    constructor() {
      super();
      this._clickListenerIds = [];
    }

    html(data) {
      this._clickListenerIds = [];
      this._data = data;
      return this._html(data);
    }

    _html(data = [], level = 0, html = "") {
      if (level == 0) html = ' <table class="table treetable">';

      data.sort((a, b) => {
        return a.order.localeCompare(b.order, "en", { sensitivity: "base" });
      });

      for (let i = 0; i < data.length; i++) {
        if (!data[i]) continue;
        const item = data[i];
        html += '<tr class="' + (data[i].rowClass || "") + '">';
        html += "<td>";

        for (let j = 0; j < level; j++) {
          html +=
            '<span style="border-right:2px solid #555;margin-right:9px;width:8px;display:block;float:left;height:20px;;"></span>';

          if (level == j)
            if (item.hasOwnProperty("childs") && item.childs.length > 0)
              html +=
                '<span class="icon icon-chevron-down" style="margin-right:3px;"></span>';
            else
              html +=
                '<span style="border-right:2px solid #555;margin-right:9px;width:8px;display:block;float:left;height:20px;"></span>';
        }

        const icon = data[i].icon || "empty";

        let style = "";
        if (data[i].iconBgColor)
          style = "background-color:" + data[i].iconBgColor;

        html +=
          '<span id="icon_' +
          item.id +
          '" data-eletype="icon" class="icon icon-' +
          icon +
          ' iconhover" style="' +
          style +
          '"></span>';

        html += "&nbsp;&nbsp;";

        html += '<a id="title_' + item.id + '" data-eletype="title" class="">';
        html += item.title;
        html += "</a>";

        html += "</td>";

        html += "<td>";

        html +=
          '  <span id="threedots_' +
          item.id +
          '" data-eletype="threedots" class="icon icon-three-dots iconhover"></span>';
        html += "</td>";
        html += "</tr>";

        if (item.hasOwnProperty("childs") && item.childs.length > 0)
          html += this._html(item.childs, level + 1);

        this._clickListenerIds["icon_" + item.id] = data[i];
        this._clickListenerIds["title_" + item.id] = data[i];
        this._clickListenerIds["threedots_" + item.id] = data[i];
      }

      if (level == 0) html += "</table>";

      return html;
    }

    bindListeners() {
      for (const i in this._clickListenerIds) {
        const el = ele.byId(i);
        if (el) {
          el.addEventListener("click", (event) => {
            const el2 = event.target;
            const eletype = el2.dataset.eletype;
            this.emitEvent(
              eletype + "_click",
              this._clickListenerIds[i],
              el2,
              event,
            );
          });

          el.addEventListener("dblclick", (event) => {
            const el2 = event.target;
            const eletype = el2.dataset.eletype;
            this.emitEvent(
              eletype + "_dblclick",
              this._clickListenerIds[i],
              el2,
              event,
            );
          });
        } else console.log("ele not found", this._clickListenerIds[i]);
      }
    }
  }

  /**
   * Helper functions
   *
   */

  String.prototype.endl = function () {
    return this + "\n";
  };

  function escapeHTML(string) {
    string = String(string) || "";
    const htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
    };
    const reUnescapedHtml = /[&<>"']/g;
    const reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

    return string && reHasUnescapedHtml.test(string)
      ? string.replace(reUnescapedHtml, function (chr) {
          return htmlEscapes[chr];
        })
      : string || "";
  }

  class PatchOutline extends Events {
    constructor() {
      super();

      this._log = new Logger("PatchOutline");
      this.includeAreas =
        this.includeSubpatches =
        this.includeComments =
        this.includeCommented =
        this.includeBookmarks =
        this.includeAnimated =
        this.includeColored =
          true;

      this._listeningSubs = false;
      this._subTree = new TreeView();

      this._subTree.on("threedots_click", (item, el) => {
        this.subPatchContextMenu(item, el);
      });

      this._subTree.on("title_dblclick", (item, el, event) => {
        if (
          item.subPatchId &&
          Gui$1.gui.patchView.getSelectedOps() &&
          Gui$1.gui.patchView.getSelectedOps().length > 0 &&
          Gui$1.gui.patchView.getSelectedOps()[0].id == item.id
        )
          Gui$1.gui.patchView.clickSubPatchNav(item.subPatchId);
      });

      this._subTree.on("title_click", (item, el, event) => {
        if (item.id) {
          if (event.shiftKey) {
            return Gui$1.gui.opParams.show(item.id);
          }

          if (
            Gui$1.gui.patchView.getSelectedOps().length > 0 &&
            Gui$1.gui.patchView.getSelectedOps()[0].id == item.id
          )
            Gui$1.gui.opParams.show(item.id);

          Gui$1.gui.patchView.centerSelectOp(item.id);
        } else this._log.warn("unknown", item);
      });

      this._subTree.on("icon_click", (item) => {
        Gui$1.gui.patchView.centerSelectOp(item.id);
        Gui$1.gui.opParams.show(item.id);
      });
    }

    deserialize(p) {
      if (!p || !p.ui || !p.ui.outline) return;

      const outlineCfg = p.ui.outline;

      this.includeBookmarks = outlineCfg.includeBookmarks;
      this.includeSubpatches = outlineCfg.includeSubpatches;
      this.includeCommented = outlineCfg.includeCommented;
      this.includeComments = outlineCfg.includeComments;
      this.includeAreas = outlineCfg.includeAreas;
      this.includeColored = outlineCfg.includeColored;

      this.updateFilterUi();
    }

    serialize(obj) {
      const outlineCfg = {};

      outlineCfg.includeBookmarks = this.includeBookmarks;
      outlineCfg.includeSubpatches = this.includeSubpatches;
      outlineCfg.includeCommented = this.includeCommented;
      outlineCfg.includeComments = this.includeComments;
      outlineCfg.includeAreas = this.includeAreas;
      outlineCfg.includeColored = this.includeColored;

      obj.outline = outlineCfg;
    }

    updateFilterUi() {
      if (!ele.byId("subtreeFilterBookmarks")) return;

      if (this.includeBookmarks)
        ele.byId("subtreeFilterBookmarks").classList.add("findToggleActive");
      else
        ele.byId("subtreeFilterBookmarks").classList.remove("findToggleActive");

      if (this.includeSubpatches)
        ele.byId("subtreeFilterSubPatchOps").classList.add("findToggleActive");
      else
        ele.byId("subtreeFilterSubPatchOps").classList.remove("findToggleActive");

      if (this.includeCommented)
        ele.byId("subtreeFilterCommented").classList.add("findToggleActive");
      else
        ele.byId("subtreeFilterCommented").classList.remove("findToggleActive");

      if (this.includeComments)
        ele.byId("subtreeFilterComments").classList.add("findToggleActive");
      else ele.byId("subtreeFilterComments").classList.remove("findToggleActive");

      if (this.includeAreas)
        ele.byId("subtreeFilterAreas").classList.add("findToggleActive");
      else ele.byId("subtreeFilterAreas").classList.remove("findToggleActive");

      if (this.includeColored)
        ele.byId("subtreeFilterColored").classList.add("findToggleActive");
      else ele.byId("subtreeFilterColored").classList.remove("findToggleActive");
    }

    isCurrentlyVisible() {
      return !!ele.byId("_cbl_outlinetree");
    }

    insert(id = "_cbl_outlinetree") {
      if (!this._listeningSubs) {
        this._listeningSubs = true;
        Gui$1.gui.corePatch().on("subpatchesChanged", () => {
          if (this.isCurrentlyVisible()) this.insert();
        });

        Gui$1.gui.on("multiUserSubpatchChanged", (_clientId, _subPatch) => {
          if (this.isCurrentlyVisible()) this.insert();
        });
      }

      let html = "<h3>Patch Outline</h3>";
      html += '<div style="margin-bottom:5px;">';
      html +=
        '<a id="subtreeFilterBookmarks" class="iconbutton findToggle tt info" data-info="outline_filter_bookmarks" data-tt="bookmarks" style="padding:3px;padding-bottom:0;" onclick=""><span class="icon icon-bookmark"></span></a>';
      html +=
        '<a id="subtreeFilterSubPatchOps" class="iconbutton findToggle tt info" data-info="outline_filter_subpatchops" data-tt="subpatchops" style="padding:3px;padding-bottom:0;" onclick=""><span class="icon icon-folder"></span></a>';
      html +=
        '<a id="subtreeFilterCommented" class="iconbutton findToggle tt info" data-info="outline_filter_commented" data-tt="commented" style="padding:3px;padding-bottom:0;" onclick=""><span class="icon icon-message"></span></a>';
      html +=
        '<a id="subtreeFilterComments" class="iconbutton findToggle tt info" data-info="outline_filter_comments" data-tt="comments" style="padding:3px;padding-bottom:0;" onclick=""><span class="icon icon-message-square-text"></span></a>';
      html +=
        '<a id="subtreeFilterAreas" class="iconbutton findToggle tt info" data-info="outline_filter_areas" data-tt="areas" style="padding:3px;padding-bottom:0;" onclick=""><span class="icon icon-box-select"></span></a>';
      html +=
        '<a id="subtreeFilterColored" class="iconbutton findToggle tt info" data-info="outline_filter_colored" data-tt="colored ops" style="padding:3px;padding-bottom:0;" onclick=""><span class="icon icon-picker"></span></a>';
      html += "</div>";

      const su = this._getSubPatchesHierarchy();

      html += this._subTree.html(su);

      let el = ele.byId(id);
      if (!el) {
        this._log.warn("no ele for outliner");
        return;
      }
      el.innerHTML = html;
      this._subTree.bindListeners();

      ele.byId("subtreeFilterBookmarks").addEventListener("click", () => {
        this.includeBookmarks = !this.includeBookmarks;
        this.updateFilterUi();
        this.insert();
      });
      ele.byId("subtreeFilterSubPatchOps").addEventListener("click", () => {
        this.includeSubpatches = !this.includeSubpatches;
        this.updateFilterUi();
        this.insert();
      });
      ele.byId("subtreeFilterCommented").addEventListener("click", () => {
        this.includeCommented = !this.includeCommented;
        this.updateFilterUi();
        this.insert();
      });
      ele.byId("subtreeFilterComments").addEventListener("click", () => {
        this.includeComments = !this.includeComments;
        this.updateFilterUi();
        this.insert();
      });
      ele.byId("subtreeFilterAreas").addEventListener("click", () => {
        this.includeAreas = !this.includeAreas;
        this.updateFilterUi();
        this.insert();
      });
      ele.byId("subtreeFilterColored").addEventListener("click", () => {
        this.includeColored = !this.includeColored;
        this.updateFilterUi();
        this.insert();
      });

      this.updateFilterUi();
    }

    _sanitizeComment(_cmt) {
      let cmt = escapeHTML(_cmt);

      if (cmt.length > 30) cmt = cmt.substring(0, 30) + "...";

      return cmt;
    }

    _getUserImagesStringSubpatch(patchId) {
      let str = "";
      if (!Gui$1.gui.socket) return "";
      const userIds = Gui$1.gui.socket.state.getUserInSubpatch(patchId);

      for (let i = 0; i < userIds.length; i++) {
        str +=
          "<img style='height:15px;border-radius:100%;margin-left:10px;' src=\"" +
          platform.getCablesUrl() +
          "/api/avatar/" +
          userIds[i] +
          '/mini"/>';
      }

      return str;
    }

    _getSubPatchesHierarchy(patchId = 0) {
      let mainTitle = "Patch ";
      if (!Gui$1.gui.savedState.isSavedSubPatch(0)) mainTitle += " (*) ";

      mainTitle += this._getUserImagesStringSubpatch(0);

      let sub = {
        title: mainTitle,
        id: "0",
        order: 0,
        subPatchId: "0",
        childs: [],
        icon: "folder",
      };

      if (Gui$1.gui.patchView.getCurrentSubPatch() == 0) sub.rowClass = "active";

      let subs = [sub];

      if (patchId) {
        const subOp = Gui$1.gui.patchView.getSubPatchOuterOp(patchId);
        if (!subOp) return;
        sub.title = subOp.getTitle();
        sub.id = subOp.id;
        if (!Gui$1.gui.savedState.isSavedSubPatch(patchId)) sub.title += " (*) ";

        sub.title += this._getUserImagesStringSubpatch(patchId);

        // html += "!!";

        if (subOp.uiAttribs.comment)
          sub.title +=
            ' <span style="color: var(--color-special);">// ' +
            this._sanitizeComment(subOp.uiAttribs.comment) +
            "</span>";

        sub.subPatchId = patchId;
        sub.id = subOp.id;
        if (subOp.uiAttribs && subOp.uiAttribs.translate)
          sub.order =
            subOp.getTitle() +
            subOp.uiAttribs.translate.x * subOp.uiAttribs.translate.y;
        else sub.order = subOp.getTitle();

        sub.subPatchVer = subOp.storage.subPatchVer || 0;

        if (Gui$1.gui.patchView.getCurrentSubPatch() == sub.subPatchId)
          sub.rowClass = "active";
        else sub.rowClass = "";

        if (subOp.isSubPatchOp() || subOp.isInBlueprint2()) {
          sub.blueprintVer = subOp.isSubPatchOp();
          sub.icon = "folder";
        }
      }

      const ops = Gui$1.gui.patchView.getAllSubPatchOps(patchId || 0);

      for (let i = 0; i < ops.length; i++) {
        let included = false;

        if (
          this.includeSubpatches &&
          ops[i].patchId &&
          ops[i].patchId.get() !== 0
        )
          included = true;
        if (this.includeColored && ops[i].uiAttribs.color) included = true;
        if (
          this.includeAreas &&
          ops[i].objName.indexOf(defaultOps.defaultOpNames.uiArea) > -1
        )
          included = true;
        if (this.includeBookmarks && ops[i].uiAttribs.bookmarked) included = true;
        if (this.includeComments && ops[i].uiAttribs.comment_title)
          included = true;
        if (this.includeCommented && ops[i].uiAttribs.comment) included = true;

        if (included) {
          if (ops[i].patchId && ops[i].patchId.get() !== 0) {
            sub.childs.push(this._getSubPatchesHierarchy(ops[i].patchId.get()));
          } else {
            let icon = "bookmark";
            if (this.includeCommented && ops[i].uiAttribs.comment)
              icon = "message";
            if (this.includeColored && ops[i].uiAttribs.color) icon = "op";
            if (
              this.includeComments &&
              ops[i].objName.indexOf("Ops.Ui.Comment") > -1 &&
              ops[i].uiAttribs.comment_title
            )
              icon = "message-square-text";
            if (this.includeAreas && ops[i].objName.indexOf("Ops.Ui.Area") > -1)
              icon = "box-select";

            let title = ops[i].uiAttribs.comment_title || ops[i].getTitle();
            if (ops[i].uiAttribs.comment)
              title +=
                ' <span style="color: var(--color-special);">// ' +
                this._sanitizeComment(ops[i].uiAttribs.comment) +
                "</span>";

            sub.childs.push({
              title: title,
              icon: icon,
              id: ops[i].id,
              order: title + ops[i].id,
              iconBgColor: ops[i].uiAttribs.color,
            });
          }
        }
      }

      if (patchId == 0) return subs;
      else return sub;
    }

    subPatchContextMenu(item, el) {
      const items = [];
      items.push({
        title: "Rename",
        func() {
          Gui$1.gui.patchView.focusSubpatchOp(item.subPatchId);
          CABLES.CMD.PATCH.setOpTitle();
        },
      });

      if (item.subPatchVer == "2" && item.blueprintVer != 2)
        items.push({
          title: "Create op from subpatch",
          func() {
            subPatchOpUtil.createBlueprint2Op(item.subPatchId);
          },
        });

      if (item.blueprintVer == 2) {
        items.push({
          title: "Save Op",
          func() {
            const op = Gui$1.gui.patchView.getSubPatchOuterOp(item.subPatchId);

            subPatchOpUtil.updateSubPatchOpAttachment(op, {
              oldSubId: item.subPatchId,
            });
          },
        });
      }
      contextMenu.show({ items }, el);
    }
  }

  /**
   * default panel when clicking into the pach background, shows patch summary and tree view
   *
   * @export
   * @class PatchPanel
   * @extends {Events}
   */
  class PatchPanel extends Events {
    constructor() {
      super();

      this._firstTime = true;
      this._outline = new PatchOutline();
    }

    deserialize(obj) {
      this._outline.deserialize(obj);
    }

    serialize(obj) {
      this._outline.serialize(obj);
    }

    show(force) {
      if (!Gui$1.gui.finishedLoading()) return;

      if (this._firstTime) {
        Gui$1.gui.corePatch().buildSubPatchCache();
        this._firstTime = false;
      }

      Gui$1.gui.opParams.emitEvent("opSelected", null);

      if (!force && ele.byClass("patchParamPanel")) return;

      let html = '<div class="patchParamPanel panel bookmarkpanel">';

      const project = Gui$1.gui.project();
      if (project) {
        const projectId = project.shortId || project._id;
        const isSameHost = platform.isPatchSameHost();

        let host = "";

        if (!isSameHost) host = Gui$1.gui.project().buildInfo.host;

        html += getHandleBarHtml("patch_summary", {
          projectId: projectId,
          project: project,
          frontendOptions: platform.frontendOptions,
          isTrustedPatch: platform.isTrustedPatch(),
          cablesUrl: platform.getCablesUrl(),
          sameHost: isSameHost,
          patchHost: host,
        });
      }

      html += '<br/><div id="_cbl_outlinetree"></div>';

      if (Gui$1.gui.longPressConnector.isActive()) {
        html += Gui$1.gui.longPressConnector.getParamPanelHtml();
      } else {
        Gui$1.gui.patchView.checkPatchErrors();

        if (!Gui$1.gui.bookmarks.needRefreshSubs && ele.byId("patchsummary"))
          return;
        if (!Gui$1.gui.bookmarks.needRefreshSubs && ele.byId("bookmarkpanel"))
          return;

        html += Gui$1.gui.bookmarks.getHtml();
      }

      if (ele.byId(Gui$1.gui.getParamPanelEleId()))
        ele.byId(Gui$1.gui.getParamPanelEleId()).innerHTML = html;

      if (ele.byId("btn_patch_settings"))
        ele.clickable(ele.byId("btn_patch_settings"), CABLES.CMD.UI.settings);
      if (ele.byId("btn_analyze_patch"))
        ele.clickable(ele.byId("btn_analyze_patch"), CABLES.CMD.PATCH.analyze);
      if (ele.byId("btn_toggle_patch_like"))
        ele.clickable(
          ele.byId("btn_toggle_patch_like"),
          CABLES.CMD.PATCH.togglePatchLike,
        );

      if (ele.byId("btn_patch_opendir"))
        ele.clickable(ele.byId("btn_patch_opendir"), (e) => {
          if (e.ctrlKey || e.metaKey)
            navigator.clipboard.writeText(platform.config.currentPatchDir);
          else CABLES.CMD.ELECTRON.openProjectDir();
        });

      this._outline.insert();
    }
  }

  /**
   * saved state of patch and subpatches, set orange icon if unsaved
   *
   * @export
   * @class SavedState
   * @extends {Events}
   */
  class SavedState extends Events {
    constructor() {
      super();
      this._log = new Logger("SavedState");
      this._statesSaved = {};
      this._statesInitiator = {};
      this._talkerState = null;
      this._timeout = null;
      this._addedGuiListener = false;

      window.addEventListener("beforeunload", (event) => {
        if (this.isSaved) {
          Gui$1.gui.hide();
          return;
        }
        const message = "unsaved content!";
        if (typeof event == "undefined") event = window.event;
        if (event) event.returnValue = message;
        return message;
      });
    }

    pause() {
      this._paused = true;
    }

    resume() {
      this._paused = false;
    }

    getBlueprint() {
      const sub = Gui$1.gui.patchView.getCurrentSubPatch() || 0;

      let bp = 0;

      if (sub) {
        const subOuter = Gui$1.gui.patchView.getSubPatchOuterOp(
          Gui$1.gui.patchView.getCurrentSubPatch(),
        );
        if (subOuter) bp = subOuter.isBlueprint2() || subOuter.isInBlueprint2();
      }
      return bp;
    }

    /**
     * @param {string} initiator
     * @param {string} section
     * @param {boolean} savedState
     */
    log(initiator, section, savedState) {
      this._statesInitiator[section] = this._statesInitiator[section] || [];
      this._statesInitiator[section].push({
        initiator: initiator,
        section: section,
        savedState: savedState,
      });
    }

    /**
     * @param {string} initiator
     */
    setSavedAll(initiator) {
      let changed = false;

      for (const sp in this._statesSaved) {
        if (this._statesSaved[sp] != true) changed = true;
        this._statesSaved[sp] = true;
        this.log(initiator, sp, true);
      }
      if (changed) Gui$1.gui.corePatch().emitEvent("savedStateChanged");

      Gui$1.gui.corePatch().emitEvent("subpatchesChanged");
      this.updateUi();
    }

    /**
     * @param {string} initiator
     * @param {string | number} subpatch
     */
    setSaved(initiator, subpatch) {
      if (subpatch === undefined) subpatch = 0;

      const changed = this._statesSaved[subpatch] !== true;
      if (changed) Gui$1.gui.corePatch().emitEvent("savedStateChanged");

      this._statesSaved[subpatch] = true;
      this.log(initiator, subpatch, true);
      Gui$1.gui.corePatch().emitEvent("subpatchesChanged");

      this.updateUi();
    }

    /**
     * @param {string} initiator
     * @param {string | number | boolean} subpatch
     */
    setUnSaved(initiator, subpatch) {
      if (this._paused) return;
      if (Gui$1.gui.isRemoteClient) return;

      if (subpatch === undefined)
        this._log.log("setUnSaved subpatch undefined", initiator, subpatch);

      if (subpatch === undefined) {
        subpatch = this.getBlueprint() || 0;
        // this._statesSaved[subpatch] = true;
      } else {
        let subOuter = Gui$1.gui.patchView.getSubPatchOuterOp(subpatch);
        if (!subOuter || !subOuter.isBlueprint2()) subpatch = 0;
      }
      if (subpatch === true) subpatch = 0;
      subpatch = subpatch || 0;

      const changed = this._statesSaved[subpatch] != false;

      this._statesSaved[subpatch] = false;

      this.log(initiator, subpatch, false);

      if (changed) Gui$1.gui.corePatch().emitEvent("savedStateChanged");

      if (changed) {
        Gui$1.gui.corePatch().emitEvent("subpatchesChanged");
        this.updateUiLater();

        if (!this._addedGuiListener) {
          this._addedGuiListener = true;
          Gui$1.gui.corePatch().on("subpatchesChanged", () => {
            this.updateRestrictionDisplay();
          });
        }
      }
    }

    /**
     * @param {string|number} bp
     */
    getStateBlueprint(bp) {
      if (!this._statesSaved.hasOwnProperty(bp))
        this._log.log("does not have state for ", bp);

      return this._statesSaved[bp];
    }

    getUnsavedPatchSubPatchOps() {
      const opIds = [];
      for (let i in this._statesSaved) {
        if (!this._statesSaved[i]) {
          const op = Gui$1.gui.patchView.getSubPatchOuterOp(i);

          if (op && op.objName.indexOf("Ops.Patch.") > -1)
            opIds.push({ objName: op.objName, op: op, opId: op.id, subId: i });
        }
      }
      return opIds;
    }

    updateUiLater() {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(() => {
        this.updateUi();
      }, 100);
    }

    updateUi() {
      if (this.isSaved) {
        if (this._talkerState != this.isSaved)
          platform.talkerAPI.send("setIconSaved");
        this._talkerState = this.isSaved;

        const elePatchName = ele.byId("patchname");

        if (elePatchName) {
          elePatchName.classList.remove("warning");
          ele.byId("savestates").innerHTML = "";
        }
      } else {
        if (this._talkerState != this.isSaved)
          platform.talkerAPI.send("setIconUnsaved");
        this._talkerState = this.isSaved;

        ele.byId("patchname").classList.add("warning");

        let str = "";
        for (const idx in this._statesSaved) {
          if (this._statesSaved[idx]) continue;
          let subname = Gui$1.gui.patchView.getSubPatchName(idx);

          if (!subname) {
            delete this._statesSaved[idx];
            this.updateUiLater();
            continue;
          }

          str +=
            '<li style="overflow:hidden;text-overflow:ellipsis" id="clickSave_' +
            idx +
            '"  class="warning">Unsaved:&nbsp;' +
            subname +
            "</li>";
        }
        str += '<li class="divide"></li>';
        ele.byId("savestates").innerHTML = str;

        for (const idx in this._statesSaved) {
          const el = ele.byId("clickSave_" + idx);
          if (el)
            el.addEventListener("click", () => {
              if (idx == 0) CABLES.CMD.PATCH.save();
              else
                subPatchOpUtil.updateSubPatchOpAttachment(
                  Gui$1.gui.patchView.getSubPatchOuterOp(idx),
                  { oldSubId: idx },
                );
            });
        }
      }
      this.updateRestrictionDisplay();
    }

    /**
     * @param {string} subOpName
     */
    isSavedSubOp(subOpName) {
      for (const idx in this._statesSaved) {
        let subname = Gui$1.gui.patchView.getSubPatchName(idx);
        if (subOpName == subname) return this._statesSaved[idx] !== false;
      }
      return true;
    }

    /**
     * @param {string} subPatchId
     */
    isSavedSubPatch(subPatchId) {
      return this._statesSaved[subPatchId] !== false;
    }

    updateRestrictionDisplay() {
      const subpatch = Gui$1.gui.patchView.getCurrentSubPatch();
      const exposeOp = Gui$1.gui.patchView.getSubPatchOuterOp(subpatch);

      if (exposeOp && exposeOp.patchId) {
        const ops = Gui$1.gui.corePatch().getOpsByObjName(exposeOp.objName);
        if (ops.length > 1) {
          if (
            !this.isSavedSubOp(exposeOp.objName) &&
            this.isSavedSubPatch(subpatch)
          ) {
            if (!Gui$1.gui.patchView.patchRenderer.greyOut) {
              this._log.log("updaterestrict?!");

              let theIdx = null;
              for (const idx in this._statesSaved) {
                let subname = Gui$1.gui.patchView.getSubPatchName(idx);
                if (exposeOp.objName == subname) {
                  theIdx = idx;
                  break;
                }
              }

              Gui$1.gui.restriction.setMessage(
                "cablesupdate",
                'A different reference of this SubPatchOp was changed, continue editing &nbsp; <a class="button" onclick="Gui.gui.patchView.setCurrentSubPatch(\'' +
                  theIdx +
                  "', () => { Gui.gui.restriction.setMessage('cablesupdate'); })\">here</a> ",
              );
              Gui$1.gui.patchView.patchRenderer.greyOut = true;
            }
          }
        }
      } else {
        if (Gui$1.gui.patchView.patchRenderer.greyOut) {
          Gui$1.gui.restriction.setMessage("cablesupdate", null);
          Gui$1.gui.patchView.patchRenderer.greyOut = false;
        }
      }
    }

    get isSaved() {
      for (const idx in this._statesSaved)
        if (!this._statesSaved[idx]) return false;

      return true;
    }
  }

  var colors_types = {
  	trigger: [
  		0.9411764705882353,
  		0.8196078431372549,
  		0.39607843137254894,
  		1
  	],
  	trigger_inactive: [
  		0.7529411764705882,
  		0.655686274509804,
  		0.3168627450980392,
  		1
  	],
  	num: [
  		0.3607843137254902,
  		0.7098039215686275,
  		0.6196078431372549,
  		1
  	],
  	num_inactive: [
  		0.28862745098039216,
  		0.567843137254902,
  		0.49568627450980396,
  		1
  	],
  	obj: [
  		0.7725490196078432,
  		0.403921568627451,
  		0.6705882352941177,
  		1
  	],
  	obj_inactive: [
  		0.6180392156862746,
  		0.3231372549019608,
  		0.5364705882352941,
  		1
  	],
  	string: [
  		0.8352941176470589,
  		0.44705882352941173,
  		0.44705882352941173,
  		1
  	],
  	string_inactive: [
  		0.6682352941176471,
  		0.35764705882352943,
  		0.35764705882352943,
  		1
  	],
  	array: [
  		0.5019607843137255,
  		0.5176470588235292,
  		0.8313725490196079,
  		1
  	],
  	array_inactive: [
  		0.40156862745098043,
  		0.4141176470588234,
  		0.6650980392156863,
  		1
  	],
  	dynamic: [
  		1,
  		1,
  		1,
  		1
  	]
  };
  var colors_namespaces = {
  	unknown: [
  		0.9040364583333333,
  		0.9040364583333333,
  		0.9040364583333333,
  		1
  	],
  	"Ops.Dev": [
  		0.40531249999999996,
  		0.40531249999999996,
  		0.40531249999999996,
  		1
  	],
  	"Ops.Ui": [
  		0,
  		1,
  		0.87453125,
  		1
  	],
  	"Ops.Vars": [
  		0,
  		1,
  		0.87453125,
  		1
  	],
  	"Ops.Patch": [
  		0,
  		1,
  		0.87453125,
  		1
  	],
  	"Ops.Cables": [
  		0,
  		1,
  		0.87453125,
  		1
  	],
  	"Ops.Array": [
  		0.5019607843137255,
  		0.5176470588235292,
  		0.8313725490196079,
  		1
  	],
  	"Ops.Arrays": [
  		0.5019607843137255,
  		0.5176470588235292,
  		0.8313725490196079,
  		1
  	],
  	"Ops.Points": [
  		0.5019607843137255,
  		0.5176470588235292,
  		0.8313725490196079,
  		1
  	],
  	"Ops.String": [
  		0.8352941176470589,
  		0.44705882352941173,
  		0.44705882352941173,
  		1
  	],
  	"Ops.Website": [
  		0.8352941176470589,
  		0.44705882352941173,
  		0.44705882352941173,
  		1
  	],
  	"Ops.Math": [
  		0.3607843137254902,
  		0.7098039215686275,
  		0.6196078431372549,
  		1
  	],
  	"Ops.Boolean": [
  		0.3607843137254902,
  		0.7098039215686275,
  		0.6196078431372549,
  		1
  	],
  	"Ops.Date": [
  		0.3607843137254902,
  		0.7098039215686275,
  		0.6196078431372549,
  		1
  	],
  	"Ops.Color": [
  		0.3607843137254902,
  		0.7098039215686275,
  		0.6196078431372549,
  		1
  	],
  	"Ops.Time": [
  		0.3607843137254902,
  		0.7098039215686275,
  		0.6196078431372549,
  		1
  	],
  	"Ops.Anim": [
  		0.3607843137254902,
  		0.7098039215686275,
  		0.6196078431372549,
  		1
  	],
  	"Ops.Number": [
  		0.3607843137254902,
  		0.7098039215686275,
  		0.6196078431372549,
  		1
  	],
  	"Ops.Sidebar": [
  		0.7725490196078432,
  		0.403921568627451,
  		0.6705882352941177,
  		1
  	],
  	"Ops.Json": [
  		0.7725490196078432,
  		0.403921568627451,
  		0.6705882352941177,
  		1
  	],
  	"Ops.Html": [
  		0.7725490196078432,
  		0.403921568627451,
  		0.6705882352941177,
  		1
  	],
  	"Ops.Net": [
  		0.7725490196078432,
  		0.403921568627451,
  		0.6705882352941177,
  		1
  	],
  	"Ops.WebAudio": [
  		0.7725490196078432,
  		0.403921568627451,
  		0.6705882352941177,
  		1
  	],
  	"Ops.Gl": [
  		0.9411764705882353,
  		0.8196078431372549,
  		0.39607843137254894,
  		1
  	],
  	"Ops.Trigger": [
  		0.9411764705882353,
  		0.8196078431372549,
  		0.39607843137254894,
  		1
  	],
  	"Ops.Graphics": [
  		0.9411764705882353,
  		0.8196078431372549,
  		0.39607843137254894,
  		1
  	]
  };
  var textedit = 0;
  var colors_patch = {
  	opBgRectSelected: [
  		0,
  		0,
  		0,
  		1
  	],
  	selected: [
  		0.24,
  		0.24,
  		0.24,
  		0.999140625
  	],
  	selectedCable: [
  		0.12710937499999997,
  		0.12710937499999997,
  		0.12710937499999997,
  		0.999140625
  	],
  	patchSelectionArea: [
  		0,
  		0.8581249999999998,
  		1,
  		0.2
  	],
  	opTitleExt: [
  		0.6333072916666667,
  		0.6333072916666667,
  		0.6333072916666667,
  		1
  	],
  	background: [
  		0.299921875,
  		0.299921875,
  		0.299921875,
  		1
  	],
  	opBoundsRect: [
  		0.3316145833333334,
  		0.3316145833333334,
  		0.3316145833333334,
  		1
  	],
  	opBgRect: [
  		0.18947916666666664,
  		0.18947916666666664,
  		0.18947916666666664,
  		1
  	],
  	opErrorWarning: [
  		1,
  		0.819693217277527,
  		0.0367584228515625,
  		1
  	],
  	opError: [
  		0.7742708333333334,
  		0,
  		0,
  		1
  	],
  	opErrorHint: [
  		0.5914843750000001,
  		0.5914843750000001,
  		0.5914843750000001,
  		1
  	],
  	opNotWorkingCross: [
  		1,
  		0,
  		0,
  		1
  	],
  	patchComment: [
  		1,
  		1,
  		1,
  		1
  	]
  };
  var colors_html = {
  	"text-color": [
  		0.7673697916666666,
  		0.7673697916666666,
  		0.7673697916666666,
  		0.48158854166666665
  	]
  };
  var patch = {
  	selectedOpBorderX: 44,
  	selectedOpBorderY: 44,
  	cablesWidth: 3,
  	cablesWidthSelected: 3,
  	cablesCurveY: 1,
  	cablesSubDivde: 2,
  	opStateIndicatorSize: 8,
  	fadeOutDistStart: 66,
  	fadeOutFadeDist: 33,
  	fadeOutFadeOpacity: 0.3,
  	cableButtonSize: 17
  };
  var colors_vizlayer = {
  	colorText: [
  		0.8490885416666667,
  		0.8490885416666667,
  		0.8490885416666667,
  		1
  	],
  	colorBackground: [
  		0.13333333333333333,
  		0.13333333333333333,
  		0.13333333333333333,
  		1
  	],
  	colorLineNumbers: [
  		0.37916666666666665,
  		0.37916666666666665,
  		0.37916666666666665,
  		1
  	]
  };
  var defaultTheme = {
  	colors_types: colors_types,
  	colors_namespaces: colors_namespaces,
  	textedit: textedit,
  	colors_patch: colors_patch,
  	colors_html: colors_html,
  	patch: patch,
  	colors_vizlayer: colors_vizlayer
  };

  /**
   * Opens a modal dialog and shows a loading indicator animation
   *
   * @param {String} title
   * @class
   */
  class ModalLoading {
    constructor(title) {
      this._tasks = [];
      this.options = {
        title: title,
        html: this.getHtml(),
      };

      this._dialog = new ModalDialog(this.options);
    }

    getHtml() {
      let str = "";
      if (this._tasks.length > 0) {
        str += '<div class="code">';
        for (let i = 0; i < this._tasks.length; i++) {
          str += "- " + this._tasks[i] + "<br/>";
        }
        str += "</div>";
      } else {
        str = '<div class="loading" ></div>';
      }

      return str;
    }

    setTask(txt) {
      this._tasks.push(txt);
      if (this._dialog) this._dialog.updateHtml(this.getHtml());
    }

    close() {
      this._dialog.close();
      this._dialog = null;
    }
  }

  /**
   * edit text files directly from the filemanager
   *
   * @export
   * @class FileManagerEditor
   */
  class FileManagerEditor {
    constructor() {
      editorSession.addListener("editAssetFile", (name, data) => {
        this.editAssetTextFile(data.filename, data.syntax, data.patchId);
      });
    }

    editAssetTextFile(filename, syntax, patchId) {
      patchId = patchId || Gui$1.gui.project()._id;
      let url = filename;
      if (!filename.startsWith("file:")) {
        url = platform.getSandboxUrl() + "/assets/" + patchId + "/" + filename;
      }

      if (!syntax) syntax = "text";
      if (syntax == "javascript") syntax = "js";
      if (syntax == "shader") syntax = "glsl";

      CABLES.ajax(url, (err2, _data, xhr2) => {
        const name = filename;

        const editorObj = editorSession.rememberOpenEditor(
          "editAssetFile",
          name,
          { filename: filename, patchId: patchId, syntax: syntax },
          true,
        );

        new EditorTab({
          title: name,
          content: _data,
          editorObj: editorObj,
          syntax: syntax.toLowerCase(),
          onClose: function (which) {
            if (editorSession)
              editorSession.remove(editorObj.type, editorObj.name);
          },
          onSave: function (setStatus, content) {
            Gui$1.gui.jobs().start({
              id: "saveeditorcontent" + filename,
              title: "saving file " + filename,
            });

            platform.talkerAPI.send(
              "updateFile",
              {
                fileName: filename,
                content: content,
              },
              (err3, res3) => {
                Gui$1.gui.savedState.setSaved("editorOnChangeFile");
                Gui$1.gui.jobs().finish("saveeditorcontent" + filename);
                setStatus("saved");
              },
            );
          },
          onChange: function (ev) {
            Gui$1.gui.savedState.setUnSaved("editorOnChangeFile");
          },
          onFinished: () => {
            // Gui.gui.mainTabs.activateTabByName(name);
          },
        });
      });
    }
  }

  function defaultSetting(initiator = "") {
    if (initiator == "LoadingStatus") return true;
    if (initiator == "core_port") return true;
    if (initiator == "core_op") return true;
    if (initiator.indexOf("cgl_shader") == 0) return true;
    if (initiator.indexOf("Ops.Patch") == 0) return true;
    if (initiator.indexOf("Ops.Team") == 0) return true;
    if (initiator.indexOf("Ops.User") == 0) return true;
    if (initiator.indexOf("op ") == 0) return true;
    return false;
  }

  class LogInitiator {
    constructor(initator) {
      this.initiator = initator;
      this.count = 0;
      this.time = performance.now();
      this.logs = [];
      this.print = defaultSetting(this.initiator);
    }

    log(txt) {
      this.count++;
      this.time = performance.now();
      this.logs.push(txt);
    }
  }

  class LogFilter extends Events {
    static logFilter = null;

    constructor() {
      super();
      this._warned = false;
      this._initiators = {};
      this._settings =
        JSON.parse(UserSettings.userSettings.get("loggingFilter")) || {};

      this.logs = [];

      UserSettings.userSettings.on("loaded", () => {
        this._settings =
          JSON.parse(UserSettings.userSettings.get("loggingFilter")) || {};
      });

      LogFilter.logFilter = this;
    }

    get initiators() {
      return this._initiators;
    }

    toggleFilter() {}

    shouldPrint(options) {
      const initiator = options.initiator;

      if (!this._initiators[initiator]) {
        this._initiators[initiator] = new LogInitiator(initiator);

        if (this._settings.hasOwnProperty(initiator))
          this._initiators[initiator].print = this._settings[initiator];

        this.emitEvent("initiatorsChanged");
      }

      let setting = this._initiators[initiator];

      if (!setting) return false;
      let should = setting.print;
      if (should && !this._warned) {
        this._warned = true;
        console.log(
          "[logging] some console messages are not printed - [ctrl/cmd+p logging] to change logging settings",
        );
      }

      if (options.level > 0) should = true;

      return should;
    }

    filterLog(options) {
      let level = options.level || 0;
      let initiator = options.initiator || "unknown";

      let args = [];
      for (let i = 1; i < arguments.length; i++) {
        // let lines = [txt];
        // if (txt.indexOf("\n") > -1)
        // {
        //     lines = txt.split("\n");
        //     lines.push("---");
        //     console.log("split lines!!!", this.initiator, lines);
        // }

        let a = arguments[i];

        args.push(a);
      }

      const o = {};
      for (let i in options) o[i] = options[i];
      o.args = args;
      o.initiator = initiator;
      o.level = level;
      o.time = performance.now();

      this.logs.push(o);
      while (this.logs.length > 50) this.logs.splice(0, 1);

      const should = this.shouldPrint(o);

      this._initiators[initiator].log(args[0]);
      if (o.level > 1) CABLES.CMD.DEBUG.logConsole();

      this.emitEvent("logAdded");

      return should;
    }

    getTabInfo() {
      return this._initiators;
    }

    resetSettings() {
      for (let i in this._initiators)
        this._initiators[i].print = defaultSetting(i);

      this._settings = {};
      UserSettings.userSettings.set(
        "loggingFilter",
        JSON.stringify(this._settings),
      );

      this.emitEvent("initiatorsChanged");
    }

    toggleInitiator(initiator) {
      if (!this._settings.hasOwnProperty(initiator))
        this._settings[initiator] = defaultSetting(initiator);

      this._settings[initiator] = !this._settings[initiator];

      UserSettings.userSettings.set(
        "loggingFilter",
        JSON.stringify(this._settings),
      );

      this._initiators[initiator].print = this._settings[initiator];
      this.emitEvent("initiatorsChanged");
    }
  }

  class LoggingTab extends Events {
    constructor(tabs) {
      super();
      this._tabs = tabs;
      this._logs = [];
      this.closed = false;

      this._tab = new Tab("Logging", {
        icon: "list",
        infotext: "tab_logging",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);
      this.data = { cells: this.cells, colNames: this.colNames };

      this._html();
      LogFilter.logFilter.on("initiatorsChanged", this._html.bind(this));

      this._tab.addEventListener("close", () => {
        this.closed = true;
        this.emitEvent("close");

        LogFilter.logFilter.off(this._showlogListener);
      });
    }

    _html() {
      const html = getHandleBarHtml("tab_logging", {
        user: Gui$1.gui.user,
        texts: text.preferences,
        info: LogFilter.logFilter.getTabInfo(),
      });
      this._tab.html(html);
    }

    _logLine(log, txt, level) {
      let html = '<div class="logLine logLevel' + level + '">';
      html += '<span style="float:left">[<span class="initiator">';

      if (log.opInstId)
        html +=
          "<a onclick=\"Gui.gui.patchView.centerSelectOp('" +
          log.opInstId +
          "');\">";

      html += log.initiator;

      if (log.opInstId) html += "</a>";

      html += "</span>]&nbsp;&nbsp;</span> ";
      html += '<div style="float:left">';
      html += txt;
      html += "</div>";
      html += "</div>";

      return html;
    }
  }

  class HtmlElementOverlay {
    constructor() {
      this._showing = true;
      this._trackEle = null;

      Gui$1.gui.opParams.on("opSelected", (op) => {
        this._trackEle = null;
        if (!op) return;

        const ports = op.portsOut;

        for (let i = 0; i < ports.length; i++)
          if (ports[i].get() && ports[i].uiAttribs.objType == "element") {
            if (this._eleOver && this._trackEle != ports[i].get()) {
              this._eleOver.remove();
              this._eleOver = null;
            }

            this._trackEle = ports[i].get();
          }

        this._update();
      });

      setInterval(this._update.bind(this), 50);
    }

    _update() {
      if (!Gui$1.gui.shouldDrawOverlay || !this._trackEle) {
        if (this._eleOver) {
          this._eleOver.remove();
          this._eleOver = null;
        }
        return;
      }

      const r = this._trackEle.getBoundingClientRect();

      if (!this._eleOver) {
        this._eleOver = document.createElement("div");
        this._eleOver.classList.add("cblUiHtmlEleOverlay");
        document.body.appendChild(this._eleOver);
      }

      this._eleOver.style.display = "block";
      this._eleOver.style.left = r.x + "px";
      this._eleOver.style.top = r.y + "px";
      this._eleOver.style.width = r.width - 2 + "px";
      this._eleOver.style.height = r.height - 2 + "px";
    }
  }

  class BottomTabPanel extends Events {
    /**
     * @param {TabPanel} tabs
     */
    constructor(tabs) {
      super();
      this._tabs = tabs;
      this._tabs.showTabListButton = false;
      this._visible = false;
      this._ele = document.getElementById("bottomtabs");
      this._ele.style.display = "none";
      this.height =
        UserSettings.userSettings.get("bottomPanelHeight") ||
        uiConfig.timingPanelHeight;
      this._toBottomPanel = null;

      this._tabs.on("onTabAdded", (tab, existedBefore) => {
        const wasVisible = this._visible;
        if (!existedBefore) this.show();

        tabs.activateTab("");
        tabs.activateTab(tab.id);

        if (!wasVisible && window.gui) Gui$1.gui.setLayout();
      });

      this._tabs.on("onTabRemoved", (_tab) => {
        if (this._tabs.getNumTabs() == 0) {
          this.hide();
          Gui$1.gui.setLayout();
        }
      });
      this.fixHeight();
    }

    init() {
      const showtabs = UserSettings.userSettings.get("bottomTabsVisible");
      if (showtabs) this.show();
      else this.hide(true);
    }

    isVisible() {
      return this._visible;
    }

    /**
     * @param {Boolean} userInteraction
     */
    show(userInteraction = false) {
      if (Gui$1.gui.unload) return;
      UserSettings.userSettings.set("bottomTabsOpened", true);
      this._tabs.emitEvent("resize");

      if (this._tabs.getNumTabs() == 0) {
        this.hide(true);
        return;
      }

      if (!userInteraction) {
        if (!UserSettings.userSettings.get("bottomTabsVisible")) {
          return;
        }
      }

      this._visible = true;
      this._ele.style.display = "block";

      ele.byId("splitterBottomTabs").style.display = "block";

      document.getElementById("editorminimized").style.display = "none";

      if (Gui$1.gui.finishedLoading() && userInteraction)
        UserSettings.userSettings.set("bottomTabsVisible", true);

      Gui$1.gui.setLayout();
    }

    getHeight() {
      if (!this._visible) return 0;
      return this.height;
    }

    fixHeight() {
      this.height = Math.min(this.height, window.innerHeight * 0.7);
      this.height = Math.max(150, this.height);
    }

    /**
     * @param {number} h
     */
    setHeight(h) {
      this.height = h;

      clearTimeout(this._toBottomPanel);
      this._toBottomPanel = setTimeout(() => {
        this.fixHeight();
        UserSettings.userSettings.set("bottomPanelHeight", this.height);
      }, 100);
      Gui$1.gui.setLayout();

      this._tabs.emitEvent("resize");
    }

    /**
     * @param {boolean} donotsave
     */
    hide(donotsave = false) {
      ele.byId("splitterBottomTabs").style.display = "none";

      UserSettings.userSettings.set("bottomTabsOpened", false);
      this._tabs.emitEvent("resize");

      this._visible = false;
      document.getElementById("editorminimized").style.display = "block";
      this._ele.style.display = "none";
      if (window.gui) Gui$1.gui.setLayout();

      if (!donotsave && Gui$1.gui.finishedLoading())
        UserSettings.userSettings.set("bottomTabsVisible", false);
    }

    /**
     * @param {boolean} userInteraction
     */
    toggle(userInteraction = false) {
      if (!Gui$1.gui.finishedLoading()) return;
      console.log("toggle", this._visible);
      if (this._visible) {
        this.hide();
        Gui$1.gui.patchView.focus();
        this._visible = false;
      } else this.show(userInteraction);
    }

    isMinimized() {
      return !this._visible;
    }
  }

  var errorStackParser$1 = {exports: {}};

  var stackframe$1 = {exports: {}};

  var stackframe = stackframe$1.exports;

  var hasRequiredStackframe;

  function requireStackframe () {
  	if (hasRequiredStackframe) return stackframe$1.exports;
  	hasRequiredStackframe = 1;
  	(function (module, exports) {
  		(function(root, factory) {
  		    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  		    /* istanbul ignore next */
  		    {
  		        module.exports = factory();
  		    }
  		}(stackframe, function() {
  		    function _isNumber(n) {
  		        return !isNaN(parseFloat(n)) && isFinite(n);
  		    }

  		    function _capitalize(str) {
  		        return str.charAt(0).toUpperCase() + str.substring(1);
  		    }

  		    function _getter(p) {
  		        return function() {
  		            return this[p];
  		        };
  		    }

  		    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
  		    var numericProps = ['columnNumber', 'lineNumber'];
  		    var stringProps = ['fileName', 'functionName', 'source'];
  		    var arrayProps = ['args'];
  		    var objectProps = ['evalOrigin'];

  		    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

  		    function StackFrame(obj) {
  		        if (!obj) return;
  		        for (var i = 0; i < props.length; i++) {
  		            if (obj[props[i]] !== undefined) {
  		                this['set' + _capitalize(props[i])](obj[props[i]]);
  		            }
  		        }
  		    }

  		    StackFrame.prototype = {
  		        getArgs: function() {
  		            return this.args;
  		        },
  		        setArgs: function(v) {
  		            if (Object.prototype.toString.call(v) !== '[object Array]') {
  		                throw new TypeError('Args must be an Array');
  		            }
  		            this.args = v;
  		        },

  		        getEvalOrigin: function() {
  		            return this.evalOrigin;
  		        },
  		        setEvalOrigin: function(v) {
  		            if (v instanceof StackFrame) {
  		                this.evalOrigin = v;
  		            } else if (v instanceof Object) {
  		                this.evalOrigin = new StackFrame(v);
  		            } else {
  		                throw new TypeError('Eval Origin must be an Object or StackFrame');
  		            }
  		        },

  		        toString: function() {
  		            var fileName = this.getFileName() || '';
  		            var lineNumber = this.getLineNumber() || '';
  		            var columnNumber = this.getColumnNumber() || '';
  		            var functionName = this.getFunctionName() || '';
  		            if (this.getIsEval()) {
  		                if (fileName) {
  		                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
  		                }
  		                return '[eval]:' + lineNumber + ':' + columnNumber;
  		            }
  		            if (functionName) {
  		                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
  		            }
  		            return fileName + ':' + lineNumber + ':' + columnNumber;
  		        }
  		    };

  		    StackFrame.fromString = function StackFrame$$fromString(str) {
  		        var argsStartIndex = str.indexOf('(');
  		        var argsEndIndex = str.lastIndexOf(')');

  		        var functionName = str.substring(0, argsStartIndex);
  		        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
  		        var locationString = str.substring(argsEndIndex + 1);

  		        if (locationString.indexOf('@') === 0) {
  		            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
  		            var fileName = parts[1];
  		            var lineNumber = parts[2];
  		            var columnNumber = parts[3];
  		        }

  		        return new StackFrame({
  		            functionName: functionName,
  		            args: args || undefined,
  		            fileName: fileName,
  		            lineNumber: lineNumber || undefined,
  		            columnNumber: columnNumber || undefined
  		        });
  		    };

  		    for (var i = 0; i < booleanProps.length; i++) {
  		        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
  		        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
  		            return function(v) {
  		                this[p] = Boolean(v);
  		            };
  		        })(booleanProps[i]);
  		    }

  		    for (var j = 0; j < numericProps.length; j++) {
  		        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
  		        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
  		            return function(v) {
  		                if (!_isNumber(v)) {
  		                    throw new TypeError(p + ' must be a Number');
  		                }
  		                this[p] = Number(v);
  		            };
  		        })(numericProps[j]);
  		    }

  		    for (var k = 0; k < stringProps.length; k++) {
  		        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
  		        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
  		            return function(v) {
  		                this[p] = String(v);
  		            };
  		        })(stringProps[k]);
  		    }

  		    return StackFrame;
  		})); 
  	} (stackframe$1));
  	return stackframe$1.exports;
  }

  var errorStackParser = errorStackParser$1.exports;

  var hasRequiredErrorStackParser;

  function requireErrorStackParser () {
  	if (hasRequiredErrorStackParser) return errorStackParser$1.exports;
  	hasRequiredErrorStackParser = 1;
  	(function (module, exports) {
  		(function(root, factory) {
  		    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  		    /* istanbul ignore next */
  		    {
  		        module.exports = factory(requireStackframe());
  		    }
  		}(errorStackParser, function ErrorStackParser(StackFrame) {

  		    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  		    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  		    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;

  		    return {
  		        /**
  		         * Given an Error object, extract the most information from it.
  		         *
  		         * @param {Error} error object
  		         * @return {Array} of StackFrames
  		         */
  		        parse: function ErrorStackParser$$parse(error) {
  		            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
  		                return this.parseOpera(error);
  		            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
  		                return this.parseV8OrIE(error);
  		            } else if (error.stack) {
  		                return this.parseFFOrSafari(error);
  		            } else {
  		                throw new Error('Cannot parse given Error object');
  		            }
  		        },

  		        // Separate line and column numbers from a string of the form: (URI:Line:Column)
  		        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
  		            // Fail-fast but return locations like "(native)"
  		            if (urlLike.indexOf(':') === -1) {
  		                return [urlLike];
  		            }

  		            var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  		            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
  		            return [parts[1], parts[2] || undefined, parts[3] || undefined];
  		        },

  		        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
  		            var filtered = error.stack.split('\n').filter(function(line) {
  		                return !!line.match(CHROME_IE_STACK_REGEXP);
  		            }, this);

  		            return filtered.map(function(line) {
  		                if (line.indexOf('(eval ') > -1) {
  		                    // Throw away eval information until we implement stacktrace.js/stackframe#8
  		                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(,.*$)/g, '');
  		                }
  		                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').replace(/^.*?\s+/, '');

  		                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
  		                // case it has spaces in it, as the string is split on \s+ later on
  		                var location = sanitizedLine.match(/ (\(.+\)$)/);

  		                // remove the parenthesized location from the line, if it was matched
  		                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

  		                // if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine
  		                // because this line doesn't have function name
  		                var locationParts = this.extractLocation(location ? location[1] : sanitizedLine);
  		                var functionName = location && sanitizedLine || undefined;
  		                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

  		                return new StackFrame({
  		                    functionName: functionName,
  		                    fileName: fileName,
  		                    lineNumber: locationParts[1],
  		                    columnNumber: locationParts[2],
  		                    source: line
  		                });
  		            }, this);
  		        },

  		        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
  		            var filtered = error.stack.split('\n').filter(function(line) {
  		                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
  		            }, this);

  		            return filtered.map(function(line) {
  		                // Throw away eval information until we implement stacktrace.js/stackframe#8
  		                if (line.indexOf(' > eval') > -1) {
  		                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
  		                }

  		                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
  		                    // Safari eval frames only have function names and nothing else
  		                    return new StackFrame({
  		                        functionName: line
  		                    });
  		                } else {
  		                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
  		                    var matches = line.match(functionNameRegex);
  		                    var functionName = matches && matches[1] ? matches[1] : undefined;
  		                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

  		                    return new StackFrame({
  		                        functionName: functionName,
  		                        fileName: locationParts[0],
  		                        lineNumber: locationParts[1],
  		                        columnNumber: locationParts[2],
  		                        source: line
  		                    });
  		                }
  		            }, this);
  		        },

  		        parseOpera: function ErrorStackParser$$parseOpera(e) {
  		            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
  		                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
  		                return this.parseOpera9(e);
  		            } else if (!e.stack) {
  		                return this.parseOpera10(e);
  		            } else {
  		                return this.parseOpera11(e);
  		            }
  		        },

  		        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
  		            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
  		            var lines = e.message.split('\n');
  		            var result = [];

  		            for (var i = 2, len = lines.length; i < len; i += 2) {
  		                var match = lineRE.exec(lines[i]);
  		                if (match) {
  		                    result.push(new StackFrame({
  		                        fileName: match[2],
  		                        lineNumber: match[1],
  		                        source: lines[i]
  		                    }));
  		                }
  		            }

  		            return result;
  		        },

  		        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
  		            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
  		            var lines = e.stacktrace.split('\n');
  		            var result = [];

  		            for (var i = 0, len = lines.length; i < len; i += 2) {
  		                var match = lineRE.exec(lines[i]);
  		                if (match) {
  		                    result.push(
  		                        new StackFrame({
  		                            functionName: match[3] || undefined,
  		                            fileName: match[2],
  		                            lineNumber: match[1],
  		                            source: lines[i]
  		                        })
  		                    );
  		                }
  		            }

  		            return result;
  		        },

  		        // Opera 10.65+ Error.stack very similar to FF/Safari
  		        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
  		            var filtered = error.stack.split('\n').filter(function(line) {
  		                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
  		            }, this);

  		            return filtered.map(function(line) {
  		                var tokens = line.split('@');
  		                var locationParts = this.extractLocation(tokens.pop());
  		                var functionCall = (tokens.shift() || '');
  		                var functionName = functionCall
  		                    .replace(/<anonymous function(: (\w+))?>/, '$2')
  		                    .replace(/\([^)]*\)/g, '') || undefined;
  		                var argsRaw;
  		                if (functionCall.match(/\(([^)]*)\)/)) {
  		                    argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
  		                }
  		                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
  		                    undefined : argsRaw.split(',');

  		                return new StackFrame({
  		                    functionName: functionName,
  		                    args: args,
  		                    fileName: locationParts[0],
  		                    lineNumber: locationParts[1],
  		                    columnNumber: locationParts[2],
  		                    source: line
  		                });
  		            }, this);
  		        }
  		    };
  		})); 
  	} (errorStackParser$1));
  	return errorStackParser$1.exports;
  }

  var errorStackParserExports = requireErrorStackParser();
  var ErrorStackParser = /*@__PURE__*/getDefaultExportFromCjs(errorStackParserExports);

  /**
   * Tab panel to display logging of cables logger
   *
   * @export
   * @class LogTab
   * @extends {Events}
   */
  class LogTab extends Events {
    constructor(tabs) {
      super();
      this._tabs = tabs;
      this._log = new Logger("LogTab");
      this._logs = [];
      this.closed = false;
      this.report = [];
      this.lastErrorSrc = [];
      this._hasError = false;
      this.lastErrorMsg = null;
      this.sentAutoReport = false;
      this.hasErrorButton = false;

      this._tab = new Tab("Log", {
        icon: "list",
        infotext: "tab_logging",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);

      this.data = { cells: this.cells, colNames: this.colNames };

      this._html();
      LogFilter.logFilter.on("initiatorsChanged", this._html.bind(this));

      this._showlogListener = logFilter.on("logAdded", this._showLog.bind(this));

      this._tab.addButton("Filter Logs", () => {
        CABLES.CMD.DEBUG.logging();
      });

      const alwaysOpenButton = this._tab.addButton(
        "Always open: " + (UserSettings.userSettings.get("openLogTab") || false),
        () => {
          UserSettings.userSettings.set(
            "openLogTab",
            !UserSettings.userSettings.get("openLogTab"),
          );
          alwaysOpenButton.innerHTML =
            "Always open: " +
            (UserSettings.userSettings.get("openLogTab") || false);
        },
      );

      this._tab.addButton("Clear", () => {
        logFilter.logs.length = 0;
        this._html();
      });

      this._tab.addButton("Copy to clipboard", () => {
        const el = ele.byId("loggingHtmlId123");
        let txt = el.innerText;
        txt = txt.replaceAll("]\n", "] ");
        let lines = txt.split("\n");
        lines = lines.reverse();
        txt = lines.join("\n");
        navigator.clipboard.writeText(txt);
      });

      this._tab.addEventListener("close", () => {
        this.close();
      });
    }

    close() {
      this.closed = true;
      logFilter.off(this._showlogListener);
      this.emitEvent("close");
      Gui$1.gui.hideBottomTabs();
    }

    _html() {
      const html = '<div id="loggingHtmlId123" class="logList"></div>';
      this._tab.html(html);
      this._showLog();
    }

    _logLine(log, txt, level, timediff) {
      let spacerClass = "";

      if (Math.abs(timediff) > 300) spacerClass = "loglineSpacer";
      let html =
        '<div class="logLine ' + spacerClass + " logLevel" + level + '">';
      html +=
        '<span style="float:left" class="outerInitiator">[<span class="initiator">';

      if (log.opInstId)
        html +=
          "<a onclick=\"Gui.gui.patchView.centerSelectOp('" +
          log.opInstId +
          "');\">";

      html += log.initiator;

      if (log.opInstId) html += "</a>";

      html += "</span>]&nbsp;</span>";
      html += '<div style="float:left" class="initiator_' + log.initiator + '">';
      html += txt;
      html += "</div>";
      html += "</div>";

      if (html.indexOf("`") > -1) {
        const parts = html.split("`");

        parts.splice(1, 0, '<span class="logLineCode">');
        parts.splice(3, 0, "</span>");

        html = parts.join("");
      }

      return html;
    }

    _showLog() {
      if (this.closed) return;
      let html = "";

      if (Gui$1.gui.isRemoteClient) {
        const el = ele.byId("bottomtabs");
        if (el) el.style.zIndex = 1111111;
      }

      for (let i = logFilter.logs.length - 1; i >= 0; i--) {
        const l = logFilter.logs[i];
        for (let j = 0; j < l.args.length; j++) {
          const arg = l.args[j];

          if (!arg) continue;
          if (arg.constructor && arg.constructor.name.indexOf("Error") > -1)
            this._hasError = true;

          try {
            ErrorStackParser.parse(arg.error || arg);
            this._hasError = true;
          } catch (e) {}
        }
      }

      if (this._hasError && !this.hasErrorButton) {
        this.hasErrorButton = true;
        this._tab.addButton("Send Error Report", () => {
          Gui$1.gui.patchView.store.sendErrorReport(this.createReport(), true);
        });
      }

      try {
        let lastTime = 0;
        for (let i = logFilter.logs.length - 1; i >= 0; i--) {
          const l = logFilter.logs[i];
          let currentLine = "";
          const timediff = l.time - lastTime;
          lastTime = l.time;

          if (!logFilter.shouldPrint(l)) continue;

          for (let j = 0; j < l.args.length; j++) {
            const arg = l.args[j];

            let errorStack = null;
            try {
              errorStack = ErrorStackParser.parse(arg.error || arg.reason || arg);
            } catch (e) {
              errorStack = null;
            }

            if (errorStack) {
              l.errorStack = errorStack;
              if (errorStack && errorStack.length > 0) {
                let stackHtml = "<table>";
                for (let k = 0; k < Math.min(2, errorStack.length); k++) {
                  if (k === 0 && i == logFilter.logs.length - 1)
                    this._logErrorSrcCodeLine(
                      l,
                      errorStack[k].fileName,
                      errorStack[k].lineNumber - 1,
                    );

                  errorStack[k].fileName = errorStack[k].fileName || null;

                  if (errorStack[k].fileName) {
                    const shortFilename = errorStack[k].fileName.replaceAll(
                      "https://",
                      "",
                    );
                    if (errorStack[k].functionName)
                      stackHtml +=
                        "  <td>" + errorStack[k].functionName + "</td>";
                    stackHtml += "  <td>";

                    if (
                      errorStack[k].fileName.indexOf("https://") == 0 ||
                      errorStack[k].fileName.indexOf("http://") == 0 ||
                      errorStack[k].fileName.indexOf("file://") == 0 ||
                      errorStack[k].fileName.indexOf("cables://") == 0
                    )
                      stackHtml +=
                        "  <a onclick=\"new CABLES.UI.ModalSourceCode({url:'" +
                        errorStack[k].fileName +
                        "',line:" +
                        errorStack[k].lineNumber +
                        '});">';
                    else
                      stackHtml +=
                        errorStack[k].fileName +
                        ":" +
                        errorStack[k].lineNumber +
                        "";

                    stackHtml += shortFilename;
                    stackHtml +=
                      "@" +
                      errorStack[k].lineNumber +
                      ":" +
                      errorStack[k].columnNumber +
                      "</a></td>";
                  }
                  stackHtml += "</tr>";
                }
                stackHtml += "</table>";

                html += this._logLine(l, stackHtml, l.level, timediff);

                let txt = "[" + arg.constructor.name + "] ";
                let msg = "";

                if (arg.message) msg = arg.message;
                if (arg.error) msg = arg.error.message;
                if (arg.reason) msg = arg.reason.message;

                this.lastErrorMsg = "";
                if (errorStack && errorStack[0] && errorStack[0].functionName)
                  this.lastErrorMsg +=
                    CABLES.basename(errorStack[0].fileName) +
                    ": " +
                    errorStack[0].functionName +
                    ": ";
                if (msg) this.lastErrorMsg += msg;
                txt += " " + msg;

                html += this._logLine(l, txt, l.level);
              } else {
                currentLine += "??? " + arg.constructor.name;
                this._log.log("what is this", arg);
              }
            } else {
              if (arg) {
                if (
                  arg.constructor.name.indexOf("Error") > -1 &&
                  (arg.hasOwnProperty("message") || arg.message)
                ) {
                  let txt = "[<b>" + arg.constructor.name + "</b>]";
                  if (arg.message)
                    txt +=
                      ": " +
                      arg.message
                        .replaceAll("\n", "<br/>")
                        .replaceAll("  ", "&nbsp;&nbsp;");

                  currentLine = txt;
                } else if (arg.constructor.name == "Op") {
                  currentLine +=
                    " <a onclick=\"Gui.gui.patchView.centerSelectOp('" +
                    arg.id +
                    "');\">op: " +
                    arg.shortName +
                    "</a>";
                } else if (typeof arg == "string") {
                  let _arg = arg.replaceAll("\n", "<br/>");
                  if (arg.startsWith("https://")) {
                    _arg =
                      '<a href="' + arg + '" target="_blank">' + arg + "</a>";
                  }
                  currentLine += _arg + " ";
                } else if (typeof arg == "number") {
                  currentLine += String(arg) + " ";
                } else if (arg.constructor.name == "PromiseRejectionEvent") {
                  if (arg.reason && arg.reason.message)
                    currentLine +=
                      arg.constructor.name + ": " + arg.reason.message;
                } else {
                  currentLine += "<br/>";
                  currentLine +=
                    "Log Object Arg " +
                    j +
                    ": [<b>" +
                    arg.constructor.name +
                    "</b>]<br/>";
                  currentLine += "{<br/>";

                  for (let oi in arg) {
                    if (arg[oi] && arg[oi].constructor) {
                      currentLine += '&nbsp;&nbsp;&nbsp;&nbsp;"' + oi + '": <b>';

                      if (
                        arg[oi].constructor.name == "Number" ||
                        arg[oi].constructor.name == "String" ||
                        arg[oi].constructor.name == "Boolean"
                      ) {
                        if (arg[oi].constructor.name == "String")
                          currentLine += '"';
                        currentLine += arg[oi];
                        if (arg[oi].constructor.name == "String")
                          currentLine += '"';
                      } else {
                        currentLine += "[" + arg[oi].constructor.name + "]";
                      }
                      currentLine += "</b>,<br/>";
                    }
                  }
                  currentLine += "}<br/>";
                }
              }
            }
          }
          if (currentLine)
            html += this._logLine(l, currentLine, l.level, timediff);
        }
      } catch (e) {
        this._log.log("error in error", e);
      }

      const el = ele.byId("loggingHtmlId123");
      if (el) el.innerHTML = html;
    }

    _logErrorSrcCodeLine(l, url, line) {
      if (!url) return;
      if (url.includes("[native code]")) return;
      if (this.lastErrorSrc.indexOf(url + line) > -1) return;
      this.lastErrorSrc.push(url + line);

      // export const ajax = function (url, cb, method, post, contenttype, jsonP, headers = {}, options = {})

      const logger = this._log;
      CABLES.ajax(
        url,
        (err, _data, xhr) => {
          if (err) {
            this._log.error("error fetching logline2", url, err, _data, xhr);
            return;
          }

          try {
            let lines = _data.match(/^.*((\r\n|\n|\r)|$)/gm);

            let lStr = lines[line];
            if (!lStr) return;
            const maxLength = 150;
            if (lStr.length > maxLength)
              lStr = lStr.substring(0, maxLength) + "...";

            const str =
              'file: "' +
              CABLES.basename(url) +
              '" line ' +
              line +
              ": `" +
              lStr +
              "`";
            logger.errorGui(str);

            if (
              // do not send error report
              url.indexOf("api/op/") == -1 && // custom executed op ?
              url.indexOf("api/op/Ops.User.") == -1 && // when user ops
              url.indexOf("api/op/Ops.Patch.") == -1 && // when patch ops
              url.indexOf("api/op/Ops.Team.") == -1 && //  when team ops
              url.indexOf("cables.gl/assets/") == -1 && //  when asset libraries
              url.indexOf("/api/lib/") == -1 && //  when libraries
              url.indexOf("ops/code/project/") == -1 //  when using patch special ops
            ) {
              if (!this.sentAutoReport) {
                this.sentAutoReport = true;
                setTimeout(() => {
                  Gui$1.gui.patchView.store.sendErrorReport(
                    this.createReport(),
                    false,
                  );
                }, 500);
              }
            }
          } catch (e) {
            this._log.log("could not parse lines.", e, url);
          }
        },
        "GET",
        null,
        null,
        null,
        null,
        { credentials: true },
      );
    }

    createReport() {
      const report = {};
      report.title = this.lastErrorMsg;
      report.patchTitle = Gui$1.gui.project().name;

      const log = [];
      for (let i = logFilter.logs.length - 1; i >= 0; i--) {
        const l = logFilter.logs[i];
        let newLine = {
          initiator: l.initiator,
          errorStack: l.errorStack,
          args: [],
          level: l.level,
        };

        log.push(newLine);

        for (let j = 0; j < l.args.length; j++) {
          const arg = l.args[j];
          let neewArg = "";

          try {
            neewArg = JSON.parse(JSON.stringify(arg));
          } catch (e) {
            if (arg) {
              if (arg.constructor.name == "Op") {
                neewArg = { objName: arg.objName, id: arg.id, opId: arg.opId };
              } else if (arg.getSerialized) {
                neewArg = arg.getSerialized();
              } else if (arg.serialize) {
                neewArg = arg.serialize();
              } else {
                neewArg = " unknown, could not serialize:" + arg.constructor.name;
              }
            } else {
              this._log.log("no arg", e);
            }
          }
          newLine.args.push(neewArg);

          if (arg) {
            if (arg.message) newLine.args.push("message: " + arg.message);
            if (arg.error) {
              if (arg.error.message)
                newLine.args.push("error message: " + arg.error.message);
              else
                newLine.args.push(
                  "error message str: " + JSON.stringify(arg.error),
                );
            }
            if (arg.reason) newLine.args.push("reason: " + arg.reason.message);
          }
        }
      }

      report.log = log;

      let history = [];
      if (undo) history = undo.getCommands();
      history = history.slice(-10);

      report.time = Date.now();
      report.history = history;

      report.url = document.location.href;
      report.infoLanguage = navigator.language;

      report.cablesUrl = platform.getCablesUrl();
      report.platformVersion = platform.getCablesVersion();
      if (window.gui && Gui$1.gui.isRemoteClient)
        report.platformVersion += " REMOTE CLIENT";
      report.browserDescription = platform.description;

      if (window.gui) {
        if (Gui$1.gui.project()) report.projectId = Gui$1.gui.project()._id;
        if (Gui$1.gui.user) {
          report.username = Gui$1.gui.user.username;
          report.userId = Gui$1.gui.user.id;
        }

        try {
          const dbgRenderInfo = gui
            .corePatch()
            .cgl.gl.getExtension("WEBGL_debug_renderer_info");
          report.glRenderer = gui
            .corePatch()
            .cgl.gl.getParameter(dbgRenderInfo.UNMASKED_RENDERER_WEBGL);
        } catch (e) {
          this._log.log(e);
        }
      }
      this._log.log("REPORT", report);
      return report;
    }
  }

  class UiProfiler {
    #filter = "";

    constructor() {
      this._measures = {};
      this._ele = null;
      this._timeout = null;

      this._currentHighlight = UserSettings.userSettings.get(
        "uiPerfLastHighlight",
      );
      this.#filter = UserSettings.userSettings.get("showUIPerfFilter") || "";
      this._ignore = false;
      // TODO: ele.byId("uiPerfFilter").value = this.#filter;
    }

    hide() {
      this._eleContainer.style.display = "none";
      clearTimeout(this._timeout);

      UserSettings.userSettings.set("showUIPerf", false);
    }

    filter(str) {
      this.#filter = str;
      this.update();
      UserSettings.userSettings.set("showUIPerfFilter", this.#filter);
    }

    show() {
      UserSettings.userSettings.set("showUIPerf", true);
      this.update();
    }

    highlight(name) {
      for (const i in this._measures) this._measures[i].highlight = false;
      this._currentHighlight = name;
      UserSettings.userSettings.set("uiPerfLastHighlight", name);
      if (UserSettings.userSettings.get("showUIPerf")) this.show();
    }

    update() {
      this._eleContainer = this._eleContainer || ele.byId("uiperfcontainer");
      this._ele = this._ele || ele.byId("uiperf");
      const data = [];

      for (const i in this._measures) {
        const lastTime =
          Math.round(
            this._measures[i].times[this._measures[i].times.length - 1] * 1000,
          ) / 1000;
        let avg = 0;
        for (let j = 0; j < this._measures[i].times.length; j++)
          avg += this._measures[i].times[j];

        avg /= this._measures[i].times.length;
        avg = Math.round(avg * 1000) / 1000;

        if (this._currentHighlight && this._currentHighlight == i) {
          this._measures[i].highlight = true;
        }

        let color = "col_recent";
        const dist = performance.now() - this._measures[i].date;
        if (dist > 2000) color = "col_inactive";
        if (dist < 600) color = "col_active";

        if (!this.#filter || i.indexOf(this.#filter) >= 0)
          data.push({
            highlight: this._measures[i].highlight,
            color: color,
            name: i,
            count: this._measures[i].count,
            last: lastTime,
            avg: avg,
          });
      }

      data.sort(function (a, b) {
        return a.name.localeCompare(b.name);
      });

      this._ignore = true;
      const html = getHandleBarHtml("uiperformance", { measures: data });

      this._ele.innerHTML = html;
      this._eleContainer.style.display = "block";
      this._ignore = false;

      clearTimeout(this._timeout);
      this._timeout = setTimeout(() => {
        if (UserSettings.userSettings.get("showUIPerf")) this.update();
      }, 500);
    }

    print() {
      const data = [];

      for (const i in this._measures) {
        const lastTime =
          Math.round(
            this._measures[i].times[this._measures[i].times.length - 1] * 1000,
          ) / 1000;
        let avg = 0;
        for (let j = 0; j < this._measures[i].times.length; j++)
          avg += this._measures[i].times[j];
        avg /= this._measures[i].times.length;
        avg = Math.round(avg * 1000) / 1000;

        data.push([i, "count " + this._measures[i].count, lastTime, "~" + avg]);
      }

      console.table("uiperf print", data);
    }

    clear() {
      this._measures = {};
    }

    start(name) {
      const ignorethis = this._ignore;
      const perf = this;
      const r = {
        start: performance.now(),
        finish() {
          if (ignorethis || !perf._measures) return;
          const time = performance.now() - this.start;

          perf._measures[name] = perf._measures[name] || {};
          perf._measures[name].count = perf._measures[name].count || 0;
          perf._measures[name].count++;

          perf._measures[name].times = perf._measures[name].times || [];

          try {
            if (perf._measures[name].times.length > 1000000)
              perf._measures[name].times.length = 0;
            perf._measures[name].times.push(time);
          } catch (e) {
            console.log(e);
            console.log(perf._measures[name].times);
          }

          perf._measures[name].date = performance.now();
        },
      };
      return r;
    }
  }

  /**
   * extending core classes for helper functions which will be only available in ui/editor mode
   */


  CABLES.OpUnLinkTempReLinkP1 = null;
  CABLES.OpUnLinkTempReLinkP2 = null;

  /**
   * @extends Op<UiPatch>
   */
  class UiOp extends Op {
    constructor(a, b, c) {
      super(a, b, c);
      this.initUi();
    }

    isAnimated() {
      for (let j = 0; j < this.portsIn.length; j++)
        if (this.portsIn[j].isAnimated()) return true;
      return false;
    }

    initUi() {
      this.on("onPortAdd", () => {
        for (let i = 0; i < this.portsIn.length; i++) {
          for (let j = 0; j < this.portsOut.length; j++)
            if (this.portsIn[i].name == this.portsOut[j].name)
              this.setUiError(
                "dupeport",
                "Duplicate Port name: " +
                  this.portsOut[j].name +
                  ". Must be unique!",
                2,
              );
          for (let j = 0; j < this.portsIn.length; j++)
            if (i != j && this.portsIn[i].name == this.portsIn[j].name)
              this.setUiError(
                "dupeport",
                "Duplicate Port name: " +
                  this.portsIn[j].name +
                  ". Must be unique!",
                2,
              );
        }
      });
    }

    undoUnLinkTemporary() {
      if (this.shakeLink) this.shakeLink.remove();
      this.shakeLink = null;

      if (this.oldLinks) {
        for (let i = 0; i < this.oldLinks.length; i++) {
          this.patch.link(
            this.oldLinks[i].in.op,
            this.oldLinks[i].in.getName(),
            this.oldLinks[i].out.op,
            this.oldLinks[i].out.getName(),
          );
        }
        this.oldLinks.length = 0;
      }

      CABLES.OpUnLinkTempReLinkP1 = null;
      CABLES.OpUnLinkTempReLinkP2 = null;
    }

    countFittingPorts(otherPort) {
      let count = 0;
      for (const ipo in this.portsOut)
        if (CABLES.Link.canLink(otherPort, this.portsOut[ipo])) count++;

      for (const ipi in this.portsIn)
        if (CABLES.Link.canLink(otherPort, this.portsIn[ipi])) count++;

      return count;
    }

    findFittingPort(otherPort, inPortsFirst = false) {
      if (inPortsFirst) {
        for (const ipi in this.portsIn)
          if (CABLES.Link.canLink(otherPort, this.portsIn[ipi]))
            return this.portsIn[ipi];
        for (const ipo in this.portsOut)
          if (CABLES.Link.canLink(otherPort, this.portsOut[ipo]))
            return this.portsOut[ipo];
      } else {
        for (const ipo in this.portsOut)
          if (CABLES.Link.canLink(otherPort, this.portsOut[ipo]))
            return this.portsOut[ipo];
        for (const ipi in this.portsIn)
          if (CABLES.Link.canLink(otherPort, this.portsIn[ipi]))
            return this.portsIn[ipi];
      }
    }

    /**
     * disconnect all links
     * @function
     * @instance
     * @memberof Op
     */
    unLink() {
      for (let ipo = 0; ipo < this.portsOut.length; ipo++)
        this.portsOut[ipo].removeLinks();
      for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        this.portsIn[ipi].removeLinks();
    }

    unLinkReconnectOthers() {
      this.unLinkOptions(true, false);
    }

    unLinkTemporary() {
      this.unLinkOptions(true, true);
    }

    unLinkOptions(tryRelink, temporary) {
      let i = 0;

      this.shakeLink = null;
      this.oldLinks = [];

      CABLES.OpUnLinkTempReLinkP1 = null;
      CABLES.OpUnLinkTempReLinkP2 = null;

      if (tryRelink) {
        if (
          this.getFirstPortIn() &&
          this.getFirstPortOut() &&
          this.getFirstPortIn().isLinked() &&
          this.getFirstPortOut().isLinked()
        ) {
          if (
            this.getFirstPortIn().getType() == this.getFirstPortOut().getType() &&
            this.getFirstPortIn().links[0]
          ) {
            CABLES.OpUnLinkTempReLinkP1 =
              this.getFirstPortIn().links[0].getOtherPort(this.getFirstPortIn());
            CABLES.OpUnLinkTempReLinkP2 =
              this.getFirstPortOut().links[0].getOtherPort(
                this.getFirstPortOut(),
              );
          }
        }
      }

      if (temporary) {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
          for (i = 0; i < this.portsIn[ipi].links.length; i++) {
            this.oldLinks.push({
              in: this.portsIn[ipi].links[i].portIn,
              out: this.portsIn[ipi].links[i].portOut,
            });
          }
        }

        for (let ipo = 0; ipo < this.portsOut.length; ipo++)
          for (i = 0; i < this.portsOut[ipo].links.length; i++)
            this.oldLinks.push({
              in: this.portsOut[ipo].links[i].portIn,
              out: this.portsOut[ipo].links[i].portOut,
            });
      }

      this.unLink();

      if (CABLES.OpUnLinkTempReLinkP1 && CABLES.OpUnLinkTempReLinkP2)
        this.shakeLink = this.patch.link(
          CABLES.OpUnLinkTempReLinkP1.op,
          CABLES.OpUnLinkTempReLinkP1.getName(),
          CABLES.OpUnLinkTempReLinkP2.op,
          CABLES.OpUnLinkTempReLinkP2.getName(),
        );
    }

    isLinked() {
      return this.isLinkedIn() || this.isLinkedOut();
    }

    /**
     * @returns {Boolean}
     */
    isLinkedIn() {
      for (let i = 0; i < this.portsIn.length; i++)
        if (this.portsIn[i] && this.portsIn[i].isLinked()) return true;
      return false;
    }

    /**
     * @returns {Boolean}
     */
    isLinkedOut() {
      for (let i = 0; i < this.portsOut.length; i++)
        if (this.portsOut[i] && this.portsOut[i].isLinked()) return true;
      return false;
    }

    hasParent(type, name, count) {
      if (this._ignoreParentChecks) return false;
      count = count || 1;
      count++;
      if (count >= 1000) {
        this._log.log("hasparent loop....", name);
        this._ignoreParentChecks = true;
        return false;
      }
      for (let i = 0; i < this.portsIn.length; i++) {
        if (
          (type === undefined || type === null || this.portsIn[i].type == type) &&
          this.portsIn[i].isLinked()
        ) {
          const pi = this.portsIn[i];
          for (let li = 0; li < pi.links.length; li++) {
            if (!pi.links[li]) continue;
            if (pi.links[li].portOut.op.objName.indexOf(name) > -1) return true;
            if (pi.links[li].portOut.op.hasParent(type, name, count)) return true;
          }
        }
      }
      return false;
    }

    /**
     * @param {UiOp | Op} op2
     */
    isConnectedTo(op2) {
      for (let i = 0; i < this.portsIn.length; i++)
        if (this.portsIn[i].isLinked())
          for (let j = 0; j < this.portsIn[i].links.length; j++)
            if (this.portsIn[i].links[j].getOtherPort(this.portsIn[i]).op == op2)
              return this.portsIn[i].links[j];

      for (let i = 0; i < this.portsOut.length; i++)
        if (this.portsOut[i].isLinked())
          for (let j = 0; j < this.portsOut[i].links.length; j++)
            if (
              this.portsOut[i].links[j].getOtherPort(this.portsOut[i]).op == op2
            )
              return this.portsOut[i].links[j];
    }

    isPatchOp() {
      return this.objName.indexOf("Ops.Patch") == 0;
    }

    isTeamOp() {
      return this.objName.indexOf("Ops.Team") == 0;
    }

    isUserOp() {
      return this.objName.indexOf("Ops.User") == 0;
    }

    isCoreOp() {
      return !this.isTeamOp() && !this.isPatchOp() && !this.isUserOp();
    }

    /**
     * @param {string} id
     */
    getUiError(id) {
      return this.uiErrors[id];
    }

    /**
     * @param {string} id
     * @param {string} txt
     */
    setUiError(id, txt, level = 2, options = {}) {
      if (!txt && !this.hasUiErrors) return;
      if (!txt && !this.uiErrors.hasOwnProperty(id)) return;
      if (this.uiErrors.hasOwnProperty(id) && this.uiErrors[id].txt == txt)
        return;

      if (id.indexOf(" ") > -1)
        this._log.warn("setuierror id cant have spaces! ", id);
      id = id.replaceAll(" ", "_");

      if (!txt && this.uiErrors.hasOwnProperty(id)) delete this.uiErrors[id];
      else {
        if (
          txt &&
          (!this.uiErrors.hasOwnProperty(id) || this.uiErrors[id].txt != txt)
        ) {
          if (level == undefined) level = 2;
          this.uiErrors[id] = {
            txt: txt,
            level: level,
            id: id,
            options: options,
          };
        }
      }

      const errorArr = [];
      for (const i in this.uiErrors) errorArr.push(this.uiErrors[i]);

      this.setUiAttrib({ uierrors: errorArr });
      this.hasUiErrors = Object.keys(this.uiErrors).length;

      this.emitEvent("uiErrorChange");
    }

    checkLinkTimeWarnings() {
      if (!Gui$1.gui.finishedLoading()) return;

      if (this.isInBlueprint2()) {
        const outer = Gui$1.gui.patchView.getSubPatchOuterOp(
          this.uiAttribs.subPatch,
        );
        if (outer) {
          let subPatchOpError = null;
          if (this.objName == outer.objName)
            subPatchOpError = "SubPatchOp Recursion error";
          if (this.isPatchOp() && outer.isTeamOp())
            subPatchOpError = "SubPatchOp Error: Patch op can't be in team ops";
          if (this.isUserOp() && outer.isTeamOp())
            subPatchOpError = "SubPatchOp Error: User op can't be in team ops";
          if (this.isPatchOp() && outer.isCoreOp())
            subPatchOpError =
              "SubPatchOp Error: Patch op can't be in core ops or extensions";
          if (this.isUserOp() && outer.isCoreOp())
            subPatchOpError =
              "SubPatchOp Error: User op can't be in core ops or extensions";

          this.setUiError("subPatchOpNoSaveError", subPatchOpError);
        }
      }

      /**
       * @param {Op} op
       */
      function hasTriggerInput(op) {
        if (op.portsIn.length > 0 && op.portsIn[0].type == portType.trigger)
          return true;
        return false;
      }

      let notWorkingMsg = null;
      let working = true;

      if (
        working &&
        this.objName.indexOf("Ops.Gl.TextureEffects") == 0 &&
        hasTriggerInput(this) &&
        this.objName.indexOf("TextureEffects.ImageCompose") == -1
      ) {
        working =
          this.hasParent(portType.trigger, "TextureEffects.ImageCompose") ||
          this.hasParent(portType.trigger, "TextureEffects.ImageCompose_v2");

        if (!working) notWorkingMsg = text.working_connected_to + "ImageCompose";
      }

      if (this.linkTimeRules.forbiddenParent && working) {
        working = !this.hasParent(
          this.linkTimeRules.forbiddenParentType || null,
          this.linkTimeRules.forbiddenParent,
        );
        if (!working)
          notWorkingMsg =
            text.working_shouldNotBeChildOf +
            this.linkTimeRules.forbiddenParent +
            "";
      }

      if (this.linkTimeRules.needsParentOp && working) {
        working = this.hasParent(null, this.linkTimeRules.needsParentOp);
        if (!working)
          notWorkingMsg =
            text.working_connected_to + this.linkTimeRules.needsParentOp + "";
      }

      if (this.linkTimeRules.needsStringToWork.length > 0) {
        for (let i = 0; i < this.linkTimeRules.needsStringToWork.length; i++) {
          const p = this.linkTimeRules.needsStringToWork[i];
          if (!p) {
            this._log.warn("[needsStringToWork] port not found");
            continue;
          }
          if (p.linkTimeListener) p.off(p.linkTimeListener);
          if (!p.isLinked() && p.get() == "") {
            working = false;

            if (!notWorkingMsg)
              notWorkingMsg = text.working_connected_needs_connections_or_string;
            else notWorkingMsg += ", ";
            notWorkingMsg += p.name.toUpperCase();

            p.linkTimeListener = p.on("change", (v, port) => {
              if (port.op.checkLinkTimeWarnings) port.op.checkLinkTimeWarnings();
            });

            p.setUiAttribs({ notWorking: true });
          } else p.setUiAttribs({ notWorking: false });
        }
      }

      if (this.linkTimeRules.needsLinkedToWork.length > 0) {
        for (let i = 0; i < this.linkTimeRules.needsLinkedToWork.length; i++) {
          const p = this.linkTimeRules.needsLinkedToWork[i];
          if (!p) {
            this._log.warn("[needsLinkedToWork] port not found");
            continue;
          }
          if (!p.isLinked()) {
            working = false;

            if (!notWorkingMsg)
              notWorkingMsg = text.working_connected_needs_connections_to;
            else notWorkingMsg += ", ";
            notWorkingMsg += p.name.toUpperCase();

            p.setUiAttribs({ notWorking: true });
          } else p.setUiAttribs({ notWorking: false });
        }
      }

      let isWebGpu = this.objName.indexOf(defaultOps.prefixes.webgpu) == 0;

      this.setUiError("wrongstride", null);
      this.setUiError("webglgpu", null);
      for (let i = 0; i < this.portsIn.length; i++) {
        if (this.portsIn[i].links.length && this.portsIn[i].links[0]) {
          const otherPort = this.portsIn[i].links[0].getOtherPort(
            this.portsIn[i],
          );

          if (
            isWebGpu &&
            otherPort.op.objName.indexOf(defaultOps.prefixes.webgl) == 0
          ) {
            this.setUiError(
              "webglgpu",
              "mixing webgl/webgpu ops: " + otherPort.op.objName,
              1,
            );
          }

          if (this.portsIn[i].type == portType.array) {
            if (
              otherPort.uiAttribs.stride != undefined &&
              this.portsIn[i].uiAttribs.stride != undefined &&
              otherPort.uiAttribs.stride != this.portsIn[i].uiAttribs.stride
            ) {
              this.setUiError(
                "wrongstride",
                'Port "' +
                  this.portsIn[i].name +
                  '" : Incompatible Array' +
                  otherPort.uiAttribs.stride +
                  " to Array" +
                  this.portsIn[i].uiAttribs.stride,
                1,
              );
            }
          }
        }
      }

      const hadError = this.hasUiError("notworking");

      if (!working) {
        // this._log.log("ERRRRR");
        // this.setUiAttrib({ working, notWorkingMsg });
        this.setUiError("notworking", notWorkingMsg, 3);
      } else if (hadError) {
        // this.setUiAttrib({ "working": true, "notWorkingMsg": null });
        this.setUiError("notworking", null);
      }

      const broke = !hadError && !working;
      if ((hadError && working) || broke) {
        clearTimeout(CABLES.timeoutCheckLinkTimeWarning);
        CABLES.timeoutCheckLinkTimeWarning = setTimeout(() => {
          // check all ops for other follow up warnings to be resolved (possible optimization: check only ops under this one...)
          const perf = Gui$1.gui.uiProfiler.start(
            "[coreOpExt] checkLinkTimeWarnings",
          );
          const ops = Gui$1.gui.corePatch().ops;

          for (let i = 0; i < ops.length; i++)
            if (
              broke ||
              (ops[i].id != this.id && ops[i].hasUiError("notworking"))
            )
              ops[i].checkLinkTimeWarnings();

          perf.finish();
        }, 33);
      }
    }

    hasLinks() {
      for (let i = 0; i < this.portsIn.length; i++)
        if (this.portsIn[i].isLinked()) return true;
      for (let i = 0; i < this.portsOut.length; i++)
        if (this.portsOut[i].isLinked()) return true;
      return false;
    }

    hasFirstInAndOutPortLinked() {
      return (
        this.portsIn.length > 0 &&
        this.getFirstPortIn().isLinked() &&
        this.portsOut.length > 0 &&
        this.getFirstPortOut().isLinked()
      );
    }

    hasFirstInLinked() {
      return this.portsIn.length > 0 && this.getFirstPortIn().isLinked();
    }

    hasFirstOutLinked() {
      return this.portsOut.length > 0 && this.getFirstPortOut().isLinked();
    }

    hasAnyOutLinked() {
      for (let i = 0; i < this.portsOut.length; i++)
        if (this.portsOut[i].isLinked()) return true;
    }

    hasMultipleOutLinked() {
      let count = 0;
      for (let i = 0; i < this.portsOut.length; i++) {
        if (this.portsOut[i].links.length > 1) return true;
        if (this.portsOut[i].isLinked()) {
          count++;
          if (count > 2) return true;
        }
      }
    }

    hasAnyInLinked() {
      for (let i = 0; i < this.portsIn.length; i++)
        if (this.portsIn[i].isLinked()) return true;
    }

    getFirstLinkedInPort() {
      for (let i = 0; i < this.portsIn.length; i++)
        if (this.portsIn[i].isLinked()) return this.portsIn[i];
    }

    getFirstLinkedInOp() {
      for (let i = 0; i < this.portsIn.length; i++)
        if (this.portsIn[i].isLinked()) {
          const otherport = this.portsIn[i].links[0].getOtherPort(
            this.portsIn[i],
          );
          return otherport.op;
        }
    }

    getLowestLinkedInOp() {
      let maxY = -999999;
      let lowestOp = null;
      for (let i = 0; i < this.portsIn.length; i++)
        if (this.portsIn[i].isLinked()) {
          if (this.portsIn[i].links[0]) {
            const otherport = this.portsIn[i].links[0].getOtherPort(
              this.portsIn[i],
            );

            if (otherport.op.getTempPosY() > maxY) {
              maxY = otherport.op.getTempPosY();
              lowestOp = otherport.op;
            }
          }
        }

      return lowestOp;

      // for (let i = 0; i < this.portsIn.length; i++) if (this.portsIn[i].isLinked())
      // {
      //     const otherport = this.portsIn[i].links[0].getOtherPort(this.portsIn[i]);
      //     return otherport.op;
      // }
    }

    isBlueprint2() {
      if (this.storage.blueprintVer === 2) return this.patchId.get();
    }

    isInBlueprint2() {
      if (!this.uiAttribs.subPatch || this.uiAttribs.subPatch == 0) return false;

      const sop = Gui$1.gui.patchView.getSubPatchOuterOp(this.uiAttribs.subPatch);
      if (sop) {
        if (sop.isBlueprint2()) return sop.isBlueprint2();

        const bp2 = sop.isInBlueprint2();
        if (bp2) return bp2;
      }

      return false;
    }

    isInLinkedToOpOutside(ops) {
      for (let i = 0; i < this.portsIn.length; i++)
        if (this.portsIn[i].isLinked()) {
          for (let j = 0; j < this.portsIn[i].links.length; j++) {
            if (
              ops.indexOf(
                this.portsIn[i].links[j].getOtherPort(this.portsIn[i]).op,
              ) == -1
            )
              return true;
          }
        }
    }

    getTempPosX() {
      if (this.uiAttribs.translateTemp) return this.uiAttribs.translateTemp.x;
      if (this.uiAttribs.translate) return this.uiAttribs.translate.x;
    }

    getTempPosY() {
      if (this.uiAttribs.translateTemp) return this.uiAttribs.translateTemp.y;
      if (this.uiAttribs.translate) return this.uiAttribs.translate.y;
    }

    setPos(x, y) {
      this.setUiAttribs({ translate: { x: x, y: y } });
    }

    setTempOpPos(x, y, w, h) {
      const pos = {
        x: x,
        y: y,
      };
      if (w !== undefined && h != undefined) {
        pos.w = w;
        pos.h = h;
      } else {
        pos.w = this.uiAttribs.translateTemp.w;
        pos.h = this.uiAttribs.translateTemp.h;
      }

      this.setUiAttribs({ translateTemp: pos });
    }

    setTempOpPosY(y) {
      this.setTempOpPos(this.getTempPosX(), y);
    }

    setTempOpPosX(x) {
      this.setTempOpPos(x, this.getTempPosY());
    }

    // getChildsBoundings(glpatch, s, untilOp, count)
    // {
    //     if (count > 100) return s;
    //     s = s || { "maxx": null, "maxy": null, "minx": null, "miny": null };

    //     if (!this.uiAttribs || !this.uiAttribs.translate) return s;

    //     s.maxx = Math.max(s.maxx || -99999999999, this.getTempPosX() + this.getWidth(glpatch));
    //     s.maxy = Math.max(s.maxy || -99999999999, this.getTempPosY() + this.getHeight(glpatch));

    //     s.minx = Math.min(s.minx || 99999999999, this.getTempPosX());
    //     s.miny = Math.min(s.miny || 99999999999, this.getTempPosY());

    //     if (untilOp && this == untilOp) return s;

    //     for (let i = 0; i < this.portsOut.length; i++)
    //     {
    //         for (let j = 0; j < this.portsOut[i].links.length; j++)
    //         {
    //             const p = this.portsOut[i].links[j].getOtherPort(this.portsOut[i]);

    //             s = p.op.getChildsBoundings(glpatch, s, untilOp, (count || 0) + 1);
    //         }
    //     }
    //     return s;
    // };

    testTempCollision(ops, glpatch) {
      // this._log.log("testTempCollision");
      for (let j = 0; j < ops.length; j++) {
        const b = ops[j];
        if (b.deleted || b == this) continue;

        // this._log.log(b.uiAttribs.translateTemp);

        if (
          this.getTempPosX() >= b.getTempPosX() &&
          this.getTempPosX() <= b.getTempPosX() + b.getWidth(glpatch) &&
          this.getTempPosY() >= b.getTempPosY() &&
          this.getTempPosY() <= b.getTempPosY() + b.getHeight(glpatch)
        ) {
          // this._log.log("colliding!");
          return b;
        }
      }
    }

    getWidth(glpatch) {
      return glpatch.getGlOp(this).w;
    }

    getHeight(glpatch) {
      return glpatch.getGlOp(this).h;
    }

    selectChilds(options) {
      options = options || {};
      if (!options.oplist) options.oplist = [];

      if (options.oplist.indexOf(this.id) > -1) return;

      options.oplist.push(this.id);

      this.setUiAttrib({ selected: true });
      for (const ipo in this.portsOut) {
        for (const l in this.portsOut[ipo].links) {
          this.portsOut[ipo].op.setUiAttrib({ selected: true });
          if (this.portsOut[ipo].links[l].portIn.op != this)
            this.portsOut[ipo].links[l].portIn.op.selectChilds(options);
        }
      }
    }

    getUiAttribs() {
      return this.uiAttribs || {};
    }

    getSubPatch() {
      return this.uiAttribs.subPatch || 0;
    }

    getParentSubPatch() {
      if (this.uiAttribs.subPatch === 0) return 0;
      const sop = Gui$1.gui.patchView.getSubPatchOuterOp(this.uiAttribs.subPatch);
      if (sop) return sop.uiAttribs.subPatch;

      return 0;
    }

    countVisiblePorts(ports) {
      let index = 0;
      for (let i = 0; i < ports.length; i++) {
        if (ports[i].uiAttribs.hidePort) continue;
        index++;
      }
      return index;
    }

    getNumVisiblePortsOut() {
      return this.countVisiblePorts(this.portsOut);
    }

    getNumVisiblePortsIn() {
      return this.countVisiblePorts(this.portsIn);
    }

    posByIndex(portIndex, numports, center = false) {
      if (portIndex == 0) {
        if (center) return gluiconfig.portWidth / 2;
        else return 0;
      }

      if (numports === undefined)
        this._log.log("posbyindex needs numports param");
      let offCenter = gluiconfig.portWidth * 0.5;
      if (!center) offCenter = 0;

      let p = 0;

      const onePort = gluiconfig.portWidth + gluiconfig.portPadding;

      if (this.uiAttribs.stretchPorts && this.uiAttribs.resizable)
        p =
          portIndex *
          (((this.uiAttribs.width ||
            (numports - 1) * onePort + gluiconfig.rectResizeSize) -
            gluiconfig.rectResizeSize) /
            (numports - 1));
      else p = portIndex * onePort;

      p += offCenter || 0;
      return p;
    }

    getPortPosX(name, opid, center, opwidth) {
      let index = 0;

      if (this.isSubPatchOp() == 2 && this.patchId) {
        const portsIn = Gui$1.gui.patchView.getSubPatchExposedPorts(
          this.patchId.get(),
          CABLES.Port.DIR_IN,
        );

        index = 0;
        for (let i = 0; i < portsIn.length; i++) {
          if (portsIn[i].uiAttribs.hidePort) continue;
          if (portsIn[i].name == name)
            return this.posByIndex(
              index,
              this.countVisiblePorts(portsIn),
              center,
            ); // * (gluiconfig.portWidth + gluiconfig.portPadding) + offCenter;
          index++;
        }

        const portsOut = Gui$1.gui.patchView.getSubPatchExposedPorts(
          this.patchId.get(),
          CABLES.Port.DIR_OUT,
        );
        index = 0;

        for (let i = 0; i < portsOut.length; i++) {
          if (portsOut[i].uiAttribs.hidePort) continue;
          if (portsOut[i].name == name)
            return this.posByIndex(
              index,
              this.countVisiblePorts(portsOut),
              center,
            ); // * (gluiconfig.portWidth + gluiconfig.portPadding) + offCenter;
          index++;
        }
      }

      index = 0;
      for (let i = 0; i < this.portsIn.length; i++) {
        if (this.portsIn[i].uiAttribs.hidePort) continue;

        if (this.portsIn[i].name == name) {
          // return (this.portsIn[i].uiAttribs["glPortIndex_" + opid] || this.portsIn[i].uiAttribs.glPortIndex || index) * (gluiconfig.portWidth + gluiconfig.portPadding) + offCenter;
          return this.posByIndex(index, this.getNumVisiblePortsIn(), center);
        }
        index++;
      }

      index = 0;
      for (let i = 0; i < this.portsOut.length; i++) {
        if (this.portsOut[i].uiAttribs.hidePort) continue;

        if (this.portsOut[i].name == name) {
          return this.posByIndex(index, this.getNumVisiblePortsOut(), center); // * (gluiconfig.portWidth + gluiconfig.portPadding) + offCenter;
        }
        index++;
      }

      // this._log.log("could not find port posx ", name, this.getTitle(), opid);

      return 2;
    }

    getFirstPortIn() {
      if (this.portsIn.length == 0) return null;
      let portIn = this.portsIn[0];
      if (portIn.ports && portIn.ports.length > 0) portIn = portIn.ports[0];

      return portIn;
    }

    getFirstPortOut() {
      if (this.portsOut.length == 0) return null;
      let portOut = this.portsOut[0];
      if (portOut.ports && portOut.ports.length > 0) portOut = portOut.ports[0];

      return portOut;
    }
  }

  CABLES.Op = UiOp;

  /**
   * tab panel for searching through the patch
   *
   * @export
   * @class FindTab
   */
  class FindTab {
    constructor(tabs, str) {
      this._toggles = [
        "recent",
        "outdated",
        "attention",
        "bookmarked",
        "commented",
        "unconnected",
        "user",
        "error",
        "warning",
        "hint",
        "dupassets",
        "extassets",
        "textures",
        "history",
        "activity",
        "notcoreops",
        "currentSubpatch",
        "selected",
      ];

      this._tab = new Tab("Search", {
        icon: "search",
        infotext: "tab_find",
        padding: true,
      });
      tabs.addTab(this._tab, true);
      this._tabs = tabs;

      this._lastSearch = "";
      this._findTimeoutId = 0;
      this._lastClicked = -1;
      this._lastSelected = -1;
      this._maxIdx = -1;
      this._inputId = "tabFindInput" + CABLES.uuid();
      this._closed = false;
      this._eleInput = null;
      this._listenerids = [];

      let colors = [];

      for (let i = 0; i < Gui$1.gui.corePatch().ops.length; i++) {
        const op = Gui$1.gui.corePatch().ops[i];
        if (!op) continue;
        if (op.uiAttribs.error) {
          if (namespace$1.isDeprecatedOp(op.objName)) op.isDeprecated = true;
        }
        if (op.uiAttribs.warning) ;
        if (op.uiAttribs.color) colors.push(op.uiAttribs.color);
      }
      colors = CABLES.uniqueArray(colors);

      const html = getHandleBarHtml("tab_find", {
        colors,
        inputid: this._inputId,
        toggles: this._toggles,
      });

      this._tab.html(html);

      this._updateCb = this.searchAfterPatchUpdate.bind(this);

      const listenerChanged = Gui$1.gui.opHistory.on(
        "changed",
        this.updateHistory.bind(this),
      );
      this._listenerids.push(listenerChanged);

      this._listenerids.push(
        Gui$1.gui.corePatch().on("warningErrorIconChange", this._updateCb),
      );
      this._listenerids.push(
        Gui$1.gui.corePatch().on("onOpDelete", this._updateCb),
      );
      this._listenerids.push(Gui$1.gui.corePatch().on("onOpAdd", this._updateCb));
      this._listenerids.push(
        Gui$1.gui.corePatch().on("commentChanged", this._updateCb),
      );

      this._tab.on("close", () => {
        Gui$1.gui.opHistory.off(listenerChanged);

        for (let i = 0; i < this._listenerids.length; i++) {
          Gui$1.gui.corePatch().off(this._listenerids[i]);
        }

        this._closed = true;
      });

      if (ele.byId(this._inputId)) ele.byId(this._inputId).focus();

      ele.byId(this._inputId).addEventListener("input", (e) => {
        this.search(e.target.value);
      });

      ele.byId(this._inputId).select();

      for (let i = 0; i < this._toggles.length; i++) {
        const toggleEle = ele.byId(this._inputId + "_" + this._toggles[i]);

        toggleEle.addEventListener("click", () => {
          toggleEle.classList.toggle("findToggleActive");

          const toggles = ele.byClassAll("findToggleActive");
          // console.log("toggles", toggles);
          let srchStr = "";
          for (let j = 0; j < toggles.length; j++)
            srchStr += (toggles[j].dataset.togglestr || "") + " ";

          const toggleInput = /** @type {HTMLInputElement} */ ele.byId(
            this._inputId + "_toggles",
          );
          toggleInput.value = srchStr;

          document
            .getElementById(this._inputId)
            .dispatchEvent(new Event("input"));
        });
      }

      ele.byId(this._inputId).addEventListener("keydown", (e) => {
        if (e.keyCode == 38) {
          let c = this._lastClicked - 1;
          if (c < 0) c = 0;
          this.setClicked(c);
          const resultEle = ele.byId("findresult" + c);
          if (resultEle) resultEle.click();
          if (ele.byId(this._inputId)) ele.byId(this._inputId).focus();
        } else if (e.keyCode == 40) {
          let c = this._lastClicked + 1;
          if (c > this._maxIdx - 1) c = this._maxIdx;
          this.setClicked(c);
          const resultEle = ele.byId("findresult" + c);
          if (resultEle) resultEle.click();
          if (ele.byId(this._inputId)) ele.byId(this._inputId).focus();
        }
      });

      this._eleInput = document.querySelector("#tabsearchbox input");
      this._eleInput.value = this._lastSearch;
      this._eleResults = ele.byId("tabsearchresult");

      this.focus();
      ele.byId(this._inputId).setSelectionRange(0, this._lastSearch.length);

      clearTimeout(this._findTimeoutId);

      this.search(this._lastSearch);
      this.updateHistory();

      if (str) {
        this._eleInput.value = str;
        this.search(str);
        this.setSearchInputValue(str);
      }
      this.focus();
    }

    focus() {
      this._tabs.activateTab(this._tab.id);

      if (
        ele.byId(this._inputId) &&
        document.activeElement != ele.byId(this._inputId)
      ) {
        ele.byId(this._inputId).focus();
        ele.byId(this._inputId).select();
      }
    }

    isClosed() {
      return this._closed;
    }

    setSearchInputValue(str) {
      this._eleInput.value = str;
    }

    searchAfterPatchUpdate() {
      clearTimeout(this._findTimeoutId);
      this._findTimeoutId = setTimeout(() => {
        const el = ele.byId(this._inputId);
        if (el) this.search(el.value, true);
      }, 100);
    }

    isVisible() {
      return this._tab.isVisible();
    }

    _addResultOp(op, result, idx) {
      if (!op || !op.uiAttribs || !op.uiAttribs.translate) return;
      let html = "";
      let info = "";
      this._maxIdx = idx;

      info +=
        "## searchresult \n\n* score : " +
        result.score +
        text.searchResult +
        "\n";

      if (op.op) op = op.op;

      const colorClass = opNames.getNamespaceClassName(op.objName);

      let hiddenClass = "";
      if (op.uiAttribs.hidden) hiddenClass = "resultHiddenOp";
      if (op.storage && op.storage.blueprint) hiddenClass = "resultHiddenOp";

      html +=
        '<div tabindex="0" id="findresult' +
        idx +
        '" class="info findresultop' +
        op.id +
        " " +
        hiddenClass +
        ' " data-info="' +
        info +
        '" ';
      html +=
        'onkeypress="ele.keyClick(event,this)" onclick="Gui.gui.focusFindResult(\'' +
        String(idx) +
        "','" +
        op.id +
        "','" +
        op.uiAttribs.subPatch +
        "'," +
        op.uiAttribs.translate.x +
        "," +
        op.uiAttribs.translate.y +
        ');">';

      let colorHandle = "";
      if (op.uiAttribs.color)
        colorHandle =
          '<span style="background-color:' +
          op.uiAttribs.color +
          ';">&nbsp;&nbsp;</span>&nbsp;&nbsp;';

      html += '<h3 class="' + colorClass + '">' + colorHandle + op.shortName;
      if (op.uiAttribs.extendTitle)
        html +=
          ' <span style="color: var(--color-13);"> | ' +
          op.uiAttribs.extendTitle +
          "</span>";

      if (op.isSubPatchOp())
        html +=
          '<span data-eletype="icon" class="icon icon-blueprint iconhover" style="margin-left: 6px;vertical-align: bottom;margin-bottom: 2px;"></span>';

      html += "</h3>";

      if (result.hint)
        html += '<div class="warning-error-level0">' + result.hint + "</div>";
      if (result.error)
        html += '<div class="warning-error-level2">' + result.error + "</div>";
      if (result.history)
        html +=
          '<span class="search-history-item">' + result.history + "</span><br/>";
      if (op.uiAttribs.comment)
        html +=
          '<span style="color: var(--color-special);"> // ' +
          op.uiAttribs.comment +
          "</span><br/>";
      // html += "" + op.objName + "<br/>";
      html += result.where || "";

      let highlightsubpatch = "";
      if (op.uiAttribs.subPatch == Gui$1.gui.patchView.getCurrentSubPatch())
        highlightsubpatch = "highlight";

      if (op.uiAttribs.subPatch != 0)
        html +=
          '<br/> Subpatch: <span class="' +
          highlightsubpatch +
          '">' +
          Gui$1.gui.patchView.getSubPatchName(op.uiAttribs.subPatch) +
          "</span>";

      html += "</div>";

      // this._eleResults.innerHTML += html;
      return html;
    }

    highlightWord(word, str) {
      if (!str || str == "") return "";
      str += "";

      const pos = str.toLowerCase().indexOf(word.toLowerCase());
      if (pos >= 0) {
        const outStrA = str.substring(pos - 15, pos);
        const outStrB = str.substring(pos, pos + word.length);
        const outStrC = str.substring(pos + word.length, pos + 15);
        // str = str.replace(stringReg, "<span class=\"highlight\">" + word + "</span>");
        str =
          outStrA +
          '<b style="background-color:#aaa;color:black;">' +
          outStrB +
          "</b>" +
          outStrC;
      }

      return str;
    }

    _doSearchTriggers(str, userInvoked, ops, results) {
      const triggers = Gui$1.gui.corePatch().namedTriggers;
      const foundtriggers = [];

      for (let i in triggers) {
        if (i.toLowerCase().indexOf(str) > -1) {
          foundtriggers.push(i);
        }
      }
      return foundtriggers;
    }

    _doSearchVars(str, userInvoked, ops, results) {
      const vars = Gui$1.gui.corePatch().getVars();
      const foundVars = [];

      for (let i in vars) {
        if (i.toLowerCase().indexOf(str) > -1) {
          foundVars.push(vars[i]);
        }
      }
      return foundVars;
    }

    /**
     * @param {String} str
     * @param {boolean} userInvoked
     * @param {Array<UiOp>} ops
     * @param {Array} results
     */
    _doSearch(str, userInvoked, ops, results) {
      this._lastSearch = str;

      str = str.toLowerCase();

      results = results || [];

      if (str.indexOf(":") == 0) {
        if (str == ":attention") {
          if (
            Gui$1.gui.project().summary.isBasicExample ||
            (Gui$1.gui.project().summary.exampleForOps &&
              Gui$1.gui.project().summary.exampleForOps.length > 0)
          ) {
            FindTab.searchOutDated(ops, results);
            for (let i = 0; i < results.length; i++) {
              if (results[i].op) {
                if (namespace$1.isDeprecatedOp(results[i].op.objName))
                  results[i].error =
                    "example patch: Op is deprecated, should not be used anymore ";
                else
                  results[i].error =
                    "example patch: Newer version of op available!";
              }
            }
          }

          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];

            if (
              op.uiAttribs &&
              op.uiAttribs.uierrors &&
              op.uiAttribs.uierrors.length > 0
            )
              for (let j = 0; j < op.uiAttribs.uierrors.length; j++)
                if (op.uiAttribs.uierrors[j].level == 2)
                  results.push({
                    op,
                    score: 2,
                    error: op.uiAttribs.uierrors[j].txt,
                  });
          }
        }

        if (str == ":outdated") {
          FindTab.searchOutDated(ops, results);
        }

        if (str == ":selected") {
          FindTab.searchSelected(ops, results);
        }

        if (str == ":recent") {
          const history = Gui$1.gui.opHistory.getAsArray(99);

          for (let i = 0; i < history.length; i++) {
            const op = Gui$1.gui.corePatch().getOpById(history[i].id);
            results.push({ op, score: 1 });
          }
        }
        if (str == ":notcoreops") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];
            if (
              namespace$1.isPatchOp(op.objName) ||
              namespace$1.isUserOp(op.objName) ||
              namespace$1.isTeamOp(op.objName) ||
              namespace$1.isExtensionOp(op.objName)
            ) {
              results.push(op);
            }
          }
        }

        if (str == ":activity") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];

            let activity = 0;
            for (let k = 0; k < ops[i].portsIn.length; k++)
              activity += ops[i].portsIn[k].activityCounter;

            if (activity) results.push({ op, score: activity }); // "where": "activity: " + activity
          }
        } else if (str == ":error") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];

            if (
              op.uiAttribs &&
              op.uiAttribs.uierrors &&
              op.uiAttribs.uierrors.length > 0
            )
              for (let j = 0; j < op.uiAttribs.uierrors.length; j++)
                if (op.uiAttribs.uierrors[j].level == 2)
                  results.push({
                    op,
                    score: 1,
                    error: op.uiAttribs.uierrors[j].txt,
                  });
          }
        } else if (str == ":warning") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];

            if (
              op.uiAttribs &&
              op.uiAttribs.uierrors &&
              op.uiAttribs.uierrors.length > 0
            )
              for (let j = 0; j < op.uiAttribs.uierrors.length; j++)
                if (op.uiAttribs.uierrors[j].level == 1)
                  results.push({ op, score: 1 });
          }
        } else if (str == ":hint") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];
            if (
              op.uiAttribs &&
              op.uiAttribs.uierrors &&
              op.uiAttribs.uierrors.length > 0
            )
              results.push({ op, score: 1 });
          }
        } else if (str == ":commented") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];

            if (
              op.uiAttribs &&
              op.uiAttribs.comment &&
              op.uiAttribs.comment.length > 0
            )
              results.push({ op, score: 1, where: op.uiAttribs.comment });
          }
        } else if (str == ":currentsubpatch") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];
            if (
              op.uiAttribs &&
              op.uiAttribs.subPatch == Gui$1.gui.patchView.getCurrentSubPatch()
            )
              results.push({ op, score: 1 });
          }
        } else if (str == ":textures") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];
            for (let j = 0; j < op.portsOut.length; j++) {
              if (
                op.portsOut[j].get() &&
                op.portsOut[j].uiAttribs.objType === "texture"
              ) {
                if (op.portsOut[j].get()) {
                  let strtex = "unknown";
                  if (op.portsOut[j].get() && op.portsOut[j].get().getInfo) {
                    const texInfo = op.portsOut[j].get().getInfo();
                    strtex =
                      op.portsOut[j].get().width +
                      " x " +
                      op.portsOut[j].get().height +
                      " - " +
                      texInfo.filter +
                      " / " +
                      texInfo.wrap +
                      " / " +
                      texInfo.textureType;
                  }

                  results.push({ op, score: 1, where: strtex });
                }
              }
            }

            // if (op.uiAttribs && op.uiAttribs.comment && op.uiAttribs.comment.length > 0)
            //     results.push({ op, "score": 1, "where": op.uiAttribs.comment });
          }
        } else if (str == ":user") {
          FindTab.searchUserOps(ops, results);
        } else if (str == ":dupassets") {
          const assetOps = {};
          for (let i = 0; i < ops.length; i++) {
            for (let k = 0; k < ops[i].portsIn.length; k++) {
              if (ops[i].portsIn[k].uiAttribs.display === "file") {
                if (ops[i].portsIn[k].get()) {
                  assetOps[ops[i].portsIn[k].get()] = assetOps[
                    ops[i].portsIn[k].get()
                  ] || { ops: [] };
                  assetOps[ops[i].portsIn[k].get()].ops.push(ops[i]);
                }
              }
            }
          }

          for (let i in assetOps) {
            if (assetOps[i].ops.length > 1) {
              for (let j = 0; j < assetOps[i].ops.length; j++)
                results.push({ op: assetOps[i].ops[j], score: 1 });
            }
          }
        } else if (str == ":extassets") {
          for (let i = 0; i < ops.length; i++) {
            for (let k = 0; k < ops[i].portsIn.length; k++) {
              if (ops[i].portsIn[k].uiAttribs.display === "file") {
                const value = ops[i].portsIn[k].get();
                if (
                  value &&
                  value.startsWith("/assets/") &&
                  !value.startsWith("/assets/" + Gui$1.gui.patchId)
                ) {
                  results.push({ op: ops[i], score: 1 });
                }
              }
            }
          }
        } else if (str.indexOf(":color=") == 0) {
          const col = str.substr(7).toLowerCase();

          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];
            if (op.uiAttribs.color && op.uiAttribs.color.toLowerCase() == col)
              results.push({ op: op, score: 1 });
          }
        } else if (str == ":bookmarked") {
          const bms = Gui$1.gui.bookmarks.getBookmarks();

          for (let i = 0; i < bms.length; i++) {
            const op = Gui$1.gui.corePatch().getOpById(bms[i]);
            results.push({ op, score: 1 });
          }
        } else if (str == ":unconnected") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];
            let count = 0;
            for (let j = 0; j < op.portsIn.length; j++)
              if (op.portsIn[j].isLinked()) count++;

            if (count == 0) {
              for (let j = 0; j < op.portsOut.length; j++)
                if (op.portsOut[j].isLinked()) count++;
            }

            if (count == 0) results.push({ op, score: 1 });
          }
        } else if (str == ":history") {
          for (let i = 0; i < ops.length; i++) {
            const op = ops[i];
            let score = 0;
            let dateString = null;
            let userName = null;
            if (op.uiAttribs.history && op.uiAttribs.history.lastInteractionAt) {
              score = op.uiAttribs.history.lastInteractionAt;
              userName = op.uiAttribs.history.lastInteractionBy.name;
              dateString = moment(
                op.uiAttribs.history.lastInteractionAt,
              ).fromNow();
            }
            if (score > 0) {
              results.push({
                op,
                score: score,
                history: dateString + " - changed by " + userName,
              });
            }
          }
        }
      } else {
        let where = "";

        for (let i = 0; i < ops.length; i++) {
          let score = 0;
          let found = false;

          if (str.length > 5) {
            if (ops[i].id.indexOf(str) > -1) {
              where = "op id ";
              score += 1;
            }
          }

          if (ops[i].objName.toLowerCase().indexOf(str) > -1) {
            where = "name: " + this.highlightWord(str, ops[i].objName);
            score += 1;
            found = true;
          }

          if (
            ops[i].uiAttribs.extendTitle &&
            (ops[i].uiAttribs.extendTitle + "").toLowerCase().indexOf(str) > -1
          ) {
            where =
              "title: " + this.highlightWord(str, ops[i].uiAttribs.extendTitle);
            score += 1;
            found = true;
          }

          if (
            ops[i].uiAttribs.comment &&
            ops[i].uiAttribs.comment.toLowerCase().indexOf(str) > -1
          ) {
            where =
              "comment: " + this.highlightWord(str, ops[i].uiAttribs.comment);
            score += 1;
            found = true;
          }

          if (ops[i].opId.indexOf(str) > -1) {
            where = "opid: " + ops[i].opId;
            score += 1;
            found = true;
          }

          if (ops[i].id.indexOf(str) > -1) {
            where = "id: " + ops[i].id;
            score += 1;
            found = true;
          }

          if (
            String(ops[i].name || "")
              .toLowerCase()
              .indexOf(str) > -1
          ) {
            if (ops[i].objName.indexOf(ops[i].name) == -1) score += 2; // extra points if non default name

            if (String(ops[i].name || "").indexOf("var set") === 0) score += 2; // extra points if var setter

            where = "name: " + this.highlightWord(str, ops[i].name);
            score += 2;
            found = true;
          }

          const op = ops[i];
          for (let j = 0; j < op.portsIn.length; j++) {
            if (
              op.portsIn[j].getVariableName() &&
              op.portsIn[j].getVariableName().toLowerCase().indexOf(str) > -1
            ) {
              score += 2;
              where +=
                'port "' +
                op.portsIn[j].name +
                '" assigned to var ' +
                op.portsIn[j].getVariableName();
              found = true;
            }

            if ((op.portsIn[j].get() + "").toLowerCase().indexOf(str) > -1) {
              where =
                '<span style="color:var(--color_port_' +
                op.portsIn[j].getTypeString().toLowerCase() +
                ');"></span> ';

              if (!op.portsIn[j].isLinked()) score += 2;
              else where += "linked ";
              where +=
                op.portsIn[j].name +
                ": " +
                this.highlightWord(str, escapeHTML(op.portsIn[j].get()));
              score += 2;
              found = true;
            }
          }

          if (op.uiAttribs.hidden) score -= 5;
          if (op.storage && op.storage.blueprint) score -= 1;
          if (
            found &&
            op.uiAttribs.subPatch == Gui$1.gui.patchView.getCurrentSubPatch()
          )
            score++;
          if (found) results.push({ op: ops[i], score, where });
        }
      }
      return results;
    }

    search(str, userInvoked) {
      str = str || this._lastSearch;
      // console.log("search str", str, (new Error()).stack);
      this._maxIdx = -1;
      this.setSelectedOp(null);
      this.setClicked(-1);

      const toggleInput = ele.byId(this._inputId + "_toggles");
      if (toggleInput && toggleInput.value) str += " " + toggleInput.value;

      const strs = str.split(" ");
      const startTime = performance.now();

      let html = "";
      this._eleResults.innerHTML = "";

      if (str.length < 2) {
        this._eleResults.innerHTML = "Type some more!";
        return;
      }

      let results =
        this._doSearch(strs[0] || "", userInvoked, Gui$1.gui.corePatch().ops) || [];

      this._doSearchTriggers(strs[0]);
      let resultsVars = [];
      // resultsVars=this._doSearchVars(strs[0]);

      if (strs.length > 1) {
        for (let i = 1; i < strs.length; i++) {
          if (!strs[i]) continue;

          const ops = [];
          for (let j = 0; j < results.length; j++) ops.push(results[j].op);

          const newResults =
            this._doSearch(strs[i] || "", userInvoked, ops) || [];

          results = newResults;
        }
      }

      let foundNum = results.length + resultsVars.length;

      if (foundNum === 0) {
        let what = "ops";
        if (str == ":error") what = "errors";

        html =
          '<div style="pointer-events:none">&nbsp;&nbsp;&nbsp;No ' +
          what +
          " found</div>";
      } else {
        results.sort(function (a, b) {
          return b.score - a.score;
        });
        const numResults = results.length;
        const limitResults = 200;
        if (numResults > limitResults) {
          html +=
            '<div style="pointer-events:none" class="warning-error-level1">found ' +
            numResults +
            " ops showing only first " +
            limitResults +
            " ops<br/></div>";
          results = results.slice(0, limitResults);
        }
        for (let i = 0; i < results.length; i++)
          html += this._addResultOp(results[i].op, results[i], i);

        let onclickResults = "Gui.gui.patchView.unselectAllOps();";

        for (let i = 0; i < results.length; i++)
          onclickResults +=
            "Gui.gui.patchView.selectOpId('" + results[i].op.id + "');";

        onclickResults += "Gui.gui.patchView.showSelectedOpsPanel();";
        html +=
          '<div style="background-color:var(--color-02);border-bottom:none;">' +
          results.length +
          " ops found";

        html +=
          ' &nbsp;&nbsp;<a class="button-small" onclick="' +
          onclickResults +
          '">Select results</a><br/>';

        html += "</div>";
      }

      this._eleResults.innerHTML = html;
      Gui$1.gui.patchView.checkPatchErrors();

      if (!userInvoked) this.focus();

      performance.now() - startTime;
    }

    setClicked(num) {
      num = parseInt(num);

      let el = ele.byId("findresult" + this._lastClicked);
      if (el) el.classList.remove("lastClicked");

      el = ele.byId("findresult" + num);
      if (el) el.classList.add("lastClicked");
      this._lastClicked = num;
    }

    setSelectedOp(opid) {
      let els = document.getElementsByClassName(
        "findresultop" + this._lastSelected,
      );
      if (els && els.length == 1) els[0].classList.remove("selected");

      els = document.getElementsByClassName("findresultop" + opid);
      if (els && els.length == 1) els[0].classList.add("selected");
      this._lastSelected = opid;
    }

    updateHistory() {
      if (this._lastSearch == ":recent") {
        this._updateCb();
      }
    }
  }

  FindTab.searchOutDated = (ops, results) => {
    for (let i = 0; i < ops.length; i++) {
      const doc = Gui$1.gui.opDocs.getOpDocByName(ops[i].objName);
      if ((doc && doc.oldVersion) || namespace$1.isDeprecatedOp(ops[i].objName))
        results.push({ op: ops[i], score: 1 });
    }
    return results;
  };

  FindTab.searchSelected = (ops, results) => {
    for (let i = 0; i < ops.length; i++) {
      if (ops[i].uiAttribs.selected) results.push({ op: ops[i], score: 1 });
    }

    return results;
  };

  FindTab.searchUserOps = (ops, results) => {
    for (let i = 0; i < ops.length; i++) {
      const op = ops[i];
      if (namespace$1.isUserOp(op.objName))
        results.push({ op: op, score: 1, where: op.objName });
    }
    return results;
  };

  FindTab.searchPatchOps = (ops, results) => {
    for (let i = 0; i < ops.length; i++) {
      const op = ops[i];
      if (namespace$1.isPatchOp(op.objName))
        results.push({ op, score: 1, where: op.objName });
    }
    return results;
  };

  FindTab.searchTeamOps = (ops, results) => {
    for (let i = 0; i < ops.length; i++) {
      const op = ops[i];
      if (namespace$1.isTeamOp(op.objName))
        results.push({ op, score: 1, where: op.objName });
    }
    return results;
  };

  FindTab.searchExtensionOps = (ops, results) => {
    for (let i = 0; i < ops.length; i++) {
      const op = ops[i];
      if (namespace$1.isExtensionOp(op.objName))
        results.push({ op, score: 1, where: op.objName });
    }
    return results;
  };

  const splitpane = {};
  window.splitpane = splitpane;
  splitpane.listeners = [];

  function initSplitPanes() {
    ele.byId("splitterPatch").addEventListener("pointerdown", function (ev) {
      Gui$1.gui.pauseProfiling();
      ev.preventDefault();
      splitpane.bound = true;
      function mm(e) {
        Gui$1.gui.pauseInteractionSplitpanes();

        Gui$1.gui.pauseProfiling();
        e.preventDefault();

        const pos =
          (window.innerWidth - e.clientX) *
          (1 / Gui$1.gui.corePatch().cgl.canvasScale);

        if (Gui$1.gui.rendererWidth != -1) Gui$1.gui.rendererWidth = pos;
        Gui$1.gui.splitpanePatchPos = pos;

        Gui$1.gui.setLayout();
        Gui$1.gui.emitEvent(Gui$1.gui.EVENT_RESIZE_CANVAS);
        Gui$1.gui.canvasManager.getCanvasUiBar().updateCanvasIconBar();
      }

      document.addEventListener("pointermove", mm);
      splitpane.listeners.push(mm);
    });

    ele.byId("splitterPatch").addEventListener("pointerup", function (_e) {
      Gui$1.gui.resumeInteractionSplitpanes();
    });

    ele.byId("splitterMaintabs").addEventListener("pointerup", function (_e) {
      Gui$1.gui.resumeInteractionSplitpanes();
    });

    function resizeTabs(_ev) {
      Gui$1.gui.pauseProfiling();
      splitpane.bound = true;
      function mm(e) {
        Gui$1.gui.pauseInteractionSplitpanes();

        Gui$1.gui.editorWidth = e.clientX;
        if (Gui$1.gui.editorWidth < 30) Gui$1.gui.editorWidth = 30;
        UserSettings.userSettings.set("editorWidth", Gui$1.gui.editorWidth);
        Gui$1.gui.setLayout();
        Gui$1.gui.mainTabs.emitEvent("resize");
      }

      document.addEventListener("pointermove", mm, { passive: false });
      splitpane.listeners.push(mm);
    }

    ele
      .byId("splitterMaintabs")
      .addEventListener("pointerdown", resizeTabs, { passive: false });

    ele.byId("splitterRenderer").addEventListener("pointerdown", function (ev) {
      ev.preventDefault();
      splitpane.bound = true;
      function mm(e) {
        e.preventDefault();
        Gui$1.gui.rendererHeight =
          e.clientY * (1 / Gui$1.gui.corePatch().cgl.canvasScale);
        Gui$1.gui.setLayout();
        Gui$1.gui.canvasManager.getCanvasUiBar().updateCanvasIconBar();
      }

      document.addEventListener("pointermove", mm);
      splitpane.listeners.push(mm);
    });

    ele.byId("splitterBottomTabs").addEventListener("pointerdown", function (ev) {
      ev.preventDefault();
      splitpane.bound = true;
      function mm(e) {
        Gui$1.gui.pauseInteractionSplitpanes();
        e.preventDefault();
        Gui$1.gui.bottomTabPanel.setHeight(window.innerHeight - e.clientY);
        Gui$1.gui.setLayout();
      }

      document.addEventListener("pointermove", mm);
      splitpane.listeners.push(mm);
    });

    function resizeRenderer(ev) {
      if (Gui$1.gui.canvasManager.mode == Gui$1.gui.canvasManager.CANVASMODE_PATCHBG)
        return;

      if (ev.shiftKey) {
        if (!splitpane.rendererAspect)
          splitpane.rendererAspect =
            Gui$1.gui.rendererWidth / Gui$1.gui.rendererHeight;
      } else splitpane.rendererAspect = 0.0;

      ev.preventDefault();
      splitpane.bound = true;
      function mm(e) {
        Gui$1.gui.pauseInteractionSplitpanes();
        let x = e.clientX;
        let y = e.clientY;

        if (x === undefined && e.touches && e.touches.length > 0) {
          x = e.touches[0].clientX;
          y = e.touches[0].clientY;
        }

        Gui$1.gui.rendererWidth =
          (window.innerWidth - x) * (1 / Gui$1.gui.corePatch().cgl.canvasScale) + 3;

        if (splitpane.rendererAspect)
          Gui$1.gui.rendererHeight =
            (1 / splitpane.rendererAspect) * Gui$1.gui.rendererWidth;
        else
          Gui$1.gui.rendererHeight =
            y * (1 / Gui$1.gui.corePatch().cgl.canvasScale) - 38;

        Gui$1.gui.setLayout();
        Gui$1.gui.canvasManager.getCanvasUiBar().updateCanvasIconBar();
        Gui$1.gui.canvasManager.focus();
        Gui$1.gui.emitEvent(Gui$1.gui.EVENT_RESIZE_CANVAS);
        e.preventDefault();
      }

      document.addEventListener("pointermove", mm);
      splitpane.listeners.push(mm);
    }

    ele
      .byId("splitterRendererWH")
      .addEventListener("pointerdown", resizeRenderer, { passive: false });

    function stopSplit(_e) {
      if (splitpane.listeners.length > 0) {
        for (let i = 0; i < splitpane.listeners.length; i++)
          document.removeEventListener("pointermove", splitpane.listeners[i]);

        Gui$1.gui.resumeInteractionSplitpanes();

        splitpane.listeners.length = 0;
        splitpane.bound = false;
        Gui$1.gui.setLayout();
      }
    }

    document.addEventListener("pointerup", stopSplit);
  }

  /**
   * rendering cables for links
   *
   * @export
   * @class GlCable
   */
  class GlCable {
    /**
     * @param {GlPatch} glPatch
     * @param {GlSplineDrawer} splineDrawer
     * @param {GlRect} buttonRect
     * @param {number} type
     * @param {GlLink} link
     * @param {String} subpatch
     */
    constructor(glPatch, splineDrawer, buttonRect, type, link, subpatch) {
      this.LINETYPE_CURVED = 0;
      this.LINETYPE_STRAIGHT = 1;
      this.LINETYPE_SIMPLE = 2;
      this.LINETYPE_HANGING = 3;

      this._log = new Logger("glcable");

      this._x = 0;
      this._y = 0;
      this._x2 = 0;
      this._y2 = 0;

      this._points = [];

      this._buttonSize = Gui$1.gui.theme.patch.cableButtonSize || 17;
      this._linetype = this.LINETYPE_CURVED;

      this._subPatch = subpatch;
      this._glPatch = glPatch;
      this._buttonRect = buttonRect;
      this._type = type;
      this._disposed = false;
      this._visible = true;
      if (link) this._visible = link.visible;

      this._link = link;

      this._splineDrawer = splineDrawer;
      this._splineIdx = this._splineDrawer.getSplineIndex();

      this._buttonRect.setShape(1);
      this._buttonRect.visible = false;

      this._buttonRect.on(GlRect.EVENT_POINTER_HOVER, () => {
        this.setCloseToMouse(true);
        this._link.cableHoverChanged(this, true);
        this.updateColor();
      });

      this._buttonRect.on(GlRect.EVENT_POINTER_UNHOVER, () => {
        this._unHover();
      });

      Gui$1.gui.on("themeChanged", () => {
        this._oldx = this._oldy = this._oldx2 = this._oldy2 = 0;
        this._buttonSize = Gui$1.gui.theme.patch.cableButtonSize || 17;
        this._setPositionButton();
        this._updateLinePos();
      });

      this._distFromPort = 0;
      this._updateDistFromPort();

      this.updateMouseListener();

      this.updateLineStyle();
      this.updateColor();
    }

    get subPatch() {
      return this._subPatch;
    }

    updateLineStyle() {
      this._oldx = this._oldy = this._oldx2 = this._oldy2 = 0;
      this._tension = 0.1;
      this._curvedSimple = false;
      // const oldLineType = this._linetype;
      this._linetype = this.LINETYPE_CURVED;

      if (UserSettings.userSettings.get("linetype") == "simple")
        this._linetype = this.LINETYPE_SIMPLE;
      if (UserSettings.userSettings.get("linetype") == "straight")
        this._linetype = this.LINETYPE_STRAIGHT;
      if (UserSettings.userSettings.get("linetype") == "h1") {
        this._linetype = this.LINETYPE_HANGING;
        this._tension = 0.0;
      }
      if (UserSettings.userSettings.get("linetype") == "h2") {
        this._linetype = this.LINETYPE_HANGING;
        this._tension = 0.2;
      }
      if (UserSettings.userSettings.get("linetype") == "h3") {
        this._linetype = this.LINETYPE_HANGING;
        this._tension = 0.3;
      }

      this._updateDistFromPort();
      this._updateLinePos();
    }

    updateMouseListener() {
      if (this._visible) {
        if (!this._listenerMousemove)
          this._listenerMousemove = this._glPatch.on(
            "mousemove",
            this._checkCollide.bind(this),
          );
      }

      if ((!this._visible || this._disposed) && this._listenerMousemove) {
        this._glPatch.off(this._listenerMousemove);
        this._listenerMousemove = null;
      }
    }

    setCloseToMouse(b) {
      if (this._buttonRect.interactive != b) {
        this._buttonRect.visible = this._buttonRect.interactive = b;
        if (!b) this._unHover();
      }
    }

    _unHover() {
      this.setCloseToMouse(false);
      this._link.cableHoverChanged();
      this.updateColor();
    }

    updateVisible() {
      const old = this._visible;
      this._visible = this._subPatch == this._glPatch.getCurrentSubPatch();
      if (this._disposed) this._visible = false;

      if (old != this._visible) {
        if (!this._visible) this.setCloseToMouse(false);
        this.updateMouseListener();
      }
    }

    /**
     * @param {boolean} v
     */
    set visible(v) {
      // is this even needed ? all cables are drawn because the splinedrawer is bound to a specific subpatch anyway....
      if (this._visible != v) this._oldx = null;
      this._visible = v;
      this._updateLinePos();
    }

    _checkCollide(e) {
      if (this._disposed) return;
      if (this._glPatch.isAreaSelecting) return;
      if (!this._visible) return false;
      if (this._subPatch != this._glPatch.getCurrentSubPatch()) return false;

      if (this._glPatch.isDraggingOps()) {
        if (this._glPatch.getNumSelectedOps() == 1) {
          const op = this._glPatch.getOnlySelectedOp();
          const glop = this._glPatch.getGlOp(op);
          if (glop.displayType === glop.DISPLAY_SUBPATCH) ; else if (op.portsIn.length > 0 && op.portsOut.length > 0) {
            if (
              !(
                op.getFirstPortIn().type == this._type &&
                op.getFirstPortOut().type == this._type
              )
            )
              return false;
          }
        }
      }

      this.collideMouse(
        e,
        this._x,
        this._y - this._distFromPort,
        this._x2,
        this._y2 + this._distFromPort,
        this._glPatch.viewBox.mousePatchX,
        this._glPatch.viewBox.mousePatchY,
        this._buttonSize * 0.4,
      );
    }

    dispose() {
      this._disposed = true;

      this._splineDrawer.setSplineColor(this._splineIdx, [0, 0, 0, 1]);
      this._buttonRect.setColor(0, 0, 0, 1);

      this._splineDrawer.deleteSpline(this._splineIdx);
      this.updateVisible();
      this.updateMouseListener();
    }

    _updateDistFromPort() {
      if (this._linetype == this.LINETYPE_SIMPLE || this._curvedSimple) {
        this._distFromPort = 0;
        return;
      }
      if (Math.abs(this._y - this._y2) < gluiconfig.portHeight * 2)
        this._distFromPort = gluiconfig.portHeight * 0.5;
      else this._distFromPort = gluiconfig.portHeight * 2.9; // magic number...?!
    }

    _subdivide(inPoints, divs) {
      const arr = [];
      const subd = divs || 4;
      let newLen = (inPoints.length - 4) * (subd - 1);

      if (newLen != arr.length) arr.length = Math.floor(Math.abs(newLen));
      let count = 0;

      function ip(x0, x1, x2, t) {
        // Bezier
        const r = x0 * (1 - t) * (1 - t) + 2 * x1 * (1 - t) * t + x2 * t * t;
        return r;
      }

      for (let i = 3; i < inPoints.length - 3; i += 3) {
        for (let j = 0; j < subd; j++) {
          for (let k = 0; k < 3; k++) {
            const p = ip(
              (inPoints[i + k - 3] + inPoints[i + k]) / 2,
              inPoints[i + k + 0],
              (inPoints[i + k + 3] + inPoints[i + k + 0]) / 2,
              j / subd,
            );
            arr[count] = p;
            count++;
          }
        }
      }

      arr.push(
        inPoints[inPoints.length - 3],
        inPoints[inPoints.length - 2],
        inPoints[inPoints.length - 1],
      );
      arr.unshift(inPoints[0], inPoints[1], inPoints[2]);

      return arr;
    }

    _updateLinePos() {
      if (this._disposed) return;
      this._updateDistFromPort();

      // "hanging" cables
      // this._splineDrawer.setSpline(this._splineIdx,
      //     this._subdivide(
      //         [
      //             this._x, this._y, 0,
      //             this._x, this._y, 0,
      //             this._x, this._y - this._distFromPort * 2.0, 0,
      //             this._x2, this._y2 + Math.abs((this._y2 - this._y)) * 1.7, 0,
      //             this._x2, this._y2, 0,
      //             this._x2, this._y2, 0,
      //         ]));

      if (
        this._oldx != this._x ||
        this._oldy != this._y ||
        this._oldx2 != this._x2 ||
        this._oldy2 != this._y2
      ) {
        let posX = (this._oldx = this._x);
        let posX2 = (this._oldy = this._y);
        this._oldx2 = this._x2;
        this._oldy2 = this._y2;

        if (this._x !== 0 && this._x2 !== 0) {
          posX = this._x + gluiconfig.portWidth / 2 - 5;
          posX2 = this._x2 + gluiconfig.portWidth / 2 - 5;
        }

        if (this._linetype == this.LINETYPE_CURVED) {
          if (this._x == this._x2 || Math.abs(this._x - this._x2) < 50) {
            this._curvedSimple = true;
            this._updateDistFromPort();

            this._points =
              // this._subdivide(
              [
                posX,
                this._y,
                gluiconfig.zPosCables,
                // posX, this._y, gluiconfig.zPosCables,
                posX2,
                this._y2,
                gluiconfig.zPosCables,
                posX2,
                this._y2,
                gluiconfig.zPosCables,
              ];
            // );

            this._splineDrawer.setSpline(this._splineIdx, this._points);
          } else {
            if (this._curvedSimple) {
              this._curvedSimple = false;
              this._updateDistFromPort();
            }

            const distY = Math.abs(this._y - this._y2);

            this._points = [
              posX,
              this._y,
              gluiconfig.zPosCables,
              posX,
              this._y -
                distY * 0.002 -
                this._distFromPort * (Gui$1.gui.theme.patch.cablesCurveY || 1.25),
              gluiconfig.zPosCables,

              (posX + posX2) * 0.5,
              (this._y + this._y2) * 0.5,
              gluiconfig.zPosCables, // center point

              posX2,
              this._y2 +
                distY * 0.002 +
                this._distFromPort * (Gui$1.gui.theme.patch.cablesCurveY || 1.25),
              gluiconfig.zPosCables,
              posX2,
              this._y2,
              gluiconfig.zPosCables,
              posX2,
              this._y2,
              gluiconfig.zPosCables,
            ];

            // console.log(Gui.gui.theme.patch.cablesSubDivde);
            // for (let i = 0; i < (Gui.gui.theme.patch.cablesSubDivde); i++)
            this._points = this._subdivide(this._points, 5);

            // this._points.unshift(posX, this._y, 0);
            // this._points.unshift(posX, this._y, 0);
            // this._points.unshift(posX, this._y, 0);
            // this._points.unshift(posX, this._y, 0);
            // this._points.push(posX2, this._y2, 0);
            // this._points.push(posX2, this._y2, 0);

            this._splineDrawer.setSpline(this._splineIdx, this._points);
          }
        } else if (this._linetype == this.LINETYPE_STRAIGHT) {
          // straight lines...

          this._points = [
            posX,
            this._y,
            gluiconfig.zPosCables,
            posX,
            this._y - this._distFromPort,
            gluiconfig.zPosCables,
            posX2,
            this._y2 + this._distFromPort,
            gluiconfig.zPosCables,
            posX2,
            this._y2,
            gluiconfig.zPosCables,
          ];

          this._splineDrawer.setSpline(this._splineIdx, this._points);
        }
        if (this._linetype == this.LINETYPE_SIMPLE) {
          this._points = [
            posX,
            this._y,
            gluiconfig.zPosCables,
            posX,
            this._y,
            gluiconfig.zPosCables,
            posX2,
            this._y2,
            gluiconfig.zPosCables,
            posX2,
            this._y2,
            gluiconfig.zPosCables,
          ];

          this._splineDrawer.setSpline(this._splineIdx, this._points);
        }
      }
      if (this._visible) ;
    }

    _setPositionButton() {
      this._buttonRect.setShape(1);
      this._buttonRect.setSize(this._buttonSize, this._buttonSize);
      this._buttonRect.setPosition(
        this._x + (this._x2 - this._x) / 2 - this._buttonSize / 2,
        this._y +
          this._buttonSize +
          (this._y2 - this._buttonSize - (this._y + this._buttonSize)) / 2 -
          this._buttonSize / 2,
        gluiconfig.zPosCableButtonRect,
      );
    }

    setPosition(x, y, x2, y2) {
      if (!(this._x != x || this._y != y || this._x2 != x2 || this._y2 != y2))
        return;

      this._x = x;
      this._y = y;

      this._x2 = x2;
      this._y2 = y2;

      this._updateLinePos();
      this._setPositionButton();

      this._buttonRect.visible = false;
    }

    get hovering() {
      return (
        this._buttonRect.isHovering() ||
        (this._link._glOpIn && this._link._glOpIn.hovering) ||
        (this._link._glOpOut && this._link._glOpOut.hovering)
      );
    }

    updateColor() {
      if (this._disposed) return;

      let hover = this.hovering;
      let selected = false;

      if (this._link) {
        if (this._link.isAPortHovering()) hover = true;
        if (this._link.isAOpSelected()) selected = true;
      }

      const col = GlPort.getColor(this._link.type, false, false);

      this._splineDrawer.setSplineColor(this._splineIdx, col);
      this._splineDrawer.setSplineColorInactive(
        this._splineIdx,
        GlPort.getInactiveColor(this._link.type),
      );
      this._splineDrawer.setSplineColorBorder(
        this._splineIdx,
        GlPort.getColorBorder(this._link.type, hover, selected),
      );

      this._buttonRect.setColor(col[0], col[1], col[2], col[3]);
    }

    setColor(_r, _g, _b, _a) {
      this.updateColor();
    }

    isHoveredButtonRect() {
      if (this._glPatch.isDraggingPort()) return false;
      return this.collideMouse(
        null,
        this._x,
        this._y - this._distFromPort,
        this._x2,
        this._y2 + this._distFromPort,
        this._glPatch.viewBox.mousePatchX,
        this._glPatch.viewBox.mousePatchY,
        7,
      );
    }

    setSpeed(speed) {
      if (this._glPatch.vizFlowMode != 0)
        this._splineDrawer.setSplineSpeed(this._splineIdx, speed);
    }

    collideLine(x1, y1, x2, y2) {
      if (!this._visible) return;
      for (let i = 0; i < this._points.length - 3; i += 3) {
        const found = this.collideLineLine(
          x1,
          y1,
          x2,
          y2,
          this._points[i + 0],
          this._points[i + 1],
          this._points[i + 3],
          this._points[i + 4],
        );

        if (found) return true;
      }
      return false;
    }

    collideMouse(e, x1, y1, x2, y2, cx, cy, r) {
      // if (this._glPatch.isDraggingPort()) return;
      // if (this._glPatch.isDraggingPort()) this._glPatch.showOpCursor(false);
      // canlink ???

      if (this._disposed) {
        this._log.warn("disposed already!!!?!");
      }

      const perf = Gui$1.gui.uiProfiler.start("glcable collideMouse");

      // is either end INSIDE the circle?
      // if so, return true immediately
      const inside1 = this._collidePointCircle(x1, y1, cx, cy, r);
      const inside2 = this._collidePointCircle(x2, y2, cx, cy, r);
      if (inside1 || inside2) {
        perf.finish();
        return true;
      }

      // get length of the line
      let distX = x1 - x2;
      let distY = y1 - y2;
      const len = Math.sqrt(distX * distX + distY * distY);

      // get dot product of the line and circle
      const dot = ((cx - x1) * (x2 - x1) + (cy - y1) * (y2 - y1)) / len ** 2;

      // find the closest point on the line
      const closestX = x1 + dot * (x2 - x1);
      const closestY = y1 + dot * (y2 - y1);

      // is this point actually on the line segment?
      // if so keep going, but if not, return false
      const onSegment = this._collideLinePoint(
        x1,
        y1,
        x2,
        y2,
        closestX,
        closestY,
      );

      if (!onSegment) {
        this.setCloseToMouse(false);

        perf.finish();
        return false;
      }

      // get distance to closest point
      distX = closestX - cx;
      distY = closestY - cy;

      const distance = Math.sqrt(distX * distX + distY * distY);
      const mouseOverLineAndOpButNotDragging =
        this._glPatch.isMouseOverOp() && !this._glPatch.isDraggingOps();

      if (distance <= r && !mouseOverLineAndOpButNotDragging) {
        const selectedOp = Gui$1.gui.patchView.getSelectedOps()[0];
        if (
          selectedOp &&
          (!selectedOp.portsIn ||
            !selectedOp.portsOut ||
            selectedOp.portsIn.length == 0 ||
            selectedOp.portsOut.length == 0)
        )
          return;

        if (
          this._glPatch.isDraggingOps() &&
          Gui$1.gui.patchView.getSelectedOps().length == 1 &&
          (this._link._glOpIn.op.id == selectedOp.id ||
            this._link._glOpOut.op.id == selectedOp.id)
        ) {
          // no self hovering/linking
          return false;
        }

        this.updateColor();
        this._buttonRect.setPosition(
          closestX - this._buttonSize / 2,
          closestY - this._buttonSize / 2,
          gluiconfig.zPosCableButtonRect,
        );

        this._glPatch._cablesHoverButtonRect = this._buttonRect;

        this.setCloseToMouse(true);

        this.updateColor();

        this._glPatch.setHoverLink(e, this._link);
        this._glPatch._dropInCircleRect = this._buttonRect;
        this._glPatch._dropInCircleLink = this._link;

        if (this._glPatch.cablesHoverText)
          this._glPatch.cablesHoverText.setPosition(closestX + 10, closestY - 10);

        Gui$1.gui.showInfo(text.linkAddCircle);

        perf.finish();
        return true;
      } else {
        if (this._buttonRect.visible) this._glPatch.setHoverLink(e, null);

        this.setCloseToMouse(false);

        perf.finish();
        return false;
      }
    }

    setText(t) {
      if (this._buttonRect.isHovering && this._glPatch.cablesHoverText) {
        this._glPatch.cablesHoverText.text = t || "";
      }
    }

    _dist(x, y, x2, y2) {
      const distX = x - x2;
      const distY = y - y2;
      return Math.sqrt(distX * distX + distY * distY);
    }

    // POINT/CIRCLE
    _collidePointCircle(px, py, cx, cy, r) {
      // get distance between the point and circle's center
      // using the Pythagorean Theorem
      // const distX = px - cx;
      // const distY = py - cy;
      // const distance = Math.sqrt((distX * distX) + (distY * distY));
      const distance = this._dist(px, py, cx, cy);

      // if the distance is less than the circle's
      // radius the point is inside!
      if (distance <= r) {
        return true;
      }
      return false;
    }

    // LINE/POINT
    _collideLinePoint(x1, y1, x2, y2, px, py) {
      // get distance from the point to the two ends of the line
      const d1 = this._dist(px, py, x1, y1);
      const d2 = this._dist(px, py, x2, y2);

      // get the length of the line
      const lineLen = this._dist(x1, y1, x2, y2);

      // since  are so minutely accurate, add
      // a little buffer zone that will give collision
      const buffer = 0.1; // higher # = less accurate

      // if the two distances are equal to the line's
      // length, the point is on the line!
      // note we use the buffer here to give a range,
      // rather than one #
      if (d1 + d2 >= lineLen - buffer && d1 + d2 <= lineLen + buffer) {
        return true;
      }
      return false;
    }

    collideLineLine(x1, y1, x2, y2, x3, y3, x4, y4) {
      // calculate the distance to intersection point
      let uA =
        ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) /
        ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
      let uB =
        ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) /
        ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

      // if uA and uB are between 0-1, lines are colliding
      if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        // optionally, draw a circle where the lines meet
        // let intersectionX = x1 + (uA * (x2 - x1));
        // let intersectionY = y1 + (uA * (y2 - y1));

        return true;
      }
      return false;
    }
  }

  /**
   * drawing gl links {@link GlCable}
   *
   * @export
   * @class GlLink
   */
  class GlLink {
    /**
     *
     * @param {GlPatch} glpatch
     * @param {Link} link
     * @param {string} id
     * @param {string} opIdInput
     * @param {string} opIdOutput
     * @param {string} portNameIn
     * @param {string} portNameOut
     * @param {string} portIdInput
     * @param {string} portIdOutput
     * @param {number} type
     * @param {boolean} visible
     * @param {string|number} subpatch
     */
    constructor(
      glpatch,
      link,
      id,
      opIdInput,
      opIdOutput,
      portNameIn,
      portNameOut,
      portIdInput,
      portIdOutput,
      type,
      visible = true,
      subpatch = 0,
    ) {
      this._log = new Logger("gllink");
      this._id = id;

      /** @type {Link} */
      this._link = link;
      this._visible = visible;

      /** @type {GlCable} */
      this._cable = null;
      this._debugColor = true;

      /** @type {GlPatch} */
      this._glPatch = glpatch;
      this._type = type;
      this._portNameInput = portNameIn;
      this._portNameOutput = portNameOut;
      this._opIdInput = opIdInput;
      this._opIdOutput = opIdOutput;
      this._portIdInput = portIdInput;
      this._portIdOutput = portIdOutput;
      this._subPatch = subpatch;
      this._cableSub = null;

      this._buttonDown = MouseState.BUTTON_NONE;
      this._buttonDownTime = 0;
      this.crossSubpatch = false;

      /** @type {GlRect} */
      this._buttonRect = this._glPatch.rectDrawer.createRect({});
      this._buttonRect.setShape(1);

      this._buttonRect.on("mouseup", (e) => {
        this._glPatch.startLinkButtonDrag = null;

        if (this._glPatch.isDraggingPort()) {
          if (this._glPatch._portDragLine.isActive) {
            /**
             * @type {Op}
             */
            const fromOp = gui
              .corePatch()
              .getOpById(this._glPatch._portDragLine._startPortOpId);

            if (!fromOp) return;
            const fromPort = fromOp.getPortById(
              this._glPatch._portDragLine._startPortId,
            );

            let otherPort = link.portOut;

            if (!otherPort || !fromPort) {
              this._log.warn(
                "port not found",
                otherPort,
                fromPort,
                this._glPatch._portDragLine,
              );
              return;
            }

            if (fromPort.type == otherPort.type) {
              if (fromPort.direction != link.portIn.direction)
                otherPort = link.portIn;

              this._link.remove();
              this._glPatch._portDragLine.stop();

              gui
                .corePatch()
                .link(fromOp, fromPort.name, otherPort.op, otherPort.name);

              return;
            }
          }
          return;
        }

        const pressTime = performance.now() - this._buttonDownTime;

        if (
          this._buttonDown == this._glPatch.mouseState.buttonForRemoveLink &&
          this._mouseDownX - e.offsetX == 0 &&
          this._mouseDownY - e.offsetY == 0 &&
          pressTime < gluiconfig.clickMaxDuration
        ) {
          this._glPatch.patchAPI.removeLink(
            this._opIdInput,
            this._opIdOutput,
            this._portIdInput,
            this._portIdOutput,
          );
          // console
        }

        if (
          this._buttonDown == this._glPatch.mouseState.buttonForLinkInsertOp &&
          pressTime < gluiconfig.clickMaxDuration
        ) {
          const opIn = this._glOpIn.op; // || Gui.gui.corePatch().getOpById(this._opIdInput);

          const pIn = opIn.getPortById(this._portIdInput);
          const opOut =
            this._glOpOut || Gui$1.gui.corePatch().getOpById(this._opIdOutput);
          const pOut = this._glOpOut.op.getPortById(this._portIdOutput);
          if (!pOut) return;
          const llink = pOut.getLinkTo(pIn);

          Gui$1.gui.opSelect().show(
            {
              x: 0,
              y: 0,
              onOpAdd: (op) => {
                const distOut = Math.sqrt(
                  (opOut.uiAttribs.translate.x -
                    this._glPatch.viewBox.mousePatchX) **
                    2 +
                    (opOut.uiAttribs.translate.y -
                      this._glPatch.viewBox.mousePatchY) **
                      2,
                );
                const distIn = Math.sqrt(
                  (opIn.uiAttribs.translate.x -
                    this._glPatch.viewBox.mousePatchX) **
                    2 +
                    (opIn.uiAttribs.translate.y -
                      this._glPatch.viewBox.mousePatchY) **
                      2,
                );

                let x = opOut.uiAttribs.translate.x;
                if (distIn < distOut) x = opIn.uiAttribs.translate.x;

                op.setUiAttrib({
                  subPatch: this._glPatch.subPatch,
                  translate: {
                    x: Snap.snapOpPosX(x),
                    y: Snap.snapOpPosY(this._glPatch.viewBox.mousePatchY),
                  },
                });
              },
            },
            null,
            null,
            llink,
          );
        }

        this._buttonDown = MouseState.BUTTON_NONE;
      });

      this._buttonRect.on("mousedown", (e) => {
        if (
          this._glPatch.mouseState.buttonStateForLinkDrag &&
          UserSettings.userSettings.get("patch_allowCableDrag")
        ) {
          this._glPatch.startLinkButtonDrag = this;
          this._startDragEvent = e;
        }

        this._mouseDownX = e.offsetX;
        this._mouseDownY = e.offsetY;

        this._buttonDown = e.buttons;
        this._buttonDownTime = performance.now();
      });

      this._initSubCables();

      this._glOpIn = null;
      this._glOpOut = null;

      this._offsetXInput = 0;
      this._offsetXOutput = 0;

      this._glPatch.addLink(this);
      this.updateVisible();
      this.update();
    }

    get hovering() {
      if (this._cableSub && this._cableSub.hovering) return true;
      return this._cable.hovering;
    }

    get type() {
      return this._type;
    }

    get link() {
      return this._link;
    }

    get opIn() {
      return this._glOpIn;
    }

    get opOut() {
      return this._glOpOut;
    }

    get id() {
      return this._id;
    }

    get nameInput() {
      return this._portNameInput;
    }

    get nameOutput() {
      return this._portNameOutput;
    }

    get opIdOutput() {
      return this._opIdOutput;
    }

    get opIdInput() {
      return this._opIdInput;
    }

    get portIdIn() {
      return this._portIdInput;
    }

    get portIdOut() {
      return this._portIdOutput;
    }

    get subPatch() {
      return this._subPatch;
    }

    startDragging(e) {
      if (this._glPatch.spacePressed || this._glPatch.linkStartedDragging) return;

      this._glPatch.linkStartedDragging = true;

      hideToolTip();
      const opIn = Gui$1.gui.corePatch().getOpById(this._opIdInput),
        opOut = Gui$1.gui.corePatch().getOpById(this._opIdOutput);

      if (!opIn || !opOut) {
        this._log.log("[gllink] no in/out op");
        return;
      }

      const pIn = opIn.getPortById(this._portIdInput),
        pOut = opOut.getPortById(this._portIdOutput);

      const distOut = Math.sqrt(
        (opOut.uiAttribs.translate.x - this._glPatch.viewBox.mousePatchX) ** 2 +
          (opOut.uiAttribs.translate.y - this._glPatch.viewBox.mousePatchY) ** 2,
      );
      const distIn = Math.sqrt(
        (opIn.uiAttribs.translate.x - this._glPatch.viewBox.mousePatchX) ** 2 +
          (opIn.uiAttribs.translate.y - this._glPatch.viewBox.mousePatchY) ** 2,
      );

      if (distIn < distOut) {
        const glop = this._glPatch.getGlOp(opOut);
        const glport = glop.getGlPort(pOut.name);
        this._glPatch.emitEvent(
          "mouseDragLink",
          glport,
          opOut.id,
          pOut.name,
          this._startDragEvent,
        );
      } else {
        const glop = this._glPatch.getGlOp(opIn);
        const glport = glop.getGlPort(pIn.name);
        this._glPatch.emitEvent(
          "mouseDragLink",
          glport,
          opIn.id,
          pIn.name,
          this._startDragEvent,
        );
      }

      if (!e.altKey) pIn.removeLinkTo(pOut);
    }

    _initSubCables() {
      if (this._cable) this._cable = this._cable.dispose();
      if (this._cableSub) this._cableSub = this._cableSub.dispose();

      this._cable = new GlCable(
        this._glPatch,
        this._glPatch.getSplineDrawer(this._subPatch),
        this._buttonRect,
        this._type,
        this,
        this._subPatch,
      );
      this._glPatch.setDrawableColorByType(this._cable, this._type);

      const op1 = Gui$1.gui.corePatch().getOpById(this._opIdInput);
      const op2 = Gui$1.gui.corePatch().getOpById(this._opIdOutput);

      if (!op1 || !op1.uiAttribs || !op2 || !op2.uiAttribs) return;
      this.crossSubpatch = op1.uiAttribs.subPatch != op2.uiAttribs.subPatch;

      if (op1.uiAttribs.subPatch != this._subPatch)
        this._cableSub = new GlCable(
          this._glPatch,
          this._glPatch.getSplineDrawer(op1.uiAttribs.subPatch),
          this._buttonRect,
          this._type,
          this,
          op1.uiAttribs.subPatch,
        );
      if (op2.uiAttribs.subPatch != this._subPatch)
        this._cableSub = new GlCable(
          this._glPatch,
          this._glPatch.getSplineDrawer(op2.uiAttribs.subPatch),
          this._buttonRect,
          this._type,
          this,
          op2.uiAttribs.subPatch,
        );

      if (this._cableSub)
        this._glPatch.setDrawableColorByType(this._cableSub, this._type);

      if (this.crossSubpatch) {
        const subpatchop =
          Gui$1.gui.patchView.getSubPatchOuterOp(op1.uiAttribs.subPatch) ||
          Gui$1.gui.patchView.getSubPatchOuterOp(op2.uiAttribs.subPatch);

        if (
          subpatchop &&
          subpatchop.uiAttribs &&
          subpatchop.uiAttribs.subPatchOp
        ) ;
        // this._subPatch
      }
    }

    updateLineStyle() {
      this._cable.dispose();
      this._cable = new GlCable(
        this._glPatch,
        this._glPatch.getSplineDrawer(this._subPatch),
        this._buttonRect,
        this._type,
        this,
        this._subPatch,
      );

      this._glPatch.setDrawableColorByType(this._cable, this._type);
      this.update();
    }

    isInCurrentSubPatch() {
      const sub = this._glPatch.getCurrentSubPatch();
      if (this._cable.subPatch == sub || this._cableSub.subPatch == sub)
        return true;

      return false;
    }

    updateVisible() {
      // const sub = this._glPatch.getCurrentSubPatch();

      if (!this._glOpIn || !this._glOpOut) {
        return;
      }

      if (
        (this._glOpIn.uiAttribs.subPatch != this._cable.subPatch &&
          this._glOpOut.uiAttribs.subPatch != this._cable.subPatch) ||
        (this._cableSub &&
          this._glOpIn.uiAttribs.subPatch != this._cableSub.subPatch &&
          this._glOpOut.uiAttribs.subPatch != this._cableSub.subPatch)
      ) {
        // redo everything when ops were moved into another subpatch
        this._subPatch = this._glOpIn.uiAttribs.subPatch;
        this._initSubCables();
      }

      // if (this._cable.subPatch == sub) this._cable.visible = true;
      // if (this._cableSub && this._cableSub.subPatch == sub) this._cableSub.visible = true;

      if (this._cable) this._cable.updateVisible();
      if (this._cableSub) this._cableSub.updateVisible();

      // this._cable.visible =
      // this._visible = (this._cable.subPatch == sub || (this._cableSub && this._cableSub.subPatch == sub));
      this._updatePosition();
    }

    /**
     * @param {boolean} _v
     */
    set visible(_v) {
      // debugger;
      this.updateVisible();
    }

    _updatePosition() {
      if (this._visible) {
        if (!this.crossSubpatch) {
          if (!this._glOpOut) this.update();

          if (
            this._cable &&
            this._glOpOut &&
            this._glOpIn &&
            this._glOpIn.getUiAttribs().translate &&
            this._glOpOut.getUiAttribs().translate
          ) {
            let topy = this._glOpIn.getUiAttribs().translate.y;
            let boty = this._glOpOut.getUiAttribs().translate.y + this._glOpOut.h;

            if (this._glOpIn.displayType === this._glOpIn.DISPLAY_REROUTE_DOT)
              topy += this._glOpIn.h / 2;
            if (this._glOpOut.displayType === this._glOpOut.DISPLAY_REROUTE_DOT)
              boty -= this._glOpOut.h / 2;

            const pos1x =
              this._glOpIn.getUiAttribs().translate.x + this._offsetXInput;
            const pos1y = topy;

            const pos2x =
              this._glOpOut.getUiAttribs().translate.x + this._offsetXOutput;
            const pos2y = boty;

            this._cable.setPosition(pos1x, pos1y, pos2x, pos2y);
          }
        } else {
          if (!this._subPatchOp && this._glOpIn && this._glOpOut) {
            const a = Gui$1.gui.patchView.getSubPatchOuterOp(
              this._glOpIn.op.uiAttribs.subPatch,
            );
            const b = Gui$1.gui.patchView.getSubPatchOuterOp(
              this._glOpOut.op.uiAttribs.subPatch,
            );

            this._subPatchOp = a || b;
            if (a && b)
              if (a.uiAttribs.subPatch == b.patchId.get()) this._subPatchOp = a;
              else this._subPatchOp = b;

            // this._glSubPatchOp = this._glPatch.getOp(this._subPatchOp.id);

            if (this._subPatchOp)
              this._subPatchOp.on("move", () => {
                this.update();
              });
          }

          if (!this._subPatchInputOp && this._cable) {
            this._subPatchInputOp = gui
              .corePatch()
              .getFirstSubPatchOpByName(
                this._cable.subPatch,
                defaultOps.subPatchInput2,
              );
            // this._glSubPatchInputOp = this._glPatch.getOp(this._subPatchInputOp.id);
            if (this._subPatchInputOp)
              this._subPatchInputOp.on("move", () => {
                this.update();
              });
          }

          if (!this._subPatchOutputOp && this._glOpOut && this._glOpOut.op) {
            this._subPatchOutputOp = gui
              .corePatch()
              .getFirstSubPatchOpByName(
                this._glOpOut.op.uiAttribs.subPatch,
                defaultOps.subPatchOutput2,
              );
            // this._glSubPatchOutputOp = this._glPatch.getOp(this._subPatchOutputOp.id);
            if (this._subPatchOutputOp)
              this._subPatchOutputOp.on("move", () => {
                this.update();
              });
          }

          if (!this._glOpIn || !this._glOpOut) this.update();

          let foundCableSub = false;
          let foundCable = false;

          // inner input port op to subpatch-input op
          if (
            this._cable &&
            this._subPatchInputOp &&
            this._glOpIn.uiAttribs.subPatch == this._cable.subPatch
          ) {
            if (!this._glOpIn.getUiAttribs().translate) return;
            if (this._debugColor) this._cable.setColor(1, 0, 1, 1);

            foundCable = true;
            this._cable.setPosition(
              this._glOpIn.getUiAttribs().translate.x + this._offsetXInput,
              this._glOpIn.getUiAttribs().translate.y,
              this._subPatchInputOp.uiAttribs.translate.x +
                this._subPatchInputOp.getPortPosX(
                  this._portNameInput,
                  this._subPatchInputOp.id,
                  true,
                ),
              this._subPatchInputOp.uiAttribs.translate.y + 30,
            );
          }

          // inner output port op to subpatch output op
          else if (
            this._cableSub &&
            this._subPatchOutputOp &&
            this._glOpOut.uiAttribs.subPatch ==
              this._subPatchOutputOp.uiAttribs.subPatch
          ) {
            if (!this._glOpOut.getUiAttribs().translate) return;
            if (this._debugColor) this._cableSub.setColor(0, 0, 1, 1);

            foundCableSub = true;
            this._cableSub.setPosition(
              this._subPatchOutputOp.uiAttribs.translate.x,
              this._subPatchOutputOp.uiAttribs.translate.y,
              this._glOpOut.getUiAttribs().translate.x + this._offsetXOutput,
              this._glOpOut.getUiAttribs().translate.y + 30,
            );
          }

          // ----------------------
          //
          //
          //
          //
          //
          // outer output port op TO subpatch op
          if (
            this._cableSub &&
            this._glOpOut &&
            this._subPatchOp &&
            this._glOpOut.getUiAttribs().translate &&
            this._glOpOut.op.uiAttribs.subPatch ==
              this._subPatchOp.uiAttribs.subPatch
          ) {
            if (!this._glOpOut.getUiAttribs().translate) return;
            if (!this._subPatchOp.uiAttribs.translate) return;

            if (this._debugColor) this._cableSub.setColor(0, 1, 0, 1); // green

            foundCableSub = true;
            this._cableSub.setPosition(
              this._subPatchOp.uiAttribs.translate.x +
                this._subPatchOp.getPortPosX(
                  this._portNameInput,
                  this._subPatchOp.id,
                  true,
                ),
              this._subPatchOp.uiAttribs.translate.y,
              this._glOpOut.getUiAttribs().translate.x + this._offsetXOutput,
              this._glOpOut.getUiAttribs().translate.y + 30,
            );
          } else if (
            this._cable &&
            this._subPatchOp &&
            this._glOpIn.getUiAttribs().translate &&
            this._subPatchOp.uiAttribs.translate &&
            this._glOpIn.op.uiAttribs.subPatch ==
              this._subPatchOp.uiAttribs.subPatch
          ) {
            // outer input port op FROM subpatch op
            if (this._debugColor) this._cable.setColor(1, 0, 0, 1); // red
            foundCable = true;
            this._cable.setPosition(
              this._glOpIn.getUiAttribs().translate.x + this._offsetXInput,
              this._glOpIn.getUiAttribs().translate.y,
              this._subPatchOp.uiAttribs.translate.x +
                this._subPatchOp.getPortPosX(
                  this._portNameOutput,
                  this._subPatchOp.id,
                  true,
                ),
              this._subPatchOp.uiAttribs.translate.y + 30,
            );
          }
          // else

          if (
            !foundCable &&
            this._cable &&
            this._subPatchOp &&
            this._glOpIn.getUiAttribs() &&
            this._glOpIn.getUiAttribs().translate &&
            this._subPatchOp.uiAttribs.translate
          ) {
            if (this._debugColor) this._cable.setColor(0, 0, 0, 1);
            this._cable.setPosition(
              this._glOpIn.getUiAttribs().translate.x + this._offsetXInput,
              this._glOpIn.getUiAttribs().translate.y,
              this._subPatchOp.uiAttribs.translate.x +
                this._subPatchOp.getPortPosX(
                  this._portNameOutput,
                  this._subPatchOp.id,
                  true,
                ),
              this._subPatchOp.uiAttribs.translate.y + 30,
            );
          }

          if (!foundCableSub && this._cableSub && this._subPatchOutputOp) {
            if (this._debugColor) this._cableSub.setColor(1, 0.5, 0.4, 1);
            this._cableSub.setPosition(
              this._subPatchOutputOp.uiAttribs.translate.x +
                this._subPatchOutputOp.getPortPosX(
                  this._portNameOutput,
                  this._subPatchOutputOp.id,
                  true,
                ),
              this._subPatchOutputOp.uiAttribs.translate.y,

              this._glOpOut.getUiAttribs().translate.x + this._offsetXOutput,
              this._glOpOut.getUiAttribs().translate.y + 30,
            );
          }
        }
      }
    }

    update() {
      if (!this._glOpIn) {
        this._glOpIn = this._glPatch.getOp(this._opIdInput);
        if (this._glOpIn) {
          this._glOpIn.addLink(this);
          this._glOpIn.on("move", () => {
            this.update();
          });
        }
      }

      if (!this._glOpOut) {
        this._glOpOut = this._glPatch.getOp(this._opIdOutput);
        if (this._glOpOut) {
          this._glOpOut.addLink(this);
          this._glOpOut.on("move", () => {
            this.update();
          });
        }
      }

      if (!this._glOpIn || !this._glOpOut) {
        this._log.warn(
          "unknown ops...",
          this._opIdInput,
          this._opIdOutput,
          this._glOpIn,
          this._glOpOut,
        );
        return;
      }

      this._offsetXInput = this._glOpIn.getPortPos(this._portNameInput);
      this._offsetXOutput = this._glOpOut.getPortPos(this._portNameOutput);

      if (!this.addedOrderListeners) {
        this.addedOrderListeners = true;
        if (this._glOpIn)
          this._glOpIn.op.on("glportOrderChanged", () => {
            this.update();
          });
        if (this._glOpOut)
          this._glOpOut._op.on("glportOrderChanged", () => {
            this.update();
          });

        if (this._subPatchOp)
          this._subPatchOp.on("glportOrderChanged", () => {
            this._log.log("this._subPatchOp --- glport order changed!@!!");
            this.update();
          });

        if (this._subPatchInputOp)
          this._subPatchInputOp.on("glportOrderChanged", () => {
            this.update();
          });

        if (this._subPatchOutputOp)
          this._subPatchOutputOp.on("glportOrderChanged", () => {
            this.update();
          });
      }

      this._glOpIn.updateVisible();
      this._glOpOut.updateVisible();
      this._updatePosition();
    }

    unlink() {
      this._link.remove();
      // if (this._glOpOut) this._glOpOut.removeLink(this._id);
      // if (this._glOpIn) this._glOpIn.removeLink(this._id);
    }

    dispose() {
      if (this._glOpOut) this._glOpOut.removeLink(this._id);
      if (this._glOpIn) this._glOpIn.removeLink(this._id);

      if (this._cable) this._cable = this._cable.dispose();
      if (this._cableSub) this._cableSub = this._cableSub.dispose();

      if (this._buttonRect) this._buttonRect = this._buttonRect.dispose();
    }

    _singleValueToString(v) {
      let r = null;
      if (typeof v == "number") r = String(Math.round(v * 1000) / 1000);
      else if (typeof v == "string") r = '"' + v + '"';
      return r;
    }

    setFlowModeActivity(act, v) {
      if (this._activity == act) return;
      this._activity = act;

      let r = "";
      if (typeof v == "number")
        r = this._singleValueToString(v); // v = Math.round(v * 1000) / 1000;
      else if (typeof v == "string")
        r = this._singleValueToString(v); // v = "\"" + v + "\"";
      else if (Array.isArray(v)) {
        r = "[";

        for (let i = 0; i < Math.min(v.length, 3); i++) {
          r += this._singleValueToString(v[i]);
          r += ", ";
        }

        if (v.length > 3) r += "...";
        r += "]";
        r += " (" + v.length + ")";
      }

      if (r.length > 10) r = r.substr(0, 43) + "...";

      this._cable.setText(r);
      this._cable.setSpeed(act);
      if (this._cableSub) {
        this._cableSub.setText(r);
        this._cableSub.setSpeed(act);
      }
    }

    highlight(b) {
      if (this._oldHighlight !== b) {
        this._cable.updateColor();
        if (this._cableSub) this._cableSub.updateColor();
        // if (this._cableSub) this._glPatch.setDrawableColorByType(this._cableSub, this._type, b ? 1 : 0);
        this._oldHighlight = b;
      }
    }

    collideLine(x1, y1, x2, y2) {
      return (
        this._cable.collideLine(x1, y1, x2, y2) ||
        this._cableSub?.collideLine(x1, y1, x2, y2)
      );
    }

    updateTheme() {
      this.highlight(false);
    }

    isAOpSelected() {
      if (this._glOpOut && this._glOpOut.selected) return true;
      if (this._glOpIn && this._glOpIn.selected) return true;
      return false;
    }

    isAPortHovering() {
      const perf = Gui$1.gui.uiProfiler.start(
        "[gllink] cableHoverChangeisAPortHoveringd",
      );

      if (this._glOpOut) {
        let port = this._glOpOut.op.getPortById(this._portIdOutput);
        let glport = this._glOpOut.getGlPort(port.name);
        if (glport && glport.hovering) return true;
      }

      if (this._glOpIn && this._glOpIn.op) {
        let port = this._glOpIn.op.getPortById(this._portIdInput);
        let glport = this._glOpIn.getGlPort(port.name);

        if (glport && glport.hovering) return true;
      }

      perf.finish();
      return false;
    }

    updateColor() {
      this._cable.updateColor();
      if (this._cableSub) this._cableSub.updateColor();
    }

    cableHoverChanged() {
      const perf = Gui$1.gui.uiProfiler.start("[gllink] cableHoverChanged");

      if (this._glOpOut && this._glOpOut.op) {
        // console.log("cableHoverChanged", this._glOpOut);
        // let glop = this._glPatch.getGlOp(this._glOpOut);
        let port = this._glOpOut.op.getPortById(this._portIdOutput);
        let glport = this._glOpOut.getGlPort(port.name);

        if (glport) glport._updateColor();
        // else console.log("no glport");
      }

      if (this._glOpIn && this._glOpIn.op) {
        let port = this._glOpIn.op.getPortById(this._portIdInput);
        let glport = this._glOpIn.getGlPort(port.name);

        if (glport) glport._updateColor();
        // else console.log("no glport");
      }

      perf.finish();

      // const glopIn = this._glPatch.getGlOp(this._glOpIn);
      // glport = glopIn.getGlPort(pIn.name);
    }
  }

  class GlPatchAPI {
    /**
     * @param {Patch} patch
     * @param {GlPatch} glpatch
     */
    constructor(patch, glpatch) {
      this._log = new Logger("glpatch");

      /** @type {Patch} */
      this._patch = patch;
      this._glPatch = glpatch;
      this._glPatch.patchAPI = this;
      this._flowvisStartFrame = 0;
      this._currentFlowMode = -1;
      this._updateCounter = 0;

      this._patch.on(Patch.EVENT_OP_ADDED, this._onAddOp.bind(this));
      this._patch.on(Patch.EVENT_OP_DELETED, this._onDeleteOp.bind(this));

      this._patch.on("onLink", this._onLink.bind(this));
      this._patch.on("onUnLink", this._onUnLink.bind(this));
    }

    /**
     * @private
     */
    _initPatch() {
      let i = 0;
      for (i = 0; i < this._patch.ops.length; i++) {
        const op = this._patch.ops[i];
        this._glPatch.addOp(op);
      }

      for (i = 0; i < this._patch.ops.length; i++) {
        const op = this._patch.ops[i];
        if (!op) continue;

        for (let ip = 0; ip < op.portsIn.length; ip++) {
          for (let il = 0; il < op.portsIn[ip].links.length; il++) {
            const link = op.portsIn[ip].links[il];

            let visible = true; // link.portIn.op.uiAttribs.subPatch != Gui.gui.patchView.getCurrentSubPatch();

            new GlLink(
              this._glPatch,
              link,
              link.id,
              link.portIn.op.id,
              link.portOut.op.id,
              link.portIn.name,
              link.portOut.name,
              link.portIn.id,
              link.portOut.id,
              link.portIn.type,
              visible,
              link.portIn.op.uiAttribs.subPatch,
            );
          }
        }
      }
    }

    stopFlowModeActivity() {
      for (let i = 0; i < this._patch.ops.length; i++) {
        const op = this._patch.ops[i];

        for (let ip = 0; ip < op.portsIn.length; ip++) {
          for (let il = 0; il < op.portsIn[ip].links.length; il++) {
            const link = op.portsIn[ip].links[il];
            this._glPatch.links[link.id].setFlowModeActivity(
              1,
              op.portsIn[ip].get(),
            );
          }
        }
      }
    }

    updateFlowModeActivity(flowMode) {
      if (flowMode == 0) return;

      const frameCount = this._glPatch._cgl.fpsCounter.frameCount;
      if (this._flowvisStartFrame == 0) this._flowvisStartFrame = frameCount;
      if (this._glPatch.frameCount - this._flowvisStartFrame < 6) return;
      if (this._glPatch.frameCount % 5 != 0) return;

      this._glPatch.frameCount - this._flowvisStartFrame;

      const perf = Gui$1.gui.uiProfiler.start("[glpatch] update flow mode");

      let numUpdates = Math.min(350, this._patch.ops.length);

      for (let ii = 0; ii < numUpdates; ii++) {
        let i = (ii + this._updateCounter) % this._patch.ops.length;
        const op = this._patch.ops[i];
        const glop = this._glPatch.getGlOp(op);

        /*
         * if (!glop.visible)
         * {
         *     numUpdates++;
         *     if (numUpdates > this._patch.ops.length) break;
         *     continue;
         * }
         */

        if (
          op &&
          op.portsIn &&
          op.portsIn[0] &&
          op.portsIn[0].activityCounterStartFrame == frameCount
        )
          continue;

        if (op && op.portsOut)
          for (let ip = 0; ip < op.portsOut.length; ip++) {
            op.portsOut[ip].apf =
              op.portsOut[ip].activityCounter /
              (frameCount - op.portsOut[ip].activityCounterStartFrame);
            op.portsOut[ip].activityCounter = 0;
            op.portsOut[ip].activityCounterStartFrame = frameCount;
          }

        if (op && op.portsIn)
          for (let ip = 0; ip < op.portsIn.length; ip++) {
            op.portsIn[ip].apf =
              op.portsIn[ip].activityCounter /
              (frameCount - op.portsIn[ip].activityCounterStartFrame);
            op.portsIn[ip].activityCounter = 0;
            op.portsIn[ip].activityCounterStartFrame = frameCount;
          }

        if (glop) {
          for (let ip = 0; ip < op.portsOut.length; ip++) {
            const thePort = op.portsOut[ip];
            const glp = glop.getGlPort(thePort.name);
            if (glp) glp.setFlowModeActivity(thePort.activityCounter);
            thePort.activityCounter = 0;
          }
        }

        if (op && op.portsIn)
          for (let ip = 0; ip < op.portsIn.length; ip++) {
            const thePort = op.portsIn[ip];
            thePort.activityCounter = 0;

            if (glop) {
              const glp = glop.getGlPort(thePort.name);
              if (glp) glp.setFlowModeActivity(thePort.activityCounter);
            }

            for (let il = 0; il < thePort.links.length; il++) {
              const link = thePort.links[il];
              let newClass = 0;

              if (link.activityCounter >= 1) newClass = 1;

              if (flowMode == 2) {
                if (link.activityCounter >= 10)
                  newClass = link.activityCounter / 10 + 3;
                else if (link.activityCounter >= 5) newClass = 3;
                else if (link.activityCounter >= 2) newClass = 2;
              }

              if (this._glPatch.links[link.id])
                this._glPatch.links[link.id].setFlowModeActivity(
                  newClass,
                  thePort.get(),
                );
              link.activityCounter = 0;
            }
          }
      }
      this._updateCounter += numUpdates;
      perf.finish();
    }

    reset() {
      this._initPatch();
    }

    _onLink(p1, p2, link, fromDeserialize) {
      if (p1.direction != 0) {
        const t = p2;
        p2 = p1;
        p1 = t;
      }

      if (!link.portOut) {
        // this._log.warn("link has no portout!");
        return;
      }

      if (!fromDeserialize) {
        ((function (patch, p1Name, p2Name, op1Id, op2Id) {
          undo.add({
            title: "Link port",
            context: {
              p1Name,
              p2Name,
            },
            undo() {
              const op1 = patch.getOpById(op1Id);
              const op2 = patch.getOpById(op2Id);
              if (!op1 || !op2) {
                this._log.warn("undo: op not found");
                return;
              }
              if (op1.getPortByName(p1Name))
                op1.getPortByName(p1Name).removeLinkTo(op2.getPortByName(p2Name));
            },
            redo() {
              patch.link(
                patch.getOpById(op1Id),
                p1Name,
                patch.getOpById(op2Id),
                p2Name,
              );
            },
          });
        }))(link.portOut.op.patch, p1.name, p2.name, p1.op.id, p2.op.id);
      }

      let visible = true; // p1.op.uiAttribs.subPatch != Gui.gui.patchView.getCurrentSubPatch();
      new GlLink(
        this._glPatch,
        link,
        link.id,
        p1.op.id,
        p2.op.id,
        p1.name,
        p2.name,
        p1.id,
        p2.id,
        p1.type,
        visible,
        p1.op.uiAttribs.subPatch,
      );
    }

    _onUnLink(a, b, link) {
      if (!link) return;

      ((function (patch, p1Name, p2Name, op1Id, op2Id) {
        undo.add({
          title: "Unlink port",
          context: {
            p1Name,
            p2Name,
          },
          undo() {
            patch.link(
              patch.getOpById(op1Id),
              p1Name,
              patch.getOpById(op2Id),
              p2Name,
            );
          },
          redo() {
            const op1 = patch.getOpById(op1Id);
            const op2 = patch.getOpById(op2Id);
            if (!op1 || !op2) {
              this._log.warn("undo: op not found");
              return;
            }
            op1.getPortByName(p1Name).removeLinkTo(op2.getPortByName(p2Name));
          },
        });
      }))(
        link.portOut.op.patch,
        link.portIn.getName(),
        link.portOut.getName(),
        link.portIn.op.id,
        link.portOut.op.id,
      );

      this._glPatch.deleteLink(link.id);
    }

    _onAddOp(op, fromDeserialize) {
      this._glPatch.addOp(op, fromDeserialize);
      if (!fromDeserialize) Gui$1.gui.patchView.testCollision(op);

      if (op.checkLinkTimeWarnings) op.checkLinkTimeWarnings();

      op.on("onPortAdd", (p) => {
        const glop = this._glPatch.getGlOp(op);
        if (glop) glop.updateSize();
      });
    }

    _onDeleteOp(op) {
      if (!undo.paused())
        Gui$1.gui.savedState.setUnSaved("patchApiOnDeleteOp", op.getSubPatch());

      let updateSubs = false;

      if (op.isSubPatchOp()) updateSubs = true;

      this._glPatch.deleteOp(op.id);

      clearInterval(CABLES.UI.hoverInterval);
      CABLES.UI.hoverInterval = -1;
      hideToolTip();

      if (updateSubs) Gui$1.gui.bookmarks.needRefreshSubs = true;
    }

    showOpParams(opid) {
      setTimeout(() => {
        const op = Gui$1.gui.corePatch().getOpById(opid);
        Gui$1.gui.opParams.show(op);
      }, 33);
    }

    removeLink(opIdIn, opIdOut, portIdIn, portIdOut) {
      const opIn = Gui$1.gui.corePatch().getOpById(opIdIn);
      const pIn = opIn.getPortById(portIdIn);
      const opOut = Gui$1.gui.corePatch().getOpById(opIdOut);
      const pOut = opOut.getPortById(portIdOut);
      if (!pOut) return;
      const l = pOut.getLinkTo(pIn);

      if (l) l.remove();
      else this._log.error("could not remove link");
    }

    /*
     * addOpIntoLink(opIdIn, opIdOut, portIdIn, portIdOut, x, y)
     * {
     *     const opIn = Gui.gui.corePatch().getOpById(opIdIn);
     *     const pIn = opIn.getPortById(portIdIn);
     *     const opOut = Gui.gui.corePatch().getOpById(opIdOut);
     *     const pOut = opOut.getPortById(portIdOut);
     *     const link = pOut.getLinkTo(pIn);
     *     // options, linkOp, linkPort, link)
     *     Gui.gui.opSelect().show({ "x": 0,
     *         "y": 0,
     *         "onOpAdd": (op) =>
     *         {
     *             // op.setUiAttrib({ "translate": { "x": coord[0], "y": coord[1] } });
     *             op.setUiAttrib({ "translate": { "x": x, "y": y } });
     *         } }, null, null, link);
     * }
     */

    deleteOp(id) {
      Gui$1.gui.corePatch().deleteOp(id, true);
    }

    setOpUiAttribs(opid, attrName, val) {
      const op = Gui$1.gui.corePatch().getOpById(opid);
      if (!op) {
        this._log.warn("[setOpUiAttribs] op not found");
        return;
      }

      const attr = {};
      attr[attrName] = val;
      op.setUiAttrib(attr);
    }

    _watchOp(op) {}
  }

  class GlCanvas {
    /**
     * @param {Patch}} _patch
     * @param {HTMLElement} parentEle
     */
    constructor(_patch, parentEle) {
      this._moveover = true;
      this._firstTime = true;
      this._lastTime = 0;
      this.width = 0;
      this.height = 0;
      this._mouseX = 0;
      this._mouseY = 0;
      this.loaded = false;
      this._inited = false;
      this.clear = true;

      document.body.style["touch-action"] = "none";

      this.canvas = document.createElement("canvas");
      this.canvas.id = "glGuiCanvas-" + CABLES.uuid();
      this.canvas.style.border = "0px solid white";
      this.canvas.style.outline = "0";
      this.canvas.style.position = "absolute";

      this.canvas.setAttribute("tabindex", 0);
      this._parentEle = parentEle;

      if (parentEle) parentEle.appendChild(this.canvas);
      else document.body.appendChild(this.canvas);

      this.patch = new CABLES.Patch({
        glCanvasId: this.canvas.id,
        glCanvasResizeToParent: false,
        glCanvasResizeToWindow: false,
        canvas: { alpha: true, premultipliedAlpha: true, antialias: true },
      });

      this.cgl = this.patch.cgl;
      this.cgl.pixelDensity = window.devicePixelRatio || 1;
      this.cgl.updateSize();

      Gui$1.gui.on("uiIdleStart", () => {
        this.patch.pause();
      });

      Gui$1.gui.on("uiIdleEnd", () => {
        this.patch.resume();
      });

      this.canvas.addEventListener("touchmove", (e) => {
        if (e.touches.length > 1) e.preventDefault();
      });
      this.canvas.addEventListener(
        "pointermove",
        (e) => {
          this.activityHigh();

          this._mouseX = e.offsetX;
          this._mouseY = e.offsetY;
        },
        { passive: true },
      );

      this.canvas.addEventListener(
        "pointerdown",
        (e) => {
          this.activityHigh();
        },
        { passive: true },
      );

      this.canvas.addEventListener(
        "pointerup",
        (e) => {
          this.activityHigh();
        },
        { passive: true },
      );

      this.canvas.addEventListener(
        "pointerleave",
        (e) => {
          this.activityMedium();
        },
        { passive: true },
      );

      this.canvas.addEventListener(
        "pointerenter",
        (e) => {
          this.activityHigh();
        },
        { passive: true },
      );
    }

    get element() {
      return this.canvas;
    }

    /**
     * @param {number} w
     * @param {number} h
     */
    setSize(w, h) {
      this.width = w;
      this.height = h;

      // this.canvas.style.width = this.width + "px";
      // this.canvas.style.height = this.height + "px";
      // this.canvas.width = this.width * window.devicePixelRatio;
      // this.canvas.height = this.height * window.devicePixelRatio;

      this.cgl.pixelDensity = window.devicePixelRatio;
      if (this.patch.isPlaying()) this.cgl.setSize(this.width, this.height);
    }

    dispose() {
      this.disposed = true;
      this.patch.pause();
      this.patch.dispose();
      this.canvas.remove();
    }

    pause() {
      this.patch.pause();
    }

    resume() {
      this.patch.resume();
    }

    activityIdle() {
      this._targetFps = 10;
    }

    activityHigh() {
      this._targetFps = 0;
      clearTimeout(this._activityTimeout);
      this._activityTimeout = setTimeout(() => {
        this.activityMedium();
      }, 40000);
    }

    activityMedium() {
      this._targetFps = 30;
      clearTimeout(this._activityTimeout);
      this._activityTimeout = setTimeout(() => {
        this.activityIdle();
      }, 30000);
    }
  }

  class GlSpline {
    #splineIdx = -1;

    /** @type {GlSplineDrawer} */
    #splineDrawer = null;

    /** @type {Array<number>} */
    #points = [0, 0, 0, 10, 10, 0];

    /** @type {GlRect} */
    #parentRect;

    /** @type {String} */
    #name = "unknown spline";

    #disposed = false;

    /**
     * @param {GlSplineDrawer} splineDrawer
     * @param {string} name
     * @param {Object} options
     */
    constructor(splineDrawer, name, options = {}) {
      this.#name = name;
      this.#splineDrawer = splineDrawer;
      this.#splineIdx = this.#splineDrawer.getSplineIndex(this.#name);
      this.#parentRect = null;
    }

    /**
     * @param {GlRect} r
     */
    setParentRect(r) {
      if (this.checkDisposed()) return;
      if (this.#parentRect) this.#parentRect.off(this.rebuild.bind(this));

      this.#parentRect = r;
      if (this.#parentRect)
        this.#parentRect.on(
          GlRect.EVENT_POSITIONCHANGED,
          this.rebuild.bind(this),
        );
      this.rebuild();
    }

    /**
     * @param {Array<number>} p
     */
    setPoints(p) {
      if (this.checkDisposed()) return;
      this.#points = p;
      this.rebuild();
    }

    rebuild() {
      if (this.checkDisposed()) return;
      const finalPoints = [];
      let x = 0,
        y = 0,
        z = 0;

      if (this.#parentRect) {
        x = this.#parentRect.x;
        y = this.#parentRect.y;
        z = this.#parentRect.z;
      }
      for (let i = 0; i < this.#points.length; i += 3) {
        finalPoints[i + 0] = this.#points[i + 0] + x;
        finalPoints[i + 1] = this.#points[i + 1] + y;
        finalPoints[i + 2] = this.#points[i + 2] + z;
      }
      this.#splineDrawer.setSpline(this.#splineIdx, finalPoints);
    }

    /**
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a=1
     */
    setColor(r, g, b, a = 1) {
      if (this.checkDisposed()) return;
      this.#splineDrawer.setSplineColor(this.#splineIdx, [r, g, b, a]);
    }

    /**
     * @param {number[]} arr
     */
    setColorArray(arr) {
      if (this.checkDisposed()) return;
      this.#splineDrawer.setSplineColor(this.#splineIdx, arr);
    }

    checkDisposed() {
      if (this.#disposed) console.log("disposed object...", this);
      return this.#disposed;
    }

    dispose() {
      this.#disposed = true;
      this.#splineDrawer.deleteSpline(this.#splineIdx);
      this.#splineIdx = -1;
      return null;
    }
  }

  class GlTlView {
    /** @type {GlTimeline} */
    #tl;

    /** @type {Anim} */
    #animZoom;

    /** @type {Anim} */
    #animScroll;

    /** @type {Anim} */
    #animScrollY;

    #zoom = 20;

    #offset = -0.1;
    #offsetY = 0.0;

    #frameMinVal = -1;
    #frameMaxVal = 1;

    #finalMinVal = -2;
    #finalMaxVal = 2;

    /** @type {Anim} */
    #animMinVal;

    /** @type {Anim} */
    #animMaxVal;

    #timer = new CABLES.Timer();

    /**
     * @param {GlTimeline} tl
     */
    constructor(tl) {
      this.#tl = tl;

      const defaultEasing = CABLES.Anim.EASING_CUBIC_OUT;

      this.#animZoom = new CABLES.Anim({ defaultEasing: defaultEasing });
      this.#animZoom.setValue(0, this.#zoom);

      this.#animScroll = new CABLES.Anim({ defaultEasing: defaultEasing });
      this.#animScroll.setValue(0, this.#offset);

      this.#animScrollY = new CABLES.Anim({ defaultEasing: defaultEasing });
      this.#animScrollY.setValue(0, this.#offsetY);

      this.#animMinVal = new CABLES.Anim({ defaultEasing: defaultEasing });
      this.#animMaxVal = new CABLES.Anim({ defaultEasing: defaultEasing });
      this.minVal = -1;
      this.maxVal = 1;

      this.#timer.play();
      this.updateAnims();
    }

    get animsFinished() {
      return (
        this.#animZoom.isFinished(this.#timer.getTime()) &&
        this.#animScroll.isFinished(this.#timer.getTime())
      );
    }

    get zoom() {
      return this.#animZoom.getValue(this.#timer.getTime());
    }

    get finalMinVal() {
      return this.#finalMinVal;
    }

    get finalMaxVal() {
      return this.#finalMaxVal;
    }

    get minVal() {
      return this.#frameMinVal;
    }

    get maxVal() {
      return this.#frameMaxVal;
    }

    checkMinMaxVals() {
      // console.log("", this.#finalMinVal, this.#finalMaxVal);
      // if (this.#finalMinVal == this.#finalMaxVal) this.#finalMaxVal = this.#finalMinVal + 1;
      // if (this.maxVal == this.minVal)
      // {
      //     this.maxVal = this.minVal + 1;
      // }
    }

    /**
     * @param {number} v
     */
    set minVal(v) {
      if (this.#finalMinVal == v) return;
      this.#finalMinVal = v;

      let dur = 0.3;
      this.#animMinVal.clear(this.#timer.getTime());
      this.#animMinVal.setValue(this.#timer.getTime() + dur, this.#finalMinVal);
    }

    /**
     * @param {number} v
     */
    set maxVal(v) {
      if (this.#finalMaxVal == v) return;
      this.#finalMaxVal = v;
      let dur = 0.3;
      this.#animMaxVal.clear(this.#timer.getTime());
      this.#animMaxVal.setValue(this.#timer.getTime() + dur, this.#finalMaxVal);
    }

    /** @returns {number} */
    get offset() {
      return this.#offset;
    }

    /** @returns {number} */
    get offsetY() {
      return this.#offsetY;
    }

    /** @returns {number} */
    get cursorTime() {
      return Gui$1.gui.corePatch().timer.getTime();
    }

    get pixelPerSecond() {
      return this.#tl.width / this.#tl.duration;
    }

    get visibleTime() {
      return this.pixelToTime(this.#tl.width);
    }

    get timeLeft() {
      return this.offset;
    }

    get timeRight() {
      return this.pixelToTime(this.#tl.width) + this.offset;
    }

    /**
     * @param {number} delta
     * @param {number} dur
     */
    setZoomOffset(delta, dur = 0.3) {
      let zoom = this.#zoom * delta;
      zoom = CABLES.clamp(zoom, 0.1, 10000000);

      this.#animZoom.clear(this.#timer.getTime());
      this.#animZoom.setValue(this.#timer.getTime(), this.#zoom);
      this.#animZoom.setValue(this.#timer.getTime() + dur, zoom);
    }

    centerCursor() {
      this.scroll(this.cursorTime - this.#offset - this.visibleTime / 2);
    }

    /**
     * @param {number} delta
     */
    scale(delta) {
      delta = 1 + delta;
      const nmin = (this.minVal *= delta);
      const nmax = (this.maxVal *= delta);
      this.minVal = Math.min(nmin, nmax);
      this.maxVal = Math.max(nmin, nmax);
    }

    /**
     * @param {number} delta
     * @param {number} duration
     */
    scroll(delta, duration = 0.2) {
      let finalTime = this.#offset + delta;

      this.#animScroll.clear(this.#timer.getTime());
      this.#animScroll.setValue(this.#timer.getTime() + duration, finalTime);
    }

    /**
     * @param {number} finalTime
     * @param {number} duration=0.2
     */
    scrollTo(finalTime, duration = 0.2) {
      this.#animScroll.clear(this.#timer.getTime());
      this.#animScroll.setValue(this.#timer.getTime() + duration, finalTime);
    }

    /**
     * @param {number} scrolly
     * @param {number} duration=0.2
     */
    scrollToY(scrolly, duration = 0.2) {
      this.#animScrollY.clear(this.#timer.getTime());
      this.#animScrollY.setValue(this.#timer.getTime() + duration, scrolly);
    }

    /**
     * @param {number} t
     */
    timeToPixelScreen(t) {
      return this.timeToPixel(t) - this.timeToPixel(this.#offset);
    }

    /**
     * @param {number} delta
     * @param {number} duration
     */
    scrollY(delta, duration = 0.2) {
      let finalTime = this.#offsetY - delta * 14;

      this.#animScrollY.clear(this.#timer.getTime());
      this.#animScrollY.setValue(this.#timer.getTime() + duration, finalTime);
    }

    /**
     * @param {number} t
     */
    timeToPixel(t) {
      return t * this.#zoom * 12;
    }

    /**
     * @param {number} x
     */
    pixelToTime(x) {
      return x / this.timeToPixel(1);
    }

    /**
     * @param {number} x
     */
    pixelScreenToTime(x) {
      return this.pixelToTime(x);
    }

    /**
     * @param {number} len
     */
    setZoomLength(len) {
      let zoom = this.#tl.duration / len;
      let dur = 0.3;
      this.#animZoom.clear(this.#timer.getTime());
      this.#animZoom.setValue(this.#timer.getTime() + dur, zoom);
    }

    updateAnims() {
      this.#timer.update();
      this.#zoom = this.#animZoom.getValue(this.#timer.getTime());
      this.#offset = this.#animScroll.getValue(this.#timer.getTime());
      this.#offsetY = this.#animScrollY.getValue(this.#timer.getTime());
      this.#frameMinVal = this.#animMinVal.getValue(this.#timer.getTime());
      this.#frameMaxVal = this.#animMaxVal.getValue(this.#timer.getTime());
      this.checkMinMaxVals();
    }

    getDebug() {
      const o = {
        minval: this.minVal,
        maxval: this.maxVal,
        finalmaxval: this.#finalMaxVal,
        finalminval: this.#finalMinVal,
        minanimfinished: this.#animMinVal.isFinished(this.#timer.getTime()),
        offset: this.offset,
        offsetY: this.offsetY,
        zoom: this.zoom,
      };
      return o;
    }
  }

  /**
   * gltl key rendering
   *
   * @export
   * @class glTlKeys
   * @extends {Events}
   */
  class glTlKeys extends Events {
    /** @type {Anim} */
    #anim = null;

    /** @type {GlTimeline} */
    #glTl = null;

    /** @type {Array<GlRect>} */
    #keyRects = [];

    /** @type {Array<GlRect>} */
    // #dopeRects = [];

    /** @type {GlRect} */
    #parentRect = null;

    /** @type {Port} */
    #port;

    /** @type {GlSpline} */
    #spline;

    #disposed = false;

    sizeKey = 9;

    /** @type {Array<number>} */
    #points = [];
    #options = {};

    #dragStarted = false;

    /** @type {glTlAnimLine} */
    #animLine = null;
    #dragStartX = 0;
    #dragStartY = 0;

    /** @type {GlTlView} */
    #view;
    #updateCount = 0;

    /**
     * @param {GlTimeline} glTl
     * @param {glTlAnimLine} animLine
     * @param {Anim} anim
     * @param {GlRect} parentRect
     * @param {Port} port
     * @param {Object} options
     */
    constructor(glTl, animLine, anim, parentRect, port, options) {
      super();
      this._log = new Logger("gltlKeys");
      if (!anim) this._log.error("no anim");
      if (!parentRect) this._log.error("no parentRect");
      if (!port) this._log.error("no port");
      this.#anim = anim;
      this.#glTl = glTl;
      this.#view = glTl.view;
      this.#parentRect = parentRect;
      this.#options = options || {};
      this.#port = port;
      this.#animLine = animLine;

      if (this.#options.keyYpos) {
        this.#spline = new GlSpline(this.#glTl.splines, port.name);

        this.#spline.setParentRect(parentRect);
        this.#spline.setPoints([0, 0, 0, 100, 10, 0, 10, 10, 0]);
      }

      this.points = [];
      this.init();
    }

    isDragging() {
      return this.#dragStarted;
    }

    get anim() {
      return this.#anim;
    }

    isCurrentOp() {
      let isCurrentOp = Gui$1.gui.patchView.isCurrentOp(this.#port.op);
      return isCurrentOp;
    }

    get keyHeight() {
      return this.sizeKey;
    }

    get sizeKey2() {
      const w = this.getKeyWidth();

      if (w <= 2 || this.#glTl.layout == GlTimeline.LAYOUT_GRAPHS)
        return this.sizeKey / 2;
      else return 0;
    }

    /**
     * @param {GlRect} kr
     */
    setKeyShapeSize(kr) {
      const w = this.getKeyWidth();

      if (w <= 2 || this.#glTl.layout == GlTimeline.LAYOUT_GRAPHS) {
        kr.setShape(6);
        kr.setSize(this.sizeKey, this.sizeKey);
      } else {
        kr.setShape(0);
        kr.setSize(w, this.sizeKey);
      }
    }

    getKeyWidth() {
      const kwidth = this.#glTl.view.timeToPixel(1 / 30) - 1;

      return kwidth;
    }

    /**
     */
    update() {
      if (this.#disposed) {
        this._log.warn("disposed", this);
        return;
      }

      if (this.#keyRects.length != this.#anim.keys.length) return this.init();

      this.#points = [];
      const pointsSort = [];

      let z = -0.4;

      for (let i = 0; i < this.#keyRects.length; i++) {
        let col = [0.4, 0.4, 0.4, 1];

        const animKey = this.#anim.keys[i];
        const kr = this.#keyRects[i];

        if (animKey.anim.tlActive) col = [0.8, 0.8, 0.8, 1];

        //     if (animKey.time == this.#glTl.view.cursorTime) this.#glTl.setColorRectSpecial(kr);
        //     else
        //     if (this.isCurrentOp()) col = [1, 1, 1];
        // if (!kr.isHovering())
        // {
        //     col[0] *= 0.8;
        //     col[1] *= 0.8;
        //     col[2] *= 0.8;
        // }

        this.setKeyShapeSize(kr);

        if (
          this.#glTl.selectRect &&
          this.#glTl.selectRect.x < kr.absX + this.sizeKey &&
          this.#glTl.selectRect.x2 > kr.absX &&
          this.#glTl.selectRect.y < kr.absY + this.keyHeight &&
          this.#glTl.selectRect.y2 > kr.absY
        ) {
          this.#glTl.selectKey(animKey, this.#anim);
        }

        if (this.#glTl.isKeySelected(animKey)) {
          col = [1, 1, 0, 1];
        }

        kr.setColorArray(col);
      }

      this.setKeyPositions();

      if (this.#options.keyYpos) {
        const steps = this.#glTl.width / 1;

        for (let i = 0; i < steps; i++) {
          const t = CABLES.map(
            i,
            0,
            steps,
            this.#glTl.view.timeLeft,
            this.#glTl.view.timeRight,
          );
          const x = this.#glTl.view.timeToPixel(t - this.#glTl.view.offset);
          let y = this.#animLine.valueToPixel(this.#anim.getValue(t));

          pointsSort.push([x, y, z]);
        }

        pointsSort.sort((a, b) => {
          return a[0] - b[0];
        });

        this.#points = pointsSort.flat();
      }

      if (this.#options.keyYpos) {
        if (this.#anim.tlActive) this.#spline.setColor(0.9, 0.9, 0.9, 1);
        else this.#spline.setColor(0.4, 0.4, 0.4, 1);

        this.#spline.setPoints(this.#points);
      }
      this.#updateCount++;
    }

    setKeyPositions() {
      for (let i = 0; i < this.#keyRects.length; i++) {
        // let col = [0.7, 0.7, 0.7, 1];

        const animKey = this.#anim.keys[i];
        const kr = this.#keyRects[i];

        if (animKey.time == this.#glTl.view.cursorTime)
          this.#glTl.setColorRectSpecial(kr);
        // else
        // if (this.isCurrentOp()) col = [1, 1, 1];

        let y = this.#parentRect.h / 2;
        if (this.#options.keyYpos) y = this.#animLine.valueToPixel(animKey.value);

        const rx =
          this.#glTl.view.timeToPixel(animKey.time - this.#glTl.view.offset) -
          this.sizeKey2;
        const ry = y - this.keyHeight / 2;

        kr.setPosition(rx, ry, -0.8);
        this.setKeyShapeSize(kr);

        if (
          this.#glTl.selectRect &&
          this.#glTl.selectRect.x < kr.absX + this.sizeKey &&
          this.#glTl.selectRect.x2 > kr.absX &&
          this.#glTl.selectRect.y < kr.absY + this.keyHeight &&
          this.#glTl.selectRect.y2 > kr.absY
        ) {
          this.#glTl.selectKey(animKey, this.#anim);
        }
      }
    }

    selectAll() {
      if (this.#anim.tlActive)
        for (let i = 0; i < this.#anim.keys.length; i++)
          this.#glTl.selectKey(this.#anim.keys[i], this.#anim);
    }

    hasSelectedKeys() {
      for (let i = 0; i < this.#anim.keys.length; i++) {
        const animKey = this.#anim.keys[i];
        if (this.#glTl.isKeySelected(animKey)) return true;
      }
      return false;
    }

    updateKeyRects() {}

    init() {
      this.reset();
      for (let i = 0; i < this.#anim.keys.length; i++) {
        const kr = this.#glTl.rects.createRect({
          draggable: true,
          interactive: true,
        });

        this.setKeyShapeSize(kr);
        kr.setColor(0.28, 0.28, 0.28, 0.28);
        kr.setColorHover(1, 1, 1, 1);
        kr.setParent(this.#parentRect);
        const key = this.#anim.keys[i];
        kr.data.key = key;

        let startDragTime = -1111;
        let startDragValue = -1111;

        /** @type {Object} */
        let oldValues = {};

        kr.draggableMove = true;
        kr.on(GlRect.EVENT_POINTER_HOVER, () => {
          this.#glTl.hoverKeyRect = kr;
          this.update();
        });
        kr.on(GlRect.EVENT_POINTER_UNHOVER, () => {
          this.#glTl.hoverKeyRect = null;
          this.update();
        });

        kr.on(GlRect.EVENT_DRAGEND, () => {
          this.#anim.sortKeys();
          this.#anim.removeDuplicates();
          this.#glTl.needsUpdateAll = true;
          this.#dragStarted = false;

          undo.add({
            title: "timeline move keys",
            undo: () => {
              this.#glTl.deserializeKeys(oldValues);

              // key.set(oldValues);
            },
            redo() {},
          });
        });

        kr.on(GlRect.EVENT_POINTER_UP, (e) => {
          if (this.click) {
            if (this.#glTl.selectRect) return;
            if (this.#dragStarted) return;

            if (!e.shiftKey) this.#glTl.unSelectAllKeys();
            this.#glTl.selectKey(key, this.#anim);
          }
          this.click = false;
        });

        kr.on(GlRect.EVENT_POINTER_DOWN, () => {
          this.click = true;
        });

        kr.on(GlRect.EVENT_DRAGSTART, (_rect, x, _y, button, e) => {
          // this.click = false;

          this.#dragStartX = x.offsetX;
          this.#dragStartY = e.offsetY;
          if (button == 1 && !this.#dragStarted) {
            oldValues = this.#glTl.serializeSelectedKeys();
            this.#dragStarted = true;
            startDragTime = this.#glTl.view.pixelToTime(e.offsetX);
            startDragValue = this.#animLine.pixelToValue(e.offsetY);

            if (e.shiftKey) this.#glTl.duplicateSelectedKeys();
          }
        });

        kr.on(GlRect.EVENT_DRAG, (rect, offx, offy, button, e) => {
          this.click = false;
          if (this.#glTl.selectRect) return;
          if (startDragTime == -1111) {
            console.log("cant drag,,,,");
            return;
          }

          if (button == 2) {
            this.#dragStartX = e.offsetX;
            this.#dragStartY = e.offsetY;
          }
          if (button == 1) {
            const offTime =
              this.#glTl.view.pixelToTime(e.offsetX) - startDragTime;
            startDragTime = this.#glTl.snapTime(
              this.#glTl.view.pixelToTime(e.offsetX),
            );

            const offVal =
              startDragValue - this.#animLine.pixelToValue(e.offsetY);
            startDragValue = this.#animLine.pixelToValue(e.offsetY);

            if (this.#glTl.getNumSelectedKeys() > 0) {
              this.#glTl.moveSelectedKeysDelta(
                this.#glTl.snapTime(offTime),
                offVal,
              );
              this.#anim.sortKeys();
            }

            this.#animLine.update();
            this.update();
          }
        });

        this.#keyRects.push(kr);
      }
      this.update();
    }

    get height() {
      return this.#parentRect.h - this.#parentRect.y;
    }

    reset() {
      for (let i = 0; i < this.#keyRects.length; i++) this.#keyRects[i].dispose();
      this.#keyRects = [];
    }

    dispose() {
      this.reset();

      if (this.#spline) this.#spline = this.#spline.dispose();
      // if (this.#zeroRect) this.#zeroRect = this.#zeroRect.dispose();

      this.#disposed = true;
    }

    getDebug() {
      const o = {};
      o.points = this.#points;
      o.updateCount = this.#updateCount;

      return o;
    }
  }

  class TlTitle extends Events {
    index = 0;

    /** @type {HTMLElement} */
    #el = null;

    /** @type {HTMLElement} */
    #elTitle = null;

    /** @type {Object} */
    #buttons = [];
    #hasSelectedKeys;

    /** @type {Op} */
    op;

    /** @type {glTlKeys} */
    tlKeys;

    /** @type {Anim} */
    #anim;
    #gltl;

    /**
     * @param {HTMLElement} parentEl
     * @param {Anim} anim
     * @param {GlTimeline} gltl
     */
    constructor(gltl, parentEl, anim) {
      super();
      this.#gltl = gltl;
      this.#anim = anim;
      this.#el = document.createElement("div");
      this.#el.classList.add("tlTitle");
      parentEl.appendChild(this.#el);

      this.#elTitle = document.createElement("span");

      ele.clickable(this.#elTitle, () => {
        this.emitEvent("titleClicked", this);
      });
      this.addButton("...", (e) => {
        contextMenu.show(
          {
            items: [
              {
                title: "Select all keys",
                func: () => {
                  this.tlKeys.selectAll();
                },
              },
            ],
          },
          e.target,
        );
      });
      if (this.#gltl.layout == GlTimeline.LAYOUT_GRAPHS)
        this.activeButton = this.addButton(
          '<span class="icon icon-check icon-0_75x nomargin info" data-info="tlactive"></span>',
          (e) => {
            if (e.buttons == 2) this.#gltl.deactivateAllAnims();
            this.toggleActive();
          },
        );
      this.#el.appendChild(this.#elTitle);

      if (this.#gltl.layout == GlTimeline.LAYOUT_GRAPHS)
        this.setActive(anim.tlActive);
      else this.setActive(true);
    }

    /**
     * @param {string} t
     */
    setTitle(t) {
      this.#elTitle.innerHTML = t;
    }

    /**
     * @param {boolean} c
     */
    setActive(c) {
      this.#anim.tlActive = c;

      this.updateIcons();
    }

    updateIcons() {
      const c = this.#anim.tlActive;

      if (c) this.#elTitle.classList.add("current");
      else this.#elTitle.classList.remove("current");

      if (this.activeButton)
        if (!c) this.activeButton.style.opacity = "0.4";
        else this.activeButton.style.opacity = "1";
    }

    toggleActive() {
      this.setActive(!this.#anim.tlActive);
    }

    /**
     * @param {boolean} c
     */
    setHasSelectedKeys(c) {
      this.#hasSelectedKeys = c;

      if (c) this.#el.classList.add("hasSelectedKeys");
      else this.#el.classList.remove("hasSelectedKeys");
    }

    /**
     * @param {string} title
     * @param {Function} cb
     */
    addButton(title, cb) {
      const button = document.createElement("a");
      button.classList.add("button-small");

      let html = "";
      html += title;
      button.innerHTML = html;
      ele.clickable(button, cb);
      button.addEventListener("contextmenu", (e) => {
        cb(e);
      });
      button.addEventListener("dblclick", (e) => {
        this.#gltl.deactivateAllAnims(true);
      });
      this.#el.appendChild(button);
      this.#buttons.push({ ele: button, cb, title });
      return button;
    }

    /**
     * @param {number} x
     * @param {number} y
     */
    setPos(x, y) {
      this.#el.style.left = x + "px";
      this.#el.style.top = y + 35 + "px";
    }

    updateColor() {
      // if (this.op)
      //     this.setIsCurrent(Gui.gui.patchView.isCurrentOp(this.op));
    }

    dispose() {
      this.#el.remove();
    }
  }

  class TlValueRuler {
    #numMarker = 20;

    /** @type {GlRect} */
    #zeroRect = null;

    /** @type {GlTimeline} */
    #glTl;

    /** @type {GlTlView} */
    #view;

    /** @type {GlRect[]} */
    #marker = [];
    #parentRect;

    /** @type {glTlAnimLine} */
    #animLine;

    /**
     * @param {GlTimeline} glTl
     * @param {glTlAnimLine} animline
     * @param {GlRect} parentRect
     */
    constructor(glTl, animline, parentRect) {
      this.#glTl = glTl;
      this.#parentRect = parentRect;
      this.#view = glTl.view;
      this.#animLine = animline;
      this.init();
    }

    init() {
      this.dispose();

      this.#zeroRect = this.#glTl.rects.createRect({
        draggable: true,
        interactive: false,
      });
      this.#zeroRect.setSize(99999, 1);
      this.#zeroRect.setColor(0, 0, 0, 1);
      this.#zeroRect.setParent(this.#parentRect);

      for (let i = 0; i < this.#numMarker; i++) {
        const r = this.#glTl.rects.createRect({
          draggable: true,
          interactive: false,
        });
        r.setPosition(0, i);
        r.setSize(20, 1);
        r.setParent(this.#parentRect);
        this.#marker.push(r);
      }
    }

    update() {
      for (let i = 0; i < this.#marker.length; i++) {
        this.#marker[i].setPosition(
          this.#parentRect.w - 20,
          this.#animLine.valueToPixel(i - this.#numMarker / 2),
        );
      }

      this.#zeroRect.setPosition(0, this.#animLine.valueToPixel(0));
    }

    dispose() {
      for (let i = 0; i < this.#marker.length; i++) this.#marker[i].dispose();
      if (this.#zeroRect) this.#zeroRect.dispose();

      return null;
    }
  }

  /**
   * gltimeline anim
   *
   * @export
   * @class glTlAnim
   * @extends {Events}
   */
  class glTlAnimLine extends Events {
    /** @type {Array<Anim>} */
    #anims = [];

    /** @type {Array<Op>} */
    #ops = [];

    /** @type {GlRect} */
    #glRectKeysBg = null;

    /** @type {GlRect} */
    // #glRectTitle = null;

    /** @type {GlText} */
    #glTextSideValue = null;

    /** @type {GlTimeline} */
    #glTl = null;

    /** @type {Array<glTlKeys>} */
    #keys = [];

    /** @type {Array<Port>} */
    #ports = [];

    static DEFAULT_HEIGHT = 25;

    width = 222;
    height = glTlAnimLine.DEFAULT_HEIGHT;

    /** @type {Array<Object >} */
    #disposeRects = [];

    #options = {};

    /** @type {TlTitle[]} */
    #titles = [];

    #animChangeListeners = [];

    #disposed = false;

    /** @type {GlTlView} */
    #view = null;

    /** @type {TlValueRuler} */
    #valueRuler = null;

    /**
     * @param {GlTimeline} glTl
     * @param {Array<Port>} ports
     * @param {Object} options
     */
    constructor(glTl, ports, options = {}) {
      super();

      this.#options = options;
      this.#glTl = glTl;
      this.#view = glTl.view;
      this.#glRectKeysBg = this.#glTl.rects.createRect({
        draggable: false,
        interactive: true,
      });
      this.#glRectKeysBg.setSize(this.width, this.height - 2);
      this.#glRectKeysBg.setColor(0.3, 0.3, 0.3);

      this.#disposeRects.push(this.#glRectKeysBg);

      for (let i = 0; i < ports.length; i++) {
        this.#anims[i] = ports[i].anim;
        this.#ops[i] = ports[i].op;
        this.#ports[i] = ports[i];
        if (this.#keys[i]) this.#keys[i].dispose();
        this.#keys[i] = new glTlKeys(
          glTl,
          this,
          this.#ports[i].anim,
          this.#glRectKeysBg,
          this.#ports[i],
          this.#options,
        );

        const keys = this.#keys[i];
        const anim = ports[i].anim;

        const lid = anim.on(Anim.EVENT_CHANGE, () => {
          if (!keys.isDragging()) keys.init();
        });

        this.#animChangeListeners.push({ id: lid, anim: anim });
      }

      for (let i = 0; i < ports.length; i++) {
        let title = ports[i].op.name + " - " + ports[i].name;
        this.setTitle(i, title, ports[i].anim);
      }
      if (this.#glTl.layout == GlTimeline.LAYOUT_GRAPHS) {
        this.#valueRuler = new TlValueRuler(glTl, this, this.#glRectKeysBg);
        this.#glTextSideValue = new GlText(this.#glTl.texts, "");
        this.#disposeRects.push(this.#glTextSideValue);

        this.#glRectKeysBg.on(GlRect.EVENT_POINTER_MOVE, (x, y) => {
          if (this.#keys.length < 1) return;
          this.#glTextSideValue.text = String(
            Math.round(
              this.pixelToValue(this.height - y + this.#glRectKeysBg.y) * 1000,
            ) / 1000,
          );
          this.#glTextSideValue.setPosition(
            this.width - this.#glTextSideValue.width - 10,
            y - 20,
            -0.5,
          );
        });
      }

      this.fitValues();
      this.updateColor();
    }

    get anims() {
      return this.#anims;
    }

    isHovering() {
      return this.#glRectKeysBg.isHovering();
    }

    /**
     * @param {string} t
     * @param {Anim} anim
     */
    addTitle(t, anim) {
      const title = new TlTitle(this.#glTl, this.#glTl.parentElement(), anim);
      title.setTitle(t);
      title.on("titleClicked", (title) => {
        Gui$1.gui.patchView.focusOp(this.#ops[title.index].id);
      });

      this.#titles.push(title);
      this.setTitlePos();
    }

    updateTitles() {
      for (let i = 0; i < this.#titles.length; i++) this.#titles[i].updateIcons();
    }

    setTitlePos() {
      for (let i = 0; i < this.#titles.length; i++) {
        this.#titles[i].setPos(
          3,
          i * glTlAnimLine.DEFAULT_HEIGHT + this.#glRectKeysBg.y,
        );
        this.#titles[i].index = i;
        this.#titles[i].tlKeys = this.#keys[i];
        this.#titles[i].op = this.#ops[i];
      }
    }

    /**
     * @param {number} idx
     * @param {string} t
     * @param {Anim} [anim]
     */
    setTitle(idx, t, anim) {
      while (this.#titles.length <= idx) this.addTitle("title...", anim);
      this.#titles[idx].setTitle(t, anim);
      this.setTitlePos();
    }

    fitValues() {
      for (let j = 0; j < this.#keys.length; j++) {
        const anim = this.#keys[j].anim;

        for (let i = 0; i < anim.keys.length; i++) {
          this.#view.minVal = Math.min(
            this.#view.finalMinVal,
            anim.keys[i].value,
          );
          this.#view.maxVal = Math.max(
            this.#view.finalMaxVal,
            anim.keys[i].value + 0.01,
          );
        }
      }
    }

    update() {
      if (this.checkDisposed()) return;
      this.updateColor();

      for (let i = 0; i < this.#keys.length; i++) this.#keys[i].update();
      if (this.#valueRuler) this.#valueRuler.update();
    }

    updateColor() {
      if (this.checkDisposed()) return;

      for (let i = 0; i < this.#titles.length; i++) {
        this.#titles[i].updateColor();
        this.#titles[i].setHasSelectedKeys(this.#keys[i].hasSelectedKeys());
      }
    }

    /**
     * @param {number} x
     * @param {number} y
     */
    setPosition(x, y) {
      if (this.checkDisposed()) return;
      // this.#glRectTitle.setPosition(x, y, -0.5);
      this.#glRectKeysBg.setPosition(0, y);
      this.setTitlePos();
    }

    /**
     * @param {number} h
     */
    setHeight(h) {
      if (this.checkDisposed()) return;
      this.height = h;
      this.setWidth(this.width);
      this.update();
    }

    /**
     * @param {number} w
     */
    setWidth(w) {
      if (this.checkDisposed()) return;
      this.width = w;
      // this.#glRectTitle.setSize(this.#glTl.titleSpace, this.height - 1);
      this.#glRectKeysBg.setSize(this.width, this.height - 2);
    }

    checkDisposed() {
      if (this.#disposed) console.log("disposed object...", this);
      return this.#disposed;
    }

    dispose() {
      if (this.#disposed) return;
      this.#disposed = true;
      if (this.#valueRuler) this.#valueRuler = this.#valueRuler.dispose();

      for (let i = 0; i < this.#titles.length; i++) this.#titles[i].dispose();

      for (let i = 0; i < this.#animChangeListeners.length; i++)
        this.#animChangeListeners[i].anim.removeEventListener(
          this.#animChangeListeners[i].id,
        );

      this.#animChangeListeners = [];

      for (let i = 0; i < this.#keys.length; i++) this.#keys[i].dispose();
      this.#keys = [];

      for (let i = 0; i < this.#disposeRects.length; i++)
        this.#disposeRects[i].dispose();

      this.#disposeRects = [];
    }

    /**
     * @param {string} id
     * @returns {Anim}
     */
    getAnimById(id) {
      for (let i = 0; i < this.#anims.length; i++) {
        if (id == this.#anims[i].id) return this.#anims[i];
      }
      return null;
    }

    /**
     * @param {string} animName
     * @returns {Anim}
     */
    getAnimByName(animName) {
      for (let i = 0; i < this.#anims.length; i++) {
        if (animName == this.#anims[i].name) return this.#anims[i];
      }
      return null;
    }

    getDebug() {
      const o = {
        numanims: this.anims.length,
        anims: [],
        keys: [],
      };
      for (let i = 0; i < this.#anims.length; i++)
        o.anims.push(this.anims[i].name);
      for (let i = 0; i < this.#keys.length; i++)
        o.keys.push(this.#keys[i].getDebug());
      return o;
    }

    /**
     * @param {Number} posy
     */
    pixelToValue(posy) {
      return CABLES.map(
        posy,
        0,
        this.height,
        this.#view.minVal,
        this.#view.maxVal,
      );
    }

    /**
     * @param {Number} v
     */
    valueToPixel(v) {
      if (this.#keys.length == 0) return;
      let y = CABLES.map(
        v + 0.0000001,
        this.#view.minVal,
        this.#view.maxVal,
        this.#keys[0].sizeKey2,
        this.#glRectKeysBg.h - this.#keys[0].keyHeight / 2,
        0,
        false,
      );

      // if (y == -Infinity) y = 0;
      // if (y == Infinity)y = 0;
      return this.#glRectKeysBg.h - y - this.#glTl.view.offsetY;
    }
  }

  /**
   * gltl ruler display
   *
   * @export
   * @class glTlRuler
   * @extends {Events}
   */
  class glTlRuler extends Events {
    /** @type {GlTimeline} */
    #glTl;

    /**
     * @param {GlTimeline} glTl
     */
    constructor(glTl) {
      super();
      this._log = new Logger("glTlRuler");
      this.#glTl = glTl;
      this.y = 30;
      this.height = 50;

      this._glRectBg = this.#glTl.rects.createRect({
        draggable: true,
        interactive: true,
      });
      this._glRectBg.setSize(222, this.height);
      this._glRectBg.setColor(0.25, 0.25, 0.25, 1);
      // this._glRectBg.setColorHover(0.2, 0.2, 0.2, 1);
      this._glRectBg.setPosition(0, this.y, -0.9);

      this._glRectBg.on(GlRect.EVENT_DRAG, (_r, _ox, _oy, _button, event) => {
        gui
          .corePatch()
          .timer.setTime(
            this.#glTl.snapTime(
              this.#glTl.view.pixelToTime(event.offsetX) + this.#glTl.view.offset,
            ),
          );
      });

      this._glRectBg.on(GlRect.EVENT_POINTER_HOVER, () => {});

      this._glRectBg.on(GlRect.EVENT_POINTER_UNHOVER, () => {});

      this._glRectBg.on(GlRect.EVENT_POINTER_DOWN, (event, _r, _x, _y) => {
        gui
          .corePatch()
          .timer.setTime(
            this.#glTl.snapTime(
              this.#glTl.view.pixelToTime(event.offsetX) + this.#glTl.view.offset,
            ),
          );
      });

      this.markf = [];
      for (let i = 0; i < 300; i++) {
        const mr = this.#glTl.rects.createRect({
          draggable: false,
          interactive: false,
        });
        mr.setColor(0.0, 0.0, 0.0, 1);
        mr.setParent(this._glRectBg);
        this.markf.push(mr);
      }

      this.markBeats = [];
      for (let i = 0; i < 400; i++) {
        const mr = this.#glTl.rects.createRect({
          draggable: false,
          interactive: false,
        });
        mr.setColor(0.2, 0.2, 0.2, 1);
        mr.setParent(this._glRectBg);
        mr.setSize(0, 0);
        this.markBeats.push(mr);
      }

      this.marks = [];
      for (let i = 0; i < 300; i++) {
        const mr = this.#glTl.rects.createRect({
          draggable: false,
          interactive: false,
        });
        mr.setParent(this._glRectBg);
        this.marks.push(mr);
      }

      this.titles = [];
      for (let i = 0; i < 100; i++) {
        const mt = new GlText(this.#glTl.texts, "");

        this.titles.push(mt);
      }

      this.update();
    }

    /**
     * @param {number} x
     */
    setTimeFromPixel(x) {
      gui
        .corePatch()
        .timer.setTime(
          this.#glTl.snapTime(
            this.#glTl.view.pixelToTime(x) + this.#glTl.view.offset,
          ),
        );
    }

    /**
     * @param {number} x
     * @param {number} y
     */
    setPosition(x, y) {
      this._glRectBg.setPosition(x, y);
    }

    update() {
      let pixelScale = this.#glTl.view.timeToPixel(1);
      let titleCounter = 0;
      let offset = Math.floor(this.#glTl.view.offset);
      // let offsetPixel = this.#glTl.view.timeToPixelScreen(this.#glTl.view.offset % 1);

      for (let i = 0; i < this.titles.length; i++) {
        this.titles[i]._align = 1;
        this.titles[i].text = "";
        this.titles[i].setParentRect(null);
      }

      if (this.#glTl.cfg.fadeInFrames) {
        const oneframePixel = this.#glTl.view.timeToPixel(1 / this.#glTl.fps);
        if (oneframePixel >= 5) {
          for (let i = 0; i < this.markf.length; i++) {
            const mr = this.markf[i];
            const t = offset + i * (1 / this.#glTl.fps);
            const x = this.#glTl.view.timeToPixel(t - this.#glTl.view.offset);
            const a = CABLES.map(oneframePixel, 5, 15, 0.04, 1.0);

            mr.setSize(oneframePixel - 2, this.height / 2);
            mr.setPosition(x + 1, this.height / 2);
            mr.setColor(0.13, 0.13, 0.13, a);

            if (t < 0) this.markf[i].setSize(0, 0);
          }
        } else {
          for (let i = 0; i < this.markf.length; i++) this.markf[i].setSize(0, 0);
        }
      } else
        for (let i = 0; i < this.markf.length; i++) this.markf[i].setSize(0, 0);

      if (this.#glTl.cfg.showBeats) {
        const bps = this.#glTl.bpm / 60;
        const onebeatPixel = this.#glTl.view.timeToPixel(1 / bps);
        // const spb = 0 / bps;

        for (let i = 0; i < this.markBeats.length; i++) {
          const mr = this.markBeats[i];
          const t = offset + i * (1 / bps);
          const x = this.#glTl.view.timeToPixel(t - this.#glTl.view.offset);
          mr.setSize(onebeatPixel - 2, 5);
          mr.setPosition(x, 1);

          // const absBeat = Math.floor(t / (spb));
          let shade = 0.5;
          // if (absBeat % 4 == 0)shade = 0.8;

          mr.setColor(shade, shade, shade, 1);

          if (t < 0) mr.setSize(0, 0);
        }
      } else {
        for (let i = 0; i < this.markBeats.length; i++)
          this.markBeats[i].setSize(0, 0);
      }

      for (let i = 0; i < this.marks.length; i++) {
        const mr = this.marks[i];
        let h = 10;
        let x = 0;
        let a = 0.4;
        let title = null;
        titleCounter %= this.titles.length;

        let time = 0;

        if (this.#glTl.displayUnits == "Seconds") {
          if (pixelScale > 50) {
            time = offset + i * 0.1;
            x = this.#glTl.view.timeToPixel(time - this.#glTl.view.offset);
            if (time % 1 == 0.5) {
              h = 25;
            }
            if (time % 1 == 0) {
              // full seconds
              h = 15;
              a = 1;
              title = time + "s";
            }
          } else if (pixelScale < 4) {
            time = offset + i * 10;
            x = this.#glTl.view.timeToPixel(time - this.#glTl.view.offset);
            if (time % 30 == 0) {
              h = 20;
              title = time + "s";
              a = 1;
            }
          } else if (pixelScale < 8) {
            time = offset + i * 10;
            x = this.#glTl.view.timeToPixel(time - this.#glTl.view.offset);
            if (time % 10 == 0) {
              h = 20;
              title = time + "s";
              a = 1;
            }
          } else if (pixelScale < 50) {
            time = offset + i;
            x = this.#glTl.view.timeToPixel(time - this.#glTl.view.offset);
            if (time % 1 == 0) {
              h = 10;
            }
            if (time % 10 == 0) {
              h = 20;
              title = time + "s";
            } else if (time % 5 == 0) {
              h = 15;
              title = time + "s";
              a = 1;
            }
          }
        }
        if (this.#glTl.displayUnits == "Frames") {
          time = offset + i;
          x = this.#glTl.view.timeToPixel(time - this.#glTl.view.offset);
          h = 20;
          title = i * this.#glTl.fps + "f";
        }

        if (time < 0 || time > this.#glTl.duration) mr.setColor(0, 0, 0, a);
        else mr.setColor(1, 1, 1, a);
        mr.setSize(1, h);
        mr.setPosition(x, this.height - h);

        if (title && x < this.#glTl.width) {
          if (time < 0 || time > this.#glTl.duration)
            this.titles[titleCounter].setColor(0, 0, 0, 1);
          else this.titles[titleCounter].setColor(1, 1, 1, 1);

          this.titles[titleCounter].text = title;
          this.titles[titleCounter].setParentRect(this._glRectBg);
          // this.titles[titleCounter].setPosition(0, 50);
          this.titles[titleCounter].setPosition(x, this.height - h - 30);

          titleCounter++;
        }
      }
    }

    /**
     * @param {number} w
     */
    setWidth(w) {
      this.width = w;
      this._glRectBg.setSize(this.width, this.height);
    }

    isHovering() {
      return this._glRectBg.isHovering();
    }
  }

  class glTlDragArea extends Events {
    /** @type {GlRect} */
    #rectBar = null;

    /** @type {GlRect} */
    #rectSizeLeft = null;

    /** @type {GlRect} */
    #rectSizeRight;

    #width = 222;
    #handleWidth = 4;

    /** @type {GlTimeline} */
    #glTl = null;

    #dragStart = 0;

    /**
     * @param {GlTimeline} glTl
     */
    constructor(glTl, parent, interactive) {
      super();
      this._log = new Logger("tl dragarea");
      this.#glTl = glTl;
      this.height = 24;

      this.#rectBar = this.#glTl.rects.createRect({
        draggable: false,
        interactive: true,
      });
      this.#rectBar.setSize(222, this.height);
      this.#rectBar.setColor(0.5, 0.5, 0.5, 1);
      this.#rectBar.setParent(parent);
      this.#rectBar.setColorHover(0.65, 0.65, 0.65, 1);

      this.#rectSizeLeft = this.#glTl.rects.createRect({
        draggable: true,
        interactive: true,
      });
      this.#rectSizeLeft.setSize(this.#handleWidth, this.height);
      this.#rectSizeLeft.setColor(0.4, 0.4, 0.4, 1);
      this.#rectSizeLeft.setParent(parent);

      this.#rectSizeRight = this.#glTl.rects.createRect({
        draggable: true,
        interactive: true,
      });
      this.#rectSizeRight.setSize(this.#handleWidth, this.height);
      this.#rectSizeRight.setColor(0.4, 0.4, 0.4, 1);
      this.#rectSizeRight.setParent(parent);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    set(x, y, width, height = this.height) {
      this.#width = width;
      this.#rectBar.setSize(width, height);
      this.#rectSizeRight.setSize(this.#handleWidth, height);
      this.#rectSizeLeft.setSize(this.#handleWidth, height);
      this.#rectBar.setPosition(x, y, 0);
      this.#rectSizeRight.setPosition(x - this.#handleWidth, y, 0);
      this.#rectSizeLeft.setPosition(x + this.#width, y, 0);
    }
  }

  class glTlScroll extends Events {
    /** @type {GlRect} */
    #mainRect = null;

    /** @type {glTlDragArea} */
    #dragBar = null;

    /** @type {GlRect} */
    #glRectCursor;

    height = 24;
    #width = 222;
    #dragStart = 0;

    /**
     * @param {GlTimeline} glTl
     */
    constructor(glTl) {
      super();
      this._log = new Logger("glTlRuler");
      this._glTl = glTl;

      this.#mainRect = this._glTl.rects.createRect({
        draggable: true,
        interactive: true,
      });
      this.#mainRect.setColor(0.2, 0.2, 0.2, 1);
      this.#mainRect.setSize(this.#width, this.height);
      this.#mainRect.setPosition(0, 0, -0.5);

      this.#dragBar = new glTlDragArea(glTl, this.#mainRect);
      // this.#dragBar.on("drag", (off) =>
      // {
      //     const pixelVisible = this._glTl.view.visibleTime * this._glTl.view.pixelPerSecond;
      //     console.log(this._glTl.view.pixelPerSecond, off / this.#width);

      //     this._glTl.view.scrollTo(((off / this.#width) * this._glTl.view.visibleTime), 0);
      //     this.update();
      // });

      this.#mainRect.on(GlRect.EVENT_POINTER_DOWN, (e, r, x, y) => {
        console.log(e, x);
        const perc = x / this.#width;

        this._glTl.view.scrollTo(perc * this._glTl.duration);
      });

      this.#mainRect.on(GlRect.EVENT_DRAGSTART, (a, x, y) => {
        this.#dragStart = x;
      });

      // this.emitEvent(GlRect.EVENT_DRAG, this, this.#dragOffsetX, this.#dragOffsetY, button, event, x, y);

      this.#mainRect.on(GlRect.EVENT_DRAG, (a, offX, c, button, event, x, y) => {
        const perc = (this.#dragStart + offX) / this.#width;

        this._glTl.view.scrollTo(perc * this._glTl.duration);
      });

      this.#glRectCursor = this._glTl.rects.createRect({
        draggable: true,
        interactive: true,
      });
      this.#glRectCursor.setSize(1, this.height);
      this.#glRectCursor.setColor(
        0.02745098039215691,
        0.968627450980392,
        0.5490196078431373,
        1,
      );
      this.#glRectCursor.setPosition(0, 0);
      this.#glRectCursor.setParent(this.#mainRect);

      this.update();
    }

    /**
     * @param {number} x
     * @param {number} y
     */
    setPosition(x, y) {
      this.#mainRect.setPosition(x, y, -0.5);
    }

    setWidth(w) {
      this.#width = w;
      this.#mainRect.setSize(this.#width, this.height);
    }

    update() {
      const pixelVisible =
        this._glTl.view.visibleTime * this._glTl.view.pixelPerSecond;

      let x = this._glTl.view.offset * this._glTl.view.pixelPerSecond;

      this.#dragBar.set(x, 0, pixelVisible);

      let cx =
        Gui$1.gui.corePatch().timer.getTime() * this._glTl.view.pixelPerSecond;
      this.#glRectCursor.setPosition(cx, 0);
    }

    isHovering() {
      return this.#mainRect.isHovering();
    }
  }

  /**
   * @typedef TlConfig
   * @property {Number} fps
   * @property {Number} [duration]
   * @property {Number} bpm
   * @property {Boolean} fadeInFrames
   * @property {Boolean} showBeats
   * @property {String} displayUnits
   * @property {Boolean} restrictToFrames
   */

  /**
   * gl timeline
   *
   * @export
   * @class GlTimeline
   * @extends {Events}
   */
  class GlTimeline extends Events {
    activateAllAnims() {
      throw new Error("Method not implemented.");
    }

    /** @type {GlTextWriter} */
    texts = null;

    /** @type {GlSplineDrawer} */
    splines;

    /** @type {GlRectInstancer} */
    #rects = null;

    /** @type {GlRectInstancer} */
    #rectsOver = null;

    /** @type {glTlRuler} */
    ruler = null;

    /** @type {glTlScroll} */
    scroll = null;

    /** @type {Array<glTlAnimLine>} */
    #tlAnims = [];

    /** @type {GlRect} */
    #glRectCursor;

    duration = 120;

    displayUnits = "Seconds";

    /** @type {GlRect} */
    // #timeBg;

    /** @type {GlRect} */
    #rectSelect;

    /** @type {GlTlView} */
    view = null;
    needsUpdateAll = true;

    static LAYOUT_LINES = 0;
    static LAYOUT_GRAPHS = 1;
    #layout = GlTimeline.LAYOUT_LINES;

    /** @type {Array<AnimKey>} */
    #selectedKeys = [];

    hoverKeyRect = null;
    disposed = false;

    #oldhtml = "";
    #canvasMouseDown = false;
    #paused = false;

    /** @type {CglContext} */
    #cgl = null;
    #isAnimated = false;
    buttonForScrolling = 2;
    toParamKeys = null;

    /** @type {TlConfig} */
    cfg = {
      fps: 30,
      bpm: 180,
      fadeInFrames: true,
      showBeats: true,
      displayUnits: "Seconds",
      restrictToFrames: true,
    };

    #selOpsStr = "";
    #lastXnoButton = 0;
    #lastYnoButton = 0;

    selectRect = null;
    #selectedKeyAnims = [];
    #firstInit = true;
    #focusRuler = false;
    #focusScroll = false;
    #keyOverEl;
    #tlTimeDisplay;

    #perfFps = new FpsCounter();
    #filterInputEl;
    #filterString = "";

    /**
     * @param {CglContext} cgl
     */
    constructor(cgl) {
      super();

      this._log = new Logger("gltimeline");

      this.#cgl = cgl;
      this.view = new GlTlView(this);

      this.#layout =
        UserSettings.userSettings.get("gltl_layout") || GlTimeline.LAYOUT_LINES;

      this.texts = new GlTextWriter(cgl, { name: "mainText", initNum: 1000 });
      this.#rects = new GlRectInstancer(cgl, {
        name: "gltl rects",
        allowDragging: true,
      });

      this.#rectsOver = new GlRectInstancer(cgl, {
        name: "gltl rects",
        allowDragging: true,
      });

      this.ruler = new glTlRuler(this);

      this.scroll = new glTlScroll(this);

      this.#glRectCursor = this.#rectsOver.createRect({
        draggable: true,
        interactive: true,
      });
      this.#glRectCursor.setSize(1, cgl.canvasHeight);
      this.#glRectCursor.setPosition(0, 0, -1);
      this.setColorRectSpecial(this.#glRectCursor);

      // this.#timeBg = this.#rects.createRect({ });
      // this.#timeBg.setSize(this.titleSpace, this.ruler.height + this.scroll.height);
      // this.#timeBg.setColor(0.15, 0.15, 0.15, 1);
      // this.#timeBg.setPosition(0, 0, -0.5);

      this.#rectSelect = this.#rectsOver.createRect({
        draggable: true,
        interactive: true,
      });
      this.#rectSelect.setSize(0, 0);
      this.#rectSelect.setPosition(0, 0, -0.9);
      this.#rectSelect.setColorArray(
        Gui$1.gui.theme.colors_patch.patchSelectionArea,
      );

      Gui$1.gui.corePatch().timer.on("playPause", () => {
        gui
          .corePatch()
          .timer.setTime(this.snapTime(Gui$1.gui.corePatch().timer.getTime()));
      });

      cgl.canvas.classList.add("cblgltimelineEle");
      cgl.canvas.addEventListener(
        "pointermove",
        this._onCanvasMouseMove.bind(this),
        { passive: false },
      );
      cgl.canvas.addEventListener("pointerup", this._onCanvasMouseUp.bind(this), {
        passive: false,
      });
      cgl.canvas.addEventListener(
        "pointerdown",
        this._onCanvasMouseDown.bind(this),
        { passive: false },
      );
      cgl.canvas.addEventListener("wheel", this._onCanvasWheel.bind(this), {
        passive: true,
      });
      cgl.addEventListener("resize", this.resize.bind(this));

      Gui$1.gui.corePatch().on("timelineConfigChange", this.onConfig.bind(this));

      Gui$1.gui.corePatch().on(CABLES.Patch.EVENT_OP_DELETED, () => {
        this.init();
      });
      Gui$1.gui.corePatch().on(CABLES.Patch.EVENT_OP_ADDED, () => {
        this.init();
      });
      Gui$1.gui.corePatch().on("portAnimToggle", () => {
        this.init();
      });

      this.#keyOverEl = document.createElement("div");
      this.#keyOverEl.classList.add("keyOverlay");
      this.#keyOverEl.classList.add("hidden");
      cgl.canvas.parentElement.appendChild(this.#keyOverEl);

      this.#filterInputEl = document.createElement("input");
      this.#filterInputEl.classList.add("filterInput");
      this.#filterInputEl.setAttribute("placeholder", "filter...");
      cgl.canvas.parentElement.appendChild(this.#filterInputEl);

      this.#filterInputEl.addEventListener("input", () => {
        this.#filterString = this.#filterInputEl.value;
        this.init();
      });

      this.#tlTimeDisplay = document.createElement("div");
      this.#tlTimeDisplay.classList.add("tltimedisplay");
      cgl.canvas.parentElement.appendChild(this.#tlTimeDisplay);

      Gui$1.gui.keys.key("c", "Center cursor", "down", cgl.canvas.id, {}, () => {
        this.view.centerCursor();
      });

      Gui$1.gui.keys.key(
        "f",
        "zoom to all or selected keys",
        "down",
        cgl.canvas.id,
        {},
        () => {
          if (this.getNumSelectedKeys() == 1) ; else if (this.getNumSelectedKeys() > 1) {
            this.zoomToFitSelection();
          } else {
            this.selectAllKeys();
            this.zoomToFitSelection();
            this.unSelectAllKeys();
          }
        },
      );

      Gui$1.gui.keys.key(
        "j",
        "Go to previous keyframe",
        "down",
        cgl.canvas.id,
        {},
        () => {
          this.jumpKey(-1);
        },
      );
      Gui$1.gui.keys.key(
        "k",
        "Go to next keyframe",
        "down",
        cgl.canvas.id,
        {},
        () => {
          this.jumpKey(1);
        },
      );

      Gui$1.gui.keys.key(
        "delete",
        "delete selected keys",
        "down",
        cgl.canvas.id,
        {},
        () => {
          this.deleteSelectedKeys();
          this.needsUpdateAll = true;
        },
      );

      Gui$1.gui.keys.key(
        "backspace",
        "delete selected keys",
        "down",
        cgl.canvas.id,
        {},
        () => {
          this.deleteSelectedKeys();
          this.needsUpdateAll = true;
        },
      );

      Gui$1.gui.keys.key(
        "a",
        "Select all keys",
        "down",
        cgl.canvas.id,
        { cmdCtrl: true },
        (_e) => {
          this.selectAllKeys();
        },
      );

      /// ///////////////////

      Gui$1.gui.on("opSelectChange", () => {
        for (let i = 0; i < this.#tlAnims.length; i++) this.#tlAnims[i].update();
        this.needsUpdateAll = true;
      });

      Gui$1.gui.patchView.patchRenderer.on("selectedOpsChanged", () => {
        let selops = Gui$1.gui.patchView.getSelectedOps();

        if (selops.length == 0) return;
        let isAnimated = false;
        for (let i = 0; i < selops.length; i++)
          if (selops[i].isAnimated()) isAnimated = true;

        if (!isAnimated) return;

        let selOpsStr = "";
        for (let i = 0; i < selops.length; i++) selOpsStr += selops[i].id;

        this.needsUpdateAll = true;
        if (
          this.#layout == GlTimeline.LAYOUT_GRAPHS &&
          selOpsStr != this.#selOpsStr
        ) {
          this.init();
          this.#selOpsStr = selOpsStr;
        }
      });
      Gui$1.gui.glTimeline = this;

      this.init();
      this._initUserPrefs();
    }

    _initUserPrefs() {
      const userSettingScrollButton = UserSettings.userSettings.get(
        "patch_button_scroll",
      );
      this.buttonForScrolling = userSettingScrollButton || 2;
    }

    /** @returns {number} */
    get bpm() {
      return this.cfg.bpm;
    }

    /** @returns {number} */
    get fps() {
      return this.cfg.fps;
    }

    get layout() {
      return this.#layout;
    }

    get rects() {
      return this.#rects;
    }

    get isAnimated() {
      return !this.view.animsFinished;
    }

    get cursorTime() {
      return Gui$1.gui.corePatch().timer.getTime();
    }

    parentElement() {
      return this.#cgl.canvas.parentElement;
    }

    resize() {
      this.scroll.setWidth(this.#cgl.canvasWidth);
      this.ruler.setWidth(this.#cgl.canvasWidth);

      for (let i = 0; i < this.#tlAnims.length; i++)
        this.#tlAnims[i].setWidth(this.#cgl.canvasWidth);

      this.needsUpdateAll = true;
    }

    /**
     * @param {number} time
     */
    snapTime(time) {
      if (this.cfg.restrictToFrames)
        time = Math.floor(time * this.fps) / this.fps;
      return time;
    }

    toggleGraphLayout() {
      if (this.#layout == GlTimeline.LAYOUT_GRAPHS)
        this.#layout = GlTimeline.LAYOUT_LINES;
      else this.#layout = GlTimeline.LAYOUT_GRAPHS;

      UserSettings.userSettings.set("gltl_layout", this.#layout);

      this.updateIcons();
      this.init();
    }

    updateIcons() {
      ele.byId("togglegraph1").parentElement.classList.remove("button-active");
      ele.byId("togglegraph2").parentElement.classList.remove("button-active");
      ele.byId("zoomgraph1").parentElement.classList.remove("button-inactive");
      ele.byId("zoomgraph2").parentElement.classList.remove("button-inactive");

      if (this.#layout == GlTimeline.LAYOUT_GRAPHS) {
        ele.byId("togglegraph1").parentElement.classList.add("button-active");
      } else {
        ele.byId("togglegraph2").parentElement.classList.add("button-active");
        ele.byId("zoomgraph1").parentElement.classList.add("button-inactive");
        ele.byId("zoomgraph2").parentElement.classList.add("button-inactive");
      }
    }

    setanim() {}

    getColorSpecial() {
      return [0.02745098039215691, 0.968627450980392, 0.5490196078431373, 1];
    }

    /**
     * @param {GlRect|GlText|GlSpline} rect
     */
    setColorRectSpecial(rect) {
      if (rect) rect.setColorArray(this.getColorSpecial());
    }

    /**
     * @param {PointerEvent} e
     */
    _onCanvasMouseDown(e) {
      if (!e.pointerType) return;
      this.#focusRuler = false;
      this.#focusScroll = false;
      if (this.ruler.isHovering()) this.#focusRuler = true;
      if (this.scroll.isHovering()) this.#focusScroll = true;

      if (this.#focusRuler) {
        this.ruler.setTimeFromPixel(e.offsetX);
      } else if (this.#focusScroll) ; else {
        if (!this.selectRect && e.buttons == 1)
          if (this.hoverKeyRect == null && !e.shiftKey)
            if (e.offsetY > this.getFirstLinePosy()) this.unSelectAllKeys();

        try {
          this.#cgl.canvas.setPointerCapture(e.pointerId);
        } catch (er) {
          this._log.log(er);
        }

        this.#rects.mouseDown(e, e.offsetX, e.offsetY);
      }

      this.mouseDown = true;
    }

    /**
     * @param {MouseEvent} event
     */
    _onCanvasMouseMove(event) {
      this.emitEvent("mousemove", event);

      let x = event.offsetX;
      let y = event.offsetY;
      this.#rects.mouseMove(x, y, event.buttons, event);

      if (event.buttons == 1) {
        if (event.ctrlKey || event.metaKey) {
          for (let i = 0; i < this.#tlAnims.length; i++) {
            if (this.#tlAnims[i].isHovering()) {
              const t = this.snapTime(
                this.view.pixelToTime(x) + this.view.timeLeft,
              );
              this.#tlAnims[i].anims[0].setValue(
                t,
                this.#tlAnims[i].anims[0].getValue(t),
              );
            }
          }
        }

        if (!this.#focusRuler && !this.#focusScroll) {
          if (this.hoverKeyRect && !this.selectRect) ; else {
            if (y > this.getFirstLinePosy()) {
              if (!event.shiftKey) this.unSelectAllKeys();

              this.selectRect = {
                x: Math.min(this.#lastXnoButton, x),
                y: Math.min(this.#lastYnoButton, y),
                x2: Math.max(this.#lastXnoButton, x),
                y2: Math.max(this.#lastYnoButton, y),
              };

              this.#rectSelect.setPosition(
                this.#lastXnoButton,
                this.#lastYnoButton,
                -1,
              );
              this.#rectSelect.setSize(
                x - this.#lastXnoButton,
                y - this.#lastYnoButton,
              );
            }
          }

          this.updateAllElements();

          this.showKeyParamsSoon();
        }
      } else if (event.buttons == this.buttonForScrolling) {
        this.view.scroll(-this.view.pixelToTime(event.movementX) * 4);
        this.view.scrollY(event.movementY);
        this.updateAllElements();
      } else {
        this.#lastXnoButton = x;
        this.#lastYnoButton = y;
      }
    }

    /**
     * @param {AnimKey} k
     * @returns {boolean}
     */
    isKeySelected(k) {
      return this.#selectedKeys.indexOf(k) != -1;
    }

    /**
     * @param {Array<AnimKey>} keys
     * @returns {Number}
     */
    getKeysSmallestTime(keys) {
      let minTime = 9999999;
      for (let i = 0; i < keys.length; i++)
        minTime = Math.min(minTime, keys[i].time);

      return minTime;
    }

    getNumSelectedKeys() {
      return this.#selectedKeys.length;
    }

    /**
     * @param {Number} time
     */
    moveSelectedKeys(time = this.cursorTime) {
      let minTime = time - this.getKeysSmallestTime(this.#selectedKeys);
      this.moveSelectedKeysDelta(minTime);
      this.needsUpdateAll = true;
    }

    /**
     * @param {Number} easing
     */
    setSelectedKeysEasing(easing) {
      for (let i = 0; i < this.#selectedKeys.length; i++)
        this.#selectedKeys[i].set({ e: easing });

      this.needsUpdateAll = true;
    }

    /**
     * @param {Number} time
     */
    setSelectedKeysTime(time = this.cursorTime) {
      for (let i = 0; i < this.#selectedKeys.length; i++)
        this.#selectedKeys[i].set({ time: time });

      this.needsUpdateAll = true;
    }

    /**
     * @param {boolean} [newId]
     */
    serializeSelectedKeys(newId) {
      const keys = [];
      for (let i = 0; i < this.#selectedKeys.length; i++) {
        const o = this.#selectedKeys[i].getSerialized();
        o.id = this.#selectedKeys[i].id;
        o.animName = this.#selectedKeyAnims[i].name;
        o.animId = this.#selectedKeyAnims[i].id;

        if (newId) o.id = CABLES.shortId();
        keys.push(o);
      }

      return keys;
    }

    /**
     * @param {number} deltaTime
     * @param {number} deltaValue
     */
    moveSelectedKeysDelta(deltaTime, deltaValue = 0) {
      if (deltaTime == 0 && deltaValue == 0) return;
      for (let i = 0; i < this.#selectedKeys.length; i++) {
        this.#selectedKeys[i].set({
          time: this.#selectedKeys[i].time + deltaTime,
          value: this.#selectedKeys[i].value + deltaValue,
        });
      }

      this.needsUpdateAll = true;
    }

    getSelectedKeysBoundsValue() {
      let min = 999999;
      let max = -999999;
      for (let i = 0; i < this.#selectedKeys.length; i++) {
        min = Math.min(min, this.#selectedKeys[i].value);
        max = Math.max(max, this.#selectedKeys[i].value);
      }
      return { min: min, max: max };
    }

    getSelectedKeysBoundsTime() {
      let min = 999999;
      let max = -999999;
      for (let i = 0; i < this.#selectedKeys.length; i++) {
        min = Math.min(min, this.#selectedKeys[i].time);
        max = Math.max(max, this.#selectedKeys[i].time);
      }
      return { min: min, max: max, length: Math.abs(max) - Math.abs(min) };
    }

    showKeyParamsSoon() {
      clearTimeout(this.toParamKeys);
      this.toParamKeys = setTimeout(() => {
        this.showKeyParams();
      }, 100);
    }

    unSelectAllKeys() {
      this.#selectedKeys = [];
      this.#selectedKeyAnims = [];
      this.showKeyParamsSoon();
    }

    selectAllKeys() {
      if (this.disposed) return;
      for (let i = 0; i < this.#tlAnims.length; i++) {
        for (let j = 0; j < this.#tlAnims[i].anims.length; j++) {
          for (let k = 0; k < this.#tlAnims[i].anims[j].keys.length; k++) {
            this.selectKey(
              this.#tlAnims[i].anims[j].keys[k],
              this.#tlAnims[i].anims[j],
            );
          }
        }
      }
      this.needsUpdateAll = true;
    }

    deleteSelectedKeys() {
      if (this.disposed) return;
      const oldKeys = this.serializeSelectedKeys();
      const gltl = this;
      undo.add({
        title: "timeline move keys",
        undo() {
          gltl.deserializeKeys(oldKeys);
        },
        redo() {},
      });

      for (let i = 0; i < this.#selectedKeys.length; i++)
        this.#selectedKeyAnims[i].remove(this.#selectedKeys[i]);

      this.unSelectAllKeys();
    }

    /**
     * @param {AnimKey} k
     * @param {Anim} a
     *
     */
    selectKey(k, a) {
      if (a.tlActive && !this.isKeySelected(k)) {
        this.#selectedKeys.push(k);
        this.#selectedKeyAnims.push(a);
      }
      this.showKeyParamsSoon();
    }

    /**
     * @param {MouseEvent} e
     */
    _onCanvasMouseUp(e) {
      this.#rects.mouseUp(e);
      this.mouseDown = false;
      this.hoverKeyRect = null;
      this.selectRect = null;
      this.#rectSelect.setSize(0, 0);
    }

    /**
     * @param {WheelEvent} event
     */
    _onCanvasWheel(event) {
      this.pixelPerSecond = this.view.timeToPixel(1);

      if (event.metaKey) {
        this.view.scroll(this.view.visibleTime * event.deltaY * 0.0005);
      } else if (event.shiftKey) {
        this.view.scale(event.deltaX * 0.003);
      } else if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
        let delta = 0;
        if (event.deltaY < 0) delta = 1.1;
        else delta = 0.9;

        this.view.setZoomOffset(delta);
      }

      this.needsUpdateAll = true;
    }

    get width() {
      return this.#cgl.canvasWidth;
    }

    init() {
      if (this.disposed) return;
      const perf = Gui$1.gui.uiProfiler.start("[gltimeline] init");

      this.splines = new GlSplineDrawer(this.#cgl, "gltlSplines_0");
      this.splines.setWidth(2);
      this.splines.setFadeout(false);

      for (let i = 0; i < this.#tlAnims.length; i++) this.#tlAnims[i].dispose();
      this.#tlAnims = [];

      let ops = [];
      const ports = [];

      Gui$1.gui.patchView.getSelectedOps();
      if (this.#layout == GlTimeline.LAYOUT_LINES) ops = Gui$1.gui.corePatch().ops;

      // if (this.#layout == GlTimeline.LAYOUT_GRAPHS && selops.length > 0) ops = selops;
      // if (this.#layout == GlTimeline.LAYOUT_GRAPHS && this.#firstInit)ops = i
      ops = Gui$1.gui.corePatch().ops;

      this.#firstInit = false;

      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        for (let j = 0; j < op.portsIn.length; j++) {
          if (op.portsIn[j].anim) {
            if (this.filter(op.portsIn[j])) {
              ports.push(op.portsIn[j]);

              if (this.#layout === GlTimeline.LAYOUT_LINES) {
                const a = new glTlAnimLine(this, [op.portsIn[j]]);
                this.#tlAnims.push(a);
              }
            }
          }
        }
      }

      if (this.#layout === GlTimeline.LAYOUT_GRAPHS) {
        const multiAnim = new glTlAnimLine(this, ports, {
          keyYpos: true,
          multiAnims: true,
        });
        multiAnim.setHeight(this.#cgl.canvasHeight - this.getFirstLinePosy());
        multiAnim.setPosition(0, this.getFirstLinePosy());
        this.#tlAnims.push(multiAnim);
      }

      this.updateAllElements();
      this.setPositions();
      this.resize();
      this.updateIcons();

      perf.finish();
    }

    /**
     * @param {Port} port
     */
    filter(port) {
      if (
        port.op.shortName.toLowerCase().includes(this.#filterString) ||
        (port.op.uiAttribs.comment || "")
          .toLowerCase()
          .includes(this.#filterString) ||
        port.name.toLowerCase().includes(this.#filterString)
      )
        return true;

      return false;
    }

    getFirstLinePosy() {
      let posy = 0;

      this.scroll.setPosition(0, posy);
      posy += this.scroll.height;

      this.ruler.setPosition(0, posy);
      posy += this.ruler.height;
      return posy;
    }

    setPositions() {
      if (this.disposed) return;
      let posy = this.getFirstLinePosy();

      for (let i = 0; i < this.#tlAnims.length; i++) {
        this.#tlAnims[i].setPosition(0, posy);
        posy += this.#tlAnims[i].height;
      }
    }

    dispose() {
      if (this.disposed) return;
      this.disposed = true;

      if (this.#rects) this.#rects = this.#rects.dispose();
    }

    updateSize() {
      if (this.disposed) return;
      this.setPositions();
      // this.updateAllElements();
      this.needsUpdateAll = true;
    }

    /**
     * @param {number} resX
     * @param {number} resY
     */
    render(resX, resY) {
      this.#perfFps.startFrame();

      if (!Gui$1.gui.bottomTabPanel.isMinimized()) {
        if (this.disposed) return;
        this.view.updateAnims();

        if (!this.view.animsFinished || this.needsUpdateAll)
          this.updateAllElements();

        this.udpateCursor();
        this.#cgl.gl.clearColor(0.2, 0.2, 0.2, 1);
        this.#cgl.gl.clear(
          this.#cgl.gl.COLOR_BUFFER_BIT | this.#cgl.gl.DEPTH_BUFFER_BIT,
        );

        this.#cgl.pushDepthTest(true);

        this.#rects.render(resX, resY, -1, 1, resX / 2);
        this.texts.render(resX, resY, -1, 1, resX / 2);
        this.splines.render(
          resX,
          resY,
          -1,
          1,
          resX / 2,
          this.#lastXnoButton,
          this.#lastYnoButton,
        );
        this.#rectsOver.render(resX, resY, -1, 1, resX / 2);

        this.#cgl.popDepthTest();
      }
      this.#perfFps.endFrame();
    }

    udpateCursor() {
      this.#glRectCursor.setPosition(
        this.view.timeToPixelScreen(this.cursorTime),
        0,
      );

      let s = "" + Math.round(this.cursorTime * 1000) / 1000;
      const parts = s.split(".");
      parts[1] = parts[1] || "000";
      while (parts[1].length < 3) parts[1] += "0";

      let html = "";
      html += "frame " + Math.floor(this.cursorTime * this.fps) + " ";
      html += "second " + parts[0] + "." + parts[1] + "<br>";

      if (this.cfg.showBeats)
        html += "beat " + Math.floor(this.cursorTime * (this.bpm / 60)) + "<br>";

      if (this.#oldhtml != html) {
        this.#tlTimeDisplay.innerHTML = html;
        this.#oldhtml = html;
      }
    }

    updateAllElements() {
      const perf = Gui$1.gui.uiProfiler.start("[gltimeline] udpateAllElements");

      this.ruler.update();
      this.scroll.update();
      for (let i = 0; i < this.#tlAnims.length; i++) this.#tlAnims[i].update();
      this.#glRectCursor.setSize(1, this.#cgl.canvasHeight);
      this.udpateCursor();

      if (this.#layout === GlTimeline.LAYOUT_GRAPHS && this.#tlAnims[0])
        this.#tlAnims[0].setHeight(
          this.#cgl.canvasHeight - this.getFirstLinePosy(),
        );

      perf.finish();
    }

    /** @param {TlConfig} cfg */
    onConfig(cfg) {
      this.cfg = cfg;
      this.duration = cfg.duration;
      this.displayUnits = cfg.displayUnits;
      this.updateAllElements();
    }

    /**
     * @param {number} dir 1 or -1
     */
    jumpKey(dir) {
      let theKey = null;

      for (let anii = 0; anii < this.#tlAnims.length; anii++) {
        for (let ans = 0; ans < this.#tlAnims[anii].anims.length; ans++) {
          const anim = this.#tlAnims[anii].anims[ans];

          for (let ik = 0; ik < anim.keys.length; ik++) {
            if (ik < 0) continue;
            let newIndex = ik;

            if (anim.keys[newIndex].time != this.view.cursorTime) {
              if (dir == 1 && anim.keys[newIndex].time > this.view.cursorTime) {
                if (!theKey) theKey = anim.keys[newIndex];
                if (anim.keys[newIndex].time < theKey.time)
                  theKey = anim.keys[newIndex];
              }

              if (dir == -1 && anim.keys[newIndex].time < this.view.cursorTime) {
                if (!theKey) theKey = anim.keys[newIndex];
                if (anim.keys[newIndex].time > theKey.time)
                  theKey = anim.keys[newIndex];
              }
            }
          }
        }
      }

      if (theKey) {
        Gui$1.gui.corePatch().timer.setTime(theKey.time);
        if (theKey.time > this.view.timeRight || theKey.time < this.view.timeLeft)
          this.view.centerCursor();
      }
    }

    zoomToFitSelection() {
      const bounds = this.getSelectedKeysBoundsTime();
      console.log(bounds);
      this.view.setZoomLength(bounds.length + 1);
      this.view.scrollTo(bounds.min - 0.5);
      this.view.scrollToY(0);
      for (let anii = 0; anii < this.#tlAnims.length; anii++)
        this.#tlAnims[anii].fitValues();
    }

    showKeyParams() {
      const timebounds = this.getSelectedKeysBoundsTime();
      const valbounds = this.getSelectedKeysBoundsValue();
      let timestr = " (" + Math.round(timebounds.length * 100) / 100 + "s)";
      let valstr =
        " (" +
        Math.round(valbounds.min * 100) / 100 +
        " - " +
        Math.round(valbounds.max * 100) / 100 +
        ")";

      if (this.#selectedKeys.length == 0) {
        this.#keyOverEl.classList.add("hidden");
        ele.byId("tlselectinfo").innerHTML = "";
      } else {
        this.#keyOverEl.classList.remove("hidden");
        ele.byId("tlselectinfo").innerHTML =
          "" +
          this.#selectedKeys.length +
          " keys selected " +
          timestr +
          " " +
          valstr;
      }

      const html = getHandleBarHtml("params_keys", {
        numKeys: this.#selectedKeys.length,
        timeBounds: timebounds,
        valueBounds: valbounds,
      });
      this.#keyOverEl.innerHTML = html;
    }

    /**
     * @param {ClipboardEvent} event
     */
    copy(event = null) {
      const obj = { keys: this.serializeSelectedKeys(true) };

      if (event) {
        const objStr = JSON.stringify(obj);
        event.clipboardData.setData("text/plain", objStr);
        event.preventDefault();
      }
      return obj;
    }

    /**
     * @param {ClipboardEvent} event
     */
    cut(event) {
      this.copy(event);
      this.deleteSelectedKeys();
    }

    /**
     * @param {Array<Object>} keys
     * @param {Object} options
     */
    deserializeKeys(keys, options = {}) {
      options.useId || false;
      const setCursorTime = options.setCursorTime || false;

      let minTime = Number.MAX_VALUE;
      for (let i in keys) {
        minTime = Math.min(minTime, keys[i].t);
      }

      let notfoundallAnims = false;
      let newKeys = [];

      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        if (setCursorTime) k.t = k.t - minTime + this.cursorTime;

        let found = false;
        for (let j = 0; j < this.#tlAnims.length; j++) {
          let an = null;
          if (k.animId) an = this.#tlAnims[j].getAnimById(k.animId);

          if (an) {
            const l = new CABLES.AnimKey(keys[i], an);

            newKeys.push(l);
            an.addKey(l);
            found = true;
          }
        }

        if (!found) notfoundallAnims = true;
      }
      return { keys: newKeys, notfoundallAnims: notfoundallAnims };
    }

    /**
     * @param {ClipboardEvent} e
     */
    paste(e) {
      if (e.clipboardData.types.indexOf("text/plain") > -1) {
        e.preventDefault();

        const str = e.clipboardData.getData("text/plain");

        e.preventDefault();

        const json = JSON.parse(str);
        if (json) {
          if (json.keys) {
            const deser = this.deserializeKeys(json.keys, {
              setCursorTime: true,
            });
            const notfoundallAnims = deser.notfoundallAnims;

            if (notfoundallAnims) {
              notifyWarn("could not find all anims for pasted keys");
            } else {
              notify(json.keys.length + " keys pasted");
            }

            const animPorts = Gui$1.gui.corePatch().getAllAnimPorts();
            for (let i = 0; i < animPorts.length; i++) {
              if (animPorts[i].anim) animPorts[i].anim.removeDuplicates();
            }

            console.log(json.keys);
            this.needsUpdateAll = true;

            return;
          }
        }
        CABLES.UI.notify("Paste failed");
      }
    }

    /** @returns {boolean} */
    isFocused() {
      // todo
      return true;
    }

    duplicateSelectedKeys() {
      const o = this.copy();

      const newKeys = this.deserializeKeys(o.keys, false).keys;

      undo.add({
        title: "timeline duplicate keys",
        undo() {
          for (let i = 0; i < newKeys.length; i++) {
            console.log("delete...dupes");
            newKeys[i].delete();
          }
          // key.set(oldValues);
        },
        redo() {},
      });
    }

    getDebug() {
      const o = {
        layout: this.#layout,
        tlAnims: [],
        view: this.view.getDebug(),
        perf: this.#perfFps.stats,
      };

      for (let anii = 0; anii < this.#tlAnims.length; anii++)
        o.tlAnims.push(this.#tlAnims[anii].getDebug());

      return o;
    }

    createKeyAtCursor() {
      for (let i = 0; i < this.#tlAnims.length; i++) {
        const t = this.cursorTime;
        this.#tlAnims[i].anims[0].setValue(
          t,
          this.#tlAnims[i].anims[0].getValue(t),
        );
      }
    }

    toggle() {
      Gui$1.gui.bottomTabPanel.toggle(true);
    }

    deactivateAllAnims(v = false) {
      for (let anii = 0; anii < this.#tlAnims.length; anii++) {
        for (let ans = 0; ans < this.#tlAnims[anii].anims.length; ans++) {
          const anim = this.#tlAnims[anii].anims[ans];
          anim.tlActive = v;
        }
        this.#tlAnims[anii].updateTitles();
      }
    }
  }

  /**
   * canvas for the timeline {@link GlTimeline}
   *
   * @export
   * @class glTimelineCanvas
   * @extends {GlCanvas}
   */
  class glTimelineCanvas extends GlCanvas {
    /**
     * @param {Patch} _patch
     * @param {HTMLElement} parentEle
     */
    constructor(_patch, parentEle, tab) {
      super(_patch, parentEle);

      this.tab = tab;
      this.setSize(100, 100);
      this.activityHigh();
      this.patch.addEventListener("onRenderFrame", this.render.bind(this));

      this.glTimeline = new GlTimeline(this.cgl, parentEle);
    }

    render() {
      if (this.tab.resizing) return;
      if (gui && Gui$1.gui.corePatch().timer.isPlaying()) this._targetFps = 0; // todo check if time is on screen...?

      if (
        this._targetFps != 0 &&
        performance.now() - this._lastTime < 1000 / this._targetFps
      )
        return;

      const cgl = this.cgl;

      if (CGL.MESH.lastMesh) CGL.MESH.lastMesh.unBind();

      if (this._oldTargetFps != this._targetFps)
        this._oldTargetFps = this._targetFps;

      cgl.renderStart(cgl);

      if (!this._inited) {
        for (let i = 0; i <= 8; i++)
          this.cgl.setTexture(i, CGL.Texture.getEmptyTexture(this.cgl).tex);
        this._inited = true;
      }

      if (this._firstTime) this._firstTime = false;

      this.glTimeline.render(this.width, this.height);

      if (this.glTimeline.isAnimated) this.activityHigh();

      cgl.renderEnd(cgl);
      this._lastTime = performance.now();
    }
  }

  class GlTimelineTab {
    /** @type {Tab} */
    #tab;
    #splitter;

    /** @type {glTimelineCanvas} */
    tlCanvas = null;

    /** @type {number} */
    #splitterPos = 100;

    resizing = false;

    /**
     * @param {TabPanel} tabs
     */
    constructor(tabs) {
      this.#tab = new Tab("gl timeline", {
        icon: "timeline",
        infotext: "gl timeline",
        closable: false,
      });
      Gui$1.gui.bottomTabPanel.show(true);

      tabs.addTab(this.#tab, true);
      this.#tab.activate();
      this.#tab.contentEle.innerHTML = "";

      this.#splitterPos =
        UserSettings.userSettings.get("timeline_titles_width") || 100;

      tabs.on("resize", () => {
        this.updateSize();
      });

      this.#tab.on("resize", () => {
        this.updateSize();
      });

      this.#tab.on("onDeactivate", () => {
        if (this.tlCanvas) this.tlCanvas.pause();
      });

      this.#tab.on("close", () => {
        UserSettings.userSettings.set("glTimelineOpened", false);
      });

      this.#tab.on("onActivate", () => {
        if (this.tlCanvas) this.tlCanvas.resume();
        this.updateSize();
      });
      this.#tab.addButtonSpacer();

      this.#tab.addButton(
        '<span class="nomargin icon icon-chevrons-left-right info" data-info="tlzoomtime"></span>',
        () => {
          this.tlCanvas.glTimeline.view.setZoomOffset(1.4, 0.5);
        },
        ["button-left"],
      );
      this.#tab.addButton(
        '<span class="nomargin icon icon-chevrons-right-left left-right info" data-info="tlzoomtime"></span>',
        () => {
          this.tlCanvas.glTimeline.view.setZoomOffset(0.6, 0.5);
        },
        ["button-right"],
      );

      this.#tab.addButtonSpacer();

      this.#tab.addButton(
        '<span id="zoomgraph1" class="nomargin icon icon-chevrons-up-down info" data-info="tlzoomgraph"></span>',
        () => {
          this.tlCanvas.glTimeline.view.scale(-0.3);
        },
        ["button-left"],
      );

      this.#tab.addButton(
        '<span id="zoomgraph2" class="nomargin icon icon-chevrons-down-up info" data-info="tlzoomgraph"></span>',
        () => {
          this.tlCanvas.glTimeline.view.scale(0.3);
        },
        ["button-right"],
      );

      this.#tab.addButtonSpacer();

      this.#tab.addButton(
        '<span class="nomargin icon icon-skip-back"></span>',
        () => {
          CABLES.CMD.TIMELINE.TimelineRewindStart();
        },
      );

      this.#tab.addButton(
        '<span class="nomargin icon icon-fast-forward" style="transform:rotate(180deg)"></span>',
        () => {
          CABLES.CMD.TIMELINE.TimelineRewind();
        },
      );

      this.#tab.addButton(
        '<span class="nomargin icon icon-keyframe_previous info" data-info="tlnextkey">"></span>',
        () => {
          this.tlCanvas.glTimeline.jumpKey(-1);
        },
      );
      const buttonPlay = this.#tab.addButton(
        '<span class="nomargin icon icon-play info" data-info="tlplay"></span>',
        () => {
          Gui$1.gui.corePatch().timer.togglePlay();

          if (Gui$1.gui.corePatch().timer.isPlaying())
            buttonPlay.innerHTML =
              '<span class="nomargin icon icon-pause"></span>';
          else
            buttonPlay.innerHTML =
              '<span class="nomargin icon icon-play"></span>';
        },
      );
      this.#tab.addButton(
        '<span class="nomargin icon icon-keyframe_next info" data-info="tlnextkey"></span>',
        () => {
          this.tlCanvas.glTimeline.jumpKey(1);
        },
      );

      this.#tab.addButton(
        '<span class="nomargin icon icon-fast-forward"></span>',
        () => {
          CABLES.CMD.TIMELINE.TimelineForward();
        },
      );

      this.#tab.addButtonSpacer();

      // this.#tab.addButton("<span class=\"nomargin icon icon-arrow-left\"></span>", () => { this.tlCanvas.glTimeline.view.scroll(-1); });
      // this.#tab.addButton("<span class=\"nomargin icon icon-arrow-right\"></span>", () => { this.tlCanvas.glTimeline.view.scroll(1); });

      // this.#tab.addButtonSpacer();
      this.#tab.addButtonSpacer();

      this.#tab.addButton(
        '<span class="nomargin icon icon-diamond-plus"></span>',
        () => {
          CABLES.CMD.TIMELINE.TimelineCreateKey();
        },
      );
      this.#tab.addButtonSpacer();

      this.#tab.addButton(
        '<span id="togglegraph1" class="nomargin icon info icon-chart-spline" data-info="tltogglegraph"></span>',
        () => {
          this.tlCanvas.glTimeline.toggleGraphLayout();
        },
        ["button-left", "button-active"],
      );
      this.#tab.addButton(
        '<span id="togglegraph2"  class="nomargin icon info icon-chart-gantt" data-info="tltogglegraph"></span>',
        () => {
          this.tlCanvas.glTimeline.toggleGraphLayout();
        },
        ["button-right"],
      );

      this.#tab.addButtonSpacer();
      this.#tab.addButton(
        '<span class="nomargin icon icon-three-dots"></span>',
        (e) => {
          contextMenu.show(
            {
              items: [
                {
                  title: "Delete Selected Keys",
                  func: () => {
                    this.tlCanvas.glTimeline.deleteSelectedKeys();
                  },
                },
                {
                  title: "Move Selected Keys to cursor",
                  func: () => {
                    this.tlCanvas.glTimeline.moveSelectedKeys();
                  },
                },
                {
                  title: "Set same time for selected keys",
                  func: () => {
                    this.tlCanvas.glTimeline.setSelectedKeysTime();
                  },
                },

                {
                  title: "fit into view",
                  func: () => {
                    this.tlCanvas.glTimeline.zoomToFitSelection();
                  },
                },
              ],
            },
            e.target,
          );
        },
      );

      this.#tab.addButtonSpacer();

      this.selectInfoEl = document.createElement("span");
      this.selectInfoEl.innerHTML = "";
      this.selectInfoEl.id = "tlselectinfo";
      this.#tab.addButtonBarElement(this.selectInfoEl);

      this.#tab.addButton(
        '<span class="nomargin icon icon-chevron-down info" data-info="tltoggle"></span>',
        () => {
          Gui$1.gui.bottomTabPanel.toggle();
        },
        ["timelineminimize"],
      );

      /// //////

      this.tlCanvas = new glTimelineCanvas(
        Gui$1.gui.corePatch(),
        this.#tab.contentEle,
        this,
      );

      UserSettings.userSettings.set("glTimelineOpened", true);

      Gui$1.gui.on(Gui$1.gui.EVENT_RESIZE, () => {
        this.updateSize();
      });

      Gui$1.gui.on(Gui$1.gui.EVENT_RESIZE_CANVAS, () => {
        this.updateSize();
      });

      this.#splitter = document.createElement("div");
      this.#splitter.classList.add("splitter");
      this.#splitter.classList.add("splitterTimeline");
      this.#splitter.style.left = this.#splitterPos + "px";
      this.#splitter.addEventListener(
        "pointerdown",
        this.resizeRenderer.bind(this),
        { passive: false },
      );
      this.#tab.contentEle.appendChild(this.#splitter);
      this.updateSize();
    }

    close() {
      this.#tab.remove();
      Gui$1.gui.glTimeline.dispose();
      Gui$1.gui.glTimeline = null;
      if (this.tlCanvas) this.tlCanvas.dispose();
      this.tlCanvas = null;
    }

    updateSize() {
      if (this.resizing) {
        console.log("rezising...");
        return;
      }
      if (!this.tlCanvas) {
        console.log("no tlcanv");
        return;
      }

      const parentEle = this.#tab.contentEle;
      if (parentEle.clientWidth == 0) {
        if (this.tlCanvas.disposed) return;
        setTimeout(this.updateSize.bind(this), 100);
        return;
      }
      this.resizing = true;
      this.tlCanvas.glTimeline.resize();
      this.tlCanvas.canvas.style.left = this.#splitterPos + "px";
      this.tlCanvas.setSize(
        parentEle.clientWidth - this.#splitterPos,
        parentEle.clientHeight,
      );
      this.resizing = false;

      UserSettings.userSettings.set("timeline_titles_width", this.#splitterPos);
    }

    resizeRenderer(ev) {
      ev.preventDefault();
      window.splitpane.bound = true;
      const mm = (e) => {
        Gui$1.gui.pauseInteractionSplitpanes();
        let x = e.clientX;
        if (x === undefined && e.touches && e.touches.length > 0)
          x = e.touches[0].clientX;
        if (x < 10) x = 10;

        this.#splitter.style.left = x + "px";
        this.#splitterPos = Math.round(x);
        this.updateSize();
        e.preventDefault();
      };
      const f = mm.bind(this);

      document.addEventListener("pointermove", f);
      window.splitpane.listeners.push(f);
    }
  }

  function bytesArrToBase64(arr) {
    const abc =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // base64 alphabet
    const bin = (n) => {
      return n.toString(2).padStart(8, 0);
    }; // convert num to 8-bit binary string
    const l = arr.length;
    let result = "";

    for (let i = 0; i <= (l - 1) / 3; i++) {
      let c1 = i * 3 + 1 >= l; // case when "=" is on end
      let c2 = i * 3 + 2 >= l; // case when "=" is on end
      let chunk =
        bin(arr[3 * i]) +
        bin(c1 ? 0 : arr[3 * i + 1]) +
        bin(c2 ? 0 : arr[3 * i + 2]);
      let r = chunk.match(/.{1,6}/g).map((x, j) => {
        return j == 3 && c2 ? "=" : j == 2 && c1 ? "=" : abc[+("0b" + x)];
      });
      result += r.join("");
    }

    return result;
  }

  class PatchSaveServer extends Events {
    constructor() {
      super();
      this._currentProject = null;
      this._log = new Logger("patchsaveserver");
      this._serverDate = 0;
      this._lastErrorReport = null;

      this.isSaving = false;
    }

    setProject(proj) {
      Gui$1.gui.setProjectName(proj.name);
      this._currentProject = proj;
    }

    setServerDate(d) {
      this._serverDate = d;
    }

    getServerDate() {
      return this._serverDate;
    }

    checkUpdatedSaveForce(updated) {
      this.setServerDate(updated);
      Gui$1.gui.closeModal();
      CABLES.CMD.PATCH.save(true, () => {
        if (platform.getPatchVersion()) {
          platform.talkerAPI.send("reload", {
            patchId: Gui$1.gui.project().shortId,
          });
        }
      });
    }

    checkUpdated(cb = null, fromSave = false, forceRequest = false) {
      if (!Gui$1.gui.project()) return;
      if (platform.isOffline() && !forceRequest) {
        if (cb) cb();
        return;
      }

      Gui$1.gui.jobs().start({
        id: "checkupdated",
        title: "check patch was updated",
        indicator: "canvas",
      });

      platform.talkerAPI.send("checkProjectUpdated", {}, (err, data) => {
        if (err) {
          this._log.log("error", err);
          Gui$1.gui.jobs().finish("checkupdated");

          /* ignore errors, unless project got deleted */
          if (cb && err.code === 404) cb(err);
          return;
        }

        platform.setOnline();
        if (Gui$1.gui.isRemoteClient) {
          Gui$1.gui.jobs().finish("checkupdated");
          if (cb) cb(null);
          return;
        }

        if (fromSave && data.maintenance && data.disallowSave) {
          const html =
            "Cables is currently in maintenance mode, saving of patches is disallowed.<br/><br/>Leave the browser-window open, and wait until we are finished with the update.<br/><br/>" +
            '<a class="button" onclick="Gui.gui.closeModal();">Close</a>&nbsp;&nbsp;';
          new ModalDialog({
            title: "Maintenance Mode",
            html: html,
            warning: true,
          });

          Gui$1.gui.jobs().finish("checkupdated");
        } else if (data.updated && this._serverDate !== data.updated) {
          const serverDate = moment(data.updated);
          const localDate = moment(Gui$1.gui.patchView.store.getServerDate());
          if (serverDate.isAfter(localDate)) {
            if (fromSave) {
              let html =
                "This patch was changed. Your version is out of date. <br/><br/>Last update: " +
                moment(data.updated).fromNow() +
                " by " +
                (data.updatedByUser || "unknown") +
                "<br/><br/>";
              html +=
                '<a class="button" onclick="Gui.gui.closeModal();">Close</a>&nbsp;&nbsp;';
              html +=
                '<a class="button" onclick="Gui.gui.patchView.store.checkUpdatedSaveForce(\'' +
                data.updated +
                '\');"><span class="icon icon-save"></span>Save anyway</a>&nbsp;&nbsp;';
              html +=
                '<a class="button" onclick="CABLES.CMD.PATCH.reload();"><span class="icon icon-refresh"></span>Reload patch</a>&nbsp;&nbsp;';

              new ModalDialog({
                title: "Meanwhile...",
                html: html,
              });
            } else if (!Gui$1.gui.restriction.visible) {
              Gui$1.gui.restriction.setMessage(
                "cablesupdate",
                "This patch was changed by " +
                  (data.updatedByUser || "unknown") +
                  ", " +
                  moment(data.updated).fromNow() +
                  '&nbsp;&nbsp;&nbsp; <a class="button" onclick="CABLES.CMD.PATCH.reload();"><span class="icon icon-refresh"></span>reload </a>to get the latest update!',
              );
            }
          }
          if (cb) cb(null);
          Gui$1.gui.jobs().finish("checkupdated");
        } else {
          if (data.platform && data.platform.buildInfo) {
            let newCore = false;
            let newUi = false;
            const buildInfo = data.platform.buildInfo;
            if (buildInfo.updateWarning) {
              if (CABLESUILOADER.buildInfo.core)
                newCore =
                  buildInfo.core.timestamp >
                  CABLESUILOADER.buildInfo.core.timestamp;
              if (CABLESUILOADER.buildInfo.ui)
                newUi =
                  buildInfo.ui.timestamp > CABLESUILOADER.buildInfo.ui.timestamp;
            }

            if (!Gui$1.gui.restriction.visible && (newCore || newUi)) {
              Gui$1.gui.restriction.setMessage(
                "cablesupdate",
                'cables.gl has been updated! &nbsp;&nbsp;&nbsp; <a class="button" onclick="CABLES.CMD.PATCH.reload();"><span class="icon icon-refresh"></span>reload </a>to get the latest update!',
              );
              Gui$1.gui.jobs().finish("checkupdated");
            } else {
              Gui$1.gui.jobs().finish("checkupdated");
            }
            if (cb) cb(null);
          } else {
            Gui$1.gui.jobs().finish("checkupdated");
            if (cb) cb(null);
          }
        }
      });
    }

    saveAs() {
      if (Gui$1.gui.showGuestWarning()) return;

      platform.talkerAPI.send("getPatch", {}, (_err, project) => {
        if (_err) {
          let msg = _err || "no response";
          if (_err && _err.msg) msg = _err.msg;
          this._log.warn("[save patch error] ", msg);
          const modalOptions = {
            warning: true,
            title: "Could not clone patch",
            text: msg,
          };
          new ModalDialog(modalOptions);
          return;
        }

        let hasPrivateUserOps = false;
        if (
          !project.userList.some((u) => {
            return u.usernameLowercase === Gui$1.gui.user.usernameLowercase;
          })
        ) {
          hasPrivateUserOps = project.ops.find((op) => {
            return (
              op.objName &&
              op.objName.startsWith("Ops.User") &&
              !op.objName.startsWith(
                "Ops.User." + Gui$1.gui.user.usernameLowercase + ".",
              )
            );
          });
        }

        const copyCollaborators = project.visibility !== "public"; // don't do this for public patches

        let prompt = "Enter a name for the copy of this patch.";

        const modalNotices = [];

        if (hasPrivateUserOps) {
          modalNotices.push(
            "<b>THIS PATCH HAS PRIVATE OPS.</b><br/>You can continue cloning this patch, but probably some things will not work.",
          );
        }

        const checkboxGroups = [];
        const hasCollaborators =
          project.userList.filter((u) => {
            return u.username !== Gui$1.gui.user.username;
          }).length > 0;

        if (hasCollaborators) {
          const userOpsUsed = Gui$1.gui.patchView.getUserOpsUsedInPatch();
          if (copyCollaborators) {
            const checkboxGroup = {
              title: "Invite the following collaborators to the copy:",
              checkboxes: [],
            };
            project.userList.forEach((user, i) => {
              if (user._id !== Gui$1.gui.user.id) {
                const link = platform.getCablesUrl() + "/user/" + user.username;
                const checkboxData = {
                  name: "copy-collab-user-" + i,
                  value: user._id,
                  title:
                    '<a href="' +
                    link +
                    '" target="blank">' +
                    user.username +
                    "</a>",
                  checked: false,
                };
                if (
                  userOpsUsed.some((userOp) => {
                    return namespace$1.isUserOpOfUser(
                      userOp.objName,
                      user.usernameLowercase,
                    );
                  })
                ) {
                  checkboxData.checked = true;
                  checkboxData.title +=
                    '<br/><span class="warning">Collaborator should not be removed, their userops are used in the patch</span>';
                }
                checkboxGroup.checkboxes.push(checkboxData);
              }
            });
            if (checkboxGroup.checkboxes.length > 0)
              checkboxGroups.push(checkboxGroup);
          } else {
            modalNotices.push(
              "Collaborators will NOT be copied for public patches!",
            );
          }
        }

        {
          if (copyCollaborators) {
            const checkboxGroup = {
              title: "Add teams to the copy:",
              checkboxes: [],
            };
            project.teams.forEach((team, i) => {
              if (team.allowEdit) {
                const link = platform.getCablesUrl() + team.link;
                checkboxGroup.checkboxes.push({
                  name: "copy-collab-team-" + i,
                  value: team._id,
                  title:
                    '<a href="' + link + '" target="blank">' + team.name + "</a>",
                  checked: false,
                  disabled: false,
                });
              }
            });
            if (checkboxGroup.checkboxes.length > 0)
              checkboxGroups.push(checkboxGroup);
          }
        }

        const usedPatchOps = Gui$1.gui.patchView.getPatchOpsUsedInPatch();
        if (usedPatchOps.length > 0) {
          let patchOpsText =
            'Patch ops used in this patch will be copied to the new patch. Create a <a href="' +
            platform.getCablesUrl() +
            '/myteams/" target="_blank">team</a> to share ops between patches and users!';
          modalNotices.push(patchOpsText);
        }

        if (project.userId !== Gui$1.gui.user.id) {
          let licenceText =
            "The author of the patch reserves all copyright on this work. Please respect this decision.";
          if (project.settings && project.settings.licence) {
            let licenceName = project.settings.licence;
            let licenceLink = null;
            if (licenceName.startsWith("cc")) {
              let licenceUrl = licenceName.split("cc-", 2)[1];
              if (licenceName === "cc0") licenceUrl = "cc0";
              licenceLink =
                "https://creativecommons.org/licenses/" + licenceUrl + "/4.0/";
              if (licenceLink)
                licenceName =
                  '<a href="' +
                  licenceLink +
                  '" target="_blank">' +
                  licenceName.toUpperCase() +
                  "</a>";
              licenceText =
                "Patch has a " +
                licenceName +
                " Licence. Please respect the licence chosen by the author.";
            }
          }
          modalNotices.push(licenceText);
        }

        let patchName = Gui$1.gui.project().name;
        if (
          Gui$1.gui.corePatch() &&
          Gui$1.gui.corePatch().name &&
          Gui$1.gui.corePatch().name !== patchName
        )
          patchName = Gui$1.gui.corePatch().name;

        const saveAsModal = new ModalDialog(
          {
            prompt: true,
            title: "Save As...",
            text: prompt,
            notices: modalNotices,
            promptValue: "copy of " + patchName,
            checkboxGroups: checkboxGroups,
            promptOk: (name, checkboxStates) => {
              const collabUsers = [];
              const collabTeams = [];
              let copyAssets = false;

              if (checkboxStates) {
                const keys = Object.keys(checkboxStates);
                keys.forEach((key) => {
                  const value = checkboxStates[key];
                  if (value) {
                    if (key.startsWith("copy-collab-team"))
                      collabTeams.push(value);
                    if (key.startsWith("copy-collab-user"))
                      collabUsers.push(value);
                    if (key === "copy-assets-on-clone") copyAssets = "used";
                    if (key === "copy-all-assets-on-clone") copyAssets = "all";
                  }
                });
              }
              platform.talkerAPI.send(
                "saveProjectAs",
                {
                  name: name,
                  copyCollaborators: copyCollaborators,
                  collabUsers: collabUsers,
                  collabTeams: collabTeams,
                  copyAssets: copyAssets,
                },
                (err, d) => {
                  if (!err) {
                    const newProjectId = d.shortId ? d.shortId : d._id;
                    Gui$1.gui.corePatch().settings =
                      Gui$1.gui.corePatch().settings || {};
                    Gui$1.gui.corePatch().settings.secret = "";

                    if (copyAssets) {
                      platform.talkerAPI.send("gotoPatch", { id: newProjectId });
                    } else {
                      this.saveCurrentProject(
                        () => {
                          platform.talkerAPI.send("gotoPatch", {
                            id: newProjectId,
                          });
                        },
                        d._id,
                        d.name,
                        true,
                      );
                    }
                  } else {
                    new ModalDialog({
                      warning: true,
                      title: "Could not clone patch",
                      text: err.msg,
                      showOkButton: true,
                    });
                  }
                },
              );
            },
          },
          false,
        );

        if (Gui$1.gui.user && Gui$1.gui.user.supporterFeatures) {
          if (Gui$1.gui.user.supporterFeatures.includes("copy_assets_on_clone")) {
            platform.talkerAPI.send(
              "getFilelist",
              { source: "patch" },
              (err, remoteFiles) => {
                let numFiles = 0;
                if (!err && remoteFiles)
                  numFiles = remoteFiles.filter((remoteFile) => {
                    return !remoteFile.isLibraryFile;
                  }).length;

                if (numFiles) {
                  const checkboxGroup = {
                    title: "Supporter Features:",
                    checkboxes: [],
                  };
                  checkboxGroup.checkboxes.push({
                    name: "copy-assets-on-clone",
                    value: true,
                    title: "Copy used files to new patch",
                  });
                  checkboxGroup.checkboxes.push({
                    name: "copy-all-assets-on-clone",
                    value: true,
                    title: "Copy all files to new patch",
                  });
                  checkboxGroups.push(checkboxGroup);
                  let patchOpsText =
                    "Make sure you have all the rights to any asset you copy over to your new patch!";
                  modalNotices.push(patchOpsText);
                }
                saveAsModal.show();
              },
            );
          } else if (
            Gui$1.gui.user.supporterFeatures.includes(
              "overquota_copy_assets_on_clone",
            )
          ) {
            let patchOpsText =
              'You are out of storage space, upgrade your <a href="https://cables.gl/support" target="_blank">cables-support level</a>, to copy assets over to new patches again!</a> ';
            modalNotices.push(patchOpsText);
            saveAsModal.show();
          } else if (
            !Gui$1.gui.user.supporterFeatures.includes(
              "disabled_copy_assets_on_clone",
            )
          ) {
            let patchOpsText =
              'Become a <a href="https://cables.gl/support" target="_blank">cables supporter</a>, to copy assets over to new patches!</a> ';
            modalNotices.push(patchOpsText);
            saveAsModal.show();
          } else {
            saveAsModal.show();
          }
        } else {
          saveAsModal.show();
        }
      });
    }

    saveCurrentProject(cb, _id, _name, _force) {
      if (Gui$1.gui.showGuestWarning()) return;
      if (!_force && Gui$1.gui.showSaveWarning()) return;

      if (_force) {
        this._saveCurrentProject(cb, _id, _name);
      } else {
        this.checkUpdated((err) => {
          if (!err) {
            this._saveCurrentProject(cb, _id, _name);
          } else {
            let msg = err || "no response";
            if (err && err.msg) msg = err.msg;
            this._log.warn("[save patch error] ", msg);
            const modalOptions = {
              warning: true,
              title: "Patch not saved",
              text: "Could not save patch: " + msg,
            };
            new ModalDialog(modalOptions);
          }
        }, true);
      }
      Gui$1.gui.patchView.removeLostSubpatches();
    }

    finishAnimations() {
      Gui$1.gui.savingTitleAnimEnd();

      setTimeout(() => {
        document.getElementById("canvasflash").classList.add("hidden");
        document.getElementById("canvasflash").classList.remove("flash");
      }, 320);
    }

    _saveCurrentProject(cb, _id, _name) {
      if (platform.isSaving()) {
        this._log.log("already saving...");
        return;
      }

      if (Gui$1.gui.showGuestWarning()) return;

      Gui$1.gui.corePatch().emitEvent("uiSavePatch");
      platform.setSaving(true);

      const ops = Gui$1.gui.corePatch().ops;
      this._savedPatchCallback = cb;

      const blueprintIds = [];
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        if (!op || !op.uiAttribs) continue;

        if (op.isSubPatchOp() && op.uiAttribs.blueprintSubpatch) {
          blueprintIds.push(op.uiAttribs.blueprintSubpatch);

          if (op.patchId && op.isInBlueprint2()) {
            blueprintIds.push(op.patchId.get());
          }
        }

        if (op.uiAttribs.title === CABLES.getShortOpName(op.objName))
          delete op.uiAttribs.title;
      }

      gui
        .jobs()
        .start({ id: "projectsave", title: "save patch", indicator: "canvas" });

      const currentProject = Gui$1.gui.project();

      currentProject._id;
      let name = currentProject.name;
      if (_name) name = _name;
      let data = Gui$1.gui.corePatch().serialize({ asObject: true });

      data.ops = data.ops || [];

      for (let i = 0; i < data.ops.length; i++) {
        if (data.ops[i].uiAttribs.error) delete data.ops[i].uiAttribs.error;
        if (data.ops[i].uiAttribs.warning) delete data.ops[i].uiAttribs.warning;
        if (data.ops[i].uiAttribs.hint) delete data.ops[i].uiAttribs.hint;
        if (data.ops[i].uiAttribs.uierrors) delete data.ops[i].uiAttribs.uierrors;
        if (data.ops[i].uiAttribs.extendTitle)
          delete data.ops[i].uiAttribs.extendTitle;
        if (data.ops[i].uiAttribs.loading) delete data.ops[i].uiAttribs.loading;
        if (data.ops[i].uiAttribs.history) delete data.ops[i].uiAttribs.history;

        if (data.ops[i].uiAttribs.hasOwnProperty("selected"))
          delete data.ops[i].uiAttribs.selected;
        if (data.ops[i].uiAttribs.subPatch == 0)
          delete data.ops[i].uiAttribs.subPatch;

        if (data.ops[i].uiAttribs.hasOwnProperty("fromNetwork"))
          delete data.ops[i].uiAttribs.fromNetwork;
      }

      // delete subpatch 2 ops
      let isu = data.ops.length;
      while (isu--)
        if (
          data.ops[isu].uiAttribs.blueprintSubpatch2 ||
          (data.ops[isu].uiAttribs.subPatch &&
            data.ops[isu].uiAttribs.subPatch.indexOf("bp2sub_") == 0)
        )
          data.ops.splice(isu, 1);

      if (blueprintIds.length > 0) {
        let i = data.ops.length;
        // iterate backwards so we can splice
        while (i--) {
          const op = data.ops[i];
          if (
            op.uiAttribs &&
            op.uiAttribs.subPatch &&
            blueprintIds.includes(op.uiAttribs.subPatch)
          ) {
            data.ops.splice(i, 1);
          }
        }
      }

      data.ui = {
        viewBox: {},
        timeLineLength: Gui$1.gui.getTimeLineLength(),
      };

      data.ui.texPreview = Gui$1.gui.metaTexturePreviewer.serialize();
      data.ui.bookmarks = Gui$1.gui.bookmarks.getBookmarks();

      Gui$1.gui.patchView.serialize(data.ui);
      Gui$1.gui.patchParamPanel.serialize(data.ui);

      data.ui.renderer = {};
      data.ui.renderer.w = Math.max(0, Gui$1.gui.rendererWidth);
      data.ui.renderer.h = Math.max(0, Gui$1.gui.rendererHeight);
      data.ui.renderer.s = Math.abs(Gui$1.gui.corePatch().cgl.canvasScale) || 1;

      CABLES.patch.namespace = currentProject.namespace;

      setTimeout(() => {
        try {
          const datastr = JSON.stringify(data);
          Gui$1.gui.patchView.warnLargestPort();

          const origSize = Math.round(datastr.length / 1024);

          let uint8data = pako.deflate(datastr);

          if (origSize > 1000)
            this._log.log(
              "saving compressed data",
              Math.round(uint8data.length / 1024) +
                "kb (was: " +
                origSize +
                "kb)",
            );

          /*
           * let b64 = Buffer.from(uint8data).toString("base64");
           * bytesArrToBase
           */
          let b64 = bytesArrToBase64(uint8data);

          if (datastr.length > 12 * 1024 * 1024)
            notifyError(
              "Patch is huge, try to reduce amount of data stored in patch/ports",
            );

          Gui$1.gui.savingTitleAnimStart("Saving Patch...");

          /*
           * document.getElementById("patchname").innerHTML = "Saving Patch";
           * document.getElementById("patchname").classList.add("blinking");
           */

          const startTime = performance.now();

          platform.savePatch(
            {
              name: name,
              namespace: currentProject.namespace,
              dataB64: b64,
              fromBackup: platform.getPatchVersion() || false,
              buildInfo: {
                core: CABLES.build,
                ui: CABLES.UI.build,
              },
            },
            (err, r) => {
              platform.setSaving(false);

              if (err) {
                this._log.warn("[save patch error] ", err.msg || err);
              } else if (r && r.updated) {
                this.setServerDate(r.updated);
              }

              Gui$1.gui.savedState.setSaved("patchServerApi", 0);
              if (this._savedPatchCallback) this._savedPatchCallback();
              this._savedPatchCallback = null;

              if (Gui$1.gui.socket)
                Gui$1.gui.socket.track("ui", "savepatch", "savepatch", {
                  sizeCompressed: uint8data.length / 1024,
                  sizeOrig: origSize,
                  time: performance.now() - startTime,
                });

              Gui$1.gui.emitEvent("patchsaved");
              Gui$1.gui.jobs().finish("projectsave");

              if (!r || !r.success || err) {
                let msg = err || "no response";
                if (r && r.msg) msg = r.msg;

                if (!navigator.onLine) msg = "no internet connection";

                const modalOptions = {
                  warning: true,
                  title: "Patch not saved",
                  text: "Could not save patch: " + msg,
                };

                if (msg === "ILLEGAL_OPS") {
                  const docsUrl = platform.getCablesDocsUrl();
                  modalOptions.text =
                    "You lack permissions to the following ops:";
                  modalOptions.footer =
                    "Invite the owners of the ops to this patch, join the teams the ops belong to, or convert them to patch ops.";
                  modalOptions.choice = true;
                  modalOptions.notices = [];
                  r.data.forEach((opName) => {
                    modalOptions.notices.push(
                      '<a href="' +
                        docsUrl +
                        "/op/" +
                        opName +
                        '">' +
                        opName +
                        "</a>",
                    );
                  });

                  modalOptions.cancelButton = {
                    text: "Convert",
                    callback: () => {
                      Gui$1.gui.patchView.unselectAllOps();
                      r.data.forEach((opName) => {
                        const opsInPatch = gui
                          .corePatch()
                          .getOpsByObjName(opName);
                        opsInPatch.forEach((op) => {
                          Gui$1.gui.patchView.selectOpId(op.id);
                        });
                      });

                      CABLES.CMD.OP.cloneSelectedOps();
                    },
                  };
                }
                if (msg !== "CANCELLED") {
                  new ModalDialog(modalOptions);
                } else {
                  Gui$1.gui.setStateUnsaved();
                }

                this._log.log(r);
                this.finishAnimations();
                return;
              } else {
                if (
                  Gui$1.gui.project().summary &&
                  Gui$1.gui.project().summary.isTest
                ) {
                  notifyWarn("Test patch saved", null, { force: true });
                } else if (
                  Gui$1.gui.project().summary &&
                  Gui$1.gui.project().summary.exampleForOps &&
                  Gui$1.gui.project().summary.exampleForOps.length > 0
                ) {
                  notifyWarn("Example patch saved", null, { force: true });
                } else if (
                  Gui$1.gui.project().summary &&
                  Gui$1.gui.project().summary.isPublic
                ) {
                  notifyWarn("Published patch saved", null, { force: true });
                } else {
                  notify(
                    "Patch saved (" +
                      data.ops.length +
                      " ops / " +
                      Math.ceil(origSize) +
                      " kb)",
                    null,
                    { force: true },
                  );
                }
              }

              const doSaveScreenshot = Gui$1.gui.corePatch().isPlaying();

              if (doSaveScreenshot && !platform.manualScreenshot())
                this.saveScreenshot();
              else this.finishAnimations();
            },
          );
        } catch (e) {
          platform.setSaving(false);

          let found = false;

          for (let i = 0; i < Gui$1.gui.corePatch().ops.length; i++) {
            try {
              JSON.stringify(Gui$1.gui.corePatch().ops[i].getSerialized());
            } catch (e2) {
              found = true;

              iziToast.error({
                position: "topRight", // bottomRight, bottomLeft, topRight, topLeft, topCenter, bottomCenter, center
                theme: "dark",
                title: "update",
                message: "Error saving patch! ",
                progressBar: false,
                animateInside: false,
                close: true,
                timeout: false,
                buttons: [
                  [
                    "<button>Go to op</button>",
                    function (instance, toast) {
                      Gui$1.gui.patchView.focusOp(Gui$1.gui.corePatch().ops[i].id);
                      Gui$1.gui.patchView.centerSelectOp(
                        Gui$1.gui.corePatch().ops[i].id,
                      );

                      iziToast.hide({}, toast);
                    },
                  ],
                ],
              });

              break;
            }
          }

          Gui$1.gui.jobs().finish("projectsave");
          this._log.log(e);
          if (!found)
            notifyError("error saving patch - try to delete disabled ops");
        } finally {
        }
      }, 100);
    }

    showModalTitleDialog(cb = null) {
      const currentProject = Gui$1.gui.project();
      new ModalDialog({
        prompt: true,
        title: "Patch Title",
        text: "Set the title of this patch",
        promptValue: currentProject.name,
        promptOk: (v) => {
          platform.talkerAPI.send(
            "setProjectName",
            {
              id: currentProject._id,
              name: v,
            },
            (error, re) => {
              const newName = re.data ? re.data.name : "";
              if (error || !newName) {
                const options = {
                  title: "Failed to set project name!",
                  html: "Error: " + re.msg,
                  warning: true,
                  showOkButton: true,
                };
                new ModalDialog(options);
              } else {
                if (re.data && re.data.summary) {
                  Gui$1.gui.project().summary = re.data.summary;
                  Gui$1.gui.patchParamPanel.show(true);
                }
                platform.talkerAPI.send(
                  "updatePatchName",
                  { name: newName },
                  () => {
                    Gui$1.gui.setProjectName(newName);
                  },
                );
                if (cb) cb(newName);
              }
            },
          );
        },
      });
    }

    saveScreenshot(hires, cb) {
      const thePatch = Gui$1.gui.corePatch();
      const cgl = thePatch.cgl;
      const w = cgl.canvas.width / cgl.pixelDensity || 640;
      const h = cgl.canvas.height / cgl.pixelDensity || 360;

      let screenshotWidth = 640;
      let screenshotHeight = 360;

      if (hires) {
        screenshotWidth = 1280;
        screenshotHeight = 720;
      }

      cgl.setSize(screenshotWidth, screenshotHeight);

      setTimeout(() => {
        cgl.setSize(w, h);
        thePatch.resume();
      }, 300);

      thePatch.pause();
      document.getElementById("canvasflash").classList.remove("hidden");
      document.getElementById("canvasflash").classList.add("flash");

      setTimeout(() => {
        // thePatch.renderOneFrame();
        // thePatch.renderOneFrame();
        Gui$1.gui.jobs().start({
          id: "screenshotsave",
          title: "save patch - create screenshot",
        });

        if (cgl.gApi == CABLES.CGState.API_WEBGL) thePatch.resume();

        const url = Gui$1.gui.canvasManager.currentCanvas().toDataURL();

        platform.talkerAPI.send(
          "saveScreenshot",
          {
            screenshot: url,
          },
          (error, re) => {
            if (error) this._log.warn("[screenshot save error]", error);

            cgl.setSize(w, h + 1);
            cgl.setSize(w, h);

            thePatch.resume(); // must resume here for webgpu
            Gui$1.gui.jobs().finish("screenshotsave");
            if (Gui$1.gui.onSaveProject) Gui$1.gui.onSaveProject();
            if (cb) cb();

            this.finishAnimations();
          },
        );
      }, 200);
    }

    sendErrorReport(report, manualSend = true) {
      const doneCallback = (res) => {
        if (manualSend) {
          const modalOptions = {
            title: "Thank you",
            showOkButton: true,
            text: "We will look into it",
          };
          new ModalDialog(modalOptions);
        }

        if (res && res.data && res.data.url)
          this._log.log("sent error report: ", res.data.url);

        CABLES.lastError = null;
      };

      let sendReport = true;
      if (!manualSend) {
        if (this._lastErrorReport)
          sendReport = performance.now() - this._lastErrorReport > 2000;
      }

      if (!sendReport) {
        doneCallback();
      } else {
        this._lastErrorReport = performance.now();
        report.browserInfo = platformLib;
        try {
          const stringReport = JSON.stringify(report);
          if (stringReport.length > 10 * 1024 * 1024) {
            this._log.warn(
              "did not send error report - too big! " +
                Math.round(stringReport.length / 1024 / 1024) +
                " mb",
            );
            doneCallback();
          } else {
            platform.talkerAPI.send("errorReport", report, doneCallback);
          }
        } catch (e) {
          this._log.warn(
            "did not send error report - failed to stringify",
            e.message,
          );
          doneCallback();
        }
      }
    }
  }

  class opCleaner {
    constructor(ops, glpatch) {
      if (ops.length == 0) return;

      this._glpatch = glpatch;
      this.ops = ops;
      const entranceOps = [];
      const unconnectedOps = [];
      const otherOps = [];
      let startPosX = ops[0].uiAttribs.translate.x;
      let startPosY = ops[0].uiAttribs.translate.y;
      let longestOpPorts = 0;

      for (let i = 0; i < ops.length; i++) {
        startPosX = Math.min(startPosX, ops[i].uiAttribs.translate.x);
        startPosY = Math.min(startPosY, ops[i].uiAttribs.translate.y);

        longestOpPorts = Math.max(longestOpPorts, ops[i].portsIn.length);
        longestOpPorts = Math.max(longestOpPorts, ops[i].portsOut.length);

        ops[i].setTempOpPos(
          ops[i].uiAttribs.translate.x,
          ops[i].uiAttribs.translate.y,
          glpatch.getGlOp(ops[i]).w,
          glpatch.getGlOp(ops[i]).h,
        );

        if (!ops[i].hasAnyInLinked() && ops[i].hasAnyOutLinked()) {
          entranceOps.push(ops[i]);
          continue;
        }

        if (ops[i].isInLinkedToOpOutside(ops)) {
          entranceOps.push(ops[i]);
          continue;
        }

        if (!ops[i].hasLinks()) {
          unconnectedOps.push(ops[i]);
          continue;
        }
        otherOps.push(ops[i]);
      }

      for (let i = 0; i < ops.length; i++)
        ops[i].setTempOpPos(startPosX, startPosY);

      // //////

      ops.sort((a, b) => {
        return a.getTempPosY() - b.getTempPosY();
      });

      // /apply rules...

      let cont = false;

      // order by parent y position

      do {
        cont = false;
        for (let i = 0; i < ops.length; i++)
          cont = cont || this.checkCollisionXTopOps(ops[i]);
      } while (cont);

      do {
        cont = false;
        for (let i = 0; i < ops.length; i++)
          cont = cont || this.checkVerticalOrder(ops[i]);
      } while (cont);

      // move op on x axis

      do {
        cont = false;
        for (let i = 0; i < ops.length; i++)
          cont = cont || this.checkCollisionY(ops[i]);
      } while (cont);

      for (let j = 0; j < 100; j++)
        for (let i = 0; i < ops.length; i++) this.checkHorizontalPos(ops[i]);

      // check collisions and move op fown if collidibng

      do {
        cont = false;
        for (let i = 0; i < ops.length; i++)
          cont = cont || this.checkCollisionY(ops[i]);
      } while (cont);

      // //////////////////////

      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        if (op.uiAttribs.translateTemp) {
          Gui$1.gui.patchView.setOpPos(op, op.getTempPosX(), op.getTempPosY());
          delete op.uiAttribs.translateTemp;
        }
      }
    }

    // only test collision on ops that have no inputs, but output links
    checkCollisionXTopOps(op) {
      const other = op.testTempCollision(
        Gui$1.gui
          .corePatch()
          .getSubPatchOps(Gui$1.gui.patchView.getCurrentSubPatch()),
        this._glpatch,
      );
      if (other) {
        console.log("yes colliding...", gluiconfig.newOpDistanceY);

        if (op.hasAnyOutLinked() && !op.hasAnyInLinked()) {
          // eg mainloop
          if (other.hasAnyOutLinked() && !other.hasAnyInLinked()) {
            // eg mainloop
            op.setTempOpPosX(
              op.getTempPosX() +
                3 * (gluiconfig.portWidth + gluiconfig.portPadding),
            );
            return true;
          }
        }
      }
    }

    checkCollisionY(op) {
      const other = op.testTempCollision(Gui$1.gui.corePatch().ops, this._glpatch);
      if (other) {
        console.log("yes colliding...", gluiconfig.newOpDistanceY);

        if (op.hasAnyOutLinked() && !op.hasAnyInLinked()) ; else if (!op.hasAnyOutLinked() && !op.hasAnyInLinked()) {
          op.setTempOpPosY(op.getTempPosY() - gluiconfig.newOpDistanceY);
          return true;
        } else {
          op.setTempOpPosY(op.getTempPosY() + gluiconfig.newOpDistanceY);
          return true;
        }
      }
    }

    checkVerticalOrder(op) {
      // should be lower than the first input link parent op
      if (op.hasAnyInLinked()) {
        const parentOp = op.getLowestLinkedInOp();
        if (parentOp) {
          let mul = 1;
          let offsetY = 0;
          if (parentOp.hasMultipleOutLinked()) {
            mul = 2;
          }
          offsetY = mul * gluiconfig.newOpDistanceY;

          // move one line below parent...
          // if (parentOp.getTempPosY() >= op.getTempPosY())

          let newpos = parentOp.getTempPosY() + offsetY;
          if (op.getTempPosY() != newpos) {
            op.setTempOpPosY(newpos);
            return true;
          }
        }
      }
    }

    getOutLinkPortIndex(parent, op) {
      for (let i = 0; i < parent.portsOut.length; i++) {
        if (parent.portsOut[i].isLinked()) {
          for (let j = 0; j < parent.portsOut[i].links.length; j++) {
            if (
              parent.portsOut[i].links[j].getOtherPort(parent.portsOut[i]).op ==
              op
            ) {
              return j;
            }
          }
        }
      }
      return 0;
    }

    checkHorizontalPos(op) {
      // position on x axis depending on parent op position and port index...

      const parent = op.getFirstLinkedInOp();

      if (parent && op.hasAnyInLinked()) {
        if (!parent.hasMultipleOutLinked()) {
          // parent has one child...
          op.setTempOpPosX(
            parent.getTempPosX() +
              this.getOutLinkPortIndex(parent, op) *
                (gluiconfig.portWidth + gluiconfig.portPadding),
          );
        } else {
          // parent has multiple childs!

          let count = 0;
          let found = false;
          for (let i = 0; i < parent.portsOut.length; i++) {
            if (parent.portsOut[i].isLinked()) {
              for (let j = 0; j < parent.portsOut[i].links.length; j++) {
                if (
                  parent.portsOut[i].links[j].getOtherPort(parent.portsOut[i]) ==
                  op.getFirstLinkedInPort()
                ) {
                  found = true;
                  break;
                }

                count++;
              }
            }
            if (found) break;
          }

          count *= gluiconfig.portWidth + gluiconfig.portPadding;

          // const s = op.getChildsBoundings(this._glpatch, null, op);
          // console.log(s);

          // if (s.maxx != null)
          // {
          //     if (op.getTempPosX() != s.maxx)
          //     {
          //         op.setTempOpPosX(s.maxx);
          //         return true;
          //     }
          // }

          do {
            op.setTempOpPosX(parent.getTempPosX() + count);
            count += 4 * (gluiconfig.portWidth + gluiconfig.portPadding);
            // if (count > 1000)
            // {
            // break;
          } while (op.testTempCollision(this.ops, this._glpatch));
        }
      }
    }
  }

  function convertPorts(p1, p2, converter) {
    let pFrom = null;
    let pTo = null;

    if (
      p1.type == converter.typeFrom &&
      p2.type == converter.typeTo &&
      p1.direction == CABLES.Port.DIR_OUT
    ) {
      pFrom = p1;
      pTo = p2;
    }
    if (
      p2.type == converter.typeFrom &&
      p1.type == converter.typeTo &&
      p1.direction == CABLES.Port.DIR_IN
    ) {
      pFrom = p2;
      pTo = p1;
    }

    Gui$1.gui.patchView.addOp(converter.op, {
      onOpAdd: (newOp) => {
        Gui$1.gui
          .corePatch()
          .link(pFrom.op, pFrom.getName(), newOp, converter.portIn);
        Gui$1.gui.corePatch().link(pTo.op, pTo.getName(), newOp, converter.portOut);

        newOp.setUiAttrib({
          translate: {
            x: pTo.op.uiAttribs.translate.x,
            y: pTo.op.uiAttribs.translate.y - gluiconfig.newOpDistanceY,
          },
        });
      },
    });
  }

  function getConverters(p1, p2) {
    const converters = [];
    for (let i = 0; i < defaultOps.converterOps.length; i++) {
      let found = false;
      if (!p1) return converters;

      if (
        p1.type == defaultOps.converterOps[i].typeFrom &&
        p2.type == defaultOps.converterOps[i].typeTo &&
        p1.direction == CABLES.Port.DIR_OUT
      ) {
        found = true;
      }
      if (
        p2.type == defaultOps.converterOps[i].typeFrom &&
        p1.type == defaultOps.converterOps[i].typeTo &&
        p1.direction == CABLES.Port.DIR_IN
      ) {
        found = true;
      }

      if (found) {
        converters.push(defaultOps.converterOps[i]);
      }
    }
    return converters;
  }

  /**
   * show suggestions for linking a port
   *
   * @export
   * @class SuggestPortDialog
   */
  class SuggestPortDialog {
    /**
     * Description
     * @param {CABLES.Op} op
     * @param {CABLES.Port} port
     * @param {MouseEvent} mouseEvent
     * @param {Function} cb
     * @param {Function} cbCancel
     */
    constructor(op, port, mouseEvent, cb, cbCancel) {
      this._suggestions = [];

      // linkRecommendations
      for (let i = 0; i < op.portsIn.length; i++) {
        const theport = op.portsIn[i];
        if (
          !theport.uiAttribs.hidePort &&
          !theport.uiAttribs.readOnly &&
          CABLES.Link.canLink(theport, port)
        ) {
          this._addPort(theport);
        }
      }

      for (let i = 0; i < op.portsOut.length; i++) {
        const theport = op.portsOut[i];
        if (
          !theport.uiAttribs.hidePort &&
          !theport.uiAttribs.readOnly &&
          CABLES.Link.canLink(theport, port)
        )
          this._addPort(theport);
      }

      if (
        op.objName == defaultOps.defaultOpNames.subPatchInput2 ||
        op.objName == defaultOps.defaultOpNames.subPatchOutput2
      ) {
        op = Gui$1.gui.patchView.getSubPatchOuterOp(op.uiAttribs.subPatch);
      }

      if (op.isSubPatchOp()) {
        this._suggestions.push({
          p: null,
          op: op,
          name: "create SubPatch Port",
          createSpOpPort: true,
        });
      }

      new SuggestionDialog(
        this._suggestions,
        op,
        mouseEvent,
        cb,
        (id) => {
          for (const i in this._suggestions)
            if (this._suggestions[i].id == id) {
              cb(
                this._suggestions[i].p,
                this._suggestions[i].op,
                this._suggestions[i],
              );
            }
        },
        false,
        cbCancel,
      );
    }

    _addPort(p) {
      for (let i = 0; i < this._suggestions.length; i++)
        if (this._suggestions[i].p == p) return;

      let className = "portSuggest" + p.type;
      if (p.isLinked()) className += "Linked";

      this._suggestions.push({
        class: className,
        p: p,
        op: p.op.id,
        name: p.title,
        // "isLinked": p.isLinked(),
        isBoundToVar: p.isBoundToVar(),
        isAnimated: p.isAnimated(),
      });
    }
  }

  /**
   * extending core classes for helper functions which will be only available in ui/editor mode
   */


  /**
   * @extends Patch<UiOp>
   */
  class UiPatch extends Patch {
    _opIdsToOps(opids) {
      let ops = [];
      for (let i = 0; i < opids.length; i++) {
        ops.push(this.getOpById(opids[i]));
      }
      return ops;
    }

    hasOp(op) {
      for (const i in this.ops) {
        if (this.ops[i].opId === op.opId) return true;
        if (this.ops[i].objName === op.objName) return true;
      }
      return false;
    }

    getOpByRefId(refId, subPatchId) {
      const ops = this.getSubPatchOps(subPatchId);
      if (ops)
        for (let i = 0; i < ops.length; i++)
          if (ops[i].storage && ops[i].storage.ref == refId) return ops[i];
    }

    clearSubPatchCache(patchId) {
      if (patchId === undefined) {
        this._subpatchOpCache = {};
        return;
      }
      this._subpatchOpCache = this._subpatchOpCache || {};
      delete this._subpatchOpCache[patchId];
    }

    _subPatchCacheAdd(subPatchId, op) {
      if (this._subpatchOpCache[subPatchId]) {
        this._subpatchOpCache[subPatchId].ops =
          this._subpatchOpCache[subPatchId].ops || {};
        this._subpatchOpCache[subPatchId].ops[op.id] = op;
      }
    }

    getSubPatchOps(subPatchId, recursive = false) {
      if (subPatchId === undefined)
        subPatchId = Gui$1.gui.patchView.getCurrentSubPatch();
      if (this.ops.length == 0) return [];
      const perf = Gui$1.gui.uiProfiler.start("[corepatch ext] getSubPatchOps");

      this._subpatchOpCache = this._subpatchOpCache || {};

      let opids = [];

      if (
        this._subpatchOpCache[subPatchId] &&
        this._subpatchOpCache[subPatchId].ops
      ) {
        // console.log("cache hit");
        opids = this._subpatchOpCache[subPatchId].ops;
      } else {
        // console.log("creating cache...ops:", this.ops.length);
        for (let i = 0; i < this.ops.length; i++) {
          // console.log("creating cache ", subPatchId, this.ops.length);
          const op = this.ops[i];
          if (!op || !op.uiAttribs) continue;

          // console.log("creating cache ", subPatchId, op.uiAttribs.subPatch, this.ops);

          if (
            (op.uiAttribs && op.uiAttribs.subPatch == subPatchId) ||
            !op.uiAttribs.hasOwnProperty("subPatch")
          ) {
            this._subpatchOpCache[subPatchId] =
              this._subpatchOpCache[subPatchId] || {}; // "ops": {}, "subPatchOpId": null };
            this._subpatchOpCache[subPatchId].ops =
              this._subpatchOpCache[subPatchId].ops || {};
            this._subpatchOpCache[subPatchId].ops[op.id] = op;
          }

          // if (op.isSubPatchOp()) console.log("issub", op.isSubPatchOp(), op.patchId.get(), subPatchId);

          if (op.isSubPatchOp()) {
            this._subpatchOpCache[op.patchId.get()] =
              this._subpatchOpCache[op.patchId.get()] || {};
            this._subpatchOpCache[op.patchId.get()].subPatchOpId = op.id;
            // console.log("subpatchiopid", op.patchId.get());
          }
        }
        // this._subpatchOpCache[subPatchId].ops = opids;
      }
      if (
        !this._subpatchOpCache[subPatchId] ||
        !this._subpatchOpCache[subPatchId].ops
      ) ; else opids = Object.keys(this._subpatchOpCache[subPatchId].ops);

      let ops = this._opIdsToOps(opids);

      if (recursive) {
        for (const i in ops) {
          if (ops[i].storage && ops[i].storage.subPatchVer) {
            const subPatchPort = ops[i].portsIn.find((port) => {
              return port.name === "patchId";
            });
            if (subPatchPort) {
              if (subPatchPort.value != subPatchId)
                ops = ops.concat(this.getSubPatchOps(subPatchPort.value, true));
            }
          }
        }
      }

      perf.finish();
      return ops;
    }

    getSubPatch2InnerInputOp(subPatchId) {
      const ops = Gui$1.gui.corePatch().getSubPatchOps(subPatchId);
      for (let i = 0; i < ops.length; i++) if (ops[i].innerInput) return ops[i];
    }

    getSubPatch2InnerOutputOp(subPatchId) {
      const ops = Gui$1.gui.corePatch().getSubPatchOps(subPatchId);
      for (let i = 0; i < ops.length; i++) if (ops[i].innerOutput) return ops[i];
    }

    buildSubPatchCache() {
      const perf = Gui$1.gui.uiProfiler.start("[corePatch ext] buildSubPatchCache");

      const ops = Gui$1.gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++) {
        if (ops[i].uiAttribs.subPatch) {
          Gui$1.gui.corePatch().getSubPatchOuterOp(ops[i].uiAttribs.subPatch);
        }
      }

      perf.finish();
    }

    getNewSubpatchId(oldSubPatchId) {
      for (let i in this._subpatchOpCache) {
        if (this._subpatchOpCache[i].subPatchOpId) {
          const outerOp = this.getOpById(this._subpatchOpCache[i].subPatchOpId);
          if (
            outerOp.oldSubPatchIds &&
            outerOp.oldSubPatchIds.indexOf(oldSubPatchId) > -1
          ) {
            return i;
          }
        }
      }
    }

    /**
     * Description
     * @param {string|number} subPatchId
     * @param {boolean} [ignoreNotFound]
     * @returns {UiOp}
     */
    getSubPatchOuterOp(subPatchId, ignoreNotFound = false) {
      if (subPatchId == 0) return null;
      // oldSubPatchIds

      if (
        !this._subpatchOpCache[subPatchId] ||
        !this._subpatchOpCache[subPatchId].subPatchOpId
      ) {
        if (!ignoreNotFound) {
          this.clearSubPatchCache(subPatchId);
          this.getSubPatchOps(subPatchId); // try build cache
        } else return null;
      }

      // console.log(this._subpatchOpCache);
      // console.log("subpatchopdi", this._subpatchOpCache[subPatchId].subPatchOpId);

      if (!this._subpatchOpCache[subPatchId]) {
        // console.log("subpatch [cache] not found", subPatchId);
        return null;
      }
      let op = this.getOpById(this._subpatchOpCache[subPatchId].subPatchOpId);
      if (op) return op;

      // const ops = this.ops;
      // for (let i = 0; i < ops.length; i++)
      // {
      //     op = ops[i];
      //     if (op.isSubPatchOp() && op.patchId.get() == subPatchId) return op;
      // }

      // console.log("not found+?!?!?!");
      return null;
    }

    getOpsInRect(xa, ya, xb, yb) {
      const perf = Gui$1.gui.uiProfiler.start("[extPatch] ops in rect");
      const x = Math.min(xa, xb);
      const y = Math.min(ya, yb);
      const x2 = Math.max(xa, xb);
      const y2 = Math.max(ya, yb);
      const ops = [];
      const cops = Gui$1.gui.corePatch().getSubPatchOps();

      for (let j = 0; j < cops.length; j++) {
        if (cops[j]) {
          const op = cops[j];
          if (
            op.uiAttribs &&
            op.uiAttribs.translate &&
            op.uiAttribs.translate.x >= x && // op.uiAttribs.translate. right edge past r2 left
            op.uiAttribs.translate.x <= x2 && // op.uiAttribs.translate. left edge past r2 right
            op.uiAttribs.translate.y >= y && // op.uiAttribs.translate. top edge past r2 bottom
            op.uiAttribs.translate.y <= y2
          ) {
            // r1 bottom edge past r2 top
            ops.push(op);
            // console.log(1);
          }
        }
        // else console.log("no c op");
      }

      perf.finish();

      return ops;
    }

    getAllAnimPorts() {
      const ports = [];
      const ops = Gui$1.gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++) {
        for (let j = 0; j < ops[i].portsIn.length; j++) {
          if (ops[i].portsIn[j].isAnimated()) ports.push(ops[i].portsIn[j]);
        }
      }

      return ports;
    }

    reloadOp(objName, cb, refOldOp) {
      let count = 0;
      const ops = [];
      const oldOps = [];

      Gui$1.gui.patchView.unselectAllOps();

      for (const i in this.ops) {
        if (this.ops[i].objName == objName) {
          oldOps.push(this.ops[i]);
        }
      }

      let refNewOp = null;

      for (let i = 0; i < oldOps.length; i++) {
        count++;
        const oldOp = oldOps[i];
        oldOp.deleted = true;
        const op = this.addOp(objName, oldOp.uiAttribs);
        if (!op) continue;
        if (oldOp && oldOp.storage)
          op.setStorage(JSON.parse(JSON.stringify(oldOp.storage)));
        ops.push(op);

        if (oldOp == refOldOp) {
          refNewOp = op;
        }

        if (oldOp.patchId) {
          op.oldSubPatchIds = oldOp.oldSubPatchIds || [];
          op.oldSubPatchIds.push(oldOp.patchId.get());
        }

        let l;
        for (let j in oldOp.portsIn) {
          if (oldOp.portsIn[j].links.length === 0) {
            const p = op.getPort(oldOp.portsIn[j].name);
            if (!p) {
              this._log.warn(
                "[reloadOp] could not set port " +
                  oldOp.portsIn[j].name +
                  ", probably renamed port ?",
              );
            } else {
              p.set(oldOp.portsIn[j].get());

              if (oldOp.portsIn[j].getVariableName())
                p.setVariable(oldOp.portsIn[j].getVariableName());
            }
          } else {
            while (oldOp.portsIn[j].links.length) {
              const oldName = oldOp.portsIn[j].links[0].portIn.name;
              const oldOutName = oldOp.portsIn[j].links[0].portOut.name;
              const oldOutOp = oldOp.portsIn[j].links[0].portOut.op;
              oldOp.portsIn[j].links[0].remove();

              l = this.link(op, oldName, oldOutOp, oldOutName);
              if (!l)
                this._log.warn(
                  "[reloadOp] relink after op reload not successfull for port " +
                    oldOutName,
                );
              else l.setValue();
            }
          }
        }

        for (let j in oldOp.portsOut) {
          while (oldOp.portsOut[j].links.length) {
            const oldNewName = oldOp.portsOut[j].links[0].portOut.name;
            const oldInName = oldOp.portsOut[j].links[0].portIn.name;
            const oldInOp = oldOp.portsOut[j].links[0].portIn.op;
            oldOp.portsOut[j].links[0].remove();

            l = this.link(op, oldNewName, oldInOp, oldInName);
            if (!l)
              this._log.warn(
                "relink after op reload not successfull for port " + oldInName,
              );
            else l.setValue();
          }
        }

        this.deleteOp(oldOp.id, false, true);
      }

      Gui$1.gui.patchView.unselectAllOps();

      cb(count, ops, refNewOp);
    }

    checkExtensionOpPatchAssets() {
      const perf = Gui$1.gui.uiProfiler.start("checkExtOpsPatchAssets");
      const allops = this.ops;
      for (let i = 0; i < allops.length; i++) {
        const sop = allops[i];
        if (sop.patchId)
          if (namespace$1.isExtensionOp(sop.objName)) {
            const ops = this.getSubPatchOps(sop.patchId.get());
            for (let k = 0; k < ops.length; k++) {
              const op = ops[k];

              op.setUiError("patchassetext", null);

              for (let j = 0; j < op.portsIn.length; j++) {
                if (
                  !op.portsIn[j].isLinked() &&
                  op.portsIn[j].uiAttribs &&
                  op.portsIn[j].uiAttribs.display &&
                  op.portsIn[j].uiAttribs.display === "file"
                ) {
                  const asset = op.portsIn[j].get();
                  if (
                    asset &&
                    asset.startsWith("/assets/") &&
                    !asset.startsWith("/assets/library")
                  ) {
                    op.setUiError("patchassetext", "patch asset in extension op");
                  }
                }
              }
            }
          }
      }
      perf.finish();
    }
  }

  CABLES.Patch = UiPatch;

  /**
   * manage patch view and helper functions
   *
   * @export
   * @class PatchView
   * @extends {Events}
   */
  class PatchView extends Events {
    constructor(corepatch) {
      super();

      this._p = corepatch;
      this._log = new Logger("patchview");
      this._element = null;
      this._pvRenderers = {};

      /** @type {GlPatch} */
      this._patchRenderer = null;
      // this._cachedSubpatchNames = {};
      this.isPasting = false;
      this._showingNavHelperEmpty = false;
      this._lastTempOP = null;

      this.boundingRect = null;
      this.store = new PatchSaveServer(); // this should probably be somewhere else need only one storage, even when opening multiple patchviews ?
      this._initListeners();
      this._eleSubpatchNav = ele.byId("subpatch_nav");

      corepatch.on("onLink", this._portValidate.bind(this));
      corepatch.on("onUnLink", this._portValidate.bind(this));

      corepatch.on("onLink", this.refreshCurrentOpParamsByPort.bind(this));
      corepatch.on("onUnLink", this.refreshCurrentOpParamsByPort.bind(this));

      // corepatch.on("onOpAdd", this._onAddOpHistory.bind(this));
      corepatch.on(
        CABLES.Patch.EVENT_OP_DELETED,
        this._onDeleteOpUndo.bind(this),
      );

      corepatch.on(CABLES.Patch.EVENT_OP_ADDED, (op) => {
        if (!undo.paused())
          Gui$1.gui.savedState.setUnSaved("onOpAdd", op.getSubPatch());
      });
      corepatch.on(CABLES.Patch.EVENT_OP_DELETED, (op) => {
        if (!undo.paused())
          Gui$1.gui.savedState.setUnSaved("onOpDelete", op.getSubPatch());
      });
      corepatch.on("onLink", (p1, p2) => {
        if (!undo.paused())
          Gui$1.gui.savedState.setUnSaved(
            "onLink",
            p1.op.getSubPatch() || p2.op.getSubPatch(),
          );
      });
      corepatch.on("onUnLink", (p1, p2) => {
        if (!undo.paused())
          Gui$1.gui.savedState.setUnSaved(
            "onUnLink",
            p1.op.getSubPatch() || p2.op.getSubPatch(),
          );
      });
    }

    get element() {
      return this._element || PatchView.getElement();
    }

    static getElement() {
      return document.querySelector("#patchviews .visible");
    }

    get patchRenderer() {
      return this._patchRenderer;
    }

    get rendererName() {
      return this._patchRenderer.name;
    }

    // _onAddOpHistory(op, fromDeserialize)
    // {
    //     if (this._showingNavHelperEmpty)
    //     {
    //         this._showingNavHelperEmpty = false;
    //         ele.hide(ele.byId("patchnavhelperEmpty"));
    //     }

    //     if (!fromDeserialize)
    //     {
    //         if (!op.uiAttribs) op.uiAttribs = {};
    //         if (!op.uiAttribs.history) op.uiAttribs.history = {};
    //         op.uiAttribs.history.createdAt = Date.now();
    //         op.uiAttribs.history.createdBy = {
    //             "name": Gui.gui.user.usernameLowercase
    //         };
    //         op.uiAttribs.history.lastInteractionAt = Date.now();
    //         op.uiAttribs.history.lastInteractionBy = {
    //             "name": Gui.gui.user.usernameLowercase
    //         };
    //     }
    // }

    /**
     * @param {String} subPatchId
     */
    focusSubpatchOp(subPatchId) {
      this._log.log("dupe focusSubpatchOp1");
      const outerOp = Gui$1.gui.corePatch().getSubPatchOuterOp(subPatchId);
      Gui$1.gui.patchView.setCurrentSubPatch(outerOp.uiAttribs.subPatch);
      console.log("lala", outerOp.opId);
      Gui$1.gui.patchView.centerSelectOp(outerOp.opId);
    }

    /**
     * @param {String} subPatchId
     */
    clickSubPatchNav(subPatchId) {
      Gui$1.gui.patchView.setCurrentSubPatch(subPatchId);
      Gui$1.gui.patchParamPanel.show(true);
      this.focus();
    }

    /**
     * @param {Op} op
     */
    _onDeleteOpUndo(op) {
      this.checkPatchErrorsSoon();

      (function (opname, _opid) {
        const oldValues = {};
        for (let i = 0; i < op.portsIn.length; i++)
          oldValues[op.portsIn[i].name] = op.portsIn[i].get();

        undo.add({
          title: "delete op",
          context: {
            opname: opname,
          },
          undo() {
            const newop = Gui$1.gui.corePatch().addOp(opname, op.uiAttribs, _opid);
            if (newop) {
              for (const i in oldValues) {
                const port = newop.getPortByName(i);
                if (port) {
                  port.set(oldValues[i]);
                  Gui$1.gui.emitEvent("portValueEdited", newop, port, oldValues[i]);
                }
              }
            }
          },
          redo() {
            Gui$1.gui.corePatch().deleteOp(_opid, false);
          },
        });
      })(op.objName, op.id);
    }

    setProject(proj, cb) {
      if (!this._patchRenderer) {
        this._log.error("no patchrenderer...");
        cb();
        return;
      }

      const perf = Gui$1.gui.uiProfiler.start("[patchview] setproject");
      this._p.logStartup("gui set project");

      if (proj && proj.ui) {
        this.store.setProject(proj);

        if (proj.ui.renderer) {
          if (
            proj.ui.renderer.w * proj.ui.renderer.s >
              document.body.clientWidth * 0.9 ||
            proj.ui.renderer.h * proj.ui.renderer.s >
              document.body.clientHeight * 0.9
          ) {
            proj.ui.renderer.w = 640;
            proj.ui.renderer.h = 360;
          }

          Gui$1.gui.rendererWidth = proj.ui.renderer.w;
          Gui$1.gui.rendererHeight = proj.ui.renderer.h;
          Gui$1.gui.corePatch().cgl.canvasScale = proj.ui.renderer.s || 1;
          Gui$1.gui.setLayout();
        }

        Gui$1.gui.setTimeLineLength(proj.ui.timeLineLength);
      }

      Gui$1.gui.setProject(proj);

      this._patchRenderer.setProject(proj);

      this.store.setServerDate(proj.updated);

      if (Gui$1.gui.isRemoteClient) {
        if (cb) cb();
        return;
      }

      perf.finish();

      this._p.logStartup("loadProjectDependencies...");
      Gui$1.gui.serverOps.loadProjectDependencies(proj, (project) => {
        this._p.logStartup("loadProjectDependencies done");
        this._p.logStartup("deserialize...");

        const perf3 = Gui$1.gui.uiProfiler.start("[core] deserialize");
        Gui$1.gui.corePatch().deSerialize(project);
        perf3.finish();

        const perf2 = Gui$1.gui.uiProfiler.start("[patchview] setproject2");

        this._p.logStartup("deserialize done");

        undo.clear();

        const ops = Gui$1.gui.corePatch().ops;
        if (!Gui$1.gui.isRemoteClient) {
          for (let i = 0; i < ops.length; i++)
            if (ops[i].uiAttribs.selected) this.selectOpId(ops[i].id);

          if (
            !this._showingNavHelperEmpty &&
            Gui$1.gui.corePatch().ops.length == 0
          ) {
            this._showingNavHelperEmpty = true;
            ele.show(ele.byId("patchnavhelperEmpty"));
          }
        }

        Gui$1.gui.patchView.checkPatchOutdated();

        if (Gui$1.gui.project() && Gui$1.gui.project().ui)
          Gui$1.gui.metaTexturePreviewer.deserialize(
            Gui$1.gui.project().ui.texPreview,
          );

        Gui$1.gui.patchView.removeLostSubpatches();

        perf2.finish();

        if (cb) cb();
      });
    }

    _initListeners() {}

    /**
     * @param {String} id
     */
    switch(id) {
      const views = ele.byId("patchviews");

      for (let i = 0; i < views.children.length; i++) {
        views.children[i].style.display = "none";
        views.children[i].classList.remove("visible");
      }

      const el = document.getElementById(id);
      el.classList.add("visible");
      el.style.display = "block";

      this._patchRenderer = this._pvRenderers[id];
      Gui$1.gui.setLayout();
    }

    updateBoundingRect() {
      const el = PatchView.getElement();
      if (el) this.boundingRect = el.getBoundingClientRect();
    }

    /**
     * @returns {Boolean}
     */
    hasFocus() {
      return this._patchRenderer.isFocused();
    }

    /**
     * @param {UiOp} op
     */
    testCollision(op) {
      if (!op || !op.uiAttribs) return;
      let count = 0;
      let collided = {};
      for (let j = 0; j < Gui$1.gui.corePatch().ops.length; j++) {
        const b = Gui$1.gui.corePatch().ops[j];
        if (!b || !b.uiAttribs || b.deleted || b == op) continue;
        if (b.uiAttribs.subPatch != op.uiAttribs.subPatch) continue;
        if (!b.uiAttribs.translate) continue;
        if (!op.uiAttribs.translate) continue;
        if (collided[b.id]) continue;

        const glopA = this._patchRenderer.getGlOp(op);
        const glopB = this._patchRenderer.getGlOp(b);

        if (!glopA || !glopB) return;

        let found = true;

        if (!op.uiAttribs.resizable && !b.uiAttribs.resizable)
          while (found) {
            found = false;
            if (
              (glopA.x >= glopB.x &&
                glopA.x <= glopB.x + glopB.w &&
                glopA.y >= glopB.y &&
                glopA.y <= glopB.y + glopB.h) ||
              (glopA.x + glopA.w >= glopB.x &&
                glopA.x + glopA.w <= glopB.x + glopB.w &&
                glopA.y + glopA.h >= glopB.y &&
                glopA.y + glopA.h <= glopB.y + glopB.h) ||
              (glopA.x >= glopB.x &&
                glopA.x <= glopB.x + glopB.w &&
                glopA.y + glopA.h >= glopB.y &&
                glopA.y + glopA.h <= glopB.y + glopB.h) ||
              (glopA.x + glopA.w >= glopB.x &&
                glopA.x + glopA.w <= glopB.x + glopB.w &&
                glopA.y >= glopB.y &&
                glopA.y <= glopB.y + glopB.h)
            ) {
              let mulDirY = 1;
              if (op.isLinkedOut() && !op.isLinkedIn()) mulDirY = -1; // move upwards
              let y = Snap.snapOpPosY(
                b.uiAttribs.translate.y +
                  mulDirY * (uiConfig.snapY / 2 + glopB.h),
              );
              let x = op.uiAttribs.translate.x;

              const link = op.isConnectedTo(b);
              if (link) {
                let p = link.portIn;
                if (link.portOut.op == op) p = link.portOut;
                const otherPort = link.getOtherPort(p);
                x =
                  otherPort.op.uiAttribs.translate.x +
                  otherPort.op.getPortPosX(otherPort.name);
              }

              op.setUiAttrib({ translate: { x: x, y: y } });

              Gui$1.gui.patchView.testCollision(op);

              found = true;
              count++;
              collided[b.id] = true;
              collided[op.id] = true;
            }

            if (count > 100) {
              this._log.log("count 100");
              return;
            }
          }
      }
    }

    focus() {
      if (this._patchRenderer.focus) this._patchRenderer.focus();
    }

    clearPatch() {
      this._patchRenderer.dispose();
      this._p.clear();
    }

    setPatchRenderer(id, pr) {
      this._pvRenderers[id] = pr;
      if (!this._patchRenderer) this._patchRenderer = pr;
    }

    addAssetOpAuto(filename, event) {
      if (window.Gui.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_FULL) return;

      const ops = opNames.getOpsForFilename(filename);

      if (ops.length == 0) {
        notify("No default op for filetype");
        return;
      }

      const opname = ops[0];
      const uiAttr = { subPatch: this.getCurrentSubPatch() };

      let coordArr = this._patchRenderer.screenToPatchCoord(150, 150);

      if (event && this._patchRenderer.screenToPatchCoord) {
        coordArr = this._patchRenderer.screenToPatchCoord(
          event.clientX || event.x,
          event.clientY || event.y,
        );
      }

      const coord = { x: coordArr[0], y: coordArr[1] };
      coord.x = Snap.snapOpPosX(coord.x, true);
      coord.y = Snap.snapOpPosY(coord.y);
      uiAttr.translate = { x: coord.x, y: coord.y };

      Gui$1.gui.serverOps.loadOpDependencies(opname, () => {
        const op = Gui$1.gui.corePatch().addOp(opname, uiAttr);

        for (let i = 0; i < op.portsIn.length; i++)
          if (op.portsIn[i].uiAttribs.display == "file")
            op.portsIn[i].set(filename);

        op.refreshParams();
        this.centerSelectOp(op.opId);
      });
    }

    addOp(opname, options) {
      Gui$1.gui.jobs().start({ id: "loadOpDependencies" });
      Gui$1.gui.serverOps.loadOpDependencies(opname, () => {
        Gui$1.gui.jobs().finish("loadOpDependencies");

        options = options || {};
        const uiAttribs = options.uiAttribs || {};

        if (options.subPatch) uiAttribs.subPatch = options.subPatch;
        if (options.createdLocally) uiAttribs.createdLocally = true;

        if (!uiAttribs.subPatch) {
          uiAttribs.subPatch = this.getCurrentSubPatch();
        }

        const op = this._p.addOp(opname, uiAttribs);

        if (!op) return;

        // this.addBlueprintInfo(op, this.getSubPatchOuterOp(uiAttribs.subPatch));

        if (this._showingNavHelperEmpty) {
          document.getElementById("patchnavhelperEmpty").style.display = "none";
        }

        // todo options:
        // - putIntoLink
        // ...?
        // positioning ?

        if (options.linkNewOpToPort) {
          const foundPort = op.findFittingPort(options.linkNewOpToPort);
          if (foundPort) {
            if (op.objName == defaultOps.defaultOpNames.number) {
              const oldValue = options.linkNewOpToPort.get();
              op.getPort("value").set(oldValue);
              op.setTitle(options.linkNewOpToPort.getName());
            }
            if (op.objName == defaultOps.defaultOpNames.string) {
              const oldValue = options.linkNewOpToPort.get();
              op.getPort("value").set(oldValue);
              op.setTitle(options.linkNewOpToPort.getName());
            }

            gui
              .corePatch()
              .link(
                options.linkNewOpToOp,
                options.linkNewOpToPort.getName(),
                op,
                foundPort.getName(),
              );
          }
        }
        if (options.linkNewLink) {
          let op1 = null;
          let op2 = null;
          let port1 = null;
          let port2 = null;

          if (options.linkNewLink.p1) {
            // patch_link
            op1 = options.linkNewLink.p1.op;
            op2 = options.linkNewLink.p2.op;
            port1 = options.linkNewLink.p1.thePort;
            port2 = options.linkNewLink.p2.thePort;
          } else {
            // core link
            op2 = options.linkNewLink.portIn.op;
            op1 = options.linkNewLink.portOut.op;
            port2 = options.linkNewLink.portIn;
            port1 = options.linkNewLink.portOut;
          }

          const foundPort1 = op.findFittingPort(port1);
          const foundPort2 = op.findFittingPort(port2);

          if (foundPort2 && foundPort1) {
            for (const il in port1.links) {
              if (
                (port1.links[il].portIn == port1 &&
                  port1.links[il].portOut == port2) ||
                (port1.links[il].portOut == port1 &&
                  port1.links[il].portIn == port2)
              )
                port1.links[il].remove();
            }

            Gui$1.gui
              .corePatch()
              .link(op, foundPort1.getName(), op1, port1.getName());

            Gui$1.gui
              .corePatch()
              .link(op, foundPort2.getName(), op2, port2.getName());
          }
        }

        if (options.onOpAdd) options.onOpAdd(op);
      });
    }

    addOpAndLink(opname, opid, portname, cb) {
      const oldOp = Gui$1.gui.corePatch().getOpById(opid);
      const trans = {
        x: oldOp.uiAttribs.translate.x,
        y: oldOp.uiAttribs.translate.y - gluiconfig.newOpDistanceY,
      };

      Gui$1.gui.patchView.addOp(opname, {
        onOpAdd: (newOp) => {
          let newPort = newOp.getFirstOutPortByType(
            oldOp.getPortByName(portname).type,
          );
          if (oldOp.getPortByName(portname).direction == PortDir.out)
            newPort = newOp.getFirstInPortByType(
              oldOp.getPortByName(portname).type,
            );

          Gui$1.gui.corePatch().link(oldOp, portname, newOp, newPort.name);

          newOp.setUiAttrib({
            translate: trans,
            subPatch: this.getCurrentSubPatch(),
          });

          this.testCollision(newOp);
          if (cb) cb(newOp);
        },
      });
    }

    showSelectedOpsPanel() {
      const ops = this.getSelectedOps();
      const numops = ops.length;

      if (numops > 0) {
        let mulSubs = false;

        for (let i = 0; i < ops.length; i++)
          if (ops[i].uiAttribs.subPatch != ops[0].uiAttribs.subPatch) {
            mulSubs = true;
            break;
          }

        const html = getHandleBarHtml("params_ops", {
          isDevEnv: platform.isDevEnv(),
          config: platform.cfg,
          showDevInfos: UserSettings.userSettings.get("devinfos"),
          bounds: this.getSelectionBounds(),
          numOps: numops,
          mulSubs: mulSubs,
        });

        Gui$1.gui.opParams.clear();

        ele.byId(Gui$1.gui.getParamPanelEleId()).innerHTML = html;
        Gui$1.gui.setTransformGizmo(null);
        Gui$1.gui.showInfo(text.patchSelectedMultiOps);
      } else {
        this.showDefaultPanel();
      }
    }

    showDefaultPanel() {
      Gui$1.gui.setTransformGizmo(null);
      Gui$1.gui.opParams.clear();
      Gui$1.gui.patchParamPanel.show();
    }

    selectAllOpsSubPatch(subPatch, noUnselect) {
      const ops = Gui$1.gui.corePatch().getSubPatchOps(subPatch);
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        if (op) {
          if (
            (op.uiAttribs.subPatch || 0) == subPatch &&
            !op.uiAttribs.selected
          ) {
            op.uiAttr({ selected: true });

            // if (op.isSubPatchOp())
            // this.selectAllOpsSubPatch(op.patchId.get(), true);
          } else if (!noUnselect) op.uiAttr({ selected: false });
        }
      }

      this.showSelectedOpsPanel();
    }

    checkPatchOutdated() {
      const perf = Gui$1.gui.uiProfiler.start("checkpatcherrors");
      this.hasOldOps = false;

      for (let i = 0; i < this._p.ops.length; i++) {
        const doc = Gui$1.gui.opDocs.getOpDocByName(this._p.ops[i].objName);

        if (
          (doc && doc.oldVersion) ||
          namespace$1.isDeprecatedOp(this._p.ops[i].objName)
        ) {
          this.hasOldOps = true;
          perf.finish();
          return;
        }
      }
      perf.finish();
    }

    checkPatchErrorsSoon() {
      setTimeout(() => {
        clearTimeout(this._checkErrorTimeout);
        this.checkPatchOutdated();
        this.checkPatchErrors();
      }, 500);
    }

    checkPatchErrors() {
      if (Gui$1.gui.unload) return;
      const perf = Gui$1.gui.uiProfiler.start("checkpatcherrors");
      const hadErrors = this.hasUiErrors;
      this.hasUiErrors = false;

      let isExamplePatch = false;
      if (Gui$1.gui.project().summary)
        isExamplePatch =
          Gui$1.gui.project().summary.isBasicExample ||
          (Gui$1.gui.project().summary.exampleForOps &&
            Gui$1.gui.project().summary.exampleForOps.length > 0);

      if (!this._checkErrorTimeout) {
        Gui$1.gui.patchView.checkPatchOutdated(); // first time also check outdated ops..
        if (isExamplePatch) CABLES.CMD.PATCH.clearOpTitles(); // examples should not have edited op titles...
      }

      const ops = Gui$1.gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++)
        if (ops[i].uiAttribs && ops[i].uiAttribs.uierrors)
          for (let j = 0; j < ops[i].uiAttribs.uierrors.length; j++)
            if (ops[i].uiAttribs.uierrors[j].level == 2) {
              this.hasUiErrors = true;
              break;
            }

      if (hadErrors != this.hasUiErrors)
        Gui$1.gui.corePatch().emitEvent("warningErrorIconChange");

      let showAttentionIcon = this.hasUiErrors;

      if (
        this.hasOldOps &&
        (Gui$1.gui.project().summary.isBasicExample || isExamplePatch)
      )
        showAttentionIcon = true;

      clearTimeout(this._checkErrorTimeout);

      const elError = ele.byId("nav-item-error");

      const wasHidden = elError.classList.contains("hidden");
      if (showAttentionIcon) ele.show(elError);
      else ele.hide(elError);

      const elIcon = ele.byId("nav-item-error-icon");
      if (showAttentionIcon) elIcon.style["background-color"] = "red";

      if (wasHidden != elError.classList.contains("hidden")) Gui$1.gui.setLayout();

      perf.finish();
      this._checkErrorTimeout = setTimeout(
        this.checkPatchErrors.bind(this),
        5000,
      );
    }

    centerSubPatchBounds(subPatch) {
      const bounds = this.getSubPatchBounds(subPatch);
      const ops = this._p.ops;

      for (let j = 0; j < ops.length; j++)
        if (
          ops[j].uiAttribs.subPatch == subPatch &&
          ops[j].uiAttribs &&
          ops[j].uiAttribs.translate
        ) {
          ops[j].setPos(
            ops[j].uiAttribs.translate.x - bounds.minX - bounds.size[0] / 2,
            ops[j].uiAttribs.translate.y - bounds.minY - bounds.size[1] / 2,
          );
        }
    }

    getSubPatchBounds(subPatchId) {
      if (subPatchId == undefined) subPatchId = this.getCurrentSubPatch();
      const perf = Gui$1.gui.uiProfiler.start("patch.getSubPatchBounds");
      const ops = this._p.ops;
      const theOps = [];

      for (let j = 0; j < ops.length; j++)
        if (ops[j].uiAttribs.subPatch == subPatchId)
          if (
            ops[j].objName != defaultOps.defaultOpNames.subPatchInput2 &&
            ops[j].objName != defaultOps.defaultOpNames.subPatchOutput2
          )
            // if (ops[j].objName.indexOf("Ops.Ui.") == -1 && ops[j].objName.indexOf("Ops.Dev.Ui.") == -1)
            theOps.push(ops[j]);

      let bounds = this.getOpBounds(theOps);

      perf.finish();

      return bounds;
    }

    getOpBounds(ops, options = {}) {
      if (options.minWidth == undefined) options.minWidth = 100;

      const bb = new CABLES.CG.BoundingBox();

      for (let j = 0; j < ops.length; j++) {
        if (ops[j].uiAttribs && ops[j].uiAttribs.translate) {
          bb.applyPos(
            ops[j].uiAttribs.translate.x,
            ops[j].uiAttribs.translate.y,
            0,
          );

          const glop = this.patchRenderer.getGlOp(ops[j]);
          if (glop)
            bb.applyPos(
              ops[j].uiAttribs.translate.x + glop.w,
              ops[j].uiAttribs.translate.y + glop.h,
              0,
            );
          else
            bb.applyPos(
              ops[j].uiAttribs.translate.x + gluiconfig.opWidth,
              ops[j].uiAttribs.translate.y + gluiconfig.opHeight,
              0,
            );
        }
      }

      bb.calcCenterSize();
      return bb;
    }

    getSelectionBounds(minWidth) {
      const ops = this.getSelectedOps();
      return this.getOpBounds(ops, { minWidth: minWidth });
    }

    getDistScore(primAxis, secAxis, primAxisB, secAxisB) {
      let score = 0;

      if (primAxis != primAxisB) score = Math.abs(primAxis - primAxisB);

      if (secAxis != secAxisB) score += Math.abs(secAxis - secAxisB) * 2;

      return score;
    }

    getClosestOp() {
      let coordArr = this._patchRenderer.screenToPatchCoord(150, 150);
      let minDist = 999999;
      let foundOp = null;
      const cursub = this.getCurrentSubPatch();

      for (let i = 0; i < this._p.ops.length; i++) {
        if (
          this._p.ops[i].getSubPatch() == cursub &&
          this._p.ops[i].uiAttribs.translate
        ) {
          const a = this.getDistScore(
            this._p.ops[i].uiAttribs.translate.x,
            this._p.ops[i].uiAttribs.translate.y,
            coordArr[0],
            coordArr[1],
          );

          if (a < minDist) {
            minDist = a;
            foundOp = this._p.ops[i];
          }
        }
      }

      return foundOp;
    }

    cursorNavOps(x, y) {
      const ops = this.getSelectedOps();
      let curOp;
      if (ops.length == 0) curOp = this.getClosestOp();
      else curOp = ops[0];

      if (!curOp) return;

      const cursub = this.getCurrentSubPatch();

      let foundOp = null;
      let foundOpScore = 9999999;

      for (let i = 0; i < this._p.ops.length; i++) {
        const op = this._p.ops[i];
        if (op.getSubPatch() == cursub && op.uiAttribs.translate) {
          if (y == 1 && op.uiAttribs.translate.y > curOp.uiAttribs.translate.y) {
            const score = this.getDistScore(
              curOp.uiAttribs.translate.y,
              curOp.uiAttribs.translate.x,
              op.uiAttribs.translate.y,
              op.uiAttribs.translate.x,
            );
            // this._log.log("  score", op.name, score);
            if (score < foundOpScore) {
              foundOp = op;
              foundOpScore = score;
            }
          } else if (
            y == -1 &&
            op.uiAttribs.translate.y < curOp.uiAttribs.translate.y
          ) {
            const score = this.getDistScore(
              curOp.uiAttribs.translate.y,
              curOp.uiAttribs.translate.x,
              op.uiAttribs.translate.y,
              op.uiAttribs.translate.x,
            );
            // this._log.log("  score", op.name, score);
            if (score < foundOpScore) {
              foundOp = op;
              foundOpScore = score;
            }
          } else if (
            x == 1 &&
            op.uiAttribs.translate.x > curOp.uiAttribs.translate.x
          ) {
            const score = this.getDistScore(
              curOp.uiAttribs.translate.x,
              curOp.uiAttribs.translate.y,
              op.uiAttribs.translate.x,
              op.uiAttribs.translate.y,
            );
            // this._log.log("  score", op.name, score);
            if (score < foundOpScore) {
              foundOp = op;
              foundOpScore = score;
            }
          } else if (
            x == -1 &&
            op.uiAttribs.translate.x < curOp.uiAttribs.translate.x
          ) {
            const score = this.getDistScore(
              curOp.uiAttribs.translate.x,
              curOp.uiAttribs.translate.y,
              op.uiAttribs.translate.x,
              op.uiAttribs.translate.y,
            );
            // this._log.log("  score", op.name, score);
            if (score < foundOpScore) {
              foundOp = op;
              foundOpScore = score;
            }
          }
        }
      }

      if (foundOp) {
        this.setSelectedOpById(foundOp.id);
        this.focusOp(foundOp.id);
      }
    }

    getSelectedOpsIds() {
      const perf = Gui$1.gui.uiProfiler.start("patchview getSelectedOpsIds");
      const ops = [];

      for (let i = 0; i < this._p.ops.length; i++)
        if (this._p.ops[i].uiAttribs.selected) ops.push(this._p.ops[i].id);

      perf.finish();

      return ops;
    }

    /**
     * @returns {Array<UiOp>}
     */
    getSelectedOps() {
      const perf = Gui$1.gui.uiProfiler.start("patchview getSelectedOps");
      const ops = [];

      for (let i = 0; i < this._p.ops.length; i++)
        if (
          this._p.ops[i] &&
          this._p.ops[i].uiAttribs &&
          this._p.ops[i].uiAttribs.selected
        )
          ops.push(this._p.ops[i]);

      perf.finish();

      return ops;
    }

    /** @param {boolean} firstOnly */
    unlinkSelectedOps(firstOnly) {
      const undoGroup = undo.startGroup();
      const ops = this.getSelectedOps();
      if (firstOnly) {
        for (const i in ops) {
          if (ops[i].portsIn.length > 0 && ops[i].portsOut.length > 0) {
            let portIn = ops[i].getFirstPortIn();
            let portOut = ops[i].getFirstPortOut();

            if (
              portOut.type == portIn.type &&
              (portOut.isLinked() || portIn.isLinked())
            ) {
              let outerIn = [];
              let outerOut = [];
              let relink = portOut.isLinked() && portIn.isLinked();

              if (relink) {
                for (let o = 0; o < portIn.links.length; o++)
                  outerOut.push(portIn.links[o].getOtherPort(portIn));

                for (let o = 0; o < portOut.links.length; o++)
                  outerIn.push(portOut.links[o].getOtherPort(portOut));
              }

              portOut.removeLinks();
              portIn.removeLinks();

              if (relink) {
                for (let j = 0; j < outerIn.length; j++)
                  for (let o = 0; o < outerOut.length; o++)
                    ops[i].patch.link(
                      outerIn[j].op,
                      outerIn[j].getName(),
                      outerOut[o].op,
                      outerOut[o].getName(),
                    );
              }
            }
          }
        }
      } else {
        for (const i in ops) ops[i].unLinkReconnectOthers();
      }
      undo.endGroup(undoGroup, "Unlink selected Ops");
    }

    deleteSelectedOps() {
      if (window.Gui.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_FULL) return;

      const undoGroup = undo.startGroup();
      const ids = [];
      const ops = this.getSelectedOps();

      for (let i = 0; i < ops.length; i++) ids.push(ops[i].id);
      for (let i = 0; i < ids.length; i++) this._p.deleteOp(ids[i], true);

      undo.endGroup(undoGroup, "Delete selected ops");
    }

    createAreaFromSelection() {
      // const selectedOus = this.getSelectedOps();
      const bounds = this.getSelectionBounds();
      const padding = 80;
      const trans = {
        x: Snap.snapOpPosX(bounds.minX - 0.8 * padding),
        y: Snap.snapOpPosY(bounds.minY - 1.2 * padding),
      };

      const areaOp = this._p.addOp(defaultOps.defaultOpNames.uiArea, {
        translate: trans,
        subPatch: this.getCurrentSubPatch(),
        area: {
          w: Snap.snapOpPosX(bounds.maxX - bounds.minX + 2.75 * padding),
          h: Snap.snapOpPosY(bounds.maxY - bounds.minY + 2 * padding),
        },
      });

      (function (opid) {
        undo.add({
          title: "paste op",
          undo() {
            Gui$1.gui.corePatch().deleteOp(opid, true);
          },
          redo() {
            Gui$1.gui.corePatch().addOp(defaultOps.defaultOpNames.uiArea, {
              translate: trans,
              area: {
                w: Snap.snapOpPosX(bounds.maxX - bounds.minX + 2.75 * padding),
                h: Snap.snapOpPosY(bounds.maxY - bounds.minY + 2.2 * padding),
              },
            });
          },
        });
      })(areaOp.id);
    }

    createSubPatchFromSelection(version = 0, next = null, options = {}) {
      let opname = defaultOps.defaultOpNames.subPatch;
      if (version == 2) opname = defaultOps.defaultOpNames.subPatch2;

      const selectedOps = this.getSelectedOps();

      Gui$1.gui.serverOps.loadOpDependencies(opname, () => {
        const bounds = this.getSelectionBounds();
        let trans = {
          x: bounds.minX + (bounds.maxX - bounds.minX) / 2,
          y: bounds.minY,
        };

        if (options.translate) trans = options.translate;

        // opname = defaultOps.defaultOpNames.subPatch;
        // if (version == 2)opname = defaultOps.defaultOpNames.subPatch2;

        const patchOp = this._p.addOp(opname, {
          translate: trans,
          subPatch: this.getCurrentSubPatch(),
        });
        const patchId = patchOp.patchId.get();

        if (version < 2) {
          for (let i in selectedOps) {
            // if (selectedOps[i].uiAttribs.subPatch == this.getCurrentSubPatch())
            selectedOps[i].setUiAttribs({ subPatch: patchId });
          }

          for (let i = 0; i < selectedOps.length; i++) {
            for (let j = 0; j < selectedOps[i].portsIn.length; j++) {
              const theOp = selectedOps[i];
              let found = null;
              for (let k = 0; k < theOp.portsIn[j].links.length; k++) {
                const otherPort = theOp.portsIn[j].links[k].getOtherPort(
                  theOp.portsIn[j],
                );
                const otherOp = otherPort.op;
                if (otherOp.uiAttribs.subPatch != patchId) {
                  theOp.portsIn[j].links[k].remove();
                  k--;

                  if (found) {
                    this._p.link(
                      otherPort.op,
                      otherPort.getName(),
                      patchOp,
                      found,
                    );
                  } else {
                    this._p.link(
                      otherPort.op,
                      otherPort.getName(),
                      patchOp,
                      patchOp.dyn.name,
                    );

                    found = patchOp.addSubLink(theOp.portsIn[j], otherPort);
                  }
                }
              }

              if (theOp.portsOut[j]) {
                for (let k = 0; k < theOp.portsOut[j].links.length; k++) {
                  const otherPortOut = theOp.portsOut[j].links[k].getOtherPort(
                    theOp.portsOut[j],
                  );
                  if (otherPortOut) {
                    const otherOpOut = otherPortOut.op;
                    if (otherOpOut.uiAttribs.subPatch != patchId) {
                      theOp.portsOut[j].links[k].remove();
                      this._p.link(
                        otherPortOut.op,
                        otherPortOut.getName(),
                        patchOp,
                        patchOp.dynOut.name,
                      );
                      patchOp.addSubLink(theOp.portsOut[j], otherPortOut);
                    }
                  }
                }
              }
            }
          }
        } else {
          for (let i in selectedOps) {
            if (selectedOps[i].uiAttribs.subPatch == this.getCurrentSubPatch())
              selectedOps[i].setUiAttribs({ subPatch: patchId });
          }

          this.setPositionSubPatchInputOutputOps();

          if (next) next(patchId, patchOp);

          // }, 100);
        }

        Gui$1.gui.patchView.setCurrentSubPatch(this.getCurrentSubPatch());
        this._p.emitEvent("subpatchCreated");
      });
    }

    setPositionSubPatchInputOutputOps(patchId) {
      const b = this.getSubPatchBounds(patchId);

      if (!patchId) return;

      let patchInputOPs = this._p.getSubPatchOpsByName(
        patchId,
        defaultOps.defaultOpNames.subPatchInput2,
      );
      let patchOutputOPs = this._p.getSubPatchOpsByName(
        patchId,
        defaultOps.defaultOpNames.subPatchOutput2,
      );

      if (patchInputOPs.length == 0) {
        if (this._p.clearSubPatchCache) this._p.clearSubPatchCache(this.patchId);

        this._p.addOp(defaultOps.defaultOpNames.subPatchInput2, {
          subPatch: patchId,
          translate: { x: 0, y: 0 },
        });
        this._p.addOp(defaultOps.defaultOpNames.subPatchOutput2, {
          subPatch: patchId,
          translate: { x: 0, y: 0 },
        });
      }

      if (patchInputOPs.length > 1) this._log.warn("too many input ops?");
      if (patchOutputOPs.length > 1) this._log.warn("too many output ops?");

      let patchInputOP = patchInputOPs[0];
      let patchOutputOP = patchOutputOPs[0];

      let x = 0;
      if (patchInputOP || patchOutputOP) {
        x = (patchInputOP || patchOutputOP).uiAttribs.translate.x;

        if (x < b.minX) x = b.minX;
        if (x > b.maxX) x = b.maxX;
      }

      if (patchInputOP) {
        let y = Math.min(
          patchInputOP.uiAttribs.translate.y,
          b.minY - gluiconfig.newOpDistanceY * 2,
        );

        patchInputOP.setUiAttribs({
          translate: {
            x: x,
            y: y,
          },
        });
      }

      if (patchOutputOP) {
        let y = Math.max(
          patchOutputOP.uiAttribs.translate.y,
          b.maxY + gluiconfig.newOpDistanceY * 2,
        );

        patchOutputOP.setUiAttribs({
          translate: {
            x: x,
            y: y,
          },
        });
      }
    }

    getSubPatchName(subpatch) {
      if (subpatch == 0) return "Main";

      const op = Gui$1.gui.corePatch().getSubPatchOuterOp(subpatch);
      if (!op) return null;
      return op.name;
    }

    getSubpatchPathArray(subId, arr) {
      arr = arr || [];
      const ops = Gui$1.gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++) {
        if (ops[i].isSubPatchOp() && ops[i].patchId) {
          if (ops[i].patchId.get() == subId) {
            let type = "subpatch";
            // if (ops[i].storage && ops[i].storage.blueprint) type = "blueprint_subpatch";
            if (ops[i].isSubPatchOp()) type = "blueprint_subpatch2";

            const patchInfo = {
              name: ops[i].name,
              id: ops[i].patchId.get(),
              type: type,
            };

            arr.push(patchInfo);
            if (ops[i].uiAttribs.subPatch !== 0)
              this.getSubpatchPathArray(ops[i].uiAttribs.subPatch, arr);
          }
        }
      }

      return arr;
    }

    removeLostSubpatches() {
      let countSubs = {};
      let foundSubPatchOps = {};
      const ops = Gui$1.gui.corePatch().ops;

      for (let i = 0; i < ops.length; i++) {
        if (!ops[i] || !ops[i].uiAttribs) continue;
        const sub = ops[i].uiAttribs.subPatch || 0;
        if (ops[i].isSubPatchOp()) foundSubPatchOps[ops[i].patchId.get()] = true;
        countSubs[sub] = countSubs[sub] || 0;
        countSubs[sub]++;
      }

      for (let subid in countSubs) {
        for (let _asub in foundSubPatchOps) {
          if (!foundSubPatchOps.hasOwnProperty(subid) && subid != 0) {
            this._log.warn("found lost subpatch...", subid);
            if (countSubs[subid] <= 2) {
              this._log.warn("deleted lost subpatch! ", subid);
              for (let i = ops.length - 1; i >= 0; i--)
                if (ops[i].uiAttribs.subPatch == subid)
                  ops[i].patch.deleteOp(ops[i].id);

              countSubs[subid] = 1000;
            }
          }
        }
      }
    }

    getSubPatches(
      sort, // flat list
    ) {
      let foundPatchIds = [];
      const foundBlueprints = {};
      let subPatches = [];
      const ops = Gui$1.gui.corePatch().ops;

      for (let i = 0; i < ops.length; i++) {
        if (ops[i].uiAttribs.hidden) continue;
        if (ops[i].patchId && ops[i].patchId.get() !== 0) {
          foundPatchIds.push(ops[i].patchId.get());
        }
      }

      for (let i = 0; i < ops.length; i++) {
        if (ops[i].uiAttribs.hidden) continue;

        if (ops[i].uiAttribs) {
          if (ops[i].uiAttribs.subPatch) {
            // && !(ops[i].storage && ops[i].storage.blueprint)
            // find lost ops, which are in subpatches, but no subpatch op exists for that subpatch..... :(
            if (foundPatchIds.indexOf(ops[i].uiAttribs.subPatch) === -1)
              foundPatchIds.push(ops[i].uiAttribs.subPatch);
          }
        }
        if (ops[i].isSubPatchOp() == 1 && ops[i].uiAttribs) {
          foundBlueprints[ops[i].id] = ops[i];
        }
      }

      foundPatchIds = CABLES.uniqueArray(foundPatchIds);

      for (let i = 0; i < foundPatchIds.length; i++) {
        let found = false;
        for (let j = 0; j < ops.length; j++) {
          if (
            ops[j].patchId != 0 &&
            ops[j].patchId &&
            ops[j].patchId.get() == foundPatchIds[i]
          ) {
            if (ops[j].uiAttribs.hidden) {
              found = true;
              break;
            }

            const o = {
              opId: ops[j].id,
              name: ops[j].getTitle(),
              id: foundPatchIds[i],
            };

            o.subPatchVer = ops[j].storage.subPatchVer;

            if (ops[j].storage && ops[j].storage.blueprint) {
              found = true;
              o.type = "blueprintSub";
            }

            o.blueprintVer = ops[j].isSubPatchOp();

            subPatches.push(o);
            found = true;
          }
        }

        if (!found && foundPatchIds[i] != 0) {
          subPatches.push({
            opId: null,
            name: "Lost subpatch " + foundPatchIds[i],
            id: foundPatchIds[i],
            type: "lostsubpatch",
          });
        }
      }

      for (const blueprintId in foundBlueprints) {
        const blueprintOp = foundBlueprints[blueprintId];
        const blueprintName = blueprintOp.uiAttribs.extendTitle || "loading...";
        subPatches.push({
          name: "Blueprint: " + blueprintName,
          id: blueprintOp.uiAttribs
            ? blueprintOp.uiAttribs.blueprintSubpatch
            : null,
          opId: blueprintOp.id,
          type: "blueprint",
        });
      }

      if (sort)
        subPatches = subPatches.sort(function (a, b) {
          return a.name.localeCompare(b.name);
        });

      return subPatches;
    }

    /**
     * @param {string|number} subPatchId
     * @returns {UiOp}
     */
    getSubPatchOuterOp(subPatchId) {
      return Gui$1.gui.corePatch().getSubPatchOuterOp(subPatchId);
    }

    /**
     * @param {String|Number} currentSubPatch
     */
    updateSubPatchBreadCrumb(currentSubPatch) {
      // this._patchRenderer.greyOutBlue =
      this._patchRenderer.greyOut = false;

      if (currentSubPatch === 0) ele.hide(this._eleSubpatchNav);
      else ele.show(this._eleSubpatchNav);

      const names = this.getSubpatchPathArray(currentSubPatch);

      let str = '<a onclick="Gui.gui.patchView.setCurrentSubPatch(0)">Main</a> ';

      for (let i = names.length - 1; i >= 0; i--) {
        if (i >= 0) str += '<span class="sparrow">&rsaquo;</span>';
        if (i == 0)
          str +=
            '<a class="' +
            names[i].type +
            '" onclick="Gui.gui.patchView.focusSubpatchOp(\'' +
            names[i].id +
            '\');"><span class="icon icon-op" style="vertical-align: sub;"></span> ' +
            names[i].name +
            "!</a>";
        else
          str +=
            '<a class="' +
            names[i].type +
            '" onclick="Gui.gui.patchView.clickSubPatchNav(\'' +
            names[i].id +
            "');\">" +
            names[i].name +
            "</a>";
      }

      if (names.length > 0) {
        if (names[0].type == "blueprint_subpatch2") ; else if (names[0].type == "blueprint_subpatch") {
          this._patchRenderer.greyOut = true;
          // this._patchRenderer.greyOutBlue = true;
          let blueprintPatchId = names[0].blueprintPatchId;
          if (!blueprintPatchId) {
            const firstBlueprint = names.find((name) => {
              return name.blueprintPatchId;
            });
            if (firstBlueprint)
              blueprintPatchId = firstBlueprint.blueprintPatchId;
          }
          let bpText = '<span class="icon icon-external"></span> Open patch';
          let bpClick =
            "window.open('" +
            platform.getCablesUrl() +
            "/edit/" +
            blueprintPatchId +
            "', '_blank');";
          if (
            Gui$1.gui.patchId === blueprintPatchId ||
            Gui$1.gui.project().shortId === blueprintPatchId
          ) {
            bpText = "Go to subpatch";
            let subpatchId = names[0].blueprintLocalSubpatch;
            if (subpatchId)
              bpClick =
                "Gui.gui.patchView.setCurrentSubPatch('" +
                subpatchId +
                "');CABLES.CMD.UI.centerPatchOps();Gui.gui.patchParamPanel.show();";
          }
          str +=
            '<a style="margin:0;" target="_blank" onclick="' +
            bpClick +
            '">' +
            bpText +
            "</a>";

          Gui$1.gui.restriction.setMessage(
            "blueprint",
            "This is a blueprint subpatch, changes will not be saved!",
          );
        }
      } else {
        Gui$1.gui.restriction.setMessage("blueprint", null);
      }

      document.getElementById("subpatch_breadcrumb").innerHTML = str;
    }

    /**
     * @param {ClipboardEvent} e
     */
    clipboardCutOps(e) {
      this.clipboardCopyOps(e);
      this.deleteSelectedOps();
    }

    serializeOps(selectedOps, _options = {}) {
      function arrayContains(arr, obj) {
        return arr.indexOf(obj) > -1;
      }

      const ops = [];
      const opIds = [];

      for (const i in selectedOps) {
        if (selectedOps[i].uiAttribs.blueprintSubpatch2) ;
        if (selectedOps[i].storage && selectedOps[i].storage.blueprint) {
          delete selectedOps[i].storage.blueprint;
        }
        if (selectedOps[i].uiAttribs.hasOwnProperty("fromNetwork")) {
          delete selectedOps[i].uiAttribs.fromNetwork;
        }
        ops.push(selectedOps[i].getSerialized());
        opIds.push(selectedOps[i].id);
      }

      for (let i = 0; i < ops.length; i++) {
        if (ops[i].storage && ops[i].storage.ref) delete ops[i].storage.ref;
        if (ops[i].uiAttribs && ops[i].uiAttribs.blueprintSubpatch2)
          delete ops[i].uiAttribs.blueprintSubpatch2;
        if (ops[i].uiAttribs && ops[i].uiAttribs.selected)
          delete ops[i].uiAttribs.selected;

        // remove links that are not fully copied...

        if (ops[i].portsIn) {
          for (let j = 0; j < ops[i].portsIn.length; j++) {
            delete ops[i].portsIn[j].expose;

            if (ops[i].portsIn[j].links) {
              let k = ops[i].portsIn[j].links.length;
              while (k--) {
                if (
                  ops[i].portsIn[j].links[k] &&
                  ops[i].portsIn[j].links[k].objIn &&
                  ops[i].portsIn[j].links[k].objOut
                ) {
                  if (
                    !arrayContains(opIds, ops[i].portsIn[j].links[k].objIn) ||
                    !arrayContains(opIds, ops[i].portsIn[j].links[k].objOut)
                  ) {
                    const p = selectedOps[0].patch
                      .getOpById(ops[i].portsIn[j].links[k].objOut)
                      .getPort(ops[i].portsIn[j].links[k].portOut);
                    ops[i].portsIn[j].links[k] = null;
                    if (
                      p &&
                      (p.type === portType.string || p.type === portType.number)
                    ) {
                      ops[i].portsIn[j].value = p.get();
                    }
                  }
                }
              }
              // numLinks += ops[i].portsIn[j].links.length;
            }
          }
        }

        if (ops[i].portsOut)
          for (let j = 0; j < ops[i].portsOut.length; j++) {
            delete ops[i].portsOut[j].expose;

            if (ops[i].portsOut[j].links) {
              let k = ops[i].portsOut[j].links.length;
              while (k--) {
                if (
                  ops[i].portsOut[j].links[k] &&
                  ops[i].portsOut[j].links[k].objIn &&
                  ops[i].portsOut[j].links[k].objOut
                ) {
                  if (
                    !arrayContains(opIds, ops[i].portsOut[j].links[k].objIn) ||
                    !arrayContains(opIds, ops[i].portsOut[j].links[k].objOut)
                  ) {
                    const p = selectedOps[0].patch
                      .getOpById(ops[i].portsOut[j].links[k].objOut)
                      .getPort(ops[i].portsOut[j].links[k].portOut);
                    ops[i].portsOut[j].links[k] = null;
                    if (
                      p &&
                      (p.type === portType.string || p.type === portType.number)
                    ) {
                      ops[i].portsOut[j].value = p.get();
                    }
                  }
                }
              }
            }
          }
      }

      return { ops: ops };
    }

    /**
     * @param {ClipboardEvent} e
     */
    clipboardCopyOps(e) {
      let selectedOps = this.getSelectedOps();

      // for (const i in selectedOps)
      // {
      //     if (selectedOps[i].isSubPatchOp() && !selectedOps[i].isBlueprint2())
      //     {
      //         this._log.log("yes....");
      //         this.selectAllOpsSubPatch(selectedOps[i].patchId.get(), true);
      //     }
      // }

      selectedOps = this.getSelectedOps();

      const ser = this.serializeOps(selectedOps);
      const ops = ser.ops;
      ops.forEach((op) => {
        op.objName = Gui$1.gui.serverOps.getOpNameByIdentifier(op.opId);
      });

      const objStr = JSON.stringify({
        ops: ops,
      });
      notify("Copied " + ops.length + " ops");

      e.clipboardData.setData("text/plain", objStr);
      e.preventDefault();
    }

    /**
     * @param {ClipboardEvent} e
     * @param {String} oldSub
     * @param {Number} mouseX
     * @param {Number} mouseY
     * @param {Function} next
     */
    clipboardPaste(e, oldSub, mouseX, mouseY, next) {
      const currentSubPatch = this.getCurrentSubPatch();

      this.isPasting = true;
      if (e.clipboardData.types.indexOf("text/plain") == -1) {
        this._log.error("clipboard not type text");
        notifyError("Paste failed");
        return;
      }
      let str = e.clipboardData.getData("text/plain");
      e.preventDefault();

      str = str.replace("```", "");
      str = str.replace("```", "");

      let pastedJson = null;
      try {
        pastedJson = JSON.parse(str);
      } catch (exp) {
        this._log.warn("pasting failed...");
      }

      const undoGroup = undo.startGroup();

      if (!pastedJson || !pastedJson.ops) return;

      if (currentSubPatch) {
        const subOuter = Gui$1.gui.patchView.getSubPatchOuterOp(currentSubPatch);
        if (subOuter && subOuter.objName) {
          for (let i = 0; i < pastedJson.ops.length; i++) {
            const pastedOp = pastedJson.ops[i];
            if (pastedOp.objName) {
              const pasteProblem = namespace$1.getNamespaceHierarchyProblem(
                subOuter.objName,
                pastedOp.objName,
              );
              if (pasteProblem) {
                notifyError("Paste failed", pasteProblem, { force: true });
                return;
              }
            }
          }
        }
      }

      let focusSubpatchop = null;
      Gui$1.gui.serverOps.loadProjectDependencies(pastedJson, (project) => {
        // change ids
        project = CABLES.Patch.replaceOpIds(project, {
          parentSubPatchId: oldSub,
        });
        for (const i in project.ops) {
          project.ops[i].uiAttribs.pasted = true;
        }

        {
          // change position of ops to paste
          let minx = Number.MAX_VALUE;
          let miny = Number.MAX_VALUE;

          for (const i in project.ops) {
            if (
              project.ops[i].uiAttribs &&
              project.ops[i].uiAttribs &&
              project.ops[i].uiAttribs.translate &&
              project.ops[i].uiAttribs.subPatch == this.getCurrentSubPatch()
            ) {
              minx = Math.min(minx, project.ops[i].uiAttribs.translate.x);
              miny = Math.min(miny, project.ops[i].uiAttribs.translate.y);
            }
          }

          for (const i in project.ops) {
            if (
              project.ops[i].uiAttribs &&
              project.ops[i].uiAttribs &&
              project.ops[i].uiAttribs.translate
            ) {
              let x = project.ops[i].uiAttribs.translate.x + mouseX - minx;
              let y = project.ops[i].uiAttribs.translate.y + mouseY - miny;
              if (UserSettings.userSettings.get("snapToGrid2")) {
                x = Snap.snapOpPosX(x);
                y = Snap.snapOpPosY(y);
              }
              project.ops[i].uiAttribs.translate.x = x;
              project.ops[i].uiAttribs.translate.y = y;
            }

            (function (opid) {
              undo.add({
                title: "paste op",
                undo() {
                  Gui$1.gui.corePatch().deleteOp(opid, true);
                },
                redo() {
                  Gui$1.gui.patchView.clipboardPaste(e);
                },
              });
            })(project.ops[i].id);
          }
        }
        notify("Pasted " + project.ops.length + " ops");
        Gui$1.gui.corePatch().deSerialize(project);
        this.isPasting = false;
        next(project.ops, focusSubpatchop);
      });
      undo.endGroup(undoGroup, "Paste");

      this.setCurrentSubPatch(currentSubPatch);
      this.unselectOpsFromOtherSubpatches();
    }

    addSpaceBetweenOpsX() {
      const bounds = this.getSelectionBounds(0);
      const ops = Gui$1.gui.patchView.getSelectedOps();
      const centerX = (bounds.minX + bounds.maxX) / 2;
      const undoGroup = undo.startGroup();

      for (let j = 0; j < ops.length; j++) {
        const diffX = ops[j].uiAttribs.translate.x - centerX;
        this.setOpPos(
          ops[j],
          Snap.snapOpPosX(centerX + diffX * 1.2),
          ops[j].uiAttribs.translate.y,
        );
      }
      undo.endGroup(undoGroup, "add space x");
    }

    addSpaceBetweenOpsY() {
      const bounds = this.getSelectionBounds(0);
      const ops = Gui$1.gui.patchView.getSelectedOps();
      const centerY = (bounds.minY + bounds.maxY) / 2;
      const undoGroup = undo.startGroup();

      for (let j = 0; j < ops.length; j++) {
        const diffY = ops[j].uiAttribs.translate.y - centerY;
        this.setOpPos(
          ops[j],
          ops[j].uiAttribs.translate.x,
          Snap.snapOpPosY(centerY + diffY * 1.8),
        );
      }
      undo.endGroup(undoGroup, "add space y");
    }

    compressSelectedOps(ops) {
      if (!ops || ops.length === 0) return;

      const undoGroup = undo.startGroup();

      this.saveUndoSelectedOpsPositions(ops);

      // ops.sort(function (a, b) { return a.uiAttribs.translate.y - b.uiAttribs.translate.y; });

      // let y = 0;
      // for (let j = 0; j < ops.length; j++)
      // {
      //     y += ops[j].uiAttribs.translate.y;
      // }
      // y = Snap.snapOpPosY(y / ops.length);

      // for (let j = 0; j < ops.length; j++)
      // {
      //     y = Snap.snapOpPosY(y);
      //     this.setOpPos(ops[j], ops[j].uiAttribs.translate.x, y);
      //     this.testCollision(ops[j]);
      // }

      this.cleanOps(ops);

      undo.endGroup(undoGroup, "Compress Ops");
    }

    // _cleanOp(op, ops, theOpWidth)
    // {
    //     let changed = false;

    //     if (op.portsIn[0] && op.hasAnyInLinked())
    //     {
    //         const firstLinkedPort = op.getFirstLinkedInPort();
    //         for (let i = 0; i < firstLinkedPort.links.length; i++)
    //         {
    //             const otherPort = firstLinkedPort.links[i].getOtherPort(firstLinkedPort);

    //             if (ops.indexOf(otherPort.op) == -1) return;

    //             let linkIndex = otherPort.links.indexOf(firstLinkedPort.links[i]);
    //             let extraLines = 1;
    //             for (let j = otherPort.op.portsOut.length - 1; j >= 0; j--)
    //             {
    //                 if (otherPort == otherPort.op.portsOut[j]) break;
    //                 if (otherPort.op.portsOut[j].isLinked())extraLines++;
    //             }

    //             changed = true;
    //             if (otherPort.links.length > 1)extraLines++;

    //             let portIndex = otherPort.op.portsOut.indexOf(otherPort);

    //             this.setTempOpPos(op, otherPort.op.getTempPosX() + (linkIndex * theOpWidth + portIndex * 30), otherPort.op.getTempPosY() + extraLines * glUiConfig.newOpDistanceY);
    //         }
    //     }

    //     if (this.testCollision(op))changed = true;
    // }

    cleanOps(ops) {
      new opCleaner(ops, this.patchRenderer);
      // c.clean();
      //     if (ops.length == 0) return
      //     const entranceOps = [];
      //     const unconnectedOps = [];
      //     const otherOps = [];
      //     let startPosX = ops[0].uiAttribs.translate.x;
      //     let startPosY = ops[0].uiAttribs.translate.y;

      //     let longestOpPorts = 0;

      //     for (let i = 0; i < ops.length; i++)
      //     {
      //         startPosX = Math.min(startPosX, ops[i].uiAttribs.translate.x);
      //         startPosY = Math.min(startPosY, ops[i].uiAttribs.translate.y);

      //         longestOpPorts = Math.max(longestOpPorts, ops[i].portsIn.length);
      //         longestOpPorts = Math.max(longestOpPorts, ops[i].portsOut.length);

      //         this.setTempOpPos(ops[i], ops[i].uiAttribs.translate.x, ops[i].uiAttribs.translate.y);

      //         if (!ops[i].hasAnyInLinked() && ops[i].hasAnyOutLinked())
      //         {
      //             entranceOps.push(ops[i]);
      //             continue;
      //         }

      //         if (ops[i].isInLinkedToOpOutside(ops))
      //         {
      //             entranceOps.push(ops[i]);
      //             continue;
      //         }

      //         if (!ops[i].hasLinks())
      //         {
      //             unconnectedOps.push(ops[i]);
      //             continue;
      //         }
      //         otherOps.push(ops[i]);
      //     }

      //     let theOpWidth = Snap.snapOpPosX((longestOpPorts + 1) * (glUiConfig.portWidth + glUiConfig.portPadding));

      //     for (let i = 0; i < ops.length; i++)
      //         this.setTempOpPos(ops[i], startPosX, startPosY);

      // let firstRowX = Snap.snapOpPosX(startPosX);
      // startPosY = Snap.snapOpPosY(startPosY);

      // for (let i = 0; i < entranceOps.length; i++)
      // {
      //     this.setTempOpPos(entranceOps[i], firstRowX, startPosY);
      //     firstRowX = Snap.snapOpPosX(firstRowX + theOpWidth);
      // }

      // for (let i = 0; i < unconnectedOps.length; i++)
      // {
      //     this.setTempOpPos(unconnectedOps[i], firstRowX, startPosY);
      //     firstRowX = Snap.snapOpPosX(firstRowX + theOpWidth);
      // }

      // let count = 0;
      // let found = true;
      // while (count < 100 || found)
      // {
      //     found = false;
      //     count++;
      //     for (let i = 0; i < otherOps.length; i++)
      //         if (this._cleanOp(otherOps[i], ops, theOpWidth))found = true;
      // }

      // for (let i = 0; i < ops.length; i++)
      // {
      //     const op = ops[i];
      //     if (op.uiAttribs.translateTemp)
      //     {
      //         this.setOpPos(op, op.getTempPosX(), op.getTempPosY());
      //         delete op.uiAttribs.translateTemp;
      //     }
      // }

      // this._log.log(count + "iterations");
    }

    alignSelectedOpsVert(ops) {
      if (ops.length == 1) {
        const op = ops[0];
        if (op.getFirstPortIn() && op.getFirstPortIn().links.length) {
          const pre = op.getFirstPortIn().links[0].portOut.op;

          if (pre.uiAttribs.translate && op.uiAttribs.translate)
            op.setUiAttrib({
              translate: {
                x: pre.uiAttribs.translate.x,
                y: op.uiAttribs.translate.y,
              },
            });
        }
      }

      if (ops.length > 0) {
        let j = 0;
        let sum = 0;
        for (j in ops) sum += ops[j].uiAttribs.translate.x;

        let avg = sum / ops.length;

        if (UserSettings.userSettings.get("snapToGrid2"))
          avg = Snap.snapOpPosX(avg);

        for (j in ops) this.setOpPos(ops[j], avg, ops[j].uiAttribs.translate.y);
      }
      return ops;
    }

    alignSelectedOpsHor(ops) {
      if (ops.length > 0) {
        let j = 0,
          sum = 0;
        for (j in ops) sum += ops[j].uiAttribs.translate.y;

        let avg = sum / ops.length;

        if (UserSettings.userSettings.get("snapToGrid2"))
          avg = Snap.snapOpPosY(avg);

        for (j in ops) this.setOpPos(ops[j], ops[j].uiAttribs.translate.x, avg);
      }
      return ops;
    }

    setOpPos(op, x, y) {
      if (op && op.uiAttribs && op.uiAttribs.translate) {
        const oldX = op.uiAttribs.translate.x;
        const oldY = op.uiAttribs.translate.y;
        undo.add({
          title: "Move op",
          context: {
            opname: op.name,
          },
          undo() {
            op.setUiAttribs({ translate: { x: oldX, y: oldY } });
          },
          redo() {
            op.setUiAttribs({ translate: { x: x, y: y } });
          },
        });
      }

      op.setUiAttribs({
        translate: {
          x: x,
          y: y,
        },
      });
    }

    /**
     * @param {Array<UiOp>} selectedOps
     */
    saveUndoSelectedOpsPositions(selectedOps) {
      const opPositions = [];
      for (let j = 0; j < selectedOps.length; j++) {
        const obj = {};
        obj.id = selectedOps[j].id;

        if (!selectedOps[j].uiAttribs) selectedOps[j].uiAttribs = {};
        if (!selectedOps[j].uiAttribs.translate)
          selectedOps[j].uiAttribs.translate = { x: 0, y: 0 };

        obj.x = selectedOps[j].uiAttribs.translate.x;
        obj.y = selectedOps[j].uiAttribs.translate.y;
        opPositions.push(obj);
      }

      undo.add({
        title: "save op positions",
        undo() {
          for (let j = 0; j < opPositions.length; j++) {
            const obj = opPositions[j];
            const op = Gui$1.gui.corePatch().getOpById(obj.id);
            Gui$1.gui.patchView.setOpPos(op, obj.x, obj.y);
          }
        },
        redo() {
          // Gui.gui.scene().addOp(objName, op.uiAttribs, opid);
        },
      });
    }

    alignOps(selectedOps) {
      const undoGroup = undo.startGroup();

      this.saveUndoSelectedOpsPositions(selectedOps);
      this.alignSelectedOpsVert(selectedOps);

      undo.endGroup(undoGroup, "Align Ops");

      return selectedOps;
    }

    unlinkPort(opid, portid) {
      const op = Gui$1.gui.corePatch().getOpById(opid);
      const p = op.getPortById(portid);

      if (!p) {
        this._log.warn("[unlinkport] portnot found ");
        return;
      }

      const undoGroup = undo.startGroup();

      p.removeLinks();
      undo.endGroup(undoGroup, "Unlink Port");
    }

    linkPortToOp(e, opid, pid, op2id) {
      let op1 = this._p.getOpById(opid);
      let op2 = this._p.getOpById(op2id);
      const p = op1.getPort(pid);
      const numFitting = op2.countFittingPorts(p);

      const isInnerOp =
        op2.objName == defaultOps.defaultOpNames.subPatchInput2 ||
        op2.objName == defaultOps.defaultOpNames.subPatchOutput2;
      const isbpOp = op2.isSubPatchOp() || isInnerOp;

      if (isbpOp || numFitting > 1) {
        new SuggestPortDialog(op2, p, e, (thePort, newOpId, options) => {
          if (options.createSpOpPort) {
            subPatchOpUtil.addPortToBlueprint(options.op.opId, p, {
              reverseDir: !isInnerOp,
              cb: (newPortJson, newOp) => {
                this._p.link(op1, pid, newOp, newPortJson.id);
              },
            });
          } else {
            op2 = this._p.getOpById(newOpId);
            this._p.link(op1, pid, op2, thePort.name);
          }
        });
      } else {
        const fitp = op2.findFittingPort(p);
        if (fitp) this._p.link(op1, pid, op2, fitp.name);
      }
    }

    linkPortsToOp(e, opid, opids, portnames) {
      if (!opids || opids.length == 0 || !portnames || portnames.length == 0)
        return;

      const op1 = this._p.getOpById(opid);
      let op2 = this._p.getOpById(opids[0]);
      const p = op2.getPort(portnames[0]);
      const numFitting = op1.countFittingPorts(p);

      if (numFitting > 1) {
        new SuggestPortDialog(op1, p, e, (suggport) => {
          if (suggport)
            for (let i = 0; i < portnames.length; i++) {
              op2 = this._p.getOpById(opids[i]);
              this._p.link(op2, portnames[i], op1, suggport.id);
            }
        });
      } else {
        const fitp = op1.findFittingPort(p);

        if (fitp)
          for (let i = 0; i < portnames.length; i++) {
            op2 = this._p.getOpById(opids[i]);
            this._p.link(op2, portnames[i], op1, fitp.name);
          }
      }
    }

    linkPorts(opid, pid, op2id, p2id, event) {
      let op1 = this._p.getOpById(opid);
      let op2 = this._p.getOpById(op2id);

      if (!op1 || !op2) return;

      {
        // helper number2string auto insert....
        let p1 = op1.getPortByName(pid);
        let p2 = op2.getPortByName(p2id);

        const converters = getConverters(p1, p2);

        if (converters.length == 1) {
          convertPorts(p1, p2, converters[0]);
          return;
        }
        if (converters.length > 1) {
          const suggs = [];
          for (let i = 0; i < converters.length; i++) {
            suggs.push({ name: converters[i].op });
          }

          new SuggestionDialog(suggs, op2, event, null, function (sid) {
            convertPorts(p1, p2, converters[sid]);
          });
        }
      }

      this._p.link(op1, pid, op2, p2id);
    }

    centerView(x, y) {
      if (this._patchRenderer.center) this._patchRenderer.center(x, y);
      else this._log.warn("patchRenderer has no function center");
    }

    pauseInteraction() {
      this._patchRenderer.pauseInteraction();
    }

    resumeInteraction() {
      this._patchRenderer.resumeInteraction();
    }

    /** @returns {String} */
    getCurrentSubPatch() {
      return this._patchRenderer.getCurrentSubPatch();
    }

    serialize(dataUi) {
      this._patchRenderer.serialize(dataUi);
    }

    setCurrentSubPatch(subpatch, next) {
      Gui$1.gui.restriction.setMessage("subpatchref", null);
      if (subpatch != 0) {
        const outerOp = this.getSubPatchOuterOp(subpatch);
        const ops = Gui$1.gui.savedState.getUnsavedPatchSubPatchOps();

        for (let i = 0; i < ops.length; i++) {
          if (
            ops[i].op &&
            outerOp &&
            ops[i].op.opId == outerOp.opId &&
            ops[i].op != outerOp
          ) {
            let subid = ops[i].subId;
            Gui$1.gui.restriction.setMessage(
              "subpatchref",
              "changed reference in patch: a unsaved reference of this subpatch ops exists in your patch. <br/>saving this can will overwrite references!<br/><a class='link' onclick='Gui.gui.patchView.setCurrentSubPatch(\"" +
                subid +
                "\")'>goto patch</a>",
            );
          }
        }
      }

      if (this._patchRenderer.setCurrentSubPatch) {
        this._patchRenderer.setCurrentSubPatch(subpatch, () => {
          Gui$1.gui.patchView.updateSubPatchBreadCrumb(subpatch);
          if (ele.byId("subpatchlist")) this.showDefaultPanel(); // update subpatchlist because its already visible
          if (next) next();
        });
      } else this._log.warn("patchRenderer has no function setCurrentSubPatch");

      Gui$1.gui.corePatch().emitEvent("subpatchesChanged");
    }

    focusOp(opid) {
      if (this._patchRenderer.focusOp) this._patchRenderer.focusOp(opid);
      else this._log.warn("patchRenderer has no function focusOp");
    }

    unselectAllOps() {
      for (let i = 0; i < this._p.ops.length; i++)
        if (this._p.ops[i].uiAttribs.selected)
          this._p.ops[i].setUiAttribs({ selected: false });
    }

    unselectOpsFromOtherSubpatches() {
      const ops = this.getSelectedOps();
      for (let i = 0; i < ops.length; i++)
        if (ops[i].uiAttribs.subPatch != this.getCurrentSubPatch())
          ops[i].setUiAttribs({ selected: false });
    }

    /**
     * @param {String} id
     */
    selectOpId(id) {
      const op = this._p.getOpById(id);
      if (op) op.setUiAttribs({ selected: true });
    }

    /**
     * @param {String} opid
     */
    centerSelectOp(opid) {
      this.setSelectedOpById(opid);
      this._patchRenderer.viewBox.centerSelectedOps();
      console.log(Gui$1.gui.patchView.getSelectedOps());
      if (Gui$1.gui.patchView.getSelectedOps().length == 1)
        this.focusOpAnim(Gui$1.gui.patchView.getSelectedOps()[0].id);
      this.focus();
    }

    /**
     * @param {String} opid
     */
    setSelectedOpById(opid) {
      if (this._patchRenderer.setSelectedOpById)
        this._patchRenderer.setSelectedOpById(opid);
      // else if (this._patchRenderer.selectOpId) this._patchRenderer.selectOpId(opid);
      else this._log.warn("patchRenderer has no function setSelectedOpById");
    }

    /**
     * @param {String} id
     */
    selectChilds(id) {
      const op = Gui$1.gui.corePatch().getOpById(id);
      op.selectChilds();
    }

    setUnsaved() {
      // Gui.gui.setStateUnsaved({ "subPatch": this.getCurrentSubPatch });
      // Gui.gui.savedState.setUnSaved("patchview??", this.getCurrentSubPatch());
      Gui$1.gui.savedState.setUnSaved("patchview??");
    }

    _portValidate(p1, p2) {
      if (p1.type != portType.object) return;
      let inp = null;
      let outp = null;

      if (p1.direction === PortDir.in) {
        inp = p1;
        outp = p2;
      } else {
        inp = p2;
        outp = p1;
      }

      const id = "_validator" + inp.name;

      inp.op.setUiError(id, null);

      if (!inp.isLinked()) return;
      if (inp.uiAttribs.ignoreObjTypeErrors) return;
      if (outp.get() == null) return;

      if (p1.uiAttribs.objType && p2.uiAttribs.objType) {
        if (p1.uiAttribs.objType == p2.uiAttribs.objType) return;
        if (
          p1.uiAttribs.objType.indexOf("sg_") == 0 &&
          p2.uiAttribs.objType.indexOf("sg_") == 0
        )
          return;
      }

      const errorMsg =
        "Object in port <b>" +
        inp.name +
        "</b> is not of type " +
        inp.uiAttribs.objType;

      // check if both have defined objtype
      if (
        p1.uiAttribs.objType &&
        p2.uiAttribs.objType &&
        p1.uiAttribs.objType != p2.uiAttribs.objType
      ) {
        inp.op.setUiError(id, errorMsg);
        return;
      }

      // validate by object value
      if (inp.uiAttribs.objType && outp.get()) {
        if (
          inp.uiAttribs.objType == "texture" &&
          !(outp.get() instanceof WebGLTexture)
        )
          inp.op.setUiError(id, errorMsg);
        if (
          inp.uiAttribs.objType == "geometry" &&
          !(outp.get() instanceof CGL.Geometry)
        )
          inp.op.setUiError(id, errorMsg);
        if (
          inp.uiAttribs.objType == "shader" &&
          !(outp.get() instanceof CGL.Shader)
        )
          inp.op.setUiError(id, errorMsg);
        if (
          inp.uiAttribs.objType == "element" &&
          !(outp.get() instanceof Element)
        )
          inp.op.setUiError(id, errorMsg);
        // * audio
        if (
          inp.uiAttribs.objType == "audioBuffer" &&
          !(outp.get() instanceof AudioBuffer)
        )
          inp.op.setUiError(id, errorMsg);
        if (
          inp.uiAttribs.objType == "audioNode" &&
          !(outp.get() instanceof AudioNode)
        )
          inp.op.setUiError(id, errorMsg);
      }
    }

    refreshCurrentOpParamsByPort(p1, p2) {
      if (this.isCurrentOp(p2.op) || this.isCurrentOp(p1.op))
        Gui$1.gui.opParams.refresh();
    }

    isCurrentOp(op) {
      return Gui$1.gui.opParams.isCurrentOp(op);
    }

    isCurrentOpId(opid) {
      return Gui$1.gui.opParams.isCurrentOpId(opid);
    }

    copyOpInputPorts(origOp, newOp) {
      for (let i = 0; i < origOp.portsIn.length; i++) {
        for (let j = 0; j < newOp.portsIn.length; j++) {
          if (
            newOp.portsIn[j].name.toLowerCase() ==
            origOp.portsIn[i].name.toLowerCase()
          )
            newOp.portsIn[j].set(origOp.portsIn[i].get());
        }
      }
    }

    downGradeOp(opid, opname) {
      if (!Gui$1.gui.opDocs.getOpDocByName(opname)) {
        notify("op has no versions....");
        return;
      }

      const versions = Gui$1.gui.opDocs.getOpDocByName(opname).versions;
      if (versions.length > 1) {
        let name = versions[0].name;
        for (let i = 0; i < versions.length; i++) {
          if (versions[i].name == opname) break;
          name = versions[i].name;
        }

        this.replaceOp(opid, name);
      } else {
        notify("could not downgrade: has no previous version");
      }

      this.unselectAllOps();
    }

    replaceOpCheck(opid, newOpObjName) {
      Gui$1.gui.serverOps.loadOpDependencies(newOpObjName, () => {
        this.addOp(newOpObjName, {
          onOpAdd: (newOp) => {
            const origOp = this._p.getOpById(opid);

            if (!newOp || !origOp) {
              this._log.warn("could not replace op.?", newOp, origOp);
              return;
            }

            let allFine = true;
            let html = "<h3>Replacing Op</h3>";

            html +=
              "Replacing <b>" +
              origOp.objName +
              "</b> with <b>" +
              newOp.objName +
              "</b><br/><br/>";

            let htmlList = "";
            htmlList += "<table>";
            for (let i = 0; i < origOp.portsIn.length; i++) {
              let found = false;

              htmlList += "<tr>";
              htmlList += "<td>Port " + origOp.portsIn[i].name + "</td>";

              for (let j = 0; j < newOp.portsIn.length; j++) {
                if (newOp.portsIn[j] && origOp.portsIn[i]) {
                  if (
                    newOp.portsIn[j].name.toLowerCase() ==
                    origOp.portsIn[i].name.toLowerCase()
                  ) {
                    found = true;
                    break;
                  }
                }
              }

              htmlList += "<td>";
              if (!found) {
                htmlList += "NOT FOUND in new version!";
                allFine = false;
              }

              htmlList += "</td>";
              htmlList += "</tr>";
            }

            this._p.deleteOp(newOp.id);
            htmlList += "</table>";

            if (allFine) {
              Gui$1.gui.patchView.replaceOp(opid, newOpObjName);
              return;
              // html += "All old ports are available in the new op, it should be safe to replace with new version. Make sure you test if it behaves the same, very accurately.<br/><br/>";
            } else {
              html +=
                "Not all old Ports are available in never version of the op. Make sure you test if it behaves the same, very accurately.<br/><br/>";
              html += htmlList;
            }

            html +=
              "<br/><a onClick=\"Gui.gui.patchView.replaceOp('" +
              opid +
              "','" +
              newOpObjName +
              '\');Gui.gui.closeModal();" class="bluebutton">Really Upgrade</a>';
            html +=
              '<a onClick="Gui.gui.closeModal();" class="button">Cancel</a>';

            setTimeout(() => {
              this.setSelectedOpById(origOp.id);
            }, 100);

            this.selectOpId(newOp.id);
            Gui$1.gui.opParams.show(newOp.id);
            this._patchRenderer.focusOpAnim(newOp.id);

            new ModalDialog({ html: html });
          },
        });
      });
    }

    replaceOp(opid, newOpObjName, cb = null) {
      Gui$1.gui.serverOps.loadOpDependencies(newOpObjName, () => {
        this.addOp(newOpObjName, {
          onOpAdd: (newOp) => {
            const origOp = this._p.getOpById(opid);

            if (origOp) {
              const oldUiAttribs = JSON.parse(JSON.stringify(origOp.uiAttribs));

              const theUiAttribs = {};
              for (const i in oldUiAttribs) {
                if (i == "uierrors") continue;
                theUiAttribs[i] = oldUiAttribs[i];
              }
              newOp.setUiAttrib(theUiAttribs);

              this.copyOpInputPorts(origOp, newOp);

              for (let i = 0; i < origOp.portsIn.length; i++) {
                for (let j = 0; j < origOp.portsIn[i].links.length; j++) {
                  const otherPort = origOp.portsIn[i].links[j].getOtherPort(
                    origOp.portsIn[i],
                  );
                  this._p.link(
                    otherPort.op,
                    otherPort.name.toLowerCase(),
                    newOp,
                    origOp.portsIn[i].name.toLowerCase(),
                    true,
                  );
                }
              }

              for (let i = 0; i < origOp.portsOut.length; i++) {
                for (let j = 0; j < origOp.portsOut[i].links.length; j++) {
                  const otherPort = origOp.portsOut[i].links[j].getOtherPort(
                    origOp.portsOut[i],
                  );
                  this._p.link(
                    otherPort.op,
                    otherPort.name.toLowerCase(),
                    newOp,
                    origOp.portsOut[i].name.toLowerCase(),
                    true,
                  );
                }
              }

              this._p.deleteOp(origOp.id);

              setTimeout(() => {
                newOp.setUiAttrib(theUiAttribs);
                this.setCurrentSubPatch(oldUiAttribs.subPatch || 0);
                if (cb) cb();
              }, 100);
            } else {
              this._log.error("no origop ?!");
            }
          },
        });
      });
    }

    // tempUnlinkOp()
    // {
    //     if (this._lastTempOP)
    //     {
    //         this._lastTempOP.undoUnLinkTemporary();
    //         this._lastTempOP.setEnabled(true);
    //         this._lastTempOP = null;
    //     }
    //     else
    //     {
    //         const op = this.getSelectedOps()[0];
    //         if (op)
    //         {
    //             op.setEnabled(false);
    //             op.unLinkTemporary();
    //             this._lastTempOP = op;
    //         }
    //     }
    // }

    toggleVisibility() {
      Gui$1.gui.patchView.element.classList.toggle("hidden");
      Gui$1.gui.patchView.patchRenderer.vizLayer._eleCanvas.classList.toggle(
        "hidden",
      );
      Gui$1.gui.emitEvent("canvasModeChange");
    }

    setVisibility(b) {
      if (b) {
        Gui$1.gui.patchView.element.classList.remove("hidden");
        Gui$1.gui.patchView.patchRenderer.vizLayer._eleCanvas.classList.remove(
          "hidden",
        );
      } else {
        Gui$1.gui.patchView.element.classList.add("hidden");
        Gui$1.gui.patchView.patchRenderer.vizLayer._eleCanvas.classList.add(
          "hidden",
        );
      }
    }

    setPortTitle(opId, portName, oldtitle) {
      new ModalDialog({
        prompt: true,
        title: "Set Title",
        text: "Enter a custom title for this port",
        promptValue: oldtitle,
        promptOk: function (name) {
          const op = Gui$1.gui.corePatch().getOpById(opId);
          const p = op.getPort(portName);
          p.setUiAttribs({ title: name });

          Gui$1.gui.opParams.show(opId);
        },
      });
    }

    insertOpInLink(oldLink, op, x, y) {
      let newPortIn = op.getFirstPortIn();
      let newPortOut = op.getFirstPortOut();

      if (!newPortIn || !newPortOut) return;
      if (newPortIn.isLinked() || newPortOut.isLinked()) return;

      let portIn = oldLink.portIn;
      let portOut = oldLink.portOut;

      if (oldLink.p1 && oldLink.p2) {
        portIn = oldLink.p1.thePort;
        portOut = oldLink.p2.thePort;

        if (oldLink.p2.thePort.direction == PortDir.in) {
          portIn = oldLink.p2.thePort;
          portOut = oldLink.p1.thePort;
        }
        oldLink.unlink();
      } else {
        oldLink.remove();
      }

      if (portIn && portOut && newPortOut) {
        // && !newPortIn.isLinked()
        if (CABLES.Link.canLink(newPortIn, portOut)) {
          //! portOut.isLinked() &&
          gui
            .corePatch()
            .link(op, newPortIn.getName(), portOut.op, portOut.getName());

          gui
            .corePatch()
            .link(op, newPortOut.getName(), portIn.op, portIn.getName());

          op.setUiAttrib({ translate: { x: x, y: y } });
        } else {
          gui
            .corePatch()
            .link(portIn.op, portIn.getName(), portOut.op, portOut.getName());
        }
      }
    }

    pause() {
      if (this._patchRenderer && this._patchRenderer.pause)
        this._patchRenderer.pause();
    }

    resume() {
      if (this._patchRenderer && this._patchRenderer.resume)
        this._patchRenderer.resume();
    }

    /**
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */
    setSize(x, y, w, h) {
      if (this._patchRenderer) this._patchRenderer.setSize(x, y, w, h);
    }

    zoomStep(step) {
      this._patchRenderer.zoomStep(step);
    }

    suggestionBetweenTwoOps(op1, op2) {
      const mouseEvent = { clientX: 400, clientY: 400 };

      const suggestions = [
        {
          cb: () => {
            Gui$1.gui.patchView.suggestionBetweenTwoOps(op2, op1);
          },
          name: "OUT: " + op1.getTitle(),
          classname: "",
        },
      ];
      if (!op1 || !op2) return;

      for (let j = 0; j < op1.portsOut.length; j++) {
        const p = op1.portsOut[j];

        const numFitting = op2.countFittingPorts(p);
        let addText = "...";
        if (numFitting > 0) {
          if (numFitting == 1) {
            const p2 = op2.findFittingPort(p);
            addText = p2.title;
          }

          suggestions.push({
            p: p,
            name: p.title + "  " + addText,
            classname: "port_text_color_" + p.getTypeString().toLowerCase(),
          });
        }
      }

      if (suggestions.length === 0) {
        notify("can not link!");
        return;
      }

      const showSuggestions2 = (id) => {
        if (suggestions[id].cb) return suggestions[id].cb();

        const p = suggestions[id].p;
        const sugIn = [
          {
            cb: () => {
              Gui$1.gui.patchView.suggestionBetweenTwoOps(op2, op1);
            },
            name: '<span class="icon icon-op"></span>IN: ' + op2.getTitle(),
            classname: "",
          },
        ];

        for (let i = 0; i < op2.portsIn.length; i++) {
          if (CABLES.Link.canLink(op2.portsIn[i], p)) {
            sugIn.push({
              p: op2.portsIn[i],
              name:
                '<span class="icon icon-arrow-right"></span>' +
                op2.portsIn[i].title,
              classname:
                "port_text_color_" + op2.portsIn[i].getTypeString().toLowerCase(),
            });
          }
        }

        if (sugIn.length == 1) {
          Gui$1.gui.corePatch().link(p.op, p.name, sugIn[0].p.op, sugIn[0].p.name);
          return;
        }

        new SuggestionDialog(sugIn, op2, mouseEvent, null, function (sid) {
          Gui$1.gui
            .corePatch()
            .link(p.op, p.name, sugIn[sid].p.op, sugIn[sid].p.name);
        });
      };

      new SuggestionDialog(
        suggestions,
        op1,
        mouseEvent,
        null,
        showSuggestions2,
        false,
      );
    }

    setOpColor(col) {
      const selectedOps = this.getSelectedOps();

      for (let i = 0; i < selectedOps.length; i++)
        if (selectedOps[i].objName == defaultOps.defaultOpNames.uiArea)
          return selectedOps[i].setUiAttrib({ color: col });

      for (let i = 0; i < selectedOps.length; i++)
        selectedOps[i].setUiAttrib({ color: col });
    }

    resetOpValues(opid, portname) {
      const op = this._p.getOpById(opid);
      if (!op) {
        this._log.error("reset op values: op not found...", opid);
        return;
      }

      if (portname) {
        const p = op.getPortByName(portname);
        const oldValue = p.get();
        undo.add({
          title: "reset defaultvalue",
          undo() {
            p.set(oldValue);
            Gui$1.gui.opParams.show(op);
          },
          redo() {
            p.set(p.defaultValue);
            Gui$1.gui.opParams.show(op);
          },
        });

        p.set(p.defaultValue);
      } else {
        // all ops
        for (let i = 0; i < op.portsIn.length; i++)
          if (op.portsIn[i].defaultValue != null)
            op.portsIn[i].set(op.portsIn[i].defaultValue);
      }

      Gui$1.gui.opParams.show(op);
    }

    // getSubPatchIdFromBlueprintOpId(opid)
    // {
    //     const ops = Gui.gui.corePatch().ops;
    //     for (let i = 0; i < ops.length; i++)
    //         if (ops[i].uiAttribs && ops[i].uiAttribs.blueprintSubpatch && ops[i].id == opid)
    //             return ops[i].uiAttribs.blueprintSubpatch;
    // }

    getBlueprintOpFromBlueprintSubpatchId(bpSubpatchId) {
      const ops = Gui$1.gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++)
        if (
          ops[i].uiAttribs &&
          ops[i].uiAttribs.blueprintSubpatch &&
          ops[i].uiAttribs.blueprintSubpatch == bpSubpatchId
        )
          return ops[i];
    }

    getAllOpsInBlueprint(subid) {
      const foundOps = [];
      const ops = Gui$1.gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++) {
        if (
          ops[i].isInBlueprint2() == subid ||
          ops[i].uiAttribs.subPatch == subid
        )
          foundOps.push(ops[i]);
      }
      return foundOps;
    }

    getAllSubPatchOps(subid) {
      const foundOps = [];
      const ops = Gui$1.gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++) {
        if (ops[i] && ops[i].uiAttribs && ops[i].uiAttribs.subPatch == subid)
          foundOps.push(ops[i]);
      }
      return foundOps;
    }

    setExposedPortOrder(port, dir) {
      const ports = this.getSubPatchExposedPorts(port.op.uiAttribs.subPatch);

      Gui$1.gui.savedState.setUnSaved(
        "exposedPortOrder",
        port.op.uiAttribs.subPatch,
      );

      function move(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      }

      const idx = ports.indexOf(port);
      if (idx + dir >= 0) move(ports, idx, idx + dir);

      for (let i = 0; i < ports.length; i++) ports[i].setUiAttribs({ order: i });

      const exposeOp = this.getSubPatchOuterOp(port.op.uiAttribs.subPatch);

      if (Gui$1.gui.opParams.op == exposeOp)
        Gui$1.gui.opParams.show(
          this.getSubPatchOuterOp(port.op.uiAttribs.subPatch).id,
        );
      exposeOp.emitEvent("portOrderChanged");
      exposeOp.emitEvent("glportOrderChanged");
    }

    getSubPatchExposedPorts(_subid, _dir) {
      let foundPorts = [];
      // const ops = this.getAllSubPatchOps(subid);

      // for (let i = 0; i < ops.length; i++)
      // {
      //     if (dir == undefined || dir === PortDir.in)
      //         if (ops[i].portsIn)
      //             for (let j = 0; j < ops[i].portsIn.length; j++)
      //                 if (ops[i].portsIn[j].uiAttribs.expose)foundPorts.push(ops[i].portsIn[j]);

      //     if (dir == undefined || dir === CABLES.Port.DIR_OUT)
      //         for (let j = 0; j < ops[i].portsOut.length; j++)
      //             if (ops[i].portsOut[j].uiAttribs.expose)foundPorts.push(ops[i].portsOut[j]);
      // }

      // foundPorts = foundPorts.sort(function (a, b) { return (a.uiAttribs.order || 0) - (b.uiAttribs.order || 0); });

      // for (let i = 0; i < foundPorts.length; i++)

      return foundPorts;
    }

    replacePortValues(ops, portName, valueNew, valueOld = undefined) {
      ops.forEach((op) => {
        const port = op.getPortByName(portName);
        if (port) {
          const value = port.get();
          if (valueOld === undefined) {
            port.set(valueNew);
          } else {
            if (value === valueOld) port.set(valueNew);
          }
        }
      });
    }

    highlightExamplePatchOps() {
      if (
        Gui$1.gui.project().summary &&
        Gui$1.gui.project().summary.exampleForOps &&
        Gui$1.gui.project().summary.exampleForOps.length > 0
      ) {
        const ops = Gui$1.gui.corePatch().ops;
        for (let i = 0; i < ops.length; i++) ops[i].setUiAttribs({ color: null });

        for (let j = 0; j < Gui$1.gui.project().summary.exampleForOps.length; j++) {
          const opz = gui
            .corePatch()
            .getOpsByObjName(Gui$1.gui.project().summary.exampleForOps[j]);
          for (let k = 0; k < opz.length; k++) {
            // const opname = opz[k];
            opz[k].setUiAttribs({ color: "#5dc0fd" });
          }
        }
      }
    }

    warnLargestPort() {
      let max = 0;
      let maxName = "unknown";
      let ser = "";
      let maxValue = "";
      let maxId = "";

      try {
        for (const i in this._p.ops) {
          for (let j in this._p.ops[i].portsIn) {
            if (this._p.ops[i].portsIn[j].uiAttribs.ignoreBigPort) continue;
            ser = JSON.stringify(this._p.ops[i].portsIn[j].getSerialized());
            if (ser.length > max) {
              max = ser.length;
              maxValue = ser;
              maxName =
                this._p.ops[i].name + " - in: " + this._p.ops[i].portsIn[j].name;
              maxId = this._p.ops[i].id;
            }
          }
          for (let j in this._p.ops[i].portsOut) {
            if (this._p.ops[i].portsOut[j].uiAttribs.ignoreBigPort) continue;
            ser = JSON.stringify(this._p.ops[i].portsOut[j].getSerialized());
            if (ser.length > max) {
              max = ser.length;
              maxValue = ser;
              maxName =
                this._p.ops[i].name +
                " - out: " +
                this._p.ops[i].portsOut[j].name;
              maxId = this._p.ops[i].id;
            }
          }
        }

        if (max > 10000) {
          const txt = "warning big port: " + maxName + " / " + max + " chars";
          notify(txt);
          this._log.log(txt);
        }
      } catch (e) {
        // TEST GIT SHIT
        this._log.error(e);
      } finally {
      }
    }

    localizeBlueprints() {
      const patch = Gui$1.gui.corePatch();
      const ops = patch.ops;
      const relevantOps = ops.filter((op) => {
        if (!op.isSubPatchOp()) return false;
        const port = op.getPortByName("externalPatchId");
        if (port) {
          const portValue = port.get();
          if (
            portValue !== Gui$1.gui.patchId &&
            portValue !== Gui$1.gui.project().shortId
          )
            return true;
        }
        return false;
      });

      const localizable = [];
      relevantOps.forEach((op) => {
        const port = op.getPortByName("subPatchId");
        if (port && port.get()) {
          const subpatchExists = ops.some((subpatchOp) => {
            if (!subpatchOp.isSubPatchOp()) return false;
            const subpatchPort = subpatchOp.getPortByName("patchId");
            return (
              subpatchPort &&
              subpatchPort.get() &&
              port.get() === subpatchPort.get()
            );
          });
          if (subpatchExists) {
            localizable.push(op);
          }
        }
      });
      Gui$1.gui.patchView.replacePortValues(
        localizable,
        "externalPatchId",
        Gui$1.gui.project().shortId,
      );
    }

    updateBlueprints(blueprintOps = []) {
      blueprintOps.forEach((blueprintOp) => {
        blueprintOp.updateBlueprint();
      });
    }

    focusOpAnim(opid) {
      this._patchRenderer.focusOpAnim(opid);
    }

    getBlueprintOpsForSubPatches(subpatchIds, localOnly = false) {
      const patch = Gui$1.gui.corePatch();
      const ops = patch.ops;
      return ops.filter((op) => {
        if (!op.isSubPatchOp()) return false;
        let isLocal = false;
        if (localOnly) {
          const patchIdPort = op.getPortByName("externalPatchId");
          if (patchIdPort) {
            const patchId = patchIdPort.get();
            isLocal =
              patchId &&
              (patchId === Gui$1.gui.project().shortId ||
                patchId === Gui$1.gui.project()._id);
          } else {
            return false;
          }
        }
        if (!localOnly || (localOnly && isLocal)) {
          const port = op.getPortByName("subPatchId");
          if (port) {
            const portValue = port.get();
            return portValue && subpatchIds.includes(portValue);
          }
        }
        return false;
      });
    }

    getPatchOpsUsedInPatch() {
      const patch = Gui$1.gui.corePatch();
      const ops = patch.ops;
      return ops.filter((op) => {
        return namespace$1.isPatchOp(op.objName);
      });
    }

    getUserOpsUsedInPatch() {
      const patch = Gui$1.gui.corePatch();
      const ops = patch.ops;
      return ops.filter((op) => {
        return namespace$1.isUserOp(op.objName);
      });
    }

    // addBlueprintInfo(op, outerOp)
    // {
    //     if (!op || !outerOp) return;
    //     if (outerOp)
    //     {
    //         if (outerOp.uiAttribs && outerOp.uiAttribs.blueprintOpId)
    //         {
    //             op.uiAttribs.blueprintOpId = outerOp.uiAttribs.blueprintOpId;
    //         }
    //         if (outerOp.storage && outerOp.storage.blueprint)
    //         {
    //             op.setStorage({ "blueprint": { "patchId": outerOp.storage.blueprint.patchId } });
    //             // op.storage = op.storage || {};
    //             // op.storage.blueprint = {
    //             //     "patchId": outerOp.storage.blueprint.patchId
    //             // };
    //         }
    //     }
    //     return op;
    // }
  }

  /**
   * main singleton class for starting the editor
   */
  let Gui$1 = class Gui extends Events {
    static EVENT_RESIZE = "resize";
    static EVENT_RESIZE_CANVAS = "resizecanvas";

    static RESTRICT_MODE_LOADING = 0;
    static RESTRICT_MODE_BLUEPRINT = 5;
    static RESTRICT_MODE_REMOTEVIEW = 10;
    static RESTRICT_MODE_FOLLOWER = 20;
    static RESTRICT_MODE_EXPLORER = 30;
    static RESTRICT_MODE_FULL = 40;

    static gui = null;

    hasAnims = false;
    unload = false;

    /** @type {GlTimeline} */
    glTimeline = null;

    /** @type {GlTimelineTab} */
    glTimeLineTab = null;

    splitpanePatchPos = 0;

    constructor(cfg) {
      super();

      this.editorSessionId = cfg.editorSessionId;

      this._log = new Logger("gui");

      /** @type {Object} */
      this.theme = defaultTheme;

      /** @type {ServerOps} */
      this.serverOps = null;

      /** @type {UserSettings} */
      this.userSettings = UserSettings.userSettings;
      this.uiProfiler = new UiProfiler();

      this.canvasManager = new CanvasManager();
      this.keys = new KeyBindingsManager();
      this.opParams = new OpParampanel();
      this.opPortModal = new ModalPortValue();
      this.longPressConnector = new LongPressConnector();

      this.socket = null;
      this.isRemoteClient = cfg.remoteClient;
      this._spaceBarStart = 0;

      this.rendererWidth = uiConfig.rendererDefaultWidth;
      this.rendererHeight = uiConfig.rendererDefaultHeight;
      this.showingtwoMetaPanel = true;

      this.patchParamPanel = new PatchPanel();

      this.canvasMagnifier = null;

      this.editorWidth = UserSettings.userSettings.get("editorWidth") || 350;
      this._timeoutPauseProfiler = null;
      this._cursor = "";
      this.restriction = new GuiRestrictions();
      this._restrictionMode = Gui.RESTRICT_MODE_LOADING;

      this._modalLoading = null;
      this._modalLoadingCount = 0;

      if (!cfg) cfg = {};
      if (!cfg.usersettings) cfg.usersettings = { settings: {} };

      let patchConfig = {
        editorMode: true,
        canvas: {
          // "forceWebGl1": cfg.UserSettings.userSettings.settings.forceWebGl1 === true || cfg.UserSettings.userSettings.settings.forceWebGl1 === "true",
          alpha: true,
          premultipliedAlpha: true,
        },
        variables: {},
      };
      if (cfg.patchConfig)
        patchConfig = Object.assign(patchConfig, cfg.patchConfig);

      /** @type {UiPatch} */
      // @ts-ignore
      this._corePatch = CABLES.patch = new CABLES.Patch(patchConfig);
      this._patchLoadEndiD = this._corePatch.on("patchLoadEnd", () => {
        this._corePatch.off(this._patchLoadEndiD);
        this.corePatch().logStartup("patch loaded 2");

        this.bookmarks.updateDynamicCommands();
        this.patchView.highlightExamplePatchOps();
        this.savedState.setSaved("patch load end", 0);

        this.corePatch().logStartup("Patch loaded");
      });
      this.on(
        "libLoadError",

        (/** @type {String} */ libName) => {
          this.showLibLoadError(libName);
        },
      );

      this.on(
        "ShaderError",

        /**
         * @param {CgShader} shader
         */
        (shader) => {
          if (this.UserSettings.userSettings.get("showAllShaderErrors"))
            CABLES.UI.showShaderError(shader);
        },
      );

      this.patchView = new PatchView(this._corePatch);

      this._corePatch.gui = true;

      this._jobs = new Jobs();
      this.cmdPallet = new CommandPallete();

      this.fileManager = null;
      this.fileManagerEditor = new FileManagerEditor();

      this._opselect = new OpSelect();
      this.introduction = new Introduction();
      this._gizmo = [];
      this.transformOverlay = new TransformsOverlay();
      this.htmlEleOverlay = null;

      this.opDocs = new OpDocs();
      this.opHistory = new OpHistory();

      this.mainTabs = new TabPanel("maintabs");
      this.maintabPanel = new MainTabPanel(this.mainTabs);

      this.bottomTabs = new TabPanel("bottomtabs");
      this.bottomTabPanel = new BottomTabPanel(this.bottomTabs);

      this.chat = null;

      this.metaTabs = new TabPanel("metatabpanel");

      this.savedState = new SavedState();
      this.savedState.pause();
      this._savedStateChangesBlueprintSubPatches = [];

      this.metaTexturePreviewer = new TexturePreviewer();
      this.metaKeyframes = null;
      this.bookmarks = new Bookmarks();
      this.bottomInfoArea = new BottomInfoAreaBar();

      this.metaOpParams = new MetaOpParams(this.metaTabs);

      this.user = null;
      this.onSaveProject = null;
      this.lastNotIdle = CABLES.now();

      this._oldCanvasWidth = 0;
      this._oldCanvasHeight = 0;
      this._oldShowingEditor = false;

      this._currentProject = null;

      this.currentModal = null;
      // @ts-ignore
      Gui.gui = this;
    }

    get patchId() {
      return this.project().shortId;
    }

    project() {
      return this._currentProject;
    }

    /**
     * @param {Object} p
     */
    setProject(p) {
      this._currentProject = p;
      this.setProjectName(p.name || "unknown");
      this.patchParamPanel.deserialize(p);
    }

    opSelect() {
      if (!this._opselect) this._opselect = new OpSelect();
      return this._opselect;
    }

    /** @returns {GlTimeline} */
    timeLine() {
      return this.glTimeline;
    }

    /** @deprecated */
    scene() {
      return this._corePatch;
    }

    /**
     * @returns {UiPatch}
     */
    corePatch() {
      return this._corePatch;
    }

    jobs() {
      return this._jobs;
    }

    get shouldDrawOverlay() {
      if (!this.UserSettings.userSettings.get("overlaysShow")) return false;

      return true;
    }

    /**
     * @param {string} title
     */
    startModalLoading(title) {
      this._modalLoadingCount++;
      this._modalLoading = this._modalLoading || new ModalLoading(title);
      return this._modalLoading;
    }

    endModalLoading() {
      this._modalLoadingCount--;
      if (this._modalLoadingCount == 0 && this._modalLoading) {
        this._modalLoading.close();
        this._modalLoading = null;
      }
    }

    finishedLoading() {
      return CABLES.UI.loaded;
    }

    /**
     * @param {Number} idx
     * @param {string} opid
     * @param {String} subpatch
     */
    focusFindResult(idx, opid, subpatch) {
      if (this.keys.shiftKey) {
        this.opParams.show(opid);
      } else {
        this.patchView.unselectAllOps();
        this.patchView.selectOpId(opid);
        this.patchView.setCurrentSubPatch(subpatch, () => {
          this.opParams.show(opid);
          this.patchView.focusOpAnim(opid);
          this.patchView.patchRenderer.viewBox.centerSelectedOps();
          this.patchView.centerSelectOp(opid);
        });
      }

      if (this.find()) this.find().setClicked(idx);
    }

    /**
     * @param {String} str
     */
    find(str = "") {
      if (this._find && this._find.isClosed()) this._find = null;

      if (str == undefined) return this._find;
      this.maintabPanel.show(true);

      if (!this._find) this._find = new FindTab(this.mainTabs, str);
      this._find.search(str);

      this.maintabPanel.show(true);
      this._find.focus();
    }

    texturePreview() {
      return this.metaTexturePreviewer;
    }

    showSaveWarning() {
      if (this.showGuestWarning()) return true;
      if (!this.canSaveInMultiplayer()) {
        iziToast.show({
          position: "topRight", // bottomRight, bottomLeft, topRight, topLeft, topCenter, bottomCenter, center
          theme: "dark",
          title: "multiplayer session",
          message: "you cannot save the patch, since you are not the pilot",
          progressBar: false,
          animateInside: false,
          close: true,
          timeout: 2000,
        });
        return true;
      }
      if (this.showBackupSaveWarning()) return true;
      return false;
    }

    showGuestWarning() {
      if (Gui.gui.isGuestEditor()) {
        CABLES.UI.MODAL.showError(
          "Demo Editor",
          text.guestHint +
            '<br/><br/><a href="' +
            platform.getCablesUrl() +
            '/signup" target="_blank" class="bluebutton">Sign up</a> <a onclick="Gui.gui.pressedEscape();" target="_blank" class="button">Close</a>',
        );
        return true;
      }
    }

    showBackupSaveWarning() {
      if (!platform.getPatchVersion()) return false;

      const html =
        "You are overwriting your original patch with a backup! Are you sure?<br/><br/>Saving will redirect back to the original patch.<br/><br/>" +
        '<a class="button" onclick="Gui.gui.patchView.store.checkUpdatedSaveForce(\'\');"><span class="icon icon-save"></span>Yes, save</a>&nbsp;&nbsp;' +
        '<a class="button" onclick="CABLES.CMD.PATCH.saveAs();"><span class="icon icon-save"></span>No, save as a copy</a>&nbsp;&nbsp;' +
        '<a class="button" onclick="Gui.gui.closeModal();">Cancel</a>&nbsp;&nbsp;';

      new ModalDialog({
        title: "Saving Backup",
        html: html,
      });
      return true;
    }

    canSaveInMultiplayer() {
      // if (Gui.gui.socket && !Gui.gui.socket.canSaveInMultiplayer()) return false;
      // else return true;
      return true;
    }

    isGuestEditor() {
      return this.user.username == "guest";
    }

    getParamPanelEleId() {
      let eleId = "options";
      if (!Gui.gui.showTwoMetaPanels()) eleId = "options_meta";
      return eleId;
    }

    isShowingModal() {
      return Gui.gui.currentModal != null;
    }

    closeModal() {
      if (Gui.gui.currentModal) Gui.gui.currentModal.close();
    }

    showTwoMetaPanels() {
      let r = true;
      if (this.rendererWidth < 1000) r = false;

      const haschanged = this.showingtwoMetaPanel != r;
      this.showingtwoMetaPanel = r;

      if (haschanged) this.metaOpParams.updateVisibility(r);

      return r;
    }

    /**
     * @param {String} opid
     * @param {String} which
     */
    watchArray(opid, which) {
      const op = Gui.gui.corePatch().getOpById(opid);
      if (!op) {
        this._log.warn("opid not found:", opid);
        return;
      }
      const port = op.getPort(which);
      if (!port) this._log.warn("port not found:", which);

      new WatchArrayTab(Gui.gui.mainTabs, op, port, {});
      Gui.gui.maintabPanel.show(true);
    }

    pauseInteractionSplitpanes() {
      const iframes = ele.byQueryAll("iframe,canvas");
      for (let i = 0; i < iframes.length; i++)
        iframes[i].style["pointer-events"] = "none";
      this.patchView.pauseInteraction();
    }

    resumeInteractionSplitpanes() {
      const iframes = ele.byQueryAll("iframe,canvas");
      for (let i = 0; i < iframes.length; i++)
        iframes[i].style["pointer-events"] = "initial";
      this.patchView.resumeInteraction();
    }

    showBottomTabs() {
      if (!this.bottomTabPanel.isVisible()) {
        new LogTab(this.bottomTabs);
        this.bottomTabPanel.show(true);
        Gui.gui.setLayout();
        Gui.gui.mainTabs.emitEvent("resize");
      }
    }

    hideBottomTabs() {
      this.bottomTabPanel.hide(true);

      Gui.gui.mainTabs.emitEvent("resize");
      Gui.gui.setLayout();
      Gui.gui.mainTabs.emitEvent("resize");
    }

    setLayout() {
      if (this.unload) return;
      this.pauseProfiling();
      const perf = this.uiProfiler.start("Gui.gui.setlayout");
      let canvasScale = 1;
      // this._elAceEditor = ele.byId("ace_editors");
      this._elSplitterPatch = this._elSplitterPatch || ele.byId("splitterPatch");
      this._elSplitterRenderer =
        this._elSplitterRenderer || ele.byId("splitterRenderer");
      this._elSplitterBottom =
        this._elSplitterBottom || ele.byId("splitterBottomTabs");

      this._elCanvasFlash = this._elCanvasFlash || ele.byId("canvasflash");
      this._elIconbarLeft =
        this._elIconbarLeft || ele.byId("iconbar_sidebar_left");

      this.patchView.updateBoundingRect();

      this._elPatch = this.patchView.element;
      this._elBgPreview = ele.byId("bgpreview");
      this._elBgPreviewButtonContainer = ele.byId("bgpreviewButtonsContainer");

      this._elOptions = this._elOptions || ele.byId("options");
      this._elMeta = this._elMeta || ele.byId("meta");
      this._elMenubar = this._elMenubar || ele.byId("menubar");
      this._elInfoArea = this._elInfoArea || ele.byId("infoArea");
      this._elInfoAreaParam = this._elInfoAreaParam || ele.byId("infoAreaParam");
      this._elProgressbar =
        this._elProgressbar || ele.byId("uploadprogresscontainer");

      this._elGlCanvasDom =
        this.canvasManager.currentCanvas() || ele.byId("glcanvas");

      this._elMaintab = this._elMaintab || ele.byId("maintabs");
      this._elEditor = this._elEditor || ele.byId("editor");
      this._elLibrary = this._elLibrary || ele.byId("library");
      this._elSplitterMaintabs =
        this._elSplitterMaintabs || ele.byId("splitterMaintabs");
      this._elEditorMinimized =
        this._elEditorMinimized || ele.byId("editorminimized");
      this._elEditorMaximized =
        this._elEditorMaximized || ele.byId("editormaximized");

      this._elBreadcrumbNav = this._elBreadcrumbNav || ele.byId("breadcrumb_nav");

      this._elCablesCanvasContainer =
        this._elCablesCanvasContainer || ele.byId("cablescanvas");
      this._elGlUiPreviewLayer =
        this._elGlUiPreviewLayer || ele.byId("gluiPreviewLayer");

      const iconBarWidth = 0;
      this.canvasInfoUiHeight = 36;

      let patchHeight = window.innerHeight;

      if (this.isRemoteClient) {
        this.canvasManager.mode = this.canvasManager.CANVASMODE_FULLSCREEN;
        this._elGlCanvasDom.classList.add("maximized");
        this.rendererWidth = 0;
      }

      if (this.isRemoteClient) {
        this._elMenubar.style.zIndex = 40;
        const lis = ele.byQueryAll("#menubar li");

        lis[0].setAttribute("onclick", "");
        for (let i = 1; i < lis.length; i++) lis[i].classList.add("hidden");
      }

      if (this.rendererWidth === undefined || this.rendererHeight === undefined) {
        this.rendererWidth = window.innerWidth * 0.4;
        this.rendererHeight = window.innerHeight * 0.25;
      }
      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_FULLSCREEN) {
        this.rendererWidth = window.innerWidth;
        this.rendererHeight = window.innerHeight;
      }

      if (this._corePatch.cgl && this._corePatch.cgl.canvasScale)
        canvasScale = this._corePatch.cgl.canvasScale;

      this.rendererWidthScaled = this.rendererWidth * canvasScale;
      this.rendererHeightScaled = this.rendererHeight * canvasScale;

      this.rendererWidth = Math.floor(this.rendererWidth);
      this.rendererHeight = Math.floor(this.rendererHeight);

      let patchWidth = window.innerWidth - this.rendererWidthScaled;
      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_PATCHBG) {
        patchWidth = window.innerWidth - this.rightPanelWidth;
        this.rendererHeightScaled = 0;
      }
      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_POPOUT)
        this.rendererHeightScaled = 0;

      this.corePatch().pause();
      this.patchView.pause();

      clearTimeout(this.delayedResizeCanvas);
      this.delayedResizeCanvas = setTimeout(() => {
        this._corePatch.cgl.updateSize();
        this.corePatch().resume();
        this.patchView.resume();
      }, 50);

      const infoAreaHeight = this.bottomInfoArea.getHeight();
      const menubarHeight = 0;
      const optionsWidth = Math.max(400, this.rendererWidthScaled / 2);

      patchHeight -= infoAreaHeight;

      let editorWidth = this.editorWidth;
      if (editorWidth > patchWidth - 50) editorWidth = patchWidth - 50;

      const patchLeft = iconBarWidth;

      if (this.maintabPanel.isVisible()) {
        const editorbarHeight = 767;
        const editorHeight =
          patchHeight - editorbarHeight - this.bottomTabPanel.getHeight();

        this._elMaintab.style.left = iconBarWidth + "px";
        this._elMaintab.style.top = 0 + "px";
        this._elMaintab.style.height = editorHeight - 2 + "px";
        this._elMaintab.style.width = editorWidth + "px";

        this._elSplitterMaintabs.style.display = "block";
        this._elSplitterMaintabs.style.left = editorWidth + iconBarWidth + "px";
        this._elSplitterMaintabs.style.height =
          patchHeight - this.bottomTabPanel.getHeight() + 2 + "px";
        this._elSplitterMaintabs.style.width = 5 + "px";
        this._elSplitterMaintabs.style.top = menubarHeight + "px";

        this._elEditorMinimized.style.display = "none";
        this._elEditorMinimized.style.left = iconBarWidth + "px";

        this._elEditorMaximized.style.display = "block";
        this._elEditorMaximized.style.left =
          editorWidth + iconBarWidth + 3 + "px";

        this._elBreadcrumbNav.style.left = editorWidth + iconBarWidth + 15 + "px";

        Gui.gui.mainTabs.updateSize();
      } else {
        this._elEditorMaximized.style.display = "none";

        if (this.mainTabs.getNumTabs() > 0)
          this._elEditorMinimized.style.display = "block";
        else this._elEditorMinimized.style.display = "none";

        this._elSplitterMaintabs.style.display = "none";
        // this._elEditorMinimized.style.top = 80 + "px";

        this._elBreadcrumbNav.style.left = iconBarWidth + 15 + "px";
      }

      // menu bar top
      let menupos = 0;
      const minmaxButtonSize = 35;
      if (this.maintabPanel.isVisible()) menupos += editorWidth;
      if (this.mainTabs.getNumTabs() > 0) menupos += minmaxButtonSize;
      this._elMenubar.style.left = menupos + 10 + "px";
      const rMenuBar = this._elMenubar.getBoundingClientRect();
      const mpMenuBar = ele.byId("multiplayerbar");
      if (mpMenuBar)
        mpMenuBar.style.left = rMenuBar.x + rMenuBar.width + 10 + "px";

      this._elProgressbar.style.left = menupos + 10 + 8 + "px";
      this._elProgressbar.style.top = rMenuBar.y + rMenuBar.height - 5 + "px";

      // this._elProgressbar.style.left = menupos + 10 + "px";

      this._elBreadcrumbNav.style.left = menupos + 5 + "px";
      this._elBreadcrumbNav.style.top = 60 + "px";

      if (this.rendererWidth < 100) this.rendererWidth = 100;

      this.rightPanelWidth = this.rendererWidthScaled;
      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_PATCHBG)
        this.rightPanelWidth = this.splitpanePatchPos;

      this._elSplitterPatch.style.left =
        window.innerWidth - this.rightPanelWidth - 4 + "px";
      this._elSplitterPatch.style.height = patchHeight + 2 + "px";
      this._elSplitterRenderer.style.top = this.rendererHeightScaled + "px";
      this._elSplitterRenderer.style.width = this.rendererWidthScaled + "px";

      this.patchView.setSize(patchLeft, menubarHeight, patchWidth, patchHeight);

      this._elPatch.style.height = patchHeight + "px";
      this._elPatch.style.width = patchWidth + "px";
      this._elPatch.style.top = 0 + "px";
      this._elPatch.style.left = patchLeft + "px";

      this._elLibrary.style.left = iconBarWidth + "px";
      this._elLibrary.style.width =
        window.innerWidth - this.rendererWidthScaled - iconBarWidth + "px";
      this._elLibrary.style.bottom = 0;

      this._elIconbarTimeline =
        this._elIconbarTimeline || ele.byId("iconbar_sidebar_timeline");
      if (this._elIconbarTimeline) {
        this._elIconbarTimeline.style.left = patchWidth / 2 + "px";
        this._elIconbarTimeline.style.bottom = 10 + infoAreaHeight + "px";
        if (!this.hasAnims) this._elIconbarTimeline.style.display = "none";
        else this._elIconbarTimeline.style.display = "inline-block";
      }

      this._elIconbarBottom =
        this._elIconbarBottom || ele.byId("iconbar_sidebar_bottom");
      if (this._elIconbarBottom) {
        this._elIconbarBottom.style.right = this.rendererWidthScaled + 20 + "px";
        this._elIconbarBottom.style.bottom = 10 + infoAreaHeight + "px";
      }

      if (this._elIconbarLeft) {
        if (this.UserSettings.userSettings.get("hideSizeBar")) {
          this._elIconbarLeft.style.display = "none";
        } else {
          this._elIconbarLeft.style.display = "block";
          this._elIconbarLeft.style.bottom = 10 + infoAreaHeight + "px";

          if (this.maintabPanel.isVisible())
            this._elIconbarLeft.style.left = editorWidth + 20 + "px";
          else this._elIconbarLeft.style.left = 10 + "px";
        }
      }

      let metaWidth;

      if (this.showTwoMetaPanels()) {
        metaWidth = this.rightPanelWidth - optionsWidth;

        this._elOptions.style.right = metaWidth + "px";
        this._elOptions.style.top =
          this.rendererHeightScaled + this.canvasInfoUiHeight + "px";
        this._elOptions.style.width = optionsWidth + "px";
        this._elOptions.style.height =
          window.innerHeight - this.rendererHeightScaled + "px";

        this._elMeta.style.right = 0 + "px";
        this._elMeta.style.top =
          this.rendererHeightScaled + this.canvasInfoUiHeight + "px";
        this._elMeta.style.width = metaWidth + "px";
        this._elMeta.style.height =
          window.innerHeight - this.rendererHeightScaled + "px";

        this._elOptions.style.display = "block";
      } else {
        metaWidth = this.rightPanelWidth;
        this._elMeta.style.right = 0 + "px";

        this._elMeta.style.top =
          this.rendererHeightScaled + this.canvasInfoUiHeight + "px";
        this._elMeta.style.width = metaWidth + "px";
        this._elMeta.style.height =
          window.innerHeight - this.rendererHeightScaled + "px";

        this._elOptions.style.width = 0 + "px";
        this._elOptions.style.height = 0 + "px";
        this._elOptions.style.display = "none";
      }

      ele.byId("canvasicons").style.height = this.canvasInfoUiHeight + "px";
      ele.byId("canvasicons").style.width =
        this.rendererWidth * canvasScale + "px";
      ele.byId("canvasicons").style.right = 0 + "px";

      const widthResizeIcon = 30;
      ele.byId("canvasIconBar").style.width =
        this.rendererWidth - widthResizeIcon - 10 + "px";

      let top = 0;
      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_PATCHBG)
        top = 0;
      else top = this.rendererHeightScaled + 1;
      ele.byId("canvasicons").style.top = top + "px";

      this._elMenubar.style.top = 0 + "px";

      if (!this.bottomInfoArea.showing) {
        this._elInfoArea.style.height = 0 + "px";
      } else {
        this._elInfoArea.style.height = infoAreaHeight + "px";
      }
      this._elInfoAreaParam.style.right = "0px";
      this._elInfoAreaParam.style.width = this.rendererWidth + "px";

      ele.byId("maintabs").style.top = menubarHeight + "px";
      ele.byId("maintabs").style.height =
        window.innerHeight -
        menubarHeight -
        infoAreaHeight -
        this.bottomTabPanel.getHeight() +
        "px";

      if (this.bottomTabPanel.isVisible()) {
        this._elSplitterBottom.style.display = "block";
        this._elSplitterBottom.style.width = patchWidth + "px";
        this._elSplitterBottom.style.bottom =
          infoAreaHeight + this.bottomTabPanel.getHeight() + "px";

        this._eleBottomTabs = ele.byId("bottomtabs");
        this._eleBottomTabs.style.width = patchWidth + "px";
        this._eleBottomTabs.style.bottom = infoAreaHeight + "px";
        this._eleBottomTabs.style.height = this.bottomTabPanel.getHeight() + "px";
        this._eleBottomTabs.style.left = iconBarWidth + "px";

        this.bottomTabs.updateSize();
      }

      const tabPanelTop = ele.byQuery("#maintabs .tabpanel");
      let tabPanelTopHeight = 0;
      if (tabPanelTop)
        tabPanelTopHeight = tabPanelTop.getBoundingClientRect().height;

      ele.byQuery("#maintabs .contentcontainer").style.height =
        window.innerHeight -
        menubarHeight -
        infoAreaHeight -
        this.bottomTabPanel.getHeight() -
        tabPanelTopHeight +
        "px";

      let metaTabPanelTabsHeight = 0;
      const metaTabPanelTabs = ele.byQuery("#metatabpanel .tabpanel");
      if (metaTabPanelTabs)
        metaTabPanelTabsHeight = metaTabPanelTabs.getBoundingClientRect().height;

      ele.byQuery("#metatabpanel .contentcontainer").style.height =
        window.innerHeight -
        this.rendererHeightScaled -
        infoAreaHeight -
        metaTabPanelTabsHeight -
        tabPanelTopHeight -
        menubarHeight -
        1 +
        "px";

      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_POPOUT) {
        this._elCablesCanvasContainer.style.left = iconBarWidth + "px";
        this._elCablesCanvasContainer.style.right = "initial";
        this._elCablesCanvasContainer.style.top = "0px";
        this._elCablesCanvasContainer.style.width = "0px";
        this._elCablesCanvasContainer.style.height = "0px";
        this._elCablesCanvasContainer.style["z-index"] = 1;
      } else if (
        this.canvasManager.mode == this.canvasManager.CANVASMODE_FULLSCREEN
      ) {
        this._elCablesCanvasContainer.style.left = 0 + "px";
        this._elCablesCanvasContainer.style.right = "initial";

        this._elCablesCanvasContainer.style.width =
          this._elGlCanvasDom.style.width = window.innerWidth + "px";
        this._elCablesCanvasContainer.style.height =
          this._elGlCanvasDom.style.height = window.innerHeight + "px";

        this._elGlCanvasDom.setAttribute("width", window.innerWidth);
        this._elGlCanvasDom.setAttribute("height", window.innerHeight);

        this._elCablesCanvasContainer.style["z-index"] = 40;
      } else if (
        this.canvasManager.mode == this.canvasManager.CANVASMODE_PATCHBG
      ) {
        this._elGlCanvasDom.style.width = this._elPatch.style.width;
        this._elGlCanvasDom.style.height = this._elPatch.style.height;

        this._elCablesCanvasContainer.style.left = iconBarWidth + "px";
        this._elCablesCanvasContainer.style.right = "initial";
        this._elCablesCanvasContainer.style.top = "0px";
        this._elCablesCanvasContainer.style.width =
          this._elGlCanvasDom.style.width;
        this._elCablesCanvasContainer.style.height =
          this._elGlCanvasDom.style.height;
        this._elCablesCanvasContainer.style["z-index"] = -1;
      } else if (
        this.canvasManager.mode == this.canvasManager.CANVASMODE_NORMAL
      ) {
        this._elCablesCanvasContainer.style["z-index"] = 10;

        this.canvasManager.setSize(this.rendererWidth, this.rendererHeight);

        this._elCablesCanvasContainer.style.width = this.rendererWidth + "px";
        this._elCablesCanvasContainer.style.height = this.rendererHeight + "px";
        this._elCablesCanvasContainer.style.right = "0px";
        this._elCablesCanvasContainer.style.left = "initial";
        this._elCablesCanvasContainer.style["transform-origin"] = "top right";
        this._elCablesCanvasContainer.style.transform =
          "scale(" + canvasScale + ")";
      }

      // flashing canvas overlay when saving
      this._elCanvasFlash.style.width = this.rendererWidth * canvasScale + "px";
      this._elCanvasFlash.style.height = this.rendererHeight * canvasScale + "px";
      this._elCanvasFlash.style.right = 0 + "px";
      this._elCanvasFlash.style.top = 0 + "px";

      this._elBgPreview.style.right = this.rightPanelWidth + 10 + "px";
      this._elBgPreview.style.top = menubarHeight + 55 + "px";

      this._elBgPreviewButtonContainer.style.right = this.rightPanelWidth + "px";
      // this._elBgPreviewButtonContainer.style.top = this._elBgPreview.height + "px";

      this.emitEvent("setLayout");

      if (this.patchView.patchRenderer.focus)
        this.patchView.patchRenderer.focus();

      perf.finish();
    }

    _switchCanvasSizeNormal() {
      this.canvasManager.mode = this.canvasManager.CANVASMODE_NORMAL;
      this.rendererWidth = this._oldCanvasWidth;
      this.rendererHeight = this._oldCanvasHeight;
    }

    _switchCanvasPatchBg() {
      this._oldCanvasWidth = this.rendererWidth;
      this._oldCanvasHeight = this.rendererHeight;
      this.rightPanelWidth = this.rendererWidth;

      this.canvasManager.mode = this.canvasManager.CANVASMODE_PATCHBG;
      this.UserSettings.userSettings.set("canvasMode", "patchbg");

      this.rendererHeight = 100;
      this.rightPanelWidth = this._oldCanvasWidth;
    }

    cyclePatchBg() {
      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_FULLSCREEN)
        this.cycleFullscreen();

      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_NORMAL) {
        this._switchCanvasPatchBg();
      } else {
        this.UserSettings.userSettings.set("canvasMode", "");
        this._switchCanvasSizeNormal();
      }

      this.setLayout();

      if (this.canvasManager.getCanvasUiBar())
        this.canvasManager.getCanvasUiBar().showCanvasModal(false);
    }

    cycleFullscreen() {
      if (this.canvasManager.mode == this.canvasManager.CANVASMODE_FULLSCREEN) {
        this.patchView.patchRenderer.storeSubPatchViewBox();
        this.canvasManager.mode = this.canvasManager.CANVASMODE_NORMAL;
        this.rendererWidth = this._oldCanvasWidth;
        this.rendererHeight = this._oldCanvasHeight;
      } else {
        this.patchView.patchRenderer.restoreSubPatchViewBox(
          this.patchView.getCurrentSubPatch(),
        );
        this._oldCanvasWidth = this.rendererWidth;
        this._oldCanvasHeight = this.rendererHeight;
        this.rightPanelWidth = this.rendererWidth;
        this.canvasManager.mode = this.canvasManager.CANVASMODE_FULLSCREEN;

        if (!this.notifiedFullscreen)
          notify("press escape to exit fullscreen mode");
        this.notifiedFullscreen = true;
      }

      if (this.canvasManager.getCanvasUiBar())
        this.canvasManager.getCanvasUiBar().showCanvasModal(false);
      this.setLayout();
    }

    isShowingTiming() {
      return this.hasAnims;
    }

    showTiming() {
      this.bottomTabPanel.show(true);
      this.setLayout();
    }

    /**
     * @param {boolean} show
     */
    showLoadingProgress(show) {
      if (this.unload) return;
      if (show) {
        ele.byId("nav-logo_idle").classList.add("logoFadeout");
        ele.byId("nav-logo_idle").classList.remove("logoFadein");
        ele.byId("nav-loading").classList.remove("hidden");
      } else {
        setTimeout(() => {
          ele.byId("nav-logo_idle").classList.remove("logoFadeout");
          ele.byId("nav-logo_idle").classList.add("logoFadein");
          ele.byId("nav-loading").classList.add("hidden");
        }, 250);
      }
    }

    /**
     * @param {Object} data
     */
    updateActivityFeedIcon(data) {
      if (!data) return;
      const feedIcon = ele.byId("nav-item-activity");
      if (feedIcon) {
        const actionable = feedIcon.querySelector(".dot");
        if (data.action_required) {
          ele.show(feedIcon);
          ele.show(actionable);
        } else {
          ele.hide(feedIcon);
          ele.hide(actionable);
        }
      }
    }

    hideTiming() {
      this._showTiming = false;
      ele.hide(ele.byId("timing"));
      Gui.gui.setLayout();
    }

    hideTimeline() {
      if (this.timeLineTab) this.timeLineTab.close();
    }

    toggleTimeline() {
      console.log(" gui toggle timeline");
      if (this.glTimeline) this.glTimeline.toggle();
      else this.timeLineTab = new GlTimelineTab(Gui.gui.bottomTabs);
    }

    refreshFileManager() {
      if (this.fileManager) this.fileManager.refresh();
      else this.showFileManager(null, true);
    }

    savingTitleAnimEnd() {
      const elePatchName = ele.byId("patchname");
      elePatchName.classList.remove("blinking");

      if (elePatchName.dataset.patchname != "undefined")
        setTimeout(() => {
          elePatchName.innerHTML = elePatchName.dataset.patchname;
        }, 200);
    }

    /**
     * @param {string} title
     */
    savingTitleAnimStart(title) {
      document.getElementById("patchname").innerHTML = title;
      document.getElementById("patchname").classList.add("blinking");
    }

    /**
     * @param {Function} cb
     * @param {boolean} userInteraction
     */
    getFileManager(cb, userInteraction) {
      if (!this.fileManager)
        this.fileManager = new FileManager(cb, userInteraction);
      return this.fileManager;
    }

    showLogging() {
      new LoggingTab(Gui.gui.mainTabs);
      Gui.gui.maintabPanel.show(true);
    }

    /**
     * @param {Function} cb
     * @param {boolean} userInteraction
     */
    showFileManager(cb = null, userInteraction = false) {
      this.getFileManager(cb, userInteraction);

      this.fileManager.show(userInteraction);
      Gui.gui.mainTabs.activateTabByName("Files");

      if (cb) cb();
    }

    /**
     * @param {string} name
     */
    setProjectName(name) {
      if (name && name !== "undefined") {
        ele.byId("patchname").innerHTML = name;
        ele.byId("patchname").dataset.patchname = name;
        Gui.gui.corePatch().name = name;
        if (this._currentProject) this._currentProject.name = name;
      }
    }

    createProject() {
      if (Gui.gui.showGuestWarning()) return;

      const randomize = this.UserSettings.userSettings.get(
        "randomizePatchName",
        true,
      );
      let title = "Enter a name for your new project";
      if (randomize) title += ", leave empty for random name";
      new ModalDialog({
        prompt: true,
        title: "New Project",
        text: title,
        promptValue: randomize ? "" : "new project",
        promptOk: (name) => {
          if (randomize || name)
            platform.talkerAPI.send("newPatch", { name: name });
        },
      });
    }

    /* Goes through all nav items and replaces "mod" with the OS-dependent modifier key */
    replaceNavShortcuts() {
      let els = ele.byQueryAll(".shortcut");

      for (let i in els) {
        const newShortcut = this.bottomInfoArea.replaceShortcuts(
          els[i].innerHTML || "",
        );
        if (els[i].innerHTML) els[i].innerHTML = newShortcut;
      }
    }

    /**
     * @param {string} selector
     */
    serializeForm(selector) {
      const json = {};
      Array.from(ele.byQuery(selector).elements).forEach((e) => {
        json[e.getAttribute("name")] = e.value;
      });
      return json;
    }

    helperContextMenu() {
      CABLES.CMD.UI.toggleOverlays();
    }

    /**
     * @param {HTMLBaseElement} el
     */
    rendererContextMenu(el) {
      contextMenu.show(
        {
          items: [
            {
              title: "Reset canvas size",
              func: CABLES.CMD.RENDERER.resetSize,
            },
            {
              title: "Set canvas size",
              func: CABLES.CMD.RENDERER.changeSize,
            },
            {
              title: "Set canvas scale",
              func: CABLES.CMD.RENDERER.scaleCanvas,
            },
            {
              title: "Canvas Magnifier",
              func: CABLES.CMD.RENDERER.canvasMagnifier,
            },
            {
              title: "Maximize Canvas",
              func: CABLES.CMD.UI.toggleMaxRenderer,
              icon: "icon-picker",
            },
            {
              title: "Canvas As Patch Background",
              func: CABLES.CMD.UI.togglePatchBgRenderer,
            },
          ],
        },
        el,
      );
    }

    /**
     * @param {HTMLElement} el
     */
    rendererAspectMenu(el) {
      contextMenu.show(
        {
          items: [
            {
              title: "32:9",
              func() {
                CABLES.CMD.RENDERER.aspect(32 / 9);
              },
            },
            {
              title: "21:9",
              func() {
                CABLES.CMD.RENDERER.aspect(21 / 9);
              },
            },
            {
              title: "16:9",
              func() {
                CABLES.CMD.RENDERER.aspect(16 / 9);
              },
            },
            {
              title: "16:10",
              func() {
                CABLES.CMD.RENDERER.aspect(16 / 10);
              },
            },
            {
              title: "4:3",
              func() {
                CABLES.CMD.RENDERER.aspect(4 / 3);
              },
            },
            {
              title: "5:4",
              func() {
                CABLES.CMD.RENDERER.aspect(5 / 4);
              },
            },
            {
              title: "1:1",
              func() {
                CABLES.CMD.RENDERER.aspect(1);
              },
            },
            {
              title: "1:2",
              func() {
                CABLES.CMD.RENDERER.aspect(1 / 2);
              },
            },
            {
              title: "9:16",
              func() {
                CABLES.CMD.RENDERER.aspect(9 / 16);
              },
            },
          ],
        },
        el,
      );
    }

    /**
     * @param {String} converterId
     * @param {String} projectId
     * @param {String} fileId
     * @param {String} converterName
     */
    showConverter(
      converterId,
      projectId,
      fileId,
      converterName,
      fileName = null,
    ) {
      const html = getHandleBarHtml("params_convert", {
        converterId: converterId,
        converterName: converterName,
        projectId: projectId,
        fileId: fileId,
        fileName: fileName,
      });

      new ModalDialog({ html: html });
    }

    /**
     * @param {String} _projectId
     * @param {String} fileId
     * @param {String} converterId
     */
    converterStart(_projectId, fileId, converterId) {
      ele.show(ele.byId("converterprogress"));
      ele.hide(ele.byId("converterform"));

      platform.talkerAPI.send(
        "fileConvert",
        {
          fileId: fileId,
          converterId: converterId,
          options: this.serializeForm("#converterform"),
        },
        function (err, res) {
          ele.hide(ele.byId("converterprogress"));
          ele.show(ele.byId("converteroutput"));
          ele.show(ele.byId("modalClose"));

          if (err) {
            const converterOutput = ele.byId("converteroutput");
            if (err.msg === "OVER_QUOTA") {
              converterOutput.innerHTML =
                'You are over quota for this action. Increase your <a href="' +
                platform.getCablesUrl() +
                "/support\" target='_blank'>support level</a> to get more space!";
            } else {
              converterOutput.innerText =
                "Error: something went wrong while converting..." +
                (err.msg || "");
            }
          } else {
            let html = "";

            if (res && res.info) html = res.info;
            else html = "Finished!";

            ele.byId("modalClose").classList.remove("hidden");
            ele.byId("converteroutput").innerHTML = html;

            FileManager.updatedFiles.push(fileId);
          }
          Gui.gui.refreshFileManager();
        },
      );
    }

    /**
     * @param {Function} cb
     */
    bind(cb) {
      this.canvasManager.addContext(this.corePatch().cgl);

      if (this.UserSettings.userSettings.get("canvasMode") == "patchbg")
        this._switchCanvasPatchBg();

      this.bottomInfoArea.on("changed", this.setLayout.bind(this));

      let lastTimeRecent = 0;
      const navCablesLogo = ele.byId("nav_logo_area");

      navCablesLogo.addEventListener("pointerenter", () => {
        if (lastTimeRecent != 0 && performance.now() - lastTimeRecent < 30000)
          return;
        platform.talkerAPI.send("getRecentPatches", {}, (_err, r) => {
          lastTimeRecent = performance.now();

          let str = "";
          str +=
            '<li id="nav_support" class="nav_support" > &nbsp;Support cables</li>';
          str += '<li id="nav_help_forum">Report Problems</li>';

          str += '<li class="divide"></li>';

          if (platform.frontendOptions.showMyLinks)
            str +=
              '<li id="nav_mypatches"><a target="_blank" href="' +
              platform.getCablesUrl() +
              '/mypatches">My Patches</a></li>';

          str += '<li id="nav_patch_new">Create New Empty Patch</li>';

          str += '<li class="divide"></li>';

          if (platform.frontendOptions.showOpenPatch) {
            let item =
              "<li><a onclick='CABLES.platform.talkerAPI.send(\"gotoPatch\");' class=\"mine\" target=\"_top\">Open Patch<span class='shortcut'><p><span class='key key_cmd'></span><code>o</code></p></span></a></li>";
            str += this.bottomInfoArea.replaceShortcuts(item);
          }

          if (r)
            for (let i = 0; i < Math.min(5, r.length); i++) {
              const url = platform.getCablesUrl() + "/edit/" + r[i].shortId;
              str +=
                '<li><a href="' +
                url +
                '" class="mine" target="_top">Open Patch ' +
                r[i].name +
                "</a></li>";
            }

          str += '<li class="divide"></li>';

          str +=
            '<li id="nav_cablesweb"><a target="_top" href="' +
            platform.getCablesUrl() +
            '/">Open cables.gl</a></li>';
          ele.byId("nav_recentpatches").innerHTML = str;

          ele.byId("nav_patch_new").addEventListener("click", () => {
            CABLES.CMD.PATCH.newPatch();
          });
          ele.byId("nav_help_forum").addEventListener("click", () => {
            window.open(
              "https://github.com/cables-gl/cables_docs/issues",
              "_blank",
            );
          });
          ele.byId("nav_support").addEventListener("click", () => {
            window.open(platform.getCablesDocsUrl() + "/support", "_blank");
          });

          if (this.user.isSupporter) ele.hide(ele.byId("nav_support"));
        });
      });

      ele.byId("nav_cmdplt").addEventListener("click", () => {
        Gui.gui.cmdPallet.show();
      });
      ele.byId("nav_search").addEventListener("click", () => {
        Gui.gui.find("");
      });

      ele.byId("nav_createBackup").addEventListener("click", () => {
        CABLES.CMD.PATCH.createBackup();
      });
      ele.byId("nav_viewBackups").addEventListener("click", () => {
        CABLES.CMD.PATCH.showBackups();
      });

      ele.byId("nav_preferences").addEventListener("click", () => {
        CABLES.CMD.UI.showPreferences();
      });
      ele.byId("nav_viewProjectLink").addEventListener("click", (e) => {
        e.preventDefault();
        const projectId = this._currentProject
          ? this._currentProject.shortId
          : null;
        if (projectId) {
          const url = platform.getCablesUrl() + "/p/" + projectId;
          const win = window.open(url, "_blank");
          win.focus();
        }
      });
      ele.byId("nav_remoteViewerLink").addEventListener("click", () => {
        CABLES.CMD.UI.openRemoteViewer();
      });

      ele.byId("nav_patch_save").addEventListener("click", () => {
        CABLES.CMD.PATCH.save();
      });
      ele.byId("nav_patch_saveas").addEventListener("click", () => {
        CABLES.CMD.PATCH.saveAs();
      });
      ele.byId("nav_patch_export").addEventListener("click", () => {
        CABLES.CMD.PATCH.export();
      });
      ele.byId("nav_patch_export_patch").addEventListener("click", () => {
        CABLES.CMD.PATCH.export("patch");
      });

      if (platform.frontendOptions.hasOpDirectories) {
        const opDirEle = ele.byId("nav_patch_add_opdir");
        if (opDirEle) {
          ele.show(opDirEle);
          opDirEle.addEventListener("click", () => {
            platform.openOpDirsTab();
          });
        }
      }

      const uploadEle = ele.byId("nav_uploadfile");
      if (uploadEle) {
        uploadEle.addEventListener("click", CABLES.CMD.PATCH.uploadFileDialog);
        if (!platform.frontendOptions.showAssetUpload)
          uploadEle.innerText = "Add file";
      }

      if (!platform.frontendOptions.showPatchSettings)
        ele.hide(ele.byId("nav_patch_settings"));
      if (!platform.frontendOptions.showPatchViewPage)
        ele.hide(ele.byId("nav_patch_page"));

      const exportLink = ele.byId("nav_patch_export");
      if (!platform.frontendOptions.showExport) {
        ele.hide(exportLink);
      }
      if (platform.isElectron()) {
        if (exportLink) exportLink.innerText = "Export - HTML";
      }

      if (!platform.frontendOptions.showExportPatch) {
        ele.hide(ele.byId("nav_patch_export_patch"));
      }

      if (!platform.frontendOptions.showMyLinks)
        ele.hide(ele.byId("nav_mypatches"));

      if (!platform.frontendOptions.showPatchBackups) {
        ele.hide(ele.byId("nav_viewBackups"));
        ele.hide(ele.byId("nav_createBackup"));
      }

      if (platform.frontendOptions.showChangeLogLink)
        ele.byId("nav_changelog").addEventListener("click", () => {
          window.open(platform.getCablesDocsUrl() + "/changelog", "_blank");
        });
      else ele.hide(ele.byId("nav_changelog"));

      if (platform.frontendOptions.showBuildInfoMenuLink)
        ele.byId("nav_buildinfo").addEventListener("click", () => {
          CABLES.CMD.UI.showBuildInfo();
        });
      else ele.hide(ele.byId("nav_buildinfo"));

      // --- Help menu
      // Documentation

      ele.byId("nav_help_keys").addEventListener("click", () => {
        CABLES.CMD.UI.showKeys();
      });
      ele.byId("nav_help_documentation").addEventListener("click", () => {
        window.open(platform.getCablesDocsUrl() + "/docs", "_blank");
      });

      ele.byId("nav_help_tips").addEventListener("click", () => {
        CABLES.CMD.UI.showTips();
      });

      // Introduction
      ele.byId("nav_help_introduction").addEventListener("click", () => {
        Gui.gui.introduction.showIntroduction();
      });
      ele.byId("nav_help_video").addEventListener("click", () => {
        window.open("https://www.youtube.com/cablesgl", "_blank");
      });

      ele.byId("nav_op_createOp").addEventListener("click", () => {
        Gui.gui.serverOps.createDialog();
      });
      ele.byId("nav_op_patchOp").addEventListener("click", () => {
        Gui.gui.patchView.unselectAllOps();
        CABLES.CMD.PATCH.createSubPatchOp();
      });
      ele.byId("nav_filemanager").addEventListener("click", () => {
        Gui.gui.showFileManager(null, true);
      });

      ele.byId("nav_timeline").addEventListener("click", () => {
        CABLES.CMD.TIMELINE.toggleTimeline();
      });

      ele.byId("nav_gpuprofiler").addEventListener("click", () => {
        CABLES.CMD.UI.profileGPU();
      });
      ele.byId("nav_log").addEventListener("click", () => {
        CABLES.CMD.DEBUG.logConsole();
      });

      ele.byId("nav_profiler").addEventListener("click", () => {
        CABLES.CMD.PATCH.patchProfiler();
      });
      ele.byId("nav_patchanalysis").addEventListener("click", () => {
        CABLES.CMD.PATCH.analyze();
      });

      if (!platform.isTrustedPatch()) {
        ele.byId("nav_op_createOp").classList.add("nav-greyout");
        ele.byId("nav_op_patchOp").classList.add("nav-greyout");
        ele.byId("nav_uploadfile").classList.add("nav-greyout");

        ele.byId("nav_createBackup").classList.add("nav-greyout");
        // ele.byId("nav_patch_settings").classList.add("nav-greyout");
        ele.byId("nav_viewBackups").classList.add("nav-greyout");
        ele.byId("nav_patch_save").classList.add("nav-greyout");
      } else if (platform.patchIsBackup()) {
        ele.hide(ele.byId("nav_createBackup"));
      }

      ele.byId("nav-item-activity").addEventListener("click", () => {
        CABLES.CMD.UI.activityFeed();
      });

      ele.byId("nav-item-bpReload").addEventListener("click", () => {
        CABLES.CMD.PATCH.updateLocalChangedBlueprints();
      });

      this.htmlEleOverlay = new HtmlElementOverlay();
      this.canvasManager.updateCanvasUi();
      cb();
    }

    onResize() {
      if (this.canvasManager.getCanvasUiBar())
        this.canvasManager.getCanvasUiBar().showCanvasModal(false);
      this.canvasManager.blur();
      this.mainTabs.emitEvent("resize");
      this.setLayout();
      this.setLayout(); // yes, twice....
      Gui.gui.emitEvent(Gui.gui.EVENT_RESIZE);
    }

    bindKeys() {
      if (Gui.gui.isRemoteClient) return;

      this.keys.key(
        "Tab",
        "cycle tab",
        "down",
        null,
        { altKey: true, ignoreInput: false },
        () => {
          Gui.gui.maintabPanel.tabs.cycleActiveTab();
        },
      );

      // opens editor for 1st string port found on an op with shift+e
      this.keys.key(
        "e",
        "shift-e editor",
        "down",
        null,
        { cmdCtrl: false, shiftKey: true, ignoreInput: true },
        () => {
          if (
            Gui.gui.patchView.getSelectedOps().length !== 1 ||
            !Gui.gui.patchView.getSelectedOps()[0].portsIn.length
          )
            return;

          const selectedOp = Gui.gui.patchView.getSelectedOps();
          const selectedOpId = selectedOp[0].id;

          let port = null;

          for (let i = 0; i < selectedOp[0].portsIn.length; i++) {
            port = selectedOp[0].portsIn[i];
            if (port.uiAttribs && port.uiAttribs.editShortcut) break;
          }

          if (port) {
            if (port.uiAttribs.display === "editor")
              paramsHelper.openParamStringEditor(
                selectedOpId,
                port.name,
                null,
                true,
              );
            if (port.uiAttribs.display === "gradient") {
              const editor = new CABLES.GradientEditor(selectedOpId, port.name, {
                openerEle: ele.byClass("gradienteditbutton"),
              });
              editor.show();
            }
          }
        },
      );

      const getSettingKeys = (keybindName, defaultKey) => {
        let val = defaultKey;
        const setting = String(
          this.UserSettings.userSettings.get(keybindName) || "",
        );
        if (setting) {
          if (setting.indexOf(",") > 0) {
            const keys = setting.split(",");
            if (keys)
              keys.map((item) => {
                return item.trim();
              });
            val = keys;
          } else val = setting;
        }

        return val;
      };

      this.keys.key(
        getSettingKeys("keybind_escape", "escape"),
        'Open "Op Create" dialog (or close current dialog)',
        "down",
        null,
        {},
        (e) => {
          if (document.activeElement)
            if (
              Gui.gui.isShowingModal() ||
              (!document.activeElement.classList.contains("ace_text-input") &&
                document.activeElement.tagName != "INPUT" &&
                document.activeElement.tagName != "TEXTAREA") ||
              !document.activeElement.classList.contains("notIgnoreEscape")
            ) {
              this.pressedEscape(e);
              this.patchView.focus();
            } else {
              return false;
              // if (e.target.hasAttribute("data-portnum"))
              // {
              //     const n = e.target.dataset.portnum;
              //     const nextInputEle = ele.byId("portval_" + (parseInt(n) + 1));
              //     if (nextInputEle) nextInputEle.focus();
              // }
            }
        },
      );

      this.keys.key(
        "Escape",
        "Toggle Tab Area",
        "down",
        null,
        { cmdCtrl: true },
        () => {
          this.maintabPanel.toggle(true);
          this.setLayout();
        },
      );

      this.keys.key(
        "p",
        "Open Command Palette",
        "down",
        null,
        { cmdCtrl: true },
        () => {
          this.cmdPallet.show();
        },
      );
      this.keys.key(
        "Enter",
        "Cycle size of renderer between normal and Fullscreen",
        "down",
        null,
        { cmdCtrl: true },
        () => {
          this.cycleFullscreen();
        },
      );
      this.keys.key(
        "Enter",
        "Cycle size of renderer between normal and Fullscreen",
        "down",
        null,
        { cmdCtrl: true, shiftKey: true },
        () => {
          this.cyclePatchBg();
        },
      );
      this.keys.key(
        "Enter",
        "Cycle patchfield visibility",
        "down",
        null,
        { cmdCtrl: false, shiftKey: true },
        () => {
          CABLES.CMD.UI.togglePatchBgPatchField();
        },
      );

      this.keys.key(
        "z",
        "undo",
        "down",
        null,
        { ignoreInput: true, cmdCtrl: true },
        () => {
          undo.undo();
        },
      );
      this.keys.key(
        "z",
        "redo",
        "down",
        null,
        { ignoreInput: true, cmdCtrl: true, shiftKey: true },
        () => {
          undo.redo();
        },
      );
      this.keys.key(
        ",",
        "Patch Settings",
        "down",
        null,
        { ignoreInput: true, cmdCtrl: true },
        () => {
          CABLES.CMD.UI.settings();
        },
      );

      this.keys.key(
        "f",
        "Find/Search in patch",
        "down",
        null,
        { cmdCtrl: true },
        (/** @type {HtmlElementOverlay} */ e) => {
          const eleAceTextEditor = ele.byQuery("#ace_editors textarea");
          if (
            !(eleAceTextEditor && ele.hasFocus(eleAceTextEditor)) &&
            !Gui.gui.isShowingModal()
          )
            CABLES.CMD.UI.showSearch();
          else e.dontPreventDefault = true;
        },
      );

      this.keys.key(
        "s",
        "Save patch as new patch",
        "down",
        null,
        { cmdCtrl: true, shiftKey: true },
        () => {
          CABLES.CMD.PATCH.saveAs();
        },
      );

      this.keys.key("s", "Save patch", "down", null, { cmdCtrl: true }, () => {
        Gui.gui.corePatch().checkExtensionOpPatchAssets();

        if (
          document.activeElement.classList.contains("ace_text-input") &&
          Gui.gui.mainTabs.getSaveButton() &&
          Gui.gui.maintabPanel.isVisible()
        ) {
          // && !this.patchView.hasFocus()
          Gui.gui.mainTabs.getSaveButton().cb();
        } else {
          const subOuter = Gui.gui.patchView.getSubPatchOuterOp(
            Gui.gui.patchView.getCurrentSubPatch(),
          );
          if (subOuter) {
            const bp = subOuter.isBlueprint2() || subOuter.isInBlueprint2();
            if (bp) {
              Gui.gui.showLoadingProgress(true);

              subPatchOpUtil.updateSubPatchOpAttachment(
                Gui.gui.patchView.getSubPatchOuterOp(bp),
                {
                  oldSubId: bp,
                  next: () => {
                    if (!Gui.gui.savedState.getStateBlueprint(0))
                      CABLES.CMD.PATCH.save();
                  },
                },
              );
            } else {
              CABLES.CMD.PATCH.save();
            }
          } else {
            CABLES.CMD.PATCH.save();
          }
        }
      });

      this.keys.key(
        " ",
        "show/hide timeline",
        "down",
        null,
        { cmdCtrl: true, ignoreInput: true },
        () => {
          Gui.gui.toggleTimeline();
        },
      );

      this.keys.key(
        " ",
        "Play/Pause timeline",
        "down",
        null,
        { ignoreInput: true },
        () => {
          if (
            document.activeElement.tagName == "BODY" ||
            document.activeElement.tagName == "DIV"
          )
            Gui.gui.toggleTimelinePlay();

          if (this._spaceBarStart === 0) this._spaceBarStart = Date.now();
        },
      );

      this.keys.key(
        " ",
        "Play/Pause timeline",
        "up",
        null,
        { ignoreInput: true },
        () => {
          if (document.activeElement.tagName == "CANVAS") {
            const timeused = Date.now() - this._spaceBarStart;
            if (timeused < 250) Gui.gui.toggleTimelinePlay();
          }
          this._spaceBarStart = 0;
        },
      );

      this.keys.key(
        "o",
        "Toggle Overlays",
        "down",
        null,
        { ignoreInput: true },
        () => {
          CABLES.CMD.UI.toggleOverlays();
        },
      );
    }

    toggleTimelinePlay() {
      Gui.gui.corePatch().timer.togglePlay();
    }

    /**
     * @param {KeyboardEvent} e
     */
    pressedEscape(e) {
      if (this.canvasManager.getCanvasUiBar())
        this.canvasManager.getCanvasUiBar().showCanvasModal(false);
      this.emitEvent("pressedEscape");

      if (this.fileManager) this.fileManager.setFilePort(null);

      if (e && (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey)) return;

      if (Gui.gui.longPressConnector.isActive())
        Gui.gui.longPressConnector.longPressCancel();
      else if (this.canvasMagnifier)
        this.canvasMagnifier = this.canvasMagnifier.close();
      else if (
        this.rendererWidth * this._corePatch.cgl.canvasScale >
        window.innerWidth * 0.9
      ) {
        if (this.canvasManager.mode == this.canvasManager.CANVASMODE_FULLSCREEN) {
          this.cycleFullscreen();
        } else {
          this.rendererWidth = window.innerWidth * 0.4;
          this.rendererHeight = window.innerHeight * 0.25;
        }

        this._elGlCanvasDom.classList.remove("maximized");
        this.setLayout();
        this.canvasManager.getCanvasUiBar().showCanvasModal(true);
      } else if (CABLES.UI.suggestions) {
        CABLES.UI.suggestions.close();
        CABLES.UI.suggestions = null;
      } else if (Gui.gui.cmdPallet.isVisible()) Gui.gui.cmdPallet.close();
      else if (contextMenu.isVisible()) contextMenu.close();
      else if (Gui.gui.isShowingModal()) {
        Gui.gui.closeModal();

        if (this.maintabPanel?._tabs?.getActiveTab()?.editor) {
          setTimeout(() => {
            this.maintabPanel?._tabs?.getActiveTab().editor.focus();
          }, 50); // why...
        }
      } else if (this._opselect.isOpen()) this._opselect.close();
      else if (
        this.maintabPanel.isVisible() &&
        Gui.gui.UserSettings.userSettings.get("escape_closetabs")
      )
        this.maintabPanel.hide();
      else {
        if (e) {
          CABLES.UI.OPSELECT.linkNewOpToPort = CABLES.UI.OPSELECT.linkNewLink =
            null;
          Gui.gui.opSelect().show({
            subPatch: this.patchView.getCurrentSubPatch(),
            x: 0,
            y: 0,
          });
        }
      }

      setTimeout(() => {
        ele.forEachClass("tooltip", (/** @type {Element | HTMLElement} */ el) => {
          ele.hide(el);
        });
      }, 50);
    }

    /**
     * @param {string} libName
     */
    showLibLoadError(libName) {
      iziToast.error({
        position: "topRight",
        theme: "dark",
        title: "error",
        message: "failed to load library: " + libName,
        progressBar: false,
        animateInside: false,
        close: true,
        timeout: false,
      });
    }

    showUiElements() {
      this._log.logGui(
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;____&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;________&nbsp;&nbsp;___________&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______",
      );
      this._log.logGui(
        "._(//&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;___)\\_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/(_\\___&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/(___&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/",
      );
      this._log.logGui(
        "|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_/___)\\&nbsp;_&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/______)/&nbsp;&nbsp;&nbsp;&nbsp;_/(___&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/(_____..___&nbsp;",
      );
      this._log.logGui(
        "|_&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/_/&nbsp;&nbsp;&nbsp;&nbsp;_/&nbsp;&nbsp;&nbsp;_//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;_)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;____&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;&nbsp;//",
      );
      this._log.logGui(
        "&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_/&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/_\\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;\\(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;_/&nbsp;&nbsp;&nbsp;_&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_||_/&nbsp;&nbsp;",
      );
      this._log.logGui(
        "/___________)__/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__________\\____________\\______&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\\\/________)diP",
      );
      this._log.logGui(
        "-&nbsp;------------/________/------------------------------\\_______\\-------------&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;",
      );

      this._log.logGui("");

      ele.show(ele.byId("cablescanvas"));
      ele.show(ele.byId("mainContainer"));

      ele.byId("menubar").classList.remove("hidden");

      if (this.UserSettings.userSettings.get("showUIPerf") == true)
        Gui.gui.uiProfiler.show();

      this._elGlCanvasDom.addEventListener("pointerenter", () => {
        Gui.gui.showInfo(text.canvas);
      });

      this._elGlCanvasDom.addEventListener("pointerleave", () => {
        hideInfo();
      });

      if (this.UserSettings.userSettings.get("presentationmode"))
        CABLES.CMD.UI.startPresentationMode();

      if (this._corePatch.cgl.aborted) {
        CABLES.UI.MODAL.showError(
          "no webgl",
          "your browser does not support webgl",
        );
        return;
      }

      if (this.UserSettings.userSettings.get("glTimelineOpened") == true)
        CABLES.CMD.TIMELINE.openGlTimeline();
      if (this.UserSettings.userSettings.get("fileManagerOpened") == true)
        this.showFileManager();
      if (this.UserSettings.userSettings.get("openLogTab") == true)
        this.showLogging();

      Gui.gui.transformOverlay.updateVisibility();

      this.iconBarLeft = new IconBar("sidebar_left");
      this.iconBarPatchNav = new IconBar("sidebar_bottom");
      this.iconBarTimeline = new IconBar("sidebar_timeline");

      if (
        this.getRestriction() != Gui.gui.RESTRICT_MODE_REMOTEVIEW &&
        this.UserSettings.userSettings.get("showTipps") &&
        this.UserSettings.userSettings.get("introCompleted")
      )
        CABLES.CMD.UI.showTips();

      if (
        platform.frontendOptions.showWelcome &&
        this.corePatch().ops.length == 0
      )
        CABLES.CMD.UI.welcomeTab(true);

      let ver = "";
      ver += platform.getCablesVersion();
      if (platform.isDevEnv()) ver += " (dev)";
      this._log.groupCollapsed("welcome to cables " + ver + "!");

      if (platform.getPatchVersion())
        Gui.gui.restriction.setMessage(
          "backup",
          "This is a backup version, saving will overwrite the current version!",
        );

      console.log("start up times:");
      console.table(CABLESUILOADER.startup.log);
      console.groupEnd();

      if (this.isRemoteClient) this._log.logGui("REMOTE CLIENT SESSION");

      this._log.logGui("browser: " + platformLib.description);

      const branches = {};

      const buildInfo = CABLESUILOADER.buildInfo;
      if (buildInfo.ui && buildInfo.ui.git) {
        const branch = buildInfo.ui.git.branch;
        if (!branches.hasOwnProperty(branch)) branches[branch] = [];
        branches[branch].push("ui");
        this._log.logGui(
          "BuildInfo: [" +
            branch +
            "] UI buildmessage: " +
            buildInfo.ui.git.message,
        );
      }

      if (buildInfo.core && buildInfo.core.git) {
        const branch = buildInfo.core.git.branch;
        if (!branches.hasOwnProperty(branch)) branches[branch] = [];
        branches[branch].push("core");
        this._log.logGui(
          "BuildInfo: [" +
            branch +
            "] CORE buildmessage: " +
            buildInfo.core.git.message,
        );
      }

      if (buildInfo.api && buildInfo.api.git) {
        const branch = buildInfo.api.git.branch;
        if (!branches.hasOwnProperty(branch)) branches[branch] = [];
        branches[branch].push("api");
        this._log.logGui(
          "BuildInfo: [" +
            branch +
            "] API buildmessage: " +
            buildInfo.api.git.message,
        );
      }

      if (buildInfo.shared && buildInfo.shared.git) {
        const branch = buildInfo.shared.git.branch;
        if (!branches.hasOwnProperty(branch)) branches[branch] = [];
        branches[branch].push("shared");
        this._log.logGui(
          "BuildInfo: [" +
            branch +
            "] SHARED buildmessage: " +
            buildInfo.shared.git.message,
        );
      }

      if (Object.keys(branches).length > 1) {
        let msg = "Diverting branches: ";
        let first = true;
        for (const branch in branches) {
          if (!first) msg += ", ";
          first = false;
          const repos = branches[branch].join(" and ");
          msg += repos + " on " + branch;
        }
        this._log.error(msg);
      }

      Gui.gui.savedState.setSavedAll("showUiElements");
      Gui.gui.savedState.resume();

      Gui.gui.metaTabs.loadCurrentTabUsersettings();
      Gui.gui.patchView.focus();

      setTimeout(() => {
        Gui.gui.setLayout();
        Gui.gui.mainTabs.emitEvent("resize");
      }, 100);

      setTimeout(() => {
        ele.hide(ele.byId("loadingstatus"));
      }, 0);
    }

    showWelcomeNotifications() {
      if (!Gui.gui.isRemoteClient && platform.showGitBranchWarning)
        platform.showGitBranchWarning();
      if (!Gui.gui.isRemoteClient && platform.showBrowserWarning)
        platform.showBrowserWarning();
      if (!Gui.gui.isRemoteClient && platform.showStartupChangelog)
        platform.showStartupChangelog();
    }

    getOpDoc(opname, _html, cb) {
      cb(this.opDocs.getHtml(opname));
    }

    showSettings() {
      window.onmessage = (e) => {
        if (e.data && typeof e.data == "string") {
          const c = e.data.split(":");
          if (c.length > 1) {
            if (c[0] == "projectname") this.setProjectName(c[1]);
            if (c[0] == "notify") notify(c[1]);
            if (c[0] == "notifyerror") notifyError(c[1]);
            if (c[0] == "cmd" && c[1] == "saveproject")
              this.patchView.store.saveCurrentProject();
          }
        }
      };

      const url =
        platform.getCablesUrl() +
        "/patch/" +
        this.project().shortId +
        "/settings?iframe=true";
      Gui.gui.mainTabs.addIframeTab(
        "Patch Settings",
        url,
        {
          icon: "settings",
          closable: true,
          singleton: true,
          gotoUrl:
            platform.getCablesUrl() +
            "/patch/" +
            this.project().shortId +
            "/settings",
        },
        true,
      );
    }

    setCursor(str) {
      if (!str) str = "auto";
      document.body.classList.remove("cursor_" + this._cursor);
      document.body.classList.add("cursor_" + str);
      this._cursor = str;
    }

    getSavedState() {
      return this.savedState.isSaved;
    }

    setTransformGizmo(params, idx) {
      if (params == null && idx === undefined) {
        for (let i = 0; i < this._gizmo.length; i++) this._gizmo[i].set(params);
        return;
      }

      idx = idx || 0;
      if (!this._gizmo[idx]) this._gizmo[idx] = new Gizmo(this.corePatch().cgl);

      if (!this.UserSettings.userSettings.get("overlaysShow")) {
        this._gizmo[idx].set(null);
        return;
      }

      this._gizmo[idx].set(params);
    }

    /**
     * @param {string} id
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    setTransform(id, x, y, z) {
      if (this.shouldDrawOverlay)
        this.transformOverlay.add(this.corePatch().cgl, id, x, y, z);
    }

    /**
     * @param {HTMLElement} el
     */
    setElementBgPattern(el) {
      if (!el) return;
      el.classList.remove("bgPatternDark");
      el.classList.remove("bgPatternBright");
      el.classList.remove("bgPatternBlack");
      el.classList.remove("bgPatternWhite");
      el.classList.remove("bgPatternRed");
      el.classList.remove("bgPatternGrey");
      el.classList.remove("bgPatternBlue");

      el.classList.add(
        this.UserSettings.userSettings.get("bgpattern") || "bgPatternDark",
      );
    }

    notIdling() {
      this.lastNotIdle = CABLES.now();
    }

    checkIdle() {
      const idling = (CABLES.now() - this.lastNotIdle) / 1000;
      if (idling > 30 * 60) ; else {
        setTimeout(Gui.gui.checkIdle, 1000 * 60 * 2);
      }
    }

    setStateUnsaved() {
      this.savedState.setUnSaved("unknown", 0);
    }

    reloadDocs(cb) {
      Gui.gui.opDocs.addCoreOpDocs();
      if (cb) cb();
    }

    pauseProfiling() {
      if (!this._corePatch.cgl || !this._corePatch.cgl.profileData) return;
      this._corePatch.cgl.profileData.pause = true;

      clearTimeout(this._timeoutPauseProfiler);
      this._timeoutPauseProfiler = setTimeout(() => {
        this._corePatch.cgl.profileData.pause = false;
      }, 200);
    }

    hideElementsByRestriction(r) {
      if (r == Gui.gui.RESTRICT_MODE_REMOTEVIEW) {
        ele.byId("undev").style.display = "none";
        ele.byId("infoAreaContainer").style.display = "none";
        ele.forEachClass("splitter", (el) => {
          ele.hide(el);
        });
      }

      if (r < Gui.gui.RESTRICT_MODE_FULL) {
        const optionsPanel = ele.byId("options");
        if (optionsPanel) optionsPanel.classList.add("readonly");

        const tabpanel = ele.byId("metatabpanel");
        if (tabpanel) {
          tabpanel.querySelectorAll(".tabcontent").forEach((tab) => {
            tab.classList.add("readonly");
            tab.inert = true;
          });
        }
        const timeline = ele.byId("timing");
        if (timeline) timeline.classList.add("readonly");

        const tlIconBar = ele.byId("iconbar_sidebar_timeline");
        if (tlIconBar) ele.hide(tlIconBar);
      } else {
        const optionsPanel = ele.byId("options");
        if (optionsPanel) {
          optionsPanel.classList.remove("readonly");
        }
        const tabpanel = ele.byId("metatabpanel");
        if (tabpanel) {
          tabpanel.querySelectorAll(".tabcontent").forEach((tab) => {
            tab.classList.remove("readonly");
            // @ts-ignore
            tab.inert = false;
          });
        }
        const timeline = ele.byId("timing");
        if (timeline) timeline.classList.remove("readonly");

        const tlIconBar = ele.byId("iconbar_sidebar_timeline");
        if (tlIconBar) ele.show(tlIconBar);
      }

      if (this.iconBarLeft)
        this.iconBarLeft.setVisible(r > Gui.gui.RESTRICT_MODE_FOLLOWER);
      if (this.iconBarPatchNav)
        this.iconBarPatchNav.setVisible(r > Gui.gui.RESTRICT_MODE_FOLLOWER);
      if (this.bottomInfoArea)
        this.bottomInfoArea.setVisible(r > Gui.gui.RESTRICT_MODE_FOLLOWER);
    }

    init() {
      // this.canvasManager.getCanvasUiBar() = new CABLES.UI.CanvasUi(this.corePatch().cgl);

      this.setTheme(JSON.parse(JSON.stringify(defaultTheme)));

      if (
        window.localStorage.getItem("cables_theme") &&
        window.localStorage.getItem("cables_theme") != "null" &&
        window.localStorage.getItem("cables_theme") != "undefined"
      ) {
        try {
          this._log.log(
            " found theme in localstorage!",
            JSON.parse(window.localStorage.getItem("cables_theme")),
          );
          this.setTheme(JSON.parse(window.localStorage.getItem("cables_theme")));
        } catch (e) {
          this._log.error(e);
        }
      }

      hljs.configure({ ignoreUnescapedHTML: true });

      if (this.isRemoteClient)
        this.setRestriction(Gui.gui.RESTRICT_MODE_REMOTEVIEW);
      else this.setRestriction(Gui.gui.RESTRICT_MODE_FULL);

      initSplitPanes();

      ele.byId("undev").addEventListener("pointerEnter", () => {
        Gui.gui.showInfo(text.undevLogo);
      });
      ele.byId("undev").addEventListener("pointerLeave", () => {
        hideInfo();
      });

      this.replaceNavShortcuts();
    }

    /**
     * @param {number} v
     */
    setFontSize(v) {
      v = v || 0;
      document.documentElement.style.setProperty(
        "--font-size-off",
        (v || 0) + "px",
      );
    }

    /**
     * @param {object} u
     */
    setUser(u) {
      this.user = u;
    }

    initCoreListeners() {
      this._corePatch.on("portAnimToggle", (_options) => {
        this.hasAnims = true;
      });

      this._corePatch.on("portAnimUpdated", (_options) => {
        if (!this.hasAnims) {
          this.hasAnims = true;
          this.setLayout();
        }
      });

      this._corePatch.on("criticalError", (options) => {
        new ModalError(options);
      });

      this._corePatch.on("renderDelayStart", () => {});

      this._corePatch.on("renderDelayEnd", () => {});

      this._corePatch.cgl.on("webglcontextlost", () => {
        new ModalDialog({
          warnning: true,
          title: "Context lost",
          text: "something went wrong. webgl context was lost. reload page or try restarting your browser",
        });
      });

      this._corePatch.checkExtensionOpPatchAssets();
    }

    /**
     * @param {string} txt
     */
    showInfoParam(txt) {
      showInfo(txt, true);
    }

    /**
     * @param {string} txt
     */
    showInfo(txt) {
      showInfo(txt);
    }

    /**
     * @param {number} r
     */
    setRestriction(r) {
      if (this._restrictionMode !== r) {
        this._restrictionMode = r;
        this.hideElementsByRestriction(r);
        this.emitEvent("restrictionChange", r);
        this.setLayout();
      }
    }

    getRestriction() {
      return this._restrictionMode;
    }

    getSavedStateChangesBlueprintSubPatches() {
      return []; // this._savedStateChangesBlueprintSubPatches; // old blueprints
    }

    setTheme(theme = {}) {
      if (!theme) return;

      theme = JSON.parse(JSON.stringify(theme));
      theme.colors = theme.colors || {};

      const missing = {};

      /**
       * @param {Array<Number>} rgb
       */
      function rgbtohex(rgb) {
        return (
          "#" +
          (
            (rgb[2] * 255) |
            ((rgb[1] * 255) << 8) |
            ((rgb[0] * 255) << 16) |
            (1 << 24)
          )
            .toString(16)
            .slice(1)
        );
      }

      const topics = Object.keys(defaultTheme);

      for (let i = 0; i < topics.length; i++) {
        const topic = topics[i];
        theme[topic] = theme[topic] || {};
        missing[topic] = {};

        for (let j in defaultTheme[topic]) {
          if (!theme[topic].hasOwnProperty(j))
            missing[topic][j] = theme[topic][j] = defaultTheme[topic][j];
        }
      }

      for (let i in theme.colors_html) {
        document.documentElement.style.setProperty(
          "--" + i,
          rgbtohex(theme.colors_html[i] || [1, 1, 1, 1]),
        );
      }

      for (let i in theme.colors_textedit) {
        document.documentElement.style.setProperty(
          "--" + i,
          rgbtohex(theme.colors_textedit[i] || [1, 1, 1, 1]),
        );
      }

      theme.colors_vizlayer = theme.colors_vizlayer || {};
      for (let i in theme.colors_vizlayer) {
        theme.colors_vizlayer[i] = rgbtohex(
          theme.colors_vizlayer[i] || [1, 1, 1, 1],
        );
      }

      document.documentElement.style.setProperty(
        "--color_port_function",
        rgbtohex(theme.colors_types.trigger || [1, 1, 1, 1]),
      );
      document.documentElement.style.setProperty(
        "--color_port_value",
        rgbtohex(theme.colors_types.num || [1, 1, 1, 1]),
      );
      document.documentElement.style.setProperty(
        "--color_port_object",
        rgbtohex(theme.colors_types.obj || [1, 1, 1, 1]),
      );
      document.documentElement.style.setProperty(
        "--color_port_string",
        rgbtohex(theme.colors_types.string || [1, 1, 1, 1]),
      );
      document.documentElement.style.setProperty(
        "--color_port_array",
        rgbtohex(theme.colors_types.array || [1, 1, 1, 1]),
      );

      this.theme = theme;

      const nsColors = document.createElement("style");
      document.body.appendChild(nsColors);

      let strNsCss = "";

      for (let i in theme.colors_namespaces) {
        let ns = i;
        ns = ns.replaceAll(".", "_");
        strNsCss +=
          ".nsColor_" +
          ns +
          "{color:" +
          rgbtohex(theme.colors_namespaces[i]) +
          " !important;}\n";
      }

      nsColors.textContent = strNsCss;

      this.emitEvent("themeChanged");
      return missing;
    }

    getDefaultTheme() {
      return JSON.parse(JSON.stringify(defaultTheme));
    }

    getTimeLineLength() {
      return 1;
    }

    /**
     * @param {Number} dur
     */
    setTimeLineLength(dur) {
      console.log("timeline length", dur);
    }

    hide() {
      if (gui) Gui.gui.unload = true;
      this._corePatch.pause();

      ele.byId("gluiPreviewLayer").style.opacity =
        ele.byId("maincomponents").style.opacity =
        ele.byId("mainContainer").style.opacity =
        ele.byId("cablescanvas").style.opacity =
          "0.0000000001";
      document.body.style["pointer-events"] = "none";
    }
  };

  let tooltipTimeout = null;
  let eleTooltip = null;
  let inited = false;

  function showToolTip(e, txt, nopadding) {
    eleTooltip = eleTooltip || ele.byId("cbltooltip");
    if (!eleTooltip) return;

    ele.show(eleTooltip);

    eleTooltip.classList.toggle("tooltip_nopadding", nopadding);

    if (!inited) {
      eleTooltip.addEventListener(
        "mouseover",
        function (_evt) {
          hideToolTip();
        },
        true,
      );

      inited = true;
    }

    if (e) {
      if (e.style) {
        eleTooltip.style.top = e.getBoundingClientRect().top + 25 + "px";
        eleTooltip.style.left = e.getBoundingClientRect().left + "px";
      } else {
        eleTooltip.style.top = e.clientY + 12 + "px";
        eleTooltip.style.left = e.clientX + 25 + "px";
      }
    }

    eleTooltip.innerHTML = txt;
  }

  function hideToolTip() {
    if (!eleTooltip) return;

    Gui$1.gui.emitEvent("portHovered", null);

    clearTimeout(tooltipTimeout);
    clearInterval(CABLES.UI.hoverInterval);

    CABLES.UI.hoverInterval = -1;
    ele.hide(eleTooltip);
  }

  function eleTtOver(e) {
    clearTimeout(tooltipTimeout);
    const txt = e.target.dataset.tt;
    if (txt)
      tooltipTimeout = setTimeout(() => {
        showToolTip(e, txt);
      }, 300);
  }

  function eleTtOut(_e) {
    if (document.activeElement.classList.contains("tt")) return;
    clearTimeout(tooltipTimeout);
    hideToolTip();
  }

  // --------------------------

  function showInfo(txt, param) {
    if (param) Gui$1.gui.bottomInfoArea.setContentParam(txt);
    else Gui$1.gui.bottomInfoArea.setContent(txt);
  }

  function hideInfo() {
    Gui$1.gui.bottomInfoArea.setContent("");
  }

  function eleInfoOver(e) {
    Gui$1.gui.bottomInfoArea.hoverInfoEle(e);
  }

  function eleInfoOut(_e) {
    clearTimeout(tooltipTimeout);
    hideInfo();
  }

  document.querySelector("body").addEventListener(
    "mouseover",
    function (evt) {
      if (!evt || !evt.target || !evt.target.classList) return;
      if (evt.target.classList.contains("tt")) eleTtOver(evt);
      if (evt.target.classList.contains("info")) eleInfoOver(evt);
    },
    true,
  );

  document.querySelector("body").addEventListener(
    "mouseout",
    function (evt) {
      if (!evt || !evt.target || !evt.target.classList) return;
      if (evt.target.classList.contains("tt")) eleTtOut();
      if (evt.target.classList.contains("info")) eleInfoOut();
    },
    true,
  );

  function isMultilineString(str) {
    if (!str || !str.match || !str.length) return false;
    return (str.match(/\n/g) || []).length > 0;
  }

  function getPortDescription(thePort, overlink) {
    let str = "";

    let objType = thePort.uiAttribs.objType || "";
    if (objType) objType += " ";

    let stride = "";
    if (thePort.uiAttribs.stride) stride = thePort.uiAttribs.stride;

    str +=
      '<span class="tooltip_port" style="background-color:var(--color_port_' +
      thePort.getTypeString().toLowerCase() +
      ');">';
    str += thePort.getTypeString() + stride;
    str += "</span>";

    if (objType) {
      objType = objType.charAt(0).toUpperCase() + objType.slice(1);
      str += '<span class="tooltip_objtype">' + objType + "</span>";
    }

    // if (!overlink)
    // {
    if (thePort.uiAttribs.title)
      str +=
        " <b>" + thePort.uiAttribs.title + " (" + thePort.getName() + ") </b> ";
    else str += " <b>" + thePort.getName() + "</b> ";
    // }
    // else
    // {
    // str += overlink.opOut.op.getTitle() + "." + overlink._portNameOutput + " <i class=\"icon-0_75x icon icon-arrow-right\" align=\"bottom\" ></i>" + overlink.opIn.op.getTitle() + "." + overlink._portNameInput;
    // str += overlink._portNameOutput + " <i class=\"icon-0_75x icon icon-arrow-right\" ></i>" + overlink._portNameInput;
    // }

    if (!overlink) {
      let strInfo = "";

      if (thePort.direction == PortDir.in) strInfo += text.portDirIn;
      if (thePort.direction == PortDir.out) strInfo += text.portDirOut;
      if (thePort.isLinked()) strInfo += text.portMouseUnlink;
      else strInfo += text.portMouseCreate;
      Gui$1.gui.showInfo(strInfo);
    }

    return str;
  }

  function updateHoverToolTip(event, port, overlink) {
    Gui$1.gui.emitEvent("portHovered", port);
    if (!port) return;

    let txt = getPortDescription(port, overlink);
    let val = null;

    if (port && !port.uiAttribs.hidePort) {
      //! port.uiAttribs.hideParam
      if (port.type == portType.number) {
        val = port.getValueForDisplay();
        if (CABLES.isNumeric(val)) val = Math.round(val * 1000) / 1000;

        txt += '<span class="tooltip_value">' + val + "</span>";
      } else if (port.type == portType.string) {
        val = port.getValueForDisplay();
        if (isMultilineString(val)) {
          val = '"' + val + '"';
          txt +=
            ': <span class="tooltip_value multiline-string-port">' +
            val +
            "</span>";
        } else {
          val = '"' + val + '"';
          txt += ': <span class="tooltip_value">' + val + "</span>";
        }
      } else if (port.type == portType.array) {
        val = port.get();
        if (val) {
          txt += " (total:" + val.length + ') <span class="tooltip_value">';
          for (let i = 0; i < Math.min(3, val.length); i++) {
            if (i != 0) txt += ", ";

            if (CABLES.isNumeric(val[i])) txt += Math.round(val[i] * 1000) / 1000;
            else if (typeof val[i] == "string") txt += '"' + val[i] + '"';
            else if (typeof val[i] == "object") {
              txt += "[object]";
            } else JSON.stringify(val[i]);
          }

          txt += " ... </span>";
        } else txt += '<span class="tooltip_value">null</span>';
      } else if (port.type == portType.object) {
        if (!port.get()) txt += '<span class="tooltip_value">null</span>';
        if (port.get()) {
          if (port.get().getInfoOneLineShort)
            txt +=
              '<span class="tooltip_value">' +
              port.get().getInfoOneLineShort() +
              "</span>";
          else if (port.get().getInfoOneLine)
            txt +=
              '<span class="tooltip_value">' +
              port.get().getInfoOneLine() +
              "</span>";
        }
      } else {
        txt += "&nbsp;&nbsp;";
      }

      if (
        Gui$1.gui.patchView.patchRenderer.dragLine &&
        Gui$1.gui.patchView.patchRenderer.dragLine.isActive
      ) {
        let oport = Gui$1.gui.patchView.patchRenderer.dragLine.glPort.port;
        if (Gui$1.gui.patchView.patchRenderer.dragLine._startGlPorts[0])
          oport = Gui$1.gui.patchView.patchRenderer.dragLine._startGlPorts[0].port;

        if (!CABLES.Link.canLink(port, oport))
          txt =
            '<span class="icon icon-alert-triangle icon-warning icon-near-text fleft"></span> &nbsp;' +
            CABLES.Link.canLinkText(port, oport);
      }
    }
    txt += "&nbsp;";

    if (port.apf > 0) txt += "" + Math.round(port.apf * 100) / 100 + " APF ";

    showToolTip(event, txt, true);

    if (overlink) {
      clearInterval(CABLES.UI.hoverInterval);
      CABLES.UI.hoverInterval = -1;
    }

    if (CABLES.UI.hoverInterval == -1)
      CABLES.UI.hoverInterval = setInterval(() => {
        updateHoverToolTip(event, port, overlink);
      }, 50);
  }

  /**
   * configuration object for a modal dialog
   * @typedef {Object} ModalDialogOptions
   * @hideconstructor
   * @property {String} [html=''] html content
   * @property {String} [tite=''] a title of the dialog
   * @property {Boolean} [nopadding=false] remove padding around the window
   * @property {Boolean} [warning=false] show a warning triangle
   * @property {Boolean} [showOkButton=false] show a ok button to close the dialog
   * @property {Boolean} [prompt=false] show an input field to enter a value
   * @property {Boolean} [choice=false] show ok/cancel buttons with onSubmit and onClosed callbacks
   */

  /**
   * open a modal dialog
   *
   * @param {ModalDialogOptions} options The option object.
   * @example
   * new ModalDialog(
   * {
   *     "title":"Title",
   *     "html":"hello world",
   * });
   */
  class ModalDialog extends Events {
    constructor(options, autoOpen = true) {
      super();
      this._log = new Logger("ModalDialog");

      if (window.gui && Gui$1.gui.currentModal) Gui$1.gui.currentModal.close();
      this._options = options;
      this._options.okButton = this._options.okButton || {};
      if (!this._options.okButton.text) this._options.okButton.text = "Ok";
      if (!this._options.okButton.cssClasses)
        this._options.okButton.cssClasses = "bluebutton";
      if (!this._options.okButton.callback)
        this._options.okButton.callback = null;

      this._options.cancelButton = this._options.cancelButton || {};
      if (!this._options.cancelButton.text)
        this._options.cancelButton.text = "Cancel";
      if (!this._options.cancelButton.cssClasses)
        this._options.cancelButton.cssClasses = "button";
      if (!this._options.cancelButton.callback)
        this._options.cancelButton.callback = null;

      this._checkboxGroups = this._options.checkboxGroups || [];

      this._ele = null;
      this._eleContent = null;
      this._bg = new ModalBackground();

      if (autoOpen) this.show();

      ele.byId("modalclose").style.display = "block";

      if (window.gui) Gui$1.gui.currentModal = this;

      this._bg.on("hide", this.close.bind(this));
    }

    close() {
      this._ele.remove();
      this._bg.hide();
      if (window.gui) Gui$1.gui.currentModal = null;
      this.emitEvent("onClose", this);
    }

    html() {
      let html = "";

      if (this._options.title) html += "<h2>";
      if (this._options.warning)
        html +=
          '<span class="icon icon-2x icon-alert-triangle" style="vertical-align:bottom;"></span>&nbsp;&nbsp;';
      if (this._options.title) html += this._options.title + "</h2>";

      if (this._options.text) html += this._options.text;
      if (this._options.html) html += this._options.html;

      if (this._options.prompt) {
        html += "<br/><br/>";
        html +=
          '<input id="modalpromptinput" class="medium" value="' +
          (this._options.promptValue || "") +
          '"/>';
        html += "<br/>";
      }

      if (this._checkboxGroups.length > 0) {
        this._checkboxGroups.forEach((group) => {
          html += '<div class="checkbox_group">';
          html += '<div class="checkbox_group_title">' + group.title + "</div>";
          group.checkboxes.forEach((checkbox) => {
            const id = "modal_checkbox_" + checkbox.name;
            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.alignItems = "center";

            const checkboxEle = document.createElement("input");
            checkboxEle.classList.add("modalcheckbox");
            checkboxEle.setAttribute("id", id);
            checkboxEle.setAttribute("type", "checkbox");
            if (checkbox.name) checkboxEle.setAttribute("name", checkbox.name);
            if (checkbox.value) checkboxEle.setAttribute("value", checkbox.value);
            if (checkbox.checked) checkboxEle.setAttribute("checked", "checked");
            if (checkbox.disabled)
              checkboxEle.setAttribute("disabled", "disabled");
            if (checkbox.tooltip) {
              checkboxEle.classList.add("tt", "tt-info");
              checkboxEle.dataset.tt = checkbox.tooltip;
            }
            checkboxContainer.appendChild(checkboxEle);
            if (checkbox.title) {
              checkboxContainer.innerHTML +=
                '<label for="' + id + '">' + checkbox.title + "</label>";
            }
            html += checkboxContainer.outerHTML;
          });
          html += "</div>";
        });
      }

      if (this._options.notices && this._options.notices.length > 0) {
        html += '<div class="modallist notices">';
        html += "<ul>";
        for (let i = 0; i < this._options.notices.length; i++) {
          const item = this._options.notices[i];
          html += "<li>" + item + "</li>";
        }
        html += "</ul></div>";
      }

      if (this._options.footer) {
        html += this._options.footer;
      }

      if (this._options.prompt) {
        html += "<br/>";
        html +=
          '<a class="' +
          this._options.okButton.cssClasses +
          '" id="prompt_ok">&nbsp;&nbsp;&nbsp;' +
          this._options.okButton.text +
          "&nbsp;&nbsp;&nbsp;</a>";
        html +=
          '&nbsp;&nbsp;<a class="button" id="prompt_cancel">&nbsp;&nbsp;&nbsp;' +
          this._options.cancelButton.text +
          "&nbsp;&nbsp;&nbsp;</a>";
      }

      if (this._options.choice) {
        html += "<br/><br/>";
        html +=
          '<a class="' +
          this._options.okButton.cssClasses +
          '" id="choice_ok">&nbsp;&nbsp;&nbsp;' +
          this._options.okButton.text +
          "&nbsp;&nbsp;&nbsp;</a>";
        html +=
          '&nbsp;&nbsp;<a class="' +
          this._options.cancelButton.cssClasses +
          '" id="choice_cancel">&nbsp;&nbsp;&nbsp;' +
          this._options.cancelButton.text +
          "&nbsp;&nbsp;&nbsp;</a>";
      }

      if (this._options.showOkButton) {
        html +=
          '<br/><br/><a class="' +
          this._options.okButton.cssClasses +
          '" id="modalClose">&nbsp;&nbsp;&nbsp;' +
          this._options.okButton.text +
          "&nbsp;&nbsp;&nbsp;</a>";
      }

      return html;
    }

    _addListeners() {
      this._eleClose.addEventListener("pointerdown", this.close.bind(this));

      const elePromptInput = ele.byId("modalpromptinput");
      if (elePromptInput) {
        elePromptInput.focus();
        elePromptInput.addEventListener("keydown", (e) => {
          if (e.code == "Enter") this._promptSubmit();
        });
      }

      const elePromptOk = ele.byId("prompt_ok");
      if (elePromptOk) {
        elePromptOk.addEventListener("pointerdown", () => {
          this._promptSubmit();
        });
      }

      const elePromptCancel = ele.byId("prompt_cancel");
      if (elePromptCancel)
        elePromptCancel.addEventListener("pointerdown", this.close.bind(this));

      const eleChoiceOk = ele.byId("choice_ok");
      if (eleChoiceOk) {
        eleChoiceOk.addEventListener("pointerdown", () => {
          this._choiceSubmit();
        });
      }

      const eleChoiceCancel = ele.byId("choice_cancel");
      if (eleChoiceCancel) {
        eleChoiceCancel.addEventListener("pointerdown", () => {
          this.close();
          if (this._options.cancelButton.callback)
            this._options.cancelButton.callback();
        });
      }

      const eleModalOk = ele.byId("modalClose");
      if (eleModalOk) {
        eleModalOk.addEventListener("pointerdown", () => {
          this.close();
          if (this._options.okButton.callback) this._options.okButton.callback();
        });
      }
    }

    /**
     * @param {string} h
     */
    updateHtml(h) {
      this._options.html = h;
      this._eleContent.innerHTML = this.html();

      Array.from(document.querySelectorAll("pre code")).forEach(function (block) {
        hljs.highlightElement(block);
      });
    }

    show() {
      this._bg.show();

      this._ele = document.createElement("div");
      this._eleContent = document.createElement("div");

      this._eleCloseIcon = document.createElement("span");
      this._eleCloseIcon.classList.add("icon-x", "icon", "icon-2x");
      this._eleClose = document.createElement("div");
      this._eleClose.classList.add("modalclose");
      this._eleClose.appendChild(this._eleCloseIcon);
      this._eleClose.style.display = "block";

      this._ele.classList.add("modalcontainer");
      this._ele.classList.add("cablesCssUi");
      this._ele.appendChild(this._eleClose);
      this._ele.appendChild(this._eleContent);

      document.body.appendChild(this._ele);

      if (!this._options.nopadding) this._eleContent.style.padding = "15px";
      if (this._options.nopadding) this._ele.style.padding = "0px";

      this._eleContent.innerHTML = this.html();

      Array.from(document.querySelectorAll("pre code")).forEach(function (block) {
        hljs.highlightElement(block);
      });

      this._addListeners();

      hideToolTip();

      this.emitEvent("onShow", this);

      setTimeout(() => {
        if (ele.byId("modalpromptinput")) ele.byId("modalpromptinput").focus();
      }, 50); // why is this delay needed in some cases (e.g. resolution button below canvas)
    }

    getElement() {
      return this._ele;
    }

    _choiceSubmit() {
      const states = this._getCheckboxStates();
      this.close();
      this.emitEvent("onSubmit", null, states);
    }

    _promptSubmit() {
      const elePromptInput = ele.byId("modalpromptinput");

      if (!elePromptInput)
        return this._log.warn("modal prompt but no input...?!");
      if (!this._options.promptOk)
        return this._log.warn("modal prompt but no promptOk callback!");

      const states = this._getCheckboxStates();
      this.close();
      this._options.promptOk(elePromptInput.value, states);
      this.emitEvent("onSubmit", elePromptInput.value, states);
    }

    persistInIdleMode() {
      return this._options.persistInIdleMode;
    }

    _getCheckboxStates() {
      const checkboxes = ele.byQueryAll(".modalcheckbox");
      const checkboxStates = {};
      checkboxes.forEach((checkbox) => {
        let state = checkbox.checked;
        if (state) {
          if (checkbox.value && checkbox.value !== "on") {
            state = checkbox.value;
          }
        }
        checkboxStates[checkbox.getAttribute("name")] = state;
      });
      return checkboxStates;
    }
  }

  /**
   * show a toast when cables changelog is new
   *
   * @export
   * @class ChangelogToast
   */
  class ChangelogToast {
    constructor() {
      this._log = new Logger("changelog");
    }

    getHtml(cb, since) {
      platform.talkerAPI.send("getChangelog", { num: 1 }, (err, obj) => {
        if (since) {
          if (obj.items)
            for (let i = 0; i < obj.items.length; i++)
              if (obj.items[i].date < since) obj.items.length = i;
          obj.onlyLatest = true;
        }

        let firstTime = false;

        if (!UserSettings.userSettings.get("changelogLastView")) {
          firstTime = true;
          this._log.log("first time changelog!");
        }

        UserSettings.userSettings.set("changelogLastView", obj.ts);

        if (!obj.items || obj.items.length === 0) {
          cb(null);
          return;
        }

        if (firstTime) {
          cb(null);
          return;
        }
        cb();
      });
    }

    showNotification() {
      iziToast.show({
        position: "topRight",
        theme: "dark",
        title: "UPDATE",
        message: "cables has been updated! ",
        progressBar: false,
        animateInside: false,
        close: true,
        timeout: false,
        buttons: [
          [
            "<button>Read More</button>",
            function (instance, toast) {
              window.open(platform.getCablesUrl() + "/changelog");
            },
          ],
        ],
      });
    }

    show() {
      if (Gui$1.gui.isRemoteClient) return;

      const url = platform.getCablesUrl() + "/changelog?iframe=true";
      const gotoUrl = platform.getCablesUrl() + "/changelog";

      Gui$1.gui.mainTabs.addIframeTab(
        "changelog",
        url,
        { icon: "book-open", closable: true, gotoUrl: gotoUrl },
        true,
      );
    }
  }

  class ElectronOpDirs {
    constructor(tabs) {
      this._log = new Logger("ElectronOpDirsTab");

      this._count = 0;
      this._timeout = null;

      this._tab = new Tab("op directories", {
        icon: "folder",
        singleton: true,
        infotext: "tab_profiler",
        padding: true,
      });
      tabs.addTab(this._tab, true);
      this.show();

      this._tab.on("onActivate", this.show);
    }

    show() {
      if (!this._tab) return;
      platform.talkerAPI.send("getProjectOpDirs", {}, (err, r) => {
        if (!err && r.data) {
          const html = getHandleBarHtml("tab_electron_opdirs", { dirs: r.data });
          this._tab.html(html);

          const listEle = ele.byId("dirlist");
          const infoBlock = listEle.querySelector(".highlightBlock");
          const addButton =
            this._tab.contentEle.querySelector("#addOpProjectDir");

          if (addButton) {
            addButton.addEventListener("click", () => {
              platform.talkerAPI.send(
                "addProjectOpDir",
                {},
                (dirErr, _dirRes) => {
                  if (!dirErr) {
                    this.show();
                    this._loadOpsInDirs();
                  } else {
                    new ModalDialog({
                      showOkButton: true,
                      warning: true,
                      title: "Warning",
                      text: dirErr.msg,
                    });
                    this._log.info(dirErr.msg);
                  }
                },
              );
            });
          }

          const packageButton =
            this._tab.contentEle.querySelector("#addOpPackage");
          if (packageButton) {
            packageButton.addEventListener("click", () => {
              platform.talkerAPI.send("addOpPackage", {}, (dirErr, _dirRes) => {
                if (!dirErr) {
                  this.show();
                  this._loadOpsInDirs();
                } else {
                  new ModalDialog({
                    showOkButton: true,
                    warning: true,
                    title: "Warning",
                    text: dirErr.msg,
                  });
                  this._log.info(dirErr.msg);
                }
              });
            });
          }

          const removeButtons = this._tab.contentEle.querySelectorAll(
            ".removeOpProjectDir",
          );
          removeButtons.forEach((removeButton) => {
            removeButton.addEventListener("click", () => {
              const dir = removeButton.dataset.dir;
              platform.talkerAPI.send("removeProjectOpDir", dir, () => {
                this.show();
                this._loadOpsInDirs();
              });
            });
          });
          ele.hide(infoBlock);

          new Sortable(listEle, {
            animation: 150,
            handle: ".handle",
            ghostClass: "ghost",
            dragClass: "dragActive",
            onEnd: () => {
              infoBlock.classList.add("info");
              infoBlock.classList.remove("error");
              const order = [];
              const dirs = listEle.querySelectorAll("[data-dir]");
              dirs.forEach((dirEle) => {
                order.push(dirEle.dataset.dir);
              });
              platform.talkerAPI.send(
                "saveProjectOpDirOrder",
                order,
                (orderErr, orderRes) => {
                  if (orderRes && orderRes.success) {
                    infoBlock.innerHTML =
                      "Saved, please reload the patch to see the changes";
                    ele.show(infoBlock);
                  } else {
                    infoBlock.classList.remove("info");
                    infoBlock.classList.add("error");
                    infoBlock.innerHTML = orderErr;
                    ele.show(infoBlock);
                  }
                },
              );
            },
          });
        }
      });
    }

    _loadOpsInDirs() {
      platform.talkerAPI.send(
        "getOpDocsAll",
        { projectId: Gui$1.gui.patchId },
        (_err, _data) => {
          if (_err) {
            this._log.error("preloading error", _err);
          } else {
            if (Gui$1.gui.opDocs) {
              Gui$1.gui.opDocs.addOpDocs(_data.opDocs);
            }
            Gui$1.gui.opSelect().reload();
          }
        },
        (response) => {
          this._log.error("preloading error", response);
        },
      );
    }
  }

  /**
   * @type {Platform}
   */
  var platform = null;

  /**
   * super class for platform implementations
   */
  class Platform extends Events {
    constructor(cfg = null) {
      super();
      platform = this;
      this._log = new Logger("platform");
      this._cfg = cfg;
      this._isOffline = false;
      this._checkOfflineInterval = null;
      this._checkOfflineIntervalSeconds = 2000;

      this.paths = {};
      this.frontendOptions = {};

      if (this._cfg) {
        if (window.CABLESUILOADER && this.talkerAPI) {
          this.talkerAPI.addEventListener("logError", (errorData) => {
            if (errorData) {
              const errorMessage = errorData.message || "unknown error";
              if (errorData.type && errorData.type === "network") {
                this.setOffline();
              }
              switch (errorData.level) {
                case "error":
                  this._log.error(errorMessage);
                  break;
                case "warn":
                  this._log.warn(errorMessage);
                  break;
                case "verbose":
                  this._log.verbose(errorMessage);
                  break;
                case "info":
                  this._log.info(errorMessage);
                  break;
                default:
                  this._log.log(errorMessage);
                  break;
              }
            } else {
              this._log.warn("unknown error");
            }
          });
        }

        if (this._cfg.usersettings && this._cfg.usersettings.settings)
          UserSettings.userSettings.load(this._cfg.usersettings.settings);
        else UserSettings.userSettings.load({});

        window.addEventListener("online", this.updateOnlineIndicator.bind(this));
        window.addEventListener("offline", this.updateOnlineIndicator.bind(this));
        this.updateOnlineIndicator();
      }
    }

    get config() {
      return this._cfg;
    }

    get talkerAPI() {
      return CABLESUILOADER.talkerAPI;
    }

    /** @abstract */
    getCablesDocsUrl() {
      return "";
    }

    /**
     * @param {String} opName
     */
    warnOpEdit(opName) {
      return (
        !platform.isDevEnv() &&
        namespace$1.isCoreOp(opName) &&
        !platform.isElectron()
      );
    }

    isElectron() {
      return false;
    }

    isTrustedPatch() {
      return this._cfg.isTrustedPatch;
    }

    getCablesVersion() {
      return "unknown version";
    }

    getPrefixAssetPath() {
      if (!this._cfg || !this._cfg.patchConfig) return "";
      return this._cfg.patchConfig.prefixAssetPath;
    }

    getIssueTrackerUrl() {
      return "https://github.com/cables-gl/cables_docs/issues";
    }

    isOffline() {
      return !navigator.onLine || this._isOffline;
    }

    setOnline() {
      this._isOffline = false;
      ele.hide(ele.byId("nav-item-offline"));
      if (this._checkOfflineInterval) clearInterval(this._checkOfflineInterval);
    }

    setOffline() {
      ele.show(ele.byId("nav-item-offline"));
      this._isOffline = true;
      if (!this._checkOfflineInterval) {
        this._checkOfflineInterval = setInterval(() => {
          Gui$1.gui.patchView.store.checkUpdated(null, false, true);
        }, this._checkOfflineIntervalSeconds);
      }
    }

    updateOnlineIndicator() {
      if (this.frontendOptions.needsInternet) {
        if (this.isOffline()) this.setOffline();
        else this.setOnline();
      }
    }

    /**
     * @param {boolean} b
     */
    setManualScreenshot(b) {
      this._cfg.patch.settings.manualScreenshot = b;
    }

    manualScreenshot() {
      return this._cfg.patch.settings.manualScreenshot;
    }

    getCablesUrl() {
      return this._cfg.urlCables;
    }

    getCablesStaticUrl() {
      return this.getCablesUrl();
    }

    isPatchSameHost() {
      if (
        !Gui$1.gui.project() ||
        !Gui$1.gui.project().buildInfo ||
        !Gui$1.gui.project().buildInfo.host
      )
        return true;
      return (
        Gui$1.gui.project().buildInfo.host ==
        platform
          .getCablesUrl()
          .replaceAll("https://", "")
          .replaceAll("http://", "")
      );
    }

    getSandboxUrl() {
      return this._cfg.urlSandbox || "";
    }

    getUrlOpsCode() {
      let url = this.getSandboxUrl() + "/api/ops/code";
      if (this.config.previewMode) url += "?preview=true";
      return url;
    }

    getUrlProjectOpsCode(projectId) {
      let url = this.getCablesUrl() + "/api/ops/code/project/" + projectId;
      if (this.config.previewMode) url += "?preview=true";
      return url;
    }

    getUrlApiPrefix() {
      return this._cfg.urlCables + "/api/";
    }

    getPatchVersion() {
      return this._cfg.patchVersion;
    }

    getSocketclusterConfig() {
      return this._cfg.socketcluster;
    }

    isDevEnv() {
      return this._cfg.isDevEnv;
    }

    noCacheUrl(url) {
      return url;
    }

    showStartupChangelog() {
      const lastView = UserSettings.userSettings.get("changelogLastView");
      const cl = new ChangelogToast();
      cl.getHtml((clhtml) => {
        if (clhtml !== null) {
          cl.showNotification();
        }
      }, lastView);
    }

    showBrowserWarning() {
      const isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;

      if (
        !Gui$1.gui.isRemoteClient &&
        !window.chrome &&
        !isFirefox &&
        !UserSettings.userSettings.get("nobrowserWarning")
      ) {
        iziToast.error({
          position: "topRight",
          theme: "dark",
          title: text.notOptimizedBrowser_title,
          message: text.notOptimizedBrowser_text,
          progressBar: false,
          animateInside: false,
          close: true,
          timeout: false,
        });
      }
    }

    showGitBranchWarning() {
      if (
        document.location.hostname != "cables.gl" &&
        document.location.hostname != "sandbox.cables.gl" &&
        CABLES.build &&
        CABLES.build.git.branch == "master"
      )
        notifyError("core: using master branch not on live?!");
      if (
        document.location.hostname != "cables.gl" &&
        document.location.hostname != "sandbox.cables.gl" &&
        CABLES.UI.build &&
        CABLES.UI.build.git.branch == "master"
      )
        notifyError("UI: using master branch not on live?!");
    }

    savePatch(options, cb) {
      this.talkerAPI.send("savePatch", options, cb);
    }

    initRouting(cb) {
      Gui$1.gui.setUser(this._cfg.user);

      this.talkerAPI.addEventListener("notify", (options, _next) => {
        notify(options.msg, options.text, options.options);
      });

      this.talkerAPI.addEventListener("notifyError", (options, _next) => {
        notifyError(options.msg, options.text, options.options);
      });

      this.talkerAPI.addEventListener("refreshFileManager", (_options, _next) => {
        Gui$1.gui.closeModal();
        Gui$1.gui.refreshFileManager();
      });

      this.talkerAPI.addEventListener("executeOp", (options, _next) => {
        if (options && options.name) {
          Gui$1.gui.serverOps.execute(options.id || options.name, () => {
            if (options.forceReload && options.name) {
              const editorTab = Gui$1.gui.mainTabs.getTabByDataId(options.name);
              if (
                editorTab &&
                editorTab.editor &&
                options.hasOwnProperty("code")
              ) {
                editorTab.editor.setContent(options.code, true);
              }
            }
            notify("reloaded op " + options.name);
          });
        }
      });

      this.talkerAPI.addEventListener("fileUpdated", (options, _next) => {
        if (options && options.filename) {
          for (let j = 0; j < Gui$1.gui.corePatch().ops.length; j++) {
            if (Gui$1.gui.corePatch().ops[j]) {
              if (Gui$1.gui.corePatch().ops[j].onFileChanged)
                Gui$1.gui.corePatch().ops[j].onFileChanged(options.filename);
              else if (Gui$1.gui.corePatch().ops[j].onFileUploaded)
                Gui$1.gui.corePatch().ops[j].onFileUploaded(options.filename); // todo deprecate , rename to onFileChanged
            }
          }
          if (options.filename.endsWith(".js")) {
            const libUrl =
              "/assets/" + Gui$1.gui.project()._id + "/" + options.filename;
            if (
              gui &&
              Gui$1.gui.opDocs &&
              Gui$1.gui.opDocs.libs &&
              !Gui$1.gui.opDocs.libs.includes(libUrl)
            ) {
              Gui$1.gui.opDocs.libs.push(libUrl);
              Gui$1.gui.emitEvent("refreshManageOp");
            }
          }
        }
      });

      this.talkerAPI.addEventListener("fileDeleted", (options, _next) => {
        if (options && options.fileName && options.fileName.endsWith(".js")) {
          for (let j = 0; j < Gui$1.gui.corePatch().ops.length; j++) {
            if (Gui$1.gui.corePatch().ops[j]) {
              if (Gui$1.gui.corePatch().ops[j].onFileChanged)
                Gui$1.gui.corePatch().ops[j].onFileChanged(options.fileName);
              else if (Gui$1.gui.corePatch().ops[j].onFileUploaded)
                Gui$1.gui.corePatch().ops[j].onFileUploaded(options.fileName); // todo deprecate , rename to onFileChanged
            }
          }

          const libUrl =
            "/assets/" + Gui$1.gui.project()._id + "/" + options.fileName;
          if (
            gui &&
            Gui$1.gui.opDocs &&
            Gui$1.gui.opDocs.libs &&
            Gui$1.gui.opDocs.libs.includes(libUrl)
          ) {
            const libIndex = Gui$1.gui.opDocs.libs.findIndex((lib) => {
              return lib === libUrl;
            });
            if (libIndex !== -1) {
              Gui$1.gui.opDocs.libs.splice(libIndex, 1);
              Gui$1.gui.emitEvent("refreshManageOp");
            }
          }
        }
      });

      this.talkerAPI.addEventListener("jobStart", (options, _next) => {
        Gui$1.gui.jobs().start({ id: options.id, title: options.title });
      });

      this.talkerAPI.addEventListener("jobFinish", (options, _next) => {
        Gui$1.gui.jobs().finish(options.id);
      });

      this.talkerAPI.addEventListener("jobProgress", (options, _next) => {
        Gui$1.gui.jobs().setProgress(options.id, options.progress);
      });

      this.talkerAPI.addEventListener("updatePatchName", (opts, _next) => {
        Gui$1.gui.setProjectName(opts.name);
        this.talkerAPI.send("updatePatchName", opts, (_err, _r) => {});
      });

      this.talkerAPI.addEventListener("updatePatchSummary", (opts, _next) => {
        const project = Gui$1.gui.project();
        if (project) Gui$1.gui.project().summary = opts;
        Gui$1.gui.patchParamPanel.show(true);
      });

      this.talkerAPI.send("getPatch", {}, (_err, r) => {
        this._cfg.patch = r;
        incrementStartup();
        this.initializeProject(() => {
          if (cb) cb();
        });
      });
    }

    createBackup() {
      const backupOptions = { title: name || "" };

      const modalNotices = [];
      if (
        gui &&
        Gui$1.gui.user &&
        platform.isTrustedPatch() &&
        Gui$1.gui.user.supporterFeatures &&
        !this.patchIsBackup()
      ) {
        const exportUrl =
          platform.getCablesUrl() + "/export/" + Gui$1.gui.patchId + "#patch";
        const importUrl = platform.getCablesUrl() + "/mydata#import";
        const quotaOverviewUrl = platform.getCablesUrl() + "/mydata";

        if (
          Gui$1.gui.user.supporterFeatures.includes("full_project_backup") ||
          Gui$1.gui.user.supporterFeatures.includes("overquota_full_project_backup")
        ) {
          let modalText = "Enter a name for the backup";
          if (
            Gui$1.gui.user.supporterFeatures.includes(
              "overquota_full_project_backup",
            )
          ) {
            modalText =
              'You are currently using all of your <a href="' +
              quotaOverviewUrl +
              '" target="_blank">backup storage space</a>. Upgade your <a href="https://cables.gl/support" target="_blank">cables supporter level</a> to get more space.<br/>';
            modalText +=
              "To free space your oldest backup will automatically be deleted, automatic backups are currently disabled!<br/><br/>";
            modalText +=
              'You can still <a href="' +
              exportUrl +
              '" target="_blank">export your patch</a> and <a href="' +
              importUrl +
              '" target="_blank">import</a> it later.';
          }
          const backupModalOptions = {
            prompt: true,
            title: "Patch Backup",
            text: modalText,
            notices: modalNotices,
            promptValue: "Manual Backup",
            promptOk: (title) => {
              backupOptions.title = title;
              Gui$1.gui.jobs().start({
                id: "patchCreateBackup",
                title: "creating backup",
                indicator: "canvas",
              });
              this.talkerAPI.send("patchCreateBackup", backupOptions);
            },
          };

          if (!Gui$1.gui.getSavedState()) {
            new ModalDialog({
              choice: true,
              cancelButton: {
                text: "Backup last saved state",
                callback: () => {
                  new ModalDialog(backupModalOptions);
                },
              },
              title: "Backup",
              warning: true,
              text: text.projectBackupNotSaved,
            });
          } else {
            new ModalDialog(backupModalOptions);
          }
        } else {
          let modalText =
            'Become a <a href="https://cables.gl/support" target="_blank">cables supporter</a>, to backup projects including assets and ops!<br/>';
          modalText +=
            'You can still <a href="' +
            exportUrl +
            '" target="_blank">export your patch</a> and <a href="' +
            importUrl +
            '" target="_blank">import</a> it later.';
          new ModalDialog({
            title: "Patch Backup",
            text: modalText,
            showOkButton: true,
          });
        }
      } else {
        let modalText = "Not possible to create a backup of this patch.";
        if (this.patchIsBackup())
          modalText += "<br/>You cannot create a backup of a backup!";
        new ModalDialog({
          showOkButton: true,
          warning: true,
          title: "Patch Backup",
          text: modalText,
        });
      }
    }

    initializeProject(cb) {
      const proj = this._cfg.patch;
      incrementStartup();
      if (window.logStartup) logStartup("set project");
      Gui$1.gui.patchView.setProject(proj, cb);
      if (proj.ui) Gui$1.gui.bookmarks.set(proj.ui.bookmarks);
    }

    showFileSelect(inputId, filterType, opid, previewId) {
      this._log.log("showFileSelect", inputId, filterType, opid, previewId);
      Gui$1.gui.showFileManager(() => {
        this._log.log("showFileSelect22222");
        const portInputEle = ele.byQuery(inputId);
        if (!portInputEle) {
          this._log.warn("[showfileselect] no portInputEle");
          return;
        }
        const fn = portInputEle.value;

        Gui$1.gui.fileManager.setFilterType(filterType);
        Gui$1.gui.fileManager.setFilePort(
          portInputEle,
          Gui$1.gui.corePatch().getOpById(opid),
          ele.byId(previewId),
        );
        Gui$1.gui.fileManager.selectFile(fn);

        ele.byId("menubar").scrollIntoView({ block: "end" }); // dont ask why... without "some"(background image op) file selects make the page scroll............
      });
    }

    openOpDirsTab() {
      if (this.frontendOptions.hasOpDirectories) {
        new ElectronOpDirs(Gui$1.gui.mainTabs);
        Gui$1.gui.maintabPanel.show(true);
      }
    }

    patchIsBackup() {
      return this._cfg && !!this._cfg.patchVersion;
    }

    exportPatch(projectId) {
      let gotoUrl = platform.getCablesUrl() + "/export/" + projectId;
      let url = "";
      if (this.patchIsBackup()) {
        gotoUrl += "?version=" + this._cfg.patchVersion;
        url = gotoUrl + "&iframe=true";
      } else {
        url = gotoUrl + "?iframe=true";
      }

      Gui$1.gui.mainTabs.addIframeTab(
        "Export Patch",
        url,
        {
          icon: "settings",
          closable: true,
          singleton: false,
          gotoUrl: gotoUrl,
        },
        true,
      );
    }

    getPatchOpsNamespace() {
      const PATCHOPS_ID_REPLACEMENTS = {
        "-": "___",
      };
      let ns = Gui$1.gui.project().shortId;
      Object.keys(PATCHOPS_ID_REPLACEMENTS).forEach((key) => {
        if (ns) ns = ns.replaceAll(key, PATCHOPS_ID_REPLACEMENTS[key]);
      });
      return defaultOps.prefixes.patchOp + ns + ".";
    }

    getSupportedOpDependencyTypes() {
      const types = ["lib", "corelib", "commonjs", "module", "op"];
      if (this.frontendOptions.npm) types.push("npm");
      return types;
    }

    /**
     *
     * @param {Boolean} state
     */
    setSaving(state) {
      Gui$1.gui.patchView.store.isSaving = state;
    }

    /**
     *
     * @return {Boolean}
     */
    isSaving() {
      return Gui$1.gui.patchView.store.isSaving;
    }

    getDefaultOpName() {
      return defaultOps.newOpNameSuggestion;
    }
  }

  class GlDebugTab {
    constructor(tabs) {
      this._count = 0;
      this._timeout = null;

      this._tab = new Tab("gluidebug", {
        icon: "pie-chart",
        singleton: true,
        infotext: "tab_profiler",
        padding: true,
      });
      tabs.addTab(this._tab, true);
      this.show();

      Gui$1.gui.patchView._patchRenderer._cgl.profileData.doProfileGlQuery = true;
    }

    show() {
      this._count++;

      let html = '<div class="tabContentScrollContainer"><table>';

      for (const i in Gui$1.gui.patchView._patchRenderer._cgl.profileData
        .glQueryData) {
        html +=
          "<tr><td>" +
          i +
          ":</td><td> " +
          Gui$1.gui.patchView._patchRenderer._cgl.profileData.glQueryData[i].time +
          "</td></tr>";
      }
      html += "</table>";
      html += "<br/><br/>";

      html += "<table>";
      for (const i in Gui$1.gui.patchView._patchRenderer.debugData) {
        html +=
          "<tr><td>" +
          i +
          ":</td><td>" +
          Gui$1.gui.patchView._patchRenderer.debugData[i] +
          "</td></tr>";
      }

      html += "</table></div>";

      this._tab.html(html);
      clearTimeout(this._timeout);
      this._timeout = setTimeout(this.show.bind(this), 300);
    }
  }

  class MetaHistory {
    constructor(tabs) {
      this.html = "";
      this._tab = new CABLES.UI.Tab("History", {
        icon: "list",
        infotext: "tab_history",
        padding: true,
      });
      tabs.addTab(this._tab);

      undo.setCallback(this.update.bind(this));

      this.update();
      this._tab.on("onActivate", () => {
        this.update();
      });
    }

    update() {
      if (!this._tab.isVisible()) return;

      this.html = "<h2>Undo History</h2>";

      this.html +=
        '<span onclick="CABLES.UI.undo.undo();" class="iconbutton"><span class="icon icon-arrow-left" ></span></span>';
      this.html +=
        '<span onclick="CABLES.UI.undo.redo();" class="iconbutton"><span class="icon icon-arrow-right"></span></span>';

      const commands = undo.getCommands();

      this.html +=
        "&nbsp;&nbsp;&nbsp;" +
        (undo.getIndex() + 1) +
        " / " +
        commands.length +
        "<br/><br/>";

      let groupSummary = [];
      let lastGroup = null;

      for (let i = -1; i < commands.length; i++) {
        let cmd = null;

        if (i == -1) cmd = { groupName: "Open patch", group: true };
        else cmd = commands[i];

        let style = "";
        if (
          !cmd.group ||
          i == 0 ||
          (i > 0 && lastGroup && lastGroup != cmd.group)
        )
          style += "margin-top:4px;";

        if (undo.getIndex() == i)
          style +=
            "border-left:4px solid var(--color-10);background-color:var(--color-04);";
        else if (undo.getIndex() < i)
          style +=
            "opacity:0.4;border-left:4px solid var(--color-06);background-color:var(--color-03);";
        else
          style +=
            "border-left:4px solid var(--color-08);background-color:var(--color-03);";

        groupSummary.push(cmd.title);

        if (!cmd.group || cmd.groupName)
          this.html += '<div style="padding:2px;padding-left:7px;' + style + '">';

        if (!cmd.group) {
          this.html += "<b>" + cmd.title + "</b>";
          groupSummary = [];
        }

        if (cmd.groupName) {
          if (i != -1 && groupSummary.length > 1) {
            groupSummary.length = Math.min(groupSummary.length, 5);
            this.html += groupSummary.join(", ");
            this.html += "...<br/>";
          }

          this.html += "<b>" + cmd.groupName + "</b>";
          lastGroup = cmd.group;
          groupSummary = [];
        }

        this.html += "</div>";
      }

      this._tab.html(this.html);
    }

    show() {
      this.update();
    }
  }

  class OpDocsJson extends Events {
    constructor(tabs) {
      super();
      this._tabs = tabs;
      this._tab = new CABLES.UI.Tab("Op Docs Json", {
        icon: "op",
        infotext: "tab_serialized",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);

      this._id = "hljs" + CABLES.uuid();

      this._op = null;
      this.rebuildHtml();
      this.setOp(Gui$1.gui.opParams.op);

      Gui$1.gui.opParams.on("opSelected", () => {
        this.setOp(Gui$1.gui.opParams.op);
      });
    }

    setOp(op) {
      if (this._op == op) return;

      if (this._op) ;

      this._op = op;

      this.rebuildHtml();
    }

    _sortObject(obj) {
      return Object.keys(obj)
        .sort()
        .reduce(function (result, key) {
          result[key] = obj[key];
          return result;
        }, {});
    }

    rebuildHtml() {
      if (this._op) {
        let json = Gui$1.gui.opDocs.getOpDocByName(this._op.objName);

        json = this._sortObject(json);

        let html =
          '<div class="tabContentScrollContainer"><code ><pre id="' +
          this._id +
          '" class="hljs language-json">' +
          JSON.stringify(json, false, 4) +
          "</code></pre></div>";
        this._tab.html(html);
      } else {
        this._tab.html("please select op");
      }

      const el = ele.byId(this._id);
      // hljs.highlightAuto();

      if (el) hljs.highlightElement(el);
    }
  }

  /**
   * debug: show current op in serialized form
   *
   * @export
   * @class OpSerialized
   * @extends {Events}
   */
  class OpSerialized extends Events {
    constructor(tabs) {
      super();
      this._tabs = tabs;
      this._tab = new CABLES.UI.Tab("Serialized Op", {
        icon: "op",
        infotext: "tab_serialized",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);

      this._id = "hljs" + CABLES.uuid();

      this._op = null;
      this.rebuildHtml();
      this.setOp(Gui$1.gui.opParams.op);

      this._tab.addButton("Refresh", () => {
        this.rebuildHtml();
      });

      Gui$1.gui.opParams.on("opSelected", () => {
        this.setOp(Gui$1.gui.opParams.op);
      });
    }

    _sortObject(obj) {
      return Object.keys(obj)
        .sort()
        .reduce(function (result, key) {
          result[key] = obj[key];
          return result;
        }, {});
    }

    setOp(op) {
      if (this._op == op) return;

      if (this._op) ;

      if (op) {
        op.addEventListener("onUiAttribsChange", () => {
          this.rebuildHtml();
        });

        this._op = op;
      }

      this.rebuildHtml();
    }

    rebuildHtml() {
      if (this._op) {
        let html =
          '<div class="tabContentScrollContainer"><code ><pre id="' +
          this._id +
          '" class="hljs language-json">' +
          JSON.stringify(this._sortObject(this._op.getSerialized()), false, 4) +
          "</code></pre></div>";
        this._tab.html(html);
      } else {
        this._tab.html("please select op");
      }

      const el = ele.byId(this._id);
      // hljs.highlightAuto();

      if (el) hljs.highlightElement(el);
    }
  }

  /**
   * debug: showing uiattribs of currently selected op
   *
   * @export
   * @class OpWatchUiAttribs
   * @extends {Events}
   */
  class OpWatchUiAttribs extends Events {
    constructor(tabs) {
      super();
      this._tabs = tabs;
      this._tab = new CABLES.UI.Tab("Op UiAttribs", {
        icon: "op",
        infotext: "tab_uiattribs",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);

      this._id = "hljs" + CABLES.uuid();

      this._op = null;
      this.rebuildHtml();
      this.setOp(Gui$1.gui.opParams.op);

      Gui$1.gui.opParams.on("opSelected", () => {
        this.setOp(Gui$1.gui.opParams.op);
      });
    }

    setOp(op) {
      if (this._op == op) return;

      if (this._op) ;

      if (op) {
        op.addEventListener("onUiAttribsChange", () => {
          this.rebuildHtml();
        });

        this._op = op;
      }

      this.rebuildHtml();
    }

    _sortObject(obj) {
      return Object.keys(obj)
        .sort()
        .reduce(function (result, key) {
          result[key] = obj[key];
          return result;
        }, {});
    }

    rebuildHtml() {
      if (this._op) {
        let html = '<div class="tabContentScrollContainer">';
        html += "<hr/><h2>Op: " + this._op.name + " </h2>";
        html +=
          '<code ><pre id="' +
          this._id +
          '" class="hljs language-json">' +
          JSON.stringify(this._sortObject(this._op.uiAttribs), false, 4) +
          "</code></pre>";

        for (let i = 0; i < this._op.portsIn.length; i++) {
          html += "<hr/><h3>Input Port: " + this._op.portsIn[i].name + " </h3>";
          html +=
            '<code ><pre id="' +
            this._id +
            '" class="hljs language-json">' +
            JSON.stringify(
              this._sortObject(this._op.portsIn[i].uiAttribs),
              false,
              4,
            ) +
            "</code></pre>";
        }

        for (let i = 0; i < this._op.portsOut.length; i++) {
          html += "<hr/><h3>Output Port: " + this._op.portsOut[i].name + " </h3>";
          html +=
            '<code ><pre id="' +
            this._id +
            '" class="hljs language-json">' +
            JSON.stringify(
              this._sortObject(this._op.portsOut[i].uiAttribs),
              false,
              4,
            ) +
            "</code></pre>";
        }

        html += "</div>";

        this._tab.html(html);
      } else {
        this._tab.html("please select op");
      }

      const el = ele.byId(this._id);
      // hljs.highlightAuto();

      if (el) hljs.highlightElement(el);
    }
  }

  /**
   * canvas for the patchfield {@link GlPatch}
   *
   * @export
   * @class GlUiCanvas
   */
  class GlUiCanvas extends GlCanvas {
    constructor(_patch, parentEle) {
      super(_patch, parentEle);

      this.glPatch = new GlPatch(this.cgl);
      this.patchApi = new GlPatchAPI(_patch, this.glPatch);
      this.patchApi.reset();

      this.cgl.on("resize", () => {
        this.glPatch.emitEvent(
          "resize",
          this.width * window.devicePixelRatio,
          this.height * window.devicePixelRatio,
        );
      });

      this.cgl.on("beginFrame", () => {
        this.glPatch.vizLayer.renderVizLayer(false);
      });

      this.setSize(100, 100);

      Gui$1.gui.on("canvasModeChange", (mode) => {
        this.canvas.classList.toggle(
          "gluiPatchBg",
          mode == Gui$1.gui.canvasManager.CANVASMODE_PATCHBG,
        );
      });

      this.glPatch.on("paused", () => {
        this.patch.pause();
      });

      this.glPatch.on("resumed", () => {
        this.cgl.setSize(this.width, this.height);
        this.patch.resume();
      });
      this.canvas.addEventListener(
        "pointermove",
        (_e) => {
          this.glPatch.needsRedraw = true;
        },
        { passive: true },
      );

      this.canvas.addEventListener(
        "pointerdown",
        (_e) => {
          this.glPatch.needsRedraw = true;
        },
        { passive: true },
      );

      this.canvas.addEventListener(
        "pointerup",
        (_e) => {
          this.glPatch.needsRedraw = true;
        },
        { passive: true },
      );

      // this is for disabling touchpad "pinch with two fingers" on macs, which would zoom in html
      this.canvas.addEventListener(
        "wheel",
        (event) => {
          if (event.ctrlKey) event.preventDefault();
        },
        { passive: false },
      );

      this.canvas.addEventListener(
        "wheel",
        (_event) => {
          this.activityHigh();
        },
        { passive: true },
      );

      this.parentResized();
      this.activityHigh();
      this.patch.on("onRenderFrame", this.render.bind(this));
    }

    parentResized() {
      this.setSize(this._parentEle.clientWidth, this._parentEle.clientHeight);
      this.glPatch.needsRedraw = true;
      this.glPatch.emitEvent(
        "resize",
        this._parentEle.clientWidth,
        this._parentEle.clientHeight,
      );
    }

    render() {
      this.glPatch.updateTime();
      if (this.glPatch.paused) return;
      if (
        this._targetFps != 0 &&
        !this.glPatch.mouseOverCanvas &&
        performance.now() - this._lastTime < 1000 / this._targetFps
      )
        return;

      const cgl = this.cgl;

      if (CGL.MESH.lastMesh) CGL.MESH.lastMesh.unBind();

      if (this._oldTargetFps != this._targetFps)
        this._oldTargetFps = this._targetFps;

      cgl.renderStart(cgl);

      if (!this._inited) {
        for (let i = 0; i <= 8; i++)
          this.cgl.setTexture(i, CGL.Texture.getEmptyTexture(this.cgl).tex);
        this._inited = true;
      }

      if (this._firstTime) this._firstTime = false;

      this.glPatch.debugData.targetFps = this._targetFps;

      this.glPatch.render(this.width, this.height);

      if (this.glPatch.isAnimated) this.activityHigh();

      cgl.renderEnd(cgl);
      this._lastTime = performance.now();
    }
  }

  class GlGuiTab {
    constructor(tabs) {
      this._tab = new Tab("GlGui", { icon: "cube", infotext: "tab_glgui" });
      tabs.addTab(this._tab, true);
      Gui$1.gui.maintabPanel.show();
      this._tab.contentEle.innerHTML = "";
      const a = new GlUiCanvas(CABLES.patch, this._tab.contentEle);
      a.parentResized();

      this._tab.on("resize", () => {
        a.parentResized();
      });
    }
  }

  const CABLES_CMD_DEBUG = {};
  const CMD_DEBUG_COMMANDS = [];

  const log$2 = new Logger("CMD DEBUG");

  const debugCommands = {
    commands: CMD_DEBUG_COMMANDS,
    functions: CABLES_CMD_DEBUG,
  };

  CABLES_CMD_DEBUG.testCommands = function () {
    for (let i = 0; i < CMD.commands.length; i++) {
      if (
        CMD.commands[i].cmd.indexOf("Test all") == -1 &&
        CMD.commands[i].cmd != "Upload file" &&
        CMD.commands[i].cmd != "Clear" &&
        CMD.commands[i].cmd != "Reload patch" &&
        CMD.commands[i].cmd != "Open patch website" &&
        CMD.commands[i].cmd != "Toggle window fullscreen"
      ) {
        log$2.log("CMD: " + CMD.commands[i].cmd);
        if (!CMD.commands[i].func) log$2.error("cmd has no function");
        else CMD.commands[i].func();
      }
    }
  };

  CABLES_CMD_DEBUG.testBlueprint2 = function () {
    const p = Gui$1.gui.corePatch();
    const sub = Gui$1.gui.patchView.getCurrentSubPatch();

    let ops = p.getSubPatchOps(sub, true);

    const serOps = [];

    for (let i = 0; i < ops.length; i++) {
      serOps.push(ops[i].getSerialized());
    }

    log$2.log(JSON.stringify(serOps));
  };

  CABLES_CMD_DEBUG.globalVarDump = function () {
    CABLESUILOADER.GlobalVarTester.after(window);
  };

  CABLES_CMD_DEBUG.newGlguiTab = function () {
    new GlGuiTab(Gui$1.gui.mainTabs);
  };

  CABLES_CMD_DEBUG.toggleMultiplayer = function () {
    platform.talkerAPI.send(
      "toggleMultiplayerSession",
      { projectId: this._patchId },
      (err, res) => {
        // window reloaded from outside
      },
    );

    /*
     *if (!Gui.gui.getSavedState())
     *{
     *    log.log("SHOW MODAL");
     *}
     *else
     *{
     *    platform.talkerAPI.send(
     *        "toggleMultiplayerSession",
     *        { "projectId": this._patchId },
     *        (err, res) =>
     *        {
     *            // window reloaded from outside
     *        },
     *    );
     *}
     */
  };

  CABLES_CMD_DEBUG.debugGlUi = function () {
    new GlDebugTab(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_DEBUG.logConsole = function () {
    Gui$1.gui?.showBottomTabs();
  };

  CABLES_CMD_DEBUG.logging = function () {
    new LoggingTab(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_DEBUG.logSocketCluster = function () {
    if (Gui$1.gui.socket) Gui$1.gui.socket.enableVerboseLogging();
  };

  CABLES_CMD_DEBUG.restrictRemoteView = () => {
    Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_REMOTEVIEW);
  };
  CABLES_CMD_DEBUG.restrictFollow = () => {
    Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_FOLLOWER);
  };
  CABLES_CMD_DEBUG.restrictExplorer = () => {
    Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_EXPLORER);
  };
  CABLES_CMD_DEBUG.restrictFull = () => {
    Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_FULL);
  };

  CABLES_CMD_DEBUG.testAllOps = function () {
    const ops = Gui$1.gui.opDocs.getAll();

    log$2.log(ops);

    for (const i in ops) {
      log$2.log(ops[i].name);
      const opname = ops[i].name;

      load(opname);
    }
  };

  CABLES_CMD_DEBUG.focusOpAnim = function () {
    const ops = Gui$1.gui.patchView.getSelectedOps();
    if (ops.length > 0) Gui$1.gui.patchView.patchRenderer.focusOpAnim(ops[0].id);
  };

  CABLES_CMD_DEBUG.testOp = function () {
    const ops = Gui$1.gui.patchView.getSelectedOps();

    for (let i = 0; i < ops.length; i++) {
      for (let j = 0; j < 100; j++) {
        for (let ip = 0; ip < ops[i].portsIn.length; ip++) {
          const p = ops[i].portsIn[ip];

          if (p.type == portType.array) {
            const tests = [
              () => {
                p.set([]);
              },
              () => {
                p.set(null);
              },
              () => {
                p.set(undefined);
              },
              () => {
                p.set([0]);
              },
              () => {
                p.set([0, 1]);
              },
              () => {
                p.set([0, 1, 2]);
              },
              () => {
                p.set([-0, -1, -2]);
              },
              () => {
                p.set([0, 1, 2, 3]);
              },
              () => {
                p.set([0, 1, 2, 3, 4]);
              },
              () => {
                p.set([0, 1, null, 3, 4]);
              },
              () => {
                p.set([0, "hallo", 2, 3, 4]);
              },
            ];
            tests[Math.floor(tests.length * Math.random())]();
          }
          if (p.type == portType.number) {
            const tests = [
              () => {
                p.set(0);
              },
              () => {
                p.set(1);
              },
              () => {
                p.set(1.2);
              },
              () => {
                p.set(100);
              },
              () => {
                p.set(-100);
              },
            ];
            tests[Math.floor(tests.length * Math.random())]();
          }
          if (p.type == portType.string) {
            const tests = [
              () => {
                p.set("hello");
              },
              () => {
                p.set("");
              },
              () => {
                p.set(null);
              },
              () => {
                p.set(undefined);
              },
            ];
            tests[Math.floor(tests.length * Math.random())]();
          }
          if (p.type == portType.object) {
            const tests = [
              () => {
                p.set(null);
              },
              () => {
                p.set(undefined);
              },
              () => {
                p.set({
                  a: () => {
                    log$2.log(1);
                  },
                });
              },
              () => {
                p.set({ a: 1234 });
              },
              () => {
                p.set({ b: null });
              },
            ];
            tests[Math.floor(tests.length * Math.random())]();
          }
          if (p.type == portType.trigger) {
            const tests = [
              () => {
                p.trigger();
              },
              () => {},
            ];
            tests[Math.floor(tests.length * Math.random())]();
          }
        }
      }
    }

    log$2.log("op test finished!");
  };

  function load(opname) {
    Gui$1.gui.serverOps.loadOpDependencies(opname, function () {
      Gui$1.gui.corePatch().addOp(opname);
    });
  }

  CABLES_CMD_DEBUG.watchOpSerialized = function () {
    new OpSerialized(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_DEBUG.watchOpDocsJson = function () {
    new OpDocsJson(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_DEBUG.watchOpUiAttribs = function () {
    new OpWatchUiAttribs(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_DEBUG.saveWithOutObjnames = () => {
    Gui$1.gui.corePatch().storeObjNames = false;
    CABLES.CMD.PATCH.save();
  };

  CABLES_CMD_DEBUG.undoHistory = () => {
    new MetaHistory(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CMD_DEBUG_COMMANDS.push(
    {
      cmd: "Glui debug",
      category: "debug",
      func: CABLES_CMD_DEBUG.debugGlUi,
      icon: "command",
    },
    {
      cmd: "Test all ops",
      category: "debug",
      func: CABLES_CMD_DEBUG.testAllOps,
      icon: "command",
    },
    {
      cmd: "Dump global vars",
      category: "debug",
      func: CABLES_CMD_DEBUG.globalVarDump,
      icon: "command",
    },
    {
      cmd: "Logging",
      category: "debug",
      func: CABLES_CMD_DEBUG.logging,
      icon: "command",
    },
    {
      cmd: "Log console",
      category: "debug",
      func: CABLES_CMD_DEBUG.logConsole,
      icon: "list",
    },
    {
      cmd: "Log socketcluster traffic",
      category: "debug",
      func: CABLES_CMD_DEBUG.logSocketCluster,
      icon: "command",
    },
    {
      cmd: "Glgui tab",
      category: "debug",
      func: CABLES_CMD_DEBUG.newGlguiTab,
      icon: "command",
    },
    {
      cmd: "Toggle multiplayer",
      category: "debug",
      func: CABLES_CMD_DEBUG.toggleMultiplayer,
      icon: "command",
    },
    {
      cmd: "Restriction remoteviewer",
      category: "debug",
      func: CABLES_CMD_DEBUG.restrictRemoteView,
      icon: "command",
    },
    {
      cmd: "Restriction follow",
      category: "debug",
      func: CABLES_CMD_DEBUG.restrictFollow,
      icon: "command",
    },
    {
      cmd: "Restriction explorer",
      category: "debug",
      func: CABLES_CMD_DEBUG.restrictExplorer,
      icon: "command",
    },
    {
      cmd: "Restriction full",
      category: "debug",
      func: CABLES_CMD_DEBUG.restrictFull,
      icon: "command",
    },
    {
      cmd: "Test op",
      category: "debug",
      func: CABLES_CMD_DEBUG.testOp,
      icon: "op",
    },
    {
      cmd: "Show op docs json",
      func: CABLES_CMD_DEBUG.watchOpDocsJson,
      category: "debug",
      icon: "op",
    },
    {
      cmd: "Show op serialized",
      func: CABLES_CMD_DEBUG.watchOpSerialized,
      category: "debug",
      icon: "op",
    },
    {
      cmd: "Show op uiattribs",
      func: CABLES_CMD_DEBUG.watchOpUiAttribs,
      category: "debug",
      icon: "op",
    },
    {
      cmd: "Save without objnames",
      func: CABLES_CMD_DEBUG.saveWithOutObjnames,
      category: "debug",
      icon: "op",
    },
    {
      cmd: "Glui focusOpAnim",
      func: CABLES_CMD_DEBUG.focusOpAnim,
      category: "debug",
    },
    {
      cmd: "Undo history",
      func: CABLES_CMD_DEBUG.undoHistory,
      category: "debug",
    },
    {
      cmd: "Test all commands",
      func: CABLES_CMD_DEBUG.testCommands,
      category: "debug",
    },
  );

  const CABLES_CMD_OP = {};
  const CMD_OP_COMMANDS = [];

  const opCommands = {
    commands: CMD_OP_COMMANDS,
    functions: CABLES_CMD_OP,
  };

  CABLES_CMD_OP.codeNewOp = () => {
    Gui$1.gui.serverOps.createDialog();
  };

  CABLES_CMD_OP.downGradeOp = function () {
    const selops = Gui$1.gui.patchView.getSelectedOps();
    for (let i = 0; i < selops.length; i++) {
      Gui$1.gui.patchView.downGradeOp(selops[i].id, selops[i].objName);
    }
  };

  CABLES_CMD_OP.copyNameClipboard = function () {
    let str = "";
    const selops = Gui$1.gui.patchView.getSelectedOps();

    for (let i = 0; i < selops.length; i++) str += selops[i].objName.endl();

    navigator.clipboard.writeText(str);
    notify("copied " + selops.length + " op names to clipboard ", null, {
      force: true,
    });
  };

  CABLES_CMD_OP.upGradeOps = function () {
    const selops = Gui$1.gui.patchView.getSelectedOps();
    for (let i = 0; i < selops.length; i++) {
      const opdoc = Gui$1.gui.opDocs.getOpDocById(selops[i].opId);
      if (
        opdoc &&
        opdoc.oldVersion &&
        opdoc.newestVersion &&
        opdoc.newestVersion.name
      )
        Gui$1.gui.patchView.replaceOp(selops[i].id, opdoc.newestVersion.name);
    }
  };

  CABLES_CMD_OP.reloadChangedOps = function () {
    for (let i in Gui$1.gui.serverOps.opIdsChangedOnServer) {
      Gui$1.gui.serverOps.execute(i, () => {
        delete Gui$1.gui.serverOps.opIdsChangedOnServer[i];
        Gui$1.gui.opParams.refresh();
      });
    }
    Gui$1.gui.restriction.hide();
  };

  CABLES_CMD_OP.cloneSelectedOp = function () {
    const ops = Gui$1.gui.patchView.getSelectedOps();
    if (ops.length > 0) Gui$1.gui.serverOps.cloneDialog(ops[0].objName, ops[0]);
  };

  CABLES_CMD_OP.manageCurrentSubpatchOp = function () {
    const oldSubPatchId = Gui$1.gui.patchView.getCurrentSubPatch();
    const subOuter = Gui$1.gui.patchView.getSubPatchOuterOp(oldSubPatchId);

    new ManageOp(Gui$1.gui.mainTabs, subOuter.opId);
  };

  CABLES_CMD_OP.manageOp = function (opid) {
    if (!opid) {
      const ops = Gui$1.gui.patchView.getSelectedOps();
      if (ops.length > 0) opid = ops[0].opId;
    }
    new ManageOp(Gui$1.gui.mainTabs, opid);
  };

  CABLES_CMD_OP.cloneSelectedOps = (ops) => {
    if (!ops) {
      ops = Gui$1.gui.patchView.getSelectedOps();

      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const opname = op.objName;
        let sanitizedOpName = opname.replaceAll(".", "_");

        let newOpname = platform.getPatchOpsNamespace() + sanitizedOpName;
        newOpname = newOpname.replaceAll(".Ops_", ".");

        const newOpnameNoVer = newOpname.replaceAll("_v", "V");

        let count = 0;
        newOpname = newOpnameNoVer;
        while (Gui$1.gui.opDocs.getOpDocByName(newOpname)) {
          newOpname = newOpnameNoVer + count;
          count++;
        }
        op.renameopto = newOpname;

        console.log("new renameto name:", newOpname);
      }

      if (ops.length == 0) return;
    }

    // loadingModal = loadingModal || Gui.gui.startModalLoading("Cloning ops...");

    if (ops.length == 0) {
      Gui$1.gui.endModalLoading();
      return;
    }
    const op = ops.pop();
    const opname = op.objName;
    const newOpname = op.renameopto;

    if (Gui$1.gui.opDocs.getOpDocByName(newOpname)) {
      // that opname was already renamed in list
      Gui$1.gui.patchView.replaceOp(op.id, newOpname);
      CABLES_CMD_OP.cloneSelectedOps(ops);
    } else {
      Gui$1.gui.serverOps.clone(
        op.opId,
        newOpname,
        () => {
          Gui$1.gui.serverOps.loadOpDependencies(opname, function () {
            Gui$1.gui.patchView.replaceOp(op.id, newOpname);

            notify("created op " + newOpname, null, { force: true });

            CABLES_CMD_OP.cloneSelectedOps(ops);
          });
        },
        { openEditor: false },
      );
    }
  };

  CABLES_CMD_OP.renameOp = (opName = null) => {
    if (!opName) {
      const ops = Gui$1.gui.patchView.getSelectedOps();
      if (!ops.length) return;
      const op = Gui$1.gui.patchView.getSelectedOps()[0];
      opName = op.objName;
    }

    if (platform.frontendOptions.opRenameInEditor) {
      Gui$1.gui.serverOps.renameDialog(opName);
    } else {
      Gui$1.gui.serverOps.renameDialogIframe(opName);
    }
  };

  CABLES_CMD_OP.createVersionSelectedOp = function () {
    const ops = Gui$1.gui.patchView.getSelectedOps();
    if (ops.length == 0) return;

    const opname = ops[0].objName;
    let newOpname = "";
    if (opname.includes("_v")) {
      const parts = opname.split("_v");
      newOpname = parts[0] + "_v" + (parseFloat(parts[1]) + 1);
    } else newOpname = opname + "_v2";

    Gui$1.gui.serverOps.clone(ops[0].opId, newOpname, () => {
      Gui$1.gui.serverOps.loadOpDependencies(opname, function () {
        Gui$1.gui.patchView.replaceOp(ops[0].id, newOpname);

        notify("created op " + newOpname, null, { force: true });
      });
    });
  };

  CABLES_CMD_OP.editOp = function (userInteraction = true) {
    const selops = Gui$1.gui.patchView.getSelectedOps();

    if (selops && selops.length > 0) {
      for (let i = 0; i < selops.length; i++)
        Gui$1.gui.serverOps.edit(selops[i], false, null, userInteraction);
    }
  };

  CMD_OP_COMMANDS.push(
    {
      cmd: "Code a new op",
      category: "op",
      icon: "op",
      func: CABLES_CMD_OP.codeNewOp,
    },
    {
      cmd: "Downgrade selected op",
      func: CABLES_CMD_OP.downGradeOp,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Upgrade selected ops",
      func: CABLES_CMD_OP.upGradeOps,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Clone selected op",
      func: CABLES_CMD_OP.cloneSelectedOp,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Clone selected ops to patch ops",
      func: CABLES_CMD_OP.cloneSelectedOps,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Create new version of op",
      func: CABLES_CMD_OP.createVersionSelectedOp,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Manage selected op",
      func: CABLES_CMD_OP.manageOp,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Edit op",
      category: "op",
      func: CABLES_CMD_OP.editOp,
      icon: "edit",
    },
    {
      cmd: "Rename op",
      func: CABLES_CMD_OP.renameOp,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Copy op names to clipboard",
      func: CABLES_CMD_OP.copyNameClipboard,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Reload changed ops",
      func: CABLES_CMD_OP.reloadChangedOps,
      category: "op",
      icon: "op",
    },
  );

  /**
   * tab panel analyze patch shows information and statistics about the current patch
   */
  class AnalyzePatchTab extends Events {
    /**
     * @param {TabPanel} tabs
     */
    constructor(tabs = null) {
      super();
      this._tabs = tabs || Gui$1.gui.mainTabs;

      this._tab = new Tab("Analyze", {
        icon: "list",
        infotext: "tab_logging",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);
      Gui$1.gui.maintabPanel.show(true);

      this._html();
    }

    _html() {
      let report = "<h1>Analyze Patch</h1>";
      const patch = Gui$1.gui.corePatch();
      report += '<div style="overflow:scroll;width:100%;height:100%">';
      report += "<h2>Ops</h2>";

      const opsCount = {};
      const opDirs = {};
      const hasOpDirs = platform.frontendOptions.hasOpDirectories;

      for (let i = 0; i < patch.ops.length; i++) {
        const opName = patch.ops[i].objName;
        opsCount[opName] = opsCount[opName] || 0;
        opsCount[opName]++;
        if (hasOpDirs) {
          const doc = Gui$1.gui.opDocs.getOpDocByName(opName);
          const opDir = doc ? doc.opDir : null;
          if (opDir) {
            opDirs[opDir] = opDirs[opDir] || 0;
            opDirs[opDir]++;
          }
        }
      }

      report += patch.ops.length + " Ops total<br/>";
      report += Object.keys(opsCount).length + " unique ops<br/>";

      if (hasOpDirs) {
        report += "<hr/>";
        report += "<h2>Used Op Directories</h2>";
        Object.keys(opDirs).forEach((opDir) => {
          report += opDirs[opDir] + " ops from " + opDir;
          report +=
            "&nbsp;<a class=\"icon icon-folder icon-0_75x\" onClick=\"CABLESUILOADER.talkerAPI.send('openDir', { 'dir': '" +
            opDir +
            "'});\"></a>";
          report += "<br>";
        });
      }

      if (platform.frontendOptions.hasAssetDirectories) {
        const ops = Gui$1.gui.corePatch().ops;
        const assets = {};
        let assetCount = 0;
        for (let i = 0; i < ops.length; i++) {
          for (let j = 0; j < ops[i].portsIn.length; j++) {
            if (
              ops[i].portsIn[j].uiAttribs &&
              ops[i].portsIn[j].uiAttribs.display &&
              ops[i].portsIn[j].uiAttribs.display === "file"
            ) {
              const asset = ops[i].portsIn[j].get();
              if (asset) {
                assets[asset] = assets[asset] || 0;
                assets[asset]++;
                assetCount++;
              }
            }
          }
        }

        report += "<hr/>";
        report += "<h2>Used Assets</h2>";

        report += assetCount + " Assets total<br/>";
        report += Object.keys(assets).length + " unique assets<br/>";
      }

      report += "<hr/>";
      report += "<h2>Op Types</h2>";

      {
        let arr = FindTab.searchOutDated(Gui$1.gui.corePatch().ops, []);
        if (arr.length > 0)
          report +=
            '<a class="link" onclick="new CABLES.UI.FindTab(Gui.gui.mainTabs, \':outdated\');">' +
            arr.length +
            " outdated ops </a><br/>";
      }
      {
        let arr = FindTab.searchPatchOps(Gui$1.gui.corePatch().ops, []);
        if (arr.length > 0)
          report +=
            '<a class="link" onclick="new CABLES.UI.FindTab(Gui.gui.mainTabs, \':notcoreops patch\');">' +
            arr.length +
            " patch ops </a><br/>";
      }
      {
        let arr = FindTab.searchUserOps(Gui$1.gui.corePatch().ops, []);
        if (arr.length > 0)
          report +=
            '<a class="link" onclick="new CABLES.UI.FindTab(Gui.gui.mainTabs, \':user\');">' +
            arr.length +
            " user ops </a><br/>";
      }
      {
        let arr = FindTab.searchTeamOps(Gui$1.gui.corePatch().ops, []);
        if (arr.length > 0)
          report +=
            '<a class="link" onclick="new CABLES.UI.FindTab(Gui.gui.mainTabs, \':notcoreops team\');">' +
            arr.length +
            " team ops </a><br/>";
      }
      {
        let arr = FindTab.searchExtensionOps(Gui$1.gui.corePatch().ops, []);
        if (arr.length > 0)
          report +=
            '<a class="link" onclick="new CABLES.UI.FindTab(Gui.gui.mainTabs, \':notcoreops extension\');">' +
            arr.length +
            " extension ops </a><br/>";
      }
      {
        let numHidden = 0;
        for (let i = 0; i < patch.ops.length; i++) {
          if (patch.ops[i].uiAttribs.hidden) numHidden++;
        }
        report += numHidden + " hidden ops ";
        report += "<br/>";
      }

      report += "<hr/>";
      report += "<h2>Vars</h2>";
      report += Object.keys(CABLES.patch.getVars()).length + " Variables<br/>";

      report += "<hr/>";
      report += "<h2>Most used Ops</h2>";

      let opscountSorted = [];

      for (const i in opsCount)
        opscountSorted.push({ name: i, count: opsCount[i] });
      opscountSorted.sort((b, a) => {
        return a.count - b.count;
      });

      report += "<table>";
      for (let i = 0; i < Math.min(25, opscountSorted.length); i++)
        report +=
          "<tr><td> " +
          opscountSorted[i].count +
          'x </td><td><a class="link" onclick="new CABLES.UI.FindTab(Gui.gui.mainTabs, \'' +
          opscountSorted[i].name +
          "');\">" +
          opscountSorted[i].name +
          "</td></tr>";

      report += "</table>";

      // ---

      report += "<hr/>";
      report += "<h2>Subpatches</h2>";

      const subpatchNumOps = {};
      for (let i = 0; i < patch.ops.length; i++) {
        const key = patch.ops[i].uiAttribs.subPatch || "root";

        subpatchNumOps[key] = subpatchNumOps[key] || 0;
        subpatchNumOps[key]++;
      }

      for (const i in subpatchNumOps)
        report += subpatchNumOps[i] + " ops in " + i + " <br/>";

      /// /////////////////////////////////////////////////

      const serializeSizes = [];
      for (let i = 0; i < patch.ops.length; i++) {
        const str = JSON.stringify(patch.ops[i].getSerialized());
        serializeSizes.push({
          name: patch.ops[i].objName,
          id: patch.ops[i].id,
          size: str.length,
        });
      }

      serializeSizes.sort((a, b) => {
        return b.size - a.size;
      });

      report += "<hr/>";
      report += "<h2>Biggest Serialized Ops</h2>";

      report += "<table>";
      for (let i = 0; i < Math.min(25, serializeSizes.length); i++) {
        const s = Math.round(serializeSizes[i].size / 1024);
        if (s > 1)
          report +=
            "<tr><td>" +
            s +
            'kb</td><td><a class="link" onclick="console.log(456);Gui.gui.patchView.centerSelectOp(\'' +
            serializeSizes[i].id +
            "')\">" +
            serializeSizes[i].name +
            "</a></td></tr>";
      }
      report += "</table>";

      report += "</div>";

      this._tab.html(report);
    }
  }

  /**
   * cpu profile the running patch, what is most expensive?
   *
   * @export
   * @class Profiler
   */
  class Profiler {
    constructor(tabs) {
      this._tab = new Tab("Profiler", {
        icon: "pie-chart",
        singleton: true,
        infotext: "tab_profiler",
        padding: true,
      });
      tabs.addTab(this._tab, true);
      this.show();

      this.colors = [
        "#7AC4E0",
        "#D183BF",
        "#9091D6",
        "#FFC395",
        "#F0D165",
        "#63A8E8",
        "#CF5D9D",
        "#66C984",
        "#D66AA6",
        "#515151",
      ];
      this.intervalId = null;
      this.lastPortTriggers = 0;
      this._subTab = 0;

      Gui$1.gui.corePatch().on("onLink", () => {
        if (Gui$1.gui.corePatch().profiler) Gui$1.gui.corePatch().profiler.clear();
        this.update();
      });
      Gui$1.gui.corePatch().on(CABLES.Patch.EVENT_OP_ADDED, () => {
        if (Gui$1.gui.corePatch().profiler) Gui$1.gui.corePatch().profiler.clear();
        this.update();
      });
      Gui$1.gui.corePatch().on(CABLES.Patch.EVENT_OP_DELETED, () => {
        if (Gui$1.gui.corePatch().profiler) Gui$1.gui.corePatch().profiler.clear();
        this.update();
      });
      Gui$1.gui.corePatch().on("onUnLink", () => {
        if (Gui$1.gui.corePatch().profiler) Gui$1.gui.corePatch().profiler.clear();
        this.update();
      });
    }

    setTab(which) {
      ele.byId("profilerTabOpsCum").classList.remove("tabActiveSubtab");
      ele.byId("profilerTabOps").classList.remove("tabActiveSubtab");
      ele.byId("profilerTabSubpatches").classList.remove("tabActiveSubtab");
      ele.byId("profilerTabPeaks").classList.remove("tabActiveSubtab");
      ele.byId("profilerTabEvents").classList.remove("tabActiveSubtab");

      if (which == 0)
        ele.byId("profilerTabOpsCum").classList.add("tabActiveSubtab");
      if (which == 3) ele.byId("profilerTabOps").classList.add("tabActiveSubtab");
      if (which == 1)
        ele.byId("profilerTabSubpatches").classList.add("tabActiveSubtab");
      if (which == 2)
        ele.byId("profilerTabPeaks").classList.add("tabActiveSubtab");
      if (which == 4)
        ele.byId("profilerTabEvents").classList.add("tabActiveSubtab");

      Gui$1.gui.corePatch().profiler.clear();
      this._subTab = which;
      this.update();
    }

    show() {
      const html = getHandleBarHtml("meta_profiler", {});
      this._tab.html(html);

      ele.byId("profilerstartbutton").addEventListener(
        "click",
        function () {
          this.start();
        }.bind(this),
      );
    }

    update() {
      const profiler = Gui$1.gui.corePatch().profiler;
      if (!profiler) return;

      const items = profiler.getItems();
      let html = "";
      let htmlBar = "";
      let allTimes = 0;
      const sortedItems = [];
      let htmlData = "";

      let cumulate = true;
      if (this._subTab == 1 || this._subTab == 3) cumulate = false;

      const cumulated = {};
      const cumulatedSubPatches = {};
      const opids = {};

      for (const i in items) {
        const item = items[i];
        allTimes += item.timeUsed;

        opids[item.opid] = 1;

        if (cumulatedSubPatches[item.subPatch]) {
          cumulatedSubPatches[item.subPatch].timeUsed += item.timeUsed;
        } else {
          cumulatedSubPatches[item.subPatch] = {};
          cumulatedSubPatches[item.subPatch].timeUsed = item.timeUsed;
          cumulatedSubPatches[item.subPatch].subPatch = item.subPatch;
        }

        if (cumulate) {
          if (cumulated[item.title]) {
            cumulated[item.title].timeUsed += item.timeUsed;
            cumulated[item.title].numTriggers += item.numTriggers;
            cumulated[item.title].numCumulated++;
          } else {
            cumulated[item.title] = item;
            cumulated[item.title].numCumulated = 1;
            sortedItems.push(cumulated[item.title]);
          }
        } else {
          sortedItems.push(item);
        }
      }

      let allPortTriggers = 0;
      for (const i in sortedItems) {
        sortedItems[i].percent = (sortedItems[i].timeUsed / allTimes) * 100;
        allPortTriggers += sortedItems[i].numTriggers;
      }
      this.lastPortTriggers = allPortTriggers;

      let colorCounter = 0;

      htmlData += "Active Ops: " + Object.keys(opids).length + "<br/><br/>";

      sortedItems.sort(function (a, b) {
        return b.percent - a.percent;
      });

      if (!ele.byId("profilerdata")) {
        clearInterval(this.intervalId);
        this.intervalId = null;
        return;
      }
      ele.byId("profilerdata").innerHTML = htmlData;

      let item = null;
      let pad = "";
      const cgl = Gui$1.gui.corePatch().cgl;

      if (this._subTab == 4) {
        html += "<table>";
        for (let i = 0; i < cgl.profileData.heavyEvents.length; i++) {
          html +=
            "<tr><td>" +
            cgl.profileData.heavyEvents[i].event +
            "</td><td>" +
            cgl.profileData.heavyEvents[i].name +
            "</td><td>" +
            (cgl.profileData.heavyEvents[i].info || "") +
            "</td></tr>";
        }
        html += "</table>";
      }
      if (this._subTab == 0 || this._subTab == 3) {
        html += "<h3>Ops</h3>";
        html += "<table>";

        html += "<tr>";
        html += '<td class="colname">%</td>';
        html += '<td class="colname">Port Name</td>';
        html += '<td class="colname">Per Frame</td>';
        html += '<td class="colname">Time used</td>';
        html += '<td class="colname">Ops</td>';
        html += "</td>";

        for (let i in sortedItems) {
          item = sortedItems[i];
          pad = "";

          html += "<tr><td><span>";
          if (sortedItems.length > 0)
            for (i = 0; i < 2 - (item.percent + "").length; i++) pad += "&nbsp;";

          html +=
            pad + Math.floor(item.percent * 100) / 100 + "% </span></td><td>";

          html += "<span>";

          html += item.title;
          html +=
            "</span></td><td><span> " +
            Math.round(item.numTriggers * 10) / 10 +
            "x</span></td><td><span> " +
            Math.round(item.timeUsed) +
            "ms </span></td>";

          if (cumulate && item.numCumulated)
            html += "<td><span>" + item.numCumulated + "</span></td>";
          if (!cumulate)
            html +=
              '<td ><a class="button-small" onclick="Gui.gui.patchView.centerSelectOp(\'' +
              item.opid +
              "')\">op</a></td>";

          html += "</tr>";

          if (item.percent > 0) {
            htmlBar +=
              '<div class="tt" data-tt="' +
              item.title +
              '" style="height:20px;background-color:' +
              this.colors[colorCounter] +
              ";float:left;padding:0px;overflow:hidden;min-width:0px;width:" +
              item.percent +
              '%"></div>';
            colorCounter++;
            if (colorCounter > this.colors.length - 1) colorCounter = 0;
          }
        }

        html += "</table>";
      }
      sortedItems.sort(function (a, b) {
        return b.peak - a.peak;
      });

      // if (Object.keys(cumulatedSubPatches).length > 1)
      if (this._subTab == 1) {
        const subPatches = [];
        let allTimesUsed = 0;
        for (const i in cumulatedSubPatches) {
          allTimesUsed += cumulatedSubPatches[i].timeUsed;
          subPatches.push(cumulatedSubPatches[i]);
        }
        for (let i = 0; i < subPatches.length; i++) {
          subPatches[i].name = Gui$1.gui.patchView.getSubPatchName(
            subPatches[i].subPatch,
          );
          subPatches[i].percent = (subPatches[i].timeUsed / allTimesUsed) * 100;
        }
        subPatches.sort(function (a, b) {
          return b.percent - a.percent;
        });

        html += "<h3>Subpatches</h3>";
        html += "<table>";
        for (let i = 0; i < subPatches.length; i++) {
          html += "<tr>";
          html +=
            "<td><span>" +
            Math.floor(subPatches[i].percent * 100) / 100 +
            "%</span></td>";
          html +=
            "<td><span><a onclick=\"Gui.gui.patchView.setCurrentSubPatch('" +
            subPatches[i].subPatch +
            "')\">" +
            subPatches[i].name +
            "</span></td>";
          html += "</tr>";
        }
        html += "</table>";
      }

      if (this._subTab == 2) {
        html += "<h3>Peaks</h3>";
        for (let i in sortedItems) {
          item = sortedItems[i];
          pad = "";

          if (sortedItems.length > 0)
            for (i = 0; i < 2 - (item.peak + "").length; i++) pad += "&nbsp;";
          html +=
            pad + Math.round(96 * item.peak) / 100 + "ms " + item.title + "<br/>";
        }
      }

      let pauseStr = "Pause";
      if (Gui$1.gui.corePatch().profiler) {
        if (Gui$1.gui.corePatch().profiler.paused) pauseStr = "Resume";
        ele.byId("profiler_pause").innerHTML = pauseStr;
      }

      ele.byId("profilerui").style.display = "block";
      // ele.byId("profilerlistPeaks").innerHTML = htmlPeaks;
      ele.byId("profilerbar").innerHTML = htmlBar;
      ele.byId("profilerlist").innerHTML = html;
      ele.byId("profilerstartbutton").style.display = "none";
    }

    start() {
      Gui$1.gui.corePatch().profile(true);
      this.update();
      ele.byId("profilerTabOpsCum").addEventListener("click", () => {
        this.setTab(0);
      });
      ele.byId("profilerTabOps").addEventListener("click", () => {
        this.setTab(3);
      });
      ele.byId("profilerTabSubpatches").addEventListener("click", () => {
        this.setTab(1);
      });
      ele.byId("profilerTabPeaks").addEventListener("click", () => {
        this.setTab(2);
      });
      ele.byId("profilerTabEvents").addEventListener("click", () => {
        this.setTab(4);
      });

      if (!this.intervalId)
        this.intervalId = setInterval(this.update.bind(this), 1000);
    }
  }

  /**
   * tab panel to debug patchfield gl Op rendering
   *
   * @export
   * @class GlOpWatcher
   * @extends {Events}
   */
  class GlOpWatcher extends Events {
    constructor(tabs) {
      super();

      this._glPatch = Gui$1.gui.patchView.patchRenderer;
      this._tabs = tabs;
      this._tab = new CABLES.UI.Tab("GlOp", {
        icon: "op",
        infotext: "tab_glop",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);

      this._op = null;
      this._glop = null;
      this.rebuildHtml();
      this.setOp(Gui$1.gui.opParams.op);

      Gui$1.gui.opParams.on("opSelected", () => {
        this.setOp(Gui$1.gui.opParams.op);
      });

      setInterval(this.rebuildHtml.bind(this), 100);
    }

    setOp(op) {
      if (this._op == op) return;

      if (this._op) ;

      if (op) {
        op.addEventListener("onUiAttribsChange", () => {
          this.rebuildHtml();
        });

        this._op = op;
        this._glop = this._glPatch.getGlOp(op);
      }

      this.rebuildHtml();
    }

    rebuildHtml() {
      if (this._op) {
        let html = "";

        html += "<table>";

        html +=
          "<tr><td>_glRectBg._dragStartX</td><td>" +
          this._glop._glRectBg._dragStartX +
          "</td></tr>";
        html +=
          "<tr><td>_passiveDragStartX</td><td>" +
          this._glop._passiveDragStartX +
          "</td></tr>";

        html +=
          "<tr><td>_glRectBg.dragOffsetX</td><td>" +
          this._glop._glRectBg.dragOffsetX +
          "</td></tr>";
        html +=
          "<tr><td>_glRectBg.dragOffsetY</td><td>" +
          this._glop._glRectBg.dragOffsetY +
          "</td></tr>";
        html +=
          "<tr><td>_glRectBg._isDragging</td><td>" +
          this._glop._glRectBg._isDragging +
          "</td></tr>";
        html +=
          "<tr><td>_glRectBg.x</td><td>" + this._glop._glRectBg.x + "</td></tr>";
        html +=
          "<tr><td>_glRectBg.y</td><td>" + this._glop._glRectBg.y + "</td></tr>";
        html +=
          "<tr><td>isPassiveDrag</td><td>" +
          this._glop.isPassiveDrag() +
          "</td></tr>";

        html += "</table>";

        html += "<div><code><pre>";
        html += JSON.stringify(this._glop.opUiAttribs, false, 4);
        html += "</code></pre></div>";

        this._tab.html(html);
      } else {
        this._tab.html("please select op");
      }
    }
  }

  class Exporter {
    constructor(project, versionId, type = null) {
      this._project = project;
      this._exportType = type;
    }

    show() {
      if (!Gui$1.gui.getSavedState()) {
        new ModalDialog({
          html: text.projectExportNotSaved,
          warning: true,
          title: "Export",
          showOkButton: true,
        });
        return;
      }

      const projectId = this._project.shortId || this._project._id;

      platform.exportPatch(projectId, this._exportType);
    }
  }

  const CABLES_CMD_PATCH = {};
  const CMD_PATCH_COMMANDS = [];

  const log$1 = new Logger("CMD_PATCH");

  const patchCommands = {
    commands: CMD_PATCH_COMMANDS,
    functions: CABLES_CMD_PATCH,
  };

  CABLES_CMD_PATCH.setPatchTitle = () => {
    Gui$1.gui.patchView.store.showModalTitleDialog();
  };

  CABLES_CMD_PATCH.openParamsTab = () => {
    const ops = Gui$1.gui.patchView.getSelectedOps();
    if (!ops.length) return;

    const op = Gui$1.gui.patchView.getSelectedOps()[0];
    const id = "params" + CABLES.uuid();

    const tab = new CABLES.UI.Tab(op.name, {
      icon: "op",
      infotext: "tab_timeline",
      padding: true,
      singleton: false,
    });
    Gui$1.gui.mainTabs.addTab(tab, true);
    Gui$1.gui.maintabPanel.show(true);
    tab.html('<div id="' + id + '"></div<');

    const opParams = new OpParampanel();

    opParams.setParentElementId(id);
    opParams.show(op);
  };

  CABLES_CMD_PATCH.clearOpTitles = function () {
    let ops = Gui$1.gui.patchView.getSelectedOps();

    if (ops.length == 0) ops = Gui$1.gui.corePatch().ops;

    if (!ops || ops.length == 0) return;

    for (let i = 0; i < ops.length; i++) {
      const op = Gui$1.gui.corePatch().getOpById(ops[i].id);
      op.setTitle("");
    }
  };

  CABLES_CMD_PATCH.selectChilds = function () {
    const ops = Gui$1.gui.patchView.getSelectedOps();

    if (!ops || ops.length == 0) return;

    for (let i = 0; i < ops.length; i++) {
      const op = Gui$1.gui.corePatch().getOpById(ops[i].id);
      op.selectChilds();
    }

    Gui$1.gui.patchView.showSelectedOpsPanel();
  };

  CABLES_CMD_PATCH.autoPosSubpatchInputOutputOps = function () {
    const sub = Gui$1.gui.patchView.getCurrentSubPatch();
    if (!sub) return;
    Gui$1.gui.patchView.setPositionSubPatchInputOutputOps(sub);
  };

  CABLES_CMD_PATCH.gotoParentSubpatch = function () {
    const names = Gui$1.gui.patchView.getSubpatchPathArray(
      Gui$1.gui.patchView.getCurrentSubPatch(),
    );

    if (names.length == 0) return;
    if (names.length == 1) Gui$1.gui.patchView.setCurrentSubPatch(0);
    else Gui$1.gui.patchView.setCurrentSubPatch(names[names.length - 1].id);
  };

  CABLES_CMD_PATCH.selectAllOps = function () {
    Gui$1.gui.patchView.selectAllOpsSubPatch(
      Gui$1.gui.patchView.getCurrentSubPatch(),
    );
  };

  CABLES_CMD_PATCH.deleteSelectedOps = function () {
    Gui$1.gui.patchView.deleteSelectedOps();
  };

  CABLES_CMD_PATCH.reload = function () {
    platform.talkerAPI.send("reload");
  };

  CABLES_CMD_PATCH.save = function (force, cb) {
    if (Gui$1.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_FULL) {
      notifyError("Not allowed");
      return;
    }
    if (platform.isSaving()) {
      log$1.log("already saving...");
      return;
    }

    Gui$1.gui.patchView.store.saveCurrentProject(cb, undefined, undefined, force);

    const ops = Gui$1.gui.savedState.getUnsavedPatchSubPatchOps();

    for (let i = 0; i < ops.length; i++) {
      ops[i].op.shortName;
      subPatchOpUtil.updateSubPatchOpAttachment(ops[i].op, {
        oldSubId: ops[i].subId,
      });
    }
  };

  CABLES_CMD_PATCH.saveAs = function () {
    Gui$1.gui.patchView.store.saveAs();
  };

  CABLES_CMD_PATCH.createBackup = function () {
    platform.createBackup();
  };

  CABLES_CMD_PATCH.clear = function () {
    Gui$1.gui.patchView.clearPatch();
  };

  CABLES_CMD_PATCH.createAreaFromSelection = function () {
    Gui$1.gui.patchView.createAreaFromSelection();
  };

  CABLES_CMD_PATCH.deleteUnusedPatchOps = function () {
    const opdocs = Gui$1.gui.opDocs.getAll();
    let text = "";
    let ids = [];

    for (let i = 0; i < opdocs.length; i++) {
      if (opdocs[i].name.indexOf("Ops.Patch") == 0) {
        const usedOps = Gui$1.gui.corePatch().getOpsByOpId(opdocs[i].id);

        if (ids.indexOf(opdocs[i].id) == -1 && usedOps.length == 0) {
          text += "- " + opdocs[i].name + "<br/>";
          ids.push(opdocs[i].id);
          log$1.log("found patch op", opdocs[i].id);
        }
      }
    }

    if (ids.length === 0) {
      new ModalDialog({
        title: "Unused Patch Ops",
        text: "No unused patch ops found.",
        showOkButton: true,
      });
    } else {
      // this will open an iframe tab an listen to "opsDeleted" that is sent by the iframe
      const idsParam = ids.join(",");
      const url =
        platform.getCablesUrl() + "/op/delete?ids=" + idsParam + "&iframe=true";
      Gui$1.gui.mainTabs.addIframeTab(
        "Delete Ops",
        url,
        {
          icon: "ops",
          closable: true,
          singleton: true,
          gotoUrl: platform.getCablesUrl() + "/op/delete?ids=" + idsParam,
        },
        true,
      );
    }
  };

  CABLES_CMD_PATCH.createSubPatchOp = function () {
    if (
      !Gui$1.gui.project().allowEdit &&
      Gui$1.gui.patchView.getCurrentSubPatch() == 0
    ) {
      new ModalDialog({
        title: "You don't have write access",
        showOkButton: true,
      });
      return;
    }

    let suggestedNamespace = platform.getPatchOpsNamespace();
    if (Gui$1.gui.patchView.getCurrentSubPatch() != 0) {
      const subOuter = Gui$1.gui.patchView.getSubPatchOuterOp(
        Gui$1.gui.patchView.getCurrentSubPatch(),
      );
      if (subOuter) {
        if (!Gui$1.gui.opDocs.getOpDocByName(subOuter.objName).allowEdit) {
          new ModalDialog({
            title: "You don't have write access in this subPatchOp",
            showOkButton: true,
          });
          return;
        }

        const parts = subOuter.objName.split(".");

        if (parts.length > 1)
          suggestedNamespace = parts[0] + "." + parts[1] + "." + parts[2] + ".";
      }
    }

    const dialogOptions = {
      title: "Create operator",
      shortName: subPatchOpUtil.getAutoName(true),
      type: "patch",
      suggestedNamespace: suggestedNamespace,
      showReplace: false,
      hasOpDirectories: platform.frontendOptions.hasOpDirectories,
    };

    if (Gui$1.gui.patchView.getCurrentSubPatch() != 0) {
      const outerOp = Gui$1.gui.patchView.getSubPatchOuterOp(
        Gui$1.gui.patchView.getCurrentSubPatch(),
      );
      if (outerOp) {
        const containerName = outerOp.objName;
        dialogOptions.sourceOpName = containerName;
      }
    }

    Gui$1.gui.serverOps.opNameDialog(
      dialogOptions,
      (newNamespace, newName, options) => {
        Gui$1.gui.closeModal();
        CABLES_CMD_PATCH.createOpFromSelection({
          newOpName: newName,
          ignoreNsCheck: true,
          ...options,
        });
      },
    );
  };

  CABLES_CMD_PATCH.centerOpsInSubpatch = function () {
    Gui$1.gui.patchView.centerSubPatchBounds(
      Gui$1.gui.patchView.getCurrentSubPatch(),
    );
  };

  CABLES_CMD_PATCH.createOpFromSelection = function (options = {}) {
    if (!options.ignoreNsCheck) {
      if (Gui$1.gui.patchView.getCurrentSubPatch() != 0) {
        const subOuter = Gui$1.gui.patchView.getSubPatchOuterOp(
          Gui$1.gui.patchView.getCurrentSubPatch(),
        );
        if (subOuter && subOuter.objName.indexOf("Ops.Patch.") != 0) {
          CABLES_CMD_PATCH.createSubPatchOp();
          return;
        }
      }
    }

    const origOpsBounds = Gui$1.gui.patchView.getSelectionBounds();
    Gui$1.gui.patchView.patchRenderer.subPatchOpAnimStart(origOpsBounds, () => {
      const selops = Gui$1.gui.patchView.getSelectedOps();

      let selectedOpIds = Gui$1.gui.patchView.getSelectedOpsIds();
      const newOpname = options.newOpName || subPatchOpUtil.getAutoName();
      const currentSubpatch = Gui$1.gui.patchView.getCurrentSubPatch();
      // const loadingModal = Gui.gui.startModalLoading("Create Subpatch");

      for (let i = 0; i < selops.length; i++) {
        if (selops[i].isSubPatchOp()) {
          if (selops[i].storage && selops[i].storage.subPatchVer != 2) {
            new ModalDialog({
              title: "Can not create subPatchOp",
              text: "not possible To create a subpatch op containing old subpatches. ",
              showOkButton: true,
            });

            return;
          }
        }
      }

      Gui$1.gui.serverOps.create(
        newOpname,
        () => {
          let newselectedOpIds = [];

          for (let i = 0; i < selectedOpIds.length; i++) {
            Gui$1.gui.patchView.selectOpId(selectedOpIds[i]);

            const op = Gui$1.gui.corePatch().getOpById(selectedOpIds[i]);
            if (op.isSubPatchOp()) {
              const newops = gui
                .corePatch()
                .getSubPatchOps(op.patchId.get(), false);
              for (let j = 0; j < newops.length; j++)
                newselectedOpIds.push(newops[j].id);
            }
          }

          Gui$1.gui.patchView.createSubPatchFromSelection(
            2,
            (patchId, OpTempSubpatch) => {
              const portJson = { ports: [] };
              const oldLinks = [];

              // find ops that are crosslinked...
              const ops = Gui$1.gui.corePatch().getSubPatchOps(patchId);

              let unlink = [];
              for (let i = 0; i < ops.length; i++) {
                const op = ops[i];
                for (let j = 0; j < op.portsIn.length; j++) {
                  const portIn = op.portsIn[j];
                  let pJson;
                  for (let k = 0; k < op.portsIn[j].links.length; k++) {
                    if (portIn.isLinked() && portIn.links[k]) {
                      const p2 = portIn.links[k].getOtherPort(portIn);
                      if (p2.op.uiAttribs.subPatch != op.uiAttribs.subPatch) {
                        if (k == 0) {
                          pJson =
                            subPatchOpUtil.createBlueprintPortJsonElement(portIn);
                          portJson.ports.push(pJson);
                        }

                        op.setUiAttrib({ tempSubOldOpId: op.id });
                        oldLinks.push({
                          pJson: pJson,
                          port: p2,
                          tempSubOldOpId: op.id,
                          origPortName: portIn.name,
                        });
                        unlink.push(portIn.links[k]);
                      }
                    }
                  }
                }

                for (let j = 0; j < op.portsOut.length; j++) {
                  const portOut = op.portsOut[j];
                  if (portOut.isLinked()) {
                    let pJson = null;
                    for (let k = 0; k < portOut.links.length; k++) {
                      const p2 = portOut.links[k].getOtherPort(portOut);
                      if (p2.op.uiAttribs.subPatch != op.uiAttribs.subPatch) {
                        if (k == 0) {
                          pJson =
                            subPatchOpUtil.createBlueprintPortJsonElement(
                              portOut,
                            );
                          portJson.ports.push(pJson);
                        }
                        op.setUiAttrib({ tempSubOldOpId: op.id });
                        oldLinks.push({
                          pJson: pJson,
                          port: p2,
                          tempSubOldOpId: op.id,
                          origPortName: portOut.name,
                        });
                        unlink.push(portOut.links[k]);
                      }
                    }
                  }
                }
              }

              unlink.forEach((l) => {
                l.remove();
              });

              Gui$1.gui.patchView.addOp(newOpname, {
                uiAttribs: {
                  translate: { x: origOpsBounds.minX, y: origOpsBounds.minY },
                },
                onOpAdd: (newOp) => {
                  subPatchOpUtil.createBlueprint2Op(
                    newOp,
                    OpTempSubpatch,
                    () => {
                      const src =
                        subPatchOpUtil.generatePortsAttachmentJsSrc(portJson);

                      Gui$1.gui.corePatch().deleteOp(OpTempSubpatch.id);
                      Gui$1.gui.patchView.setCurrentSubPatch(currentSubpatch);

                      platform.talkerAPI.send(
                        "opUpdate",
                        {
                          opname: newOpname,
                          update: {
                            attachments: {
                              "att_inc_gen_ports.js": src,
                              "att_ports.json": JSON.stringify(portJson),
                            },
                          },
                        },
                        (err, r) => {
                          if (err) {
                            this.showApiError(err);
                            return;
                          }

                          Gui$1.gui.serverOps.execute(newOpname, (newOps) => {
                            newOp = newOps[0];

                            const subPatchId = newOp.patchId.get();

                            // relink inside ports....
                            const subOps = gui
                              .corePatch()
                              .getSubPatchOps(subPatchId, false);
                            for (let j = 0; j < oldLinks.length; j++) {
                              // outer linking
                              const oldLink = oldLinks[j];

                              if (oldLink.pJson) {
                                newOp.patch.link(
                                  newOp,
                                  oldLink.pJson.id,
                                  oldLink.port.op,
                                  oldLink.port.name,
                                );

                                for (let i = 0; i < subOps.length; i++) {
                                  const op = subOps[i];
                                  if (
                                    op.uiAttribs.tempSubOldOpId ==
                                    oldLink.tempSubOldOpId
                                  ) {
                                    let patchInputOP = gui
                                      .corePatch()
                                      .getSubPatch2InnerInputOp(subPatchId);
                                    let l = newOp.patch.link(
                                      patchInputOP,
                                      "innerOut_" + oldLink.pJson.id,
                                      op,
                                      oldLink.origPortName,
                                    );

                                    if (!l) {
                                      let patchOutputOP = gui
                                        .corePatch()
                                        .getSubPatch2InnerOutputOp(subPatchId);
                                      l = newOp.patch.link(
                                        patchOutputOP,
                                        "innerIn_" + oldLink.pJson.id,
                                        op,
                                        oldLink.origPortName,
                                      );
                                    }

                                    if (!l)
                                      log$1.log(
                                        "could not recreate oldlink",
                                        oldLink,
                                      );
                                  }
                                }
                              }
                            }

                            for (let i = 0; i < subOps.length; i++)
                              subOps[i].setUiAttrib({ tempSubOldOpId: null });

                            if (selectedOpIds.length == 0) newOp.setPos(0, 0);
                            else
                              newOp.setPos(
                                origOpsBounds.minX,
                                origOpsBounds.minY,
                              );

                            Gui$1.gui.patchView.testCollision(newOp);
                            Gui$1.gui.patchView.setPositionSubPatchInputOutputOps(
                              subPatchId,
                            );

                            if (
                              !Gui$1.gui.savedState.getStateBlueprint(subPatchId)
                            ) {
                              subPatchOpUtil.updateSubPatchOpAttachment(newOp, {
                                oldSubId: subPatchId,
                                next: () => {
                                  /*
                                   * log.log("bp", bp);
                                   * CABLES.CMD.PATCH.save();
                                   */
                                },
                              });
                            }
                            Gui$1.gui.patchView.patchRenderer.focusOpAnim(newOp.id);
                            Gui$1.gui.patchView.patchRenderer.subPatchOpAnimEnd(
                              newOp.id,
                            );
                            Gui$1.gui.emitEvent(
                              "createdSubPatchOp",
                              newOp,
                              subPatchId,
                            );
                          });
                        },
                      );
                    },
                    { doNotExecute: true },
                  );
                },
              });
            },
            { translate: { x: 0, y: 0 } },
          );
        },
        false,
        { noLoadOp: true, ...options },
      );
    });
  };

  /*
   * CABLES_CMD_PATCH.createSubPatchFromSelection = function (version)
   * {
   *     Gui.gui.patchView.createSubPatchFromSelection(version);
   * };
   */

  CABLES_CMD_PATCH.findCommentedOps = function () {
    Gui$1.gui.find(":commented");
  };

  CABLES_CMD_PATCH.findUnconnectedOps = function () {
    Gui$1.gui.find(":unconnected");
  };

  CABLES_CMD_PATCH.findUserOps = function () {
    Gui$1.gui.find(":user");
  };

  CABLES_CMD_PATCH.findOpsUsingExternalAssets = function () {
    Gui$1.gui.find(":extassets");
  };

  CABLES_CMD_PATCH.createFile = function () {
    Gui$1.gui.showFileManager(function () {
      Gui$1.gui.fileManager.createFile();
    });
  };

  CABLES_CMD_PATCH.uploadFile = function () {
    if (!window.gui) return;
    const fileElem = document.getElementById("hiddenfileElem");
    if (fileElem) fileElem.click();
  };

  CABLES_CMD_PATCH.reuploadFile = function (id, fileName) {
    if (!window.gui || !fileName) return;
    CABLES.reuploadName = fileName;
    const fileEle = ele.byId("fileReUpload" + id);
    if (fileEle && fileEle.dataset.filePath)
      CABLES.reuploadName = fileEle.dataset.filePath;
    const uploadEle = ele.byId("hiddenfileElemReupload");
    if (uploadEle) uploadEle.click();
  };

  CABLES_CMD_PATCH.uploadFileDialog = function () {
    if (!window.gui || !Gui$1.gui.project()) return;
    const fileElem = document.getElementById("uploaddialog");

    if (!fileElem) {
      const html = getHandleBarHtml("dialog_upload", {
        patchId: Gui$1.gui.project()._id,
      });

      new ModalDialog({ html: html });
    }
  };

  CABLES_CMD_PATCH.uploadFileTab = () => {
    const url =
      platform.getCablesUrl() +
      "/patch/" +
      Gui$1.gui.project()._id +
      "/settings/upload?iframe=true";
    Gui$1.gui.mainTabs.addIframeTab(
      "Upload File",
      url,
      {
        icon: "settings",
        closable: true,
        singleton: true,
      },
      true,
    );
  };

  CABLES_CMD_PATCH.showBackups = () => {
    const url =
      platform.getCablesUrl() +
      "/patch/" +
      Gui$1.gui.project()._id +
      "/settings?iframe=true#versions";
    const gotoUrl =
      platform.getCablesUrl() +
      "/patch/" +
      Gui$1.gui.project()._id +
      "/settings#versions";
    Gui$1.gui.mainTabs.addIframeTab(
      "Patch Backups",
      url,
      {
        icon: "settings",
        closable: true,
        singleton: true,
        gotoUrl: gotoUrl,
      },
      true,
    );
  };

  CABLES_CMD_PATCH.export = function (type) {
    const exporter = new Exporter(
      Gui$1.gui.project(),
      platform.getPatchVersion(),
      type,
    );
    exporter.show();
  };

  CABLES_CMD_PATCH.newPatch = function () {
    Gui$1.gui.createProject();
  };

  CABLES_CMD_PATCH.addOpByName = (name) => {
    new ModalDialog({
      prompt: true,
      title: "Add Op",
      text: "Enter full op name",
      promptValue: name,
      promptOk: (opname) => {
        Gui$1.gui.serverOps.loadOpDependencies(opname, function () {
          Gui$1.gui.patchView.addOp(opname, {
            onOpAdd: (op) => {
              op.setUiAttrib({
                translate: {
                  x: Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchX,
                  y: Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchY,
                },
              });
              if (op) {
                Gui$1.gui.patchView.focusOp(op.id);
              }
            },
          });
        });
      },
    });
  };

  CABLES_CMD_PATCH.reloadOp = function (x, y) {
    const ops = Gui$1.gui.patchView.getSelectedOps();
    if (!ops.length) return;

    const op = Gui$1.gui.patchView.getSelectedOps()[0];

    Gui$1.gui.serverOps.execute(op.opId, () => {
      notify("reloaded op " + op.objName);
    });
  };

  CABLES_CMD_PATCH.addOp = function (x, y) {
    Gui$1.gui.opSelect().show({ x: 0, y: 0 });
  };

  CABLES_CMD_PATCH.patchWebsite = function () {
    window.open(
      platform.getCablesUrl() + "/p/" + Gui$1.gui.project().shortId ||
        Gui$1.gui.project()._id,
    );
  };

  CABLES_CMD_PATCH.renameVariable = function (oldname) {
    new ModalDialog({
      prompt: true,
      title: "Rename Variable",
      text: "Enter a new name for the variable " + oldname,
      promptValue: oldname,
      promptOk: (newname) => {
        Gui$1.gui.corePatch().emitEvent("variableRename", oldname, newname);
        Gui$1.gui.corePatch().deleteVar(oldname);
      },
    });
  };

  CABLES_CMD_PATCH.createVariable = function (op) {
    new ModalDialog({
      prompt: true,
      title: "New Variable",
      text: "Enter a name for the new variable",
      promptValue: "",
      promptOk: (str) => {
        if (op) {
          op.setTitle(str);
          op.varName.set(str);
          Gui$1.gui.opParams.show(op);
        }
      },
    });
  };

  CABLES_CMD_PATCH.createVarNumber = function (next) {
    new ModalDialog({
      prompt: true,
      title: "New Variable",
      text: "Enter a name for the new variable",
      promptValue: "myNewVar",
      promptOk: (str) => {
        const opSetter = Gui$1.gui.patchView.addOp(
          defaultOps.defaultOpNames.VarSetNumber,
        );
        const opGetter = Gui$1.gui.patchView.addOp(
          defaultOps.defaultOpNames.VarGetNumber,
        );

        opSetter.varName.set(str);
        opGetter.varName.set(str);
      },
    });
  };

  CABLES_CMD_PATCH.analyze = function (force) {
    new AnalyzePatchTab();
  };

  CABLES_CMD_PATCH._createVariable = function (name, p, p2, value, next) {
    const getsetOp = opNames.getVarGetterOpNameByType(p.type, p);

    let portName = getsetOp.portName;
    let portNameOut = getsetOp.portNameOut;
    let opSetterName = getsetOp.setter;
    let opGetterName = getsetOp.getter;

    Gui$1.gui.patchView.addOp(opSetterName, {
      onOpAdd: (opSetter) => {
        Gui$1.gui.patchView.addOp(opGetterName, {
          onOpAdd: (opGetter) => {
            opSetter.uiAttr({ subPatch: Gui$1.gui.patchView.getCurrentSubPatch() });
            opGetter.uiAttr({ subPatch: Gui$1.gui.patchView.getCurrentSubPatch() });

            if (p.type != portType.trigger)
              opSetter.getPortByName(portName).set(value);

            if (p.direction == CABLES.Port.DIR_IN) {
              p.op.patch.link(opGetter, portName, p.op, p.name);
              if (p2) p2.op.patch.link(opSetter, portNameOut, p2.op, p2.name);
            } else {
              p.op.patch.link(opSetter, portName, p.op, p.name);
              if (p2) p2.op.patch.link(opGetter, portNameOut, p2.op, p2.name);
            }

            opSetter.varName.set(name);
            opGetter.varName.set(name);

            Gui$1.gui.patchView.setCurrentSubPatch(
              Gui$1.gui.patchView.getCurrentSubPatch(),
            );

            if (next) next(opSetter, opGetter);

            Gui$1.gui.closeModal();
          },
        });
      },
    });
  };

  CABLES_CMD_PATCH.replaceLinkTriggerReceiveExist = function () {
    const link = CABLES.UI.OPSELECT.linkNewLink;
    const p = link.portIn;
    link.portOut;
    CABLES.UI.OPSELECT.linkNewLink = null;

    Gui$1.gui.opSelect().close();
    Gui$1.gui.closeModal();
    const getsetOp = opNames.getVarGetterOpNameByType(p.type, p);

    Gui$1.gui.patchView.addOp(getsetOp.getter, {
      onOpAdd: (opGetter) => {
        link.remove();
        p.removeLinks();
        p.op.patch.link(opGetter, getsetOp.portNameOut, p.op, p.name);

        opGetter.uiAttr({
          subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
          translate: {
            x: p.op.uiAttribs.translate.x + 20,
            y: p.op.uiAttribs.translate.y - 40,
          },
        });
      },
    });
  };

  CABLES_CMD_PATCH.createTriggerSendReceiveExist = function () {
    const type = CABLES.UI.OPSELECT.linkNewOpToPort.type;
    const p = CABLES.UI.OPSELECT.linkNewOpToPort;

    Gui$1.gui.opSelect().close();
    Gui$1.gui.closeModal();
    const getsetOp = opNames.getVarGetterOpNameByType(type, p);
    CABLES.UI.OPSELECT.linkNewOpToPort = null;

    let getset = getsetOp.setter;
    if (p.direction == CABLES.Port.DIR_IN) getset = getsetOp.getter;

    Gui$1.gui.patchView.addOp(getset, {
      onOpAdd: (op) => {
        let off = -40;

        if (p.direction == CABLES.Port.DIR_IN) {
          p.op.patch.link(op, getsetOp.portNameOut, p.op, p.name);
        } else {
          p.op.patch.link(op, getsetOp.portName, p.op, p.name);
          off *= -1;
        }

        op.uiAttr({
          subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
          translate: {
            x: p.op.uiAttribs.translate.x + 20,
            y: p.op.uiAttribs.translate.y + off,
          },
        });
      },
    });
  };

  CABLES_CMD_PATCH.replaceLinkVariableExist = function () {
    const link = CABLES.UI.OPSELECT.linkNewLink;
    const p = link.portIn;
    link.portOut;
    CABLES.UI.OPSELECT.linkNewLink = null;

    Gui$1.gui.opSelect().close();
    Gui$1.gui.closeModal();
    const getsetOp = opNames.getVarGetterOpNameByType(p.type, p);

    Gui$1.gui.patchView.addOp(getsetOp.getter, {
      onOpAdd: (opGetter) => {
        link.remove();
        p.removeLinks();

        p.op.patch.link(opGetter, getsetOp.portName, p.op, p.name);

        opGetter.uiAttr({
          subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
          translate: {
            x: p.op.uiAttribs.translate.x + 20,
            y: p.op.uiAttribs.translate.y - 40,
          },
        });
      },
    });
  };

  CABLES_CMD_PATCH.addLinkReroute = function () {
    const link = CABLES.UI.OPSELECT.linkNewLink;
    const p = link.portIn;
    link.portOut;
    CABLES.UI.OPSELECT.linkNewLink = null;

    Gui$1.gui.opSelect().close();
    Gui$1.gui.closeModal();
    const getsetOp = opNames.getRerouteOp(p.type);

    Gui$1.gui.patchView.addOp(getsetOp, {
      onOpAdd: (opGetter) => {
        const glPatch = Gui$1.gui.patchView.patchRenderer;
        let x = glPatch._lastMouseX;
        let y = glPatch._lastMouseY;

        opGetter.uiAttr({
          subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
        });

        setTimeout(() => {
          x = glPatch.snap.snapX(x);
          y = glPatch.snap.snapY(y);

          Gui$1.gui.patchView.insertOpInLink(link, opGetter, x, y);
        }, 100);
      },
    });
  };

  CABLES_CMD_PATCH.createLinkVariableExist = function (createTrigger = false) {
    Gui$1.gui.opSelect().close();
    const type = CABLES.UI.OPSELECT.linkNewOpToPort.type;
    const p = CABLES.UI.OPSELECT.linkNewOpToPort;

    Gui$1.gui.closeModal();
    const getsetOp = opNames.getVarGetterOpNameByType(type, p);
    CABLES.UI.OPSELECT.linkNewOpToPort = null;

    let opFunction = getsetOp.getter;
    let newOpX = p.op.uiAttribs.translate.x + 20;
    let newOpY = p.op.uiAttribs.translate.y - 40;
    if (p.direction === CABLES.Port.DIR_OUT) {
      if (createTrigger) {
        opFunction = getsetOp.setTrigger;
      } else {
        opFunction = getsetOp.setter;
      }
      newOpY = p.op.uiAttribs.translate.y + 40;
    }

    Gui$1.gui.patchView.addOp(opFunction, {
      onOpAdd: (opGetter) => {
        p.removeLinks();
        p.op.patch.link(opGetter, getsetOp.portName, p.op, p.name);

        opGetter.uiAttr({
          subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
          translate: {
            x: newOpX,
            y: newOpY,
          },
        });
      },
    });
  };

  CABLES_CMD_PATCH.replaceLinkVariable = function () {
    Gui$1.gui.opSelect().close();
    new ModalDialog({
      prompt: true,
      title: "New Variable",
      text: "Enter a name for the new variable",
      promptValue: "",
      promptOk: (str) => {
        const link = CABLES.UI.OPSELECT.linkNewLink;

        const p1 = link.portIn;
        const p2 = link.portOut;
        CABLES.UI.OPSELECT.linkNewLink = null;

        if (p1.direction == CABLES.Port.DIR_IN) p1.removeLinks();
        else p2.removeLinks();

        link.remove();

        CABLES_CMD_PATCH._createVariable(
          str,
          p2,
          p1,
          p2.get(),
          (setter, getter) => {
            getter.uiAttr({
              translate: {
                x: p1.op.uiAttribs.translate.x,
                y: p1.op.uiAttribs.translate.y - 40,
              },
            });

            setter.uiAttr({
              translate: {
                x: p2.op.uiAttribs.translate.x,
                y: p2.op.uiAttribs.translate.y + 40,
              },
            });
          },
        );
      },
    });
  };

  CABLES_CMD_PATCH.createTriggerSendReceive = () => {
    Gui$1.gui.opSelect().close();
    const link = CABLES.UI.OPSELECT.linkNewLink;

    new ModalDialog({
      prompt: true,
      title: "New Trigger Send",
      text: "Enter a name for a new wireless trigger",
      promptValue: link.portOut.name,
      promptOk: (str) => {
        const p1 = link.portIn;
        const p2 = link.portOut;
        CABLES.UI.OPSELECT.linkNewLink = null;

        if (p1.direction == CABLES.Port.DIR_IN) p1.removeLinks();
        else p2.removeLinks();

        link.remove();

        CABLES_CMD_PATCH._createVariable(
          str,
          p2,
          p1,
          p2.get(),
          (setter, getter) => {
            getter.uiAttr({
              subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
              translate: {
                x: p1.op.uiAttribs.translate.x,
                y: p1.op.uiAttribs.translate.y - 40,
              },
            });

            setter.uiAttr({
              subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
              translate: {
                x: p2.op.uiAttribs.translate.x,
                y: p2.op.uiAttribs.translate.y + 40,
              },
            });
          },
        );
      },
    });
  };

  CABLES_CMD_PATCH.createAutoVariable = function () {
    Gui$1.gui.opSelect().close();
    const p = CABLES.UI.OPSELECT.linkNewOpToPort;

    new ModalDialog({
      prompt: true,
      title: "New Variable",
      text: "Enter a name for the new variable",
      promptValue: p.name,
      promptOk: (str) => {
        CABLES_CMD_PATCH._createVariable(
          str,
          p,
          null,
          p.get(),
          (setter, getter) => {
            if (!setter.uiAttribs.translate)
              setter.uiAttr({
                subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
                translate: {
                  x: p.op.uiAttribs.translate.x,
                  y: p.op.uiAttribs.translate.y + 40,
                },
              });

            getter.uiAttr({
              subPatch: Gui$1.gui.patchView.getCurrentSubPatch(),
              translate: {
                x: setter.uiAttribs.translate.x,
                y: setter.uiAttribs.translate.y + 40,
              },
            });
          },
        );
      },
    });
  };

  CABLES_CMD_PATCH.addSpaceX = () => {
    Gui$1.gui.patchView.addSpaceBetweenOpsX();
  };

  CABLES_CMD_PATCH.addSpaceY = () => {
    Gui$1.gui.patchView.addSpaceBetweenOpsY();
  };

  CABLES_CMD_PATCH.linkTwoSelectedOps = () => {
    if (Gui$1.gui.patchView.getSelectedOps().length != 2) {
      log$1.log("needs 2 selected ops");
      return;
    }

    let a = Gui$1.gui.patchView.getSelectedOps()[0];
    let b = Gui$1.gui.patchView.getSelectedOps()[1];

    if (a.uiAttribs.translate.y > b.uiAttribs.translate.y)
      Gui$1.gui.patchView.suggestionBetweenTwoOps(b, a);
    else Gui$1.gui.patchView.suggestionBetweenTwoOps(a, b);
  };

  CABLES_CMD_PATCH.compressOps = () => {
    Gui$1.gui.patchView.compressSelectedOps(Gui$1.gui.patchView.getSelectedOps());
  };

  CABLES_CMD_PATCH.alignOpsLeft = () => {
    Gui$1.gui.patchView.alignSelectedOpsVert(Gui$1.gui.patchView.getSelectedOps());
  };

  CABLES_CMD_PATCH.watchGlOp = function () {
    new GlOpWatcher(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_PATCH.savePatchScreenshot = function () {
    Gui$1.gui.patchView.patchRenderer._cgl.saveScreenshot(
      "patchfield_" + performance.now(),
      () => {
        Gui$1.gui.patchView.patchRenderer._cgl.patch.resume();
      },
    );
  };

  CABLES_CMD_PATCH.toggleResizable = function () {
    const ops = Gui$1.gui.patchView.getSelectedOps();

    for (let i = 0; i < ops.length; i++) {
      const op = ops[i];

      op.setUiAttribs({
        stretchPorts: !op.uiAttribs.stretchPorts,
        resizableY: false,
        resizable: !op.uiAttribs.stretchPorts,
      });
    }
  };

  CABLES_CMD_PATCH.setOpTitle = function () {
    const ops = Gui$1.gui.patchView.getSelectedOps();

    if (ops.length != 1) {
      log$1.warn("rename canceled - select one op!");
      return;
    }

    new ModalDialog({
      prompt: true,
      title: "Set Title",
      text: "Enter a title for this op",
      promptValue: ops[0].name,
      promptOk: (name) => {
        Gui$1.gui.opParams.setCurrentOpTitle(name);
      },
    });
  };

  CABLES_CMD_PATCH.resume = function () {
    Gui$1.gui.corePatch().resume();
  };

  CABLES_CMD_PATCH.pause = function () {
    Gui$1.gui.corePatch().pause();
  };

  CABLES_CMD_PATCH.replaceOp = function () {
    new ModalDialog({
      prompt: true,
      title: "Replace Ops",
      text: "Replace selected ops with: Enter full op name",
      promptOk: (opname) => {
        const ops = Gui$1.gui.patchView.getSelectedOps();
        for (let i = 0; i < ops.length; i++) {
          Gui$1.gui.patchView.replaceOp(ops[i].id, opname);
        }
      },
    });
  };

  CABLES_CMD_PATCH.editOpSummary = function (opId, opName, oldSummary = "") {
    if (!platform.frontendOptions.editOpSummary) return;

    new ModalDialog({
      prompt: true,
      title: opName,
      text: "New summary:",
      promptValue: oldSummary,
      promptOk: (summary) => {
        Gui$1.gui.savingTitleAnimStart("Updating Op...");
        platform.talkerAPI.send(
          "opSetSummary",
          { id: opId, name: opName, summary: summary },
          (err, res) => {
            if (!err) {
              Gui$1.gui.serverOps.loadOpDependencies(
                opName,
                () => {
                  Gui$1.gui.savingTitleAnimEnd();
                  Gui$1.gui.emitEvent("refreshManageOp", opName);
                },
                true,
              );
            }
          },
        );
      },
    });
  };

  CABLES_CMD_PATCH.uncollideOps = function (ops) {
    // while (found)

    for (let i = 0; i < Gui$1.gui.corePatch().ops.length; i++) {
      const op = Gui$1.gui.corePatch().ops[i];

      if (!op.uiAttribs.translate) op.uiAttribs.translate = { x: 0, y: 0 };

      for (let j = 0; j < Gui$1.gui.corePatch().ops.length; j++) {
        const b = Gui$1.gui.corePatch().ops[j];
        if (b.deleted || b == op) continue;

        while (
          b.uiAttribs.translate &&
          op.uiAttribs.translate &&
          op.uiAttribs.translate.x <= b.uiAttribs.translate.x + 50 &&
          op.uiAttribs.translate.x >= b.uiAttribs.translate.x &&
          op.uiAttribs.translate.y == b.uiAttribs.translate.y
        ) {
          op.setUiAttrib({
            translate: {
              x: b.uiAttribs.translate.x,
              y: b.uiAttribs.translate.y + gluiconfig.newOpDistanceY,
            },
          });
        }
      }
    }
  };

  CABLES_CMD_PATCH.togglePatchLike = (targetElement = null) => {
    platform.talkerAPI.send("toggleFav", {}, (err, res) => {
      if (!err && res.success && targetElement) {
        if (targetElement.target) targetElement = targetElement.target;
        const icon = targetElement.querySelector(".icon");
        if (icon) {
          if (res.favstate) {
            icon.classList.remove("icon-heart");
            icon.classList.add("icon-heart-fill");
          } else {
            icon.classList.remove("icon-heart-fill");
            icon.classList.add("icon-heart");
          }
        }
      }
    });
  };

  CABLES_CMD_PATCH.deleteOp = (opName = null) => {
    if (!opName) {
      const ops = Gui$1.gui.patchView.getSelectedOps();
      if (!ops.length) return;
      const op = Gui$1.gui.patchView.getSelectedOps()[0];
      opName = op.objName;
    }

    if (platform.frontendOptions.opDeleteInEditor) {
      Gui$1.gui.serverOps.deleteDialog(opName);
    }
  };

  CABLES_CMD_PATCH.patchProfiler = () => {
    new Profiler(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CMD_PATCH_COMMANDS.push(
    {
      cmd: "Select all ops",
      category: "patch",
      func: CABLES_CMD_PATCH.selectAllOps,
      hotkey: "CMD + a",
    },
    {
      cmd: "Delete selected ops",
      category: "patch",
      func: CABLES_CMD_PATCH.deleteSelectedOps,
      icon: "trash",
      hotkey: "DEL",
    },
    {
      cmd: "Save patch",
      category: "patch",
      func: CABLES_CMD_PATCH.save,
      icon: "save",
      hotkey: "[cmd_ctrl]`S`",
      infotext: "cmd_savepatch",
    },
    {
      cmd: "Save patch as...",
      category: "patch",
      func: CABLES_CMD_PATCH.saveAs,
      icon: "save",
      hotkey: "[cmd_ctrl][shift]`s`",
    },
    {
      cmd: "Upload file dialog",
      category: "patch",
      func: CABLES_CMD_PATCH.uploadFileDialog,
      icon: "file",
      frontendOption: "uploadFiles",
    },
    {
      cmd: "Upload file",
      category: "patch",
      func: CABLES_CMD_PATCH.uploadFile,
      icon: "file",
      frontendOption: "uploadFiles",
    },
    {
      cmd: "Create new file",
      category: "patch",
      func: CABLES_CMD_PATCH.createFile,
      icon: "file",
      frontendOption: "uploadFiles",
    },
    {
      cmd: "Select child ops",
      category: "op",
      func: CABLES_CMD_PATCH.selectChilds,
    },
    {
      cmd: "Clear op titles",
      category: "op",
      func: CABLES_CMD_PATCH.clearOpTitles,
    },

    /*
     * {
     *     "cmd": "Create subpatch",
     *     "category": "patch",
     *     "func": CABLES_CMD_PATCH.createSubPatchFromSelection,
     *     "icon": "subpatch"
     * },
     */
    {
      cmd: "Export static html",
      category: "patch",
      func: CABLES_CMD_PATCH.export,
      icon: "download",
      frontendOption: "showExport",
    },
    {
      cmd: "Show backups",
      category: "patch",
      func: CABLES_CMD_PATCH.showBackups,
      icon: "file",
      frontendOption: "showPatchBackups",
    },
    {
      cmd: "Create new patch",
      category: "patch",
      func: CABLES_CMD_PATCH.newPatch,
      icon: "file",
    },
    {
      cmd: "Reload op",
      category: "patch",
      func: CABLES_CMD_PATCH.reloadOp,
      icon: "op",
      infotext: "cmd_reloadop",
    },
    {
      cmd: "Add op",
      category: "patch",
      func: CABLES_CMD_PATCH.addOp,
      icon: "op",
      infotext: "cmd_addop",
    },
    {
      cmd: "Add op by name",
      category: "patch",
      func: CABLES_CMD_PATCH.addOpByName,
      icon: "op",
    },
    {
      cmd: "Set title",
      category: "op",
      func: CABLES_CMD_PATCH.setOpTitle,
      icon: "edit",
    },
    {
      cmd: "Toggle op resizable",
      category: "op",
      func: CABLES_CMD_PATCH.toggleResizable,
      icon: "op",
    },
    {
      cmd: "Clear patch",
      category: "patch",
      func: CABLES_CMD_PATCH.clear,
    },
    {
      cmd: "Open patch website",
      category: "patch",
      func: CABLES_CMD_PATCH.patchWebsite,
      icon: "link",
      frontendOption: "hasCommunity",
    },
    {
      cmd: "Pause patch execution",
      category: "patch",
      func: CABLES_CMD_PATCH.pause,
    },
    {
      cmd: "Resume patch execution",
      category: "patch",
      func: CABLES_CMD_PATCH.resume,
    },
    {
      cmd: "Replace file path",
      category: "patch",
      func: CABLES_CMD_PATCH.replaceFilePath,
    },
    {
      cmd: "Find unconnected ops",
      category: "patch",
      func: CABLES_CMD_PATCH.findUnconnectedOps,
    },
    {
      cmd: "Find user ops",
      category: "patch",
      func: CABLES_CMD_PATCH.findUserOps,
    },
    {
      cmd: "Find commented ops",
      category: "patch",
      func: CABLES_CMD_PATCH.findCommentedOps,
    },
    {
      cmd: "Find external assets",
      category: "patch",
      func: CABLES_CMD_PATCH.findOpsUsingExternalAssets,
    },
    {
      cmd: "Analyze patch",
      category: "patch",
      func: CABLES_CMD_PATCH.analyze,
    },
    {
      cmd: "Create number variable",
      category: "patch",
      func: CABLES_CMD_PATCH.createVarNumber,
    },
    {
      cmd: "Create backup",
      category: "patch",
      func: CABLES_CMD_PATCH.createBackup,
    },
    {
      cmd: "Align ops left",
      func: CABLES_CMD_PATCH.alignOpsLeft,
      category: "patch",
      icon: "align-left",
    },
    {
      cmd: "Compress ops vertically",
      func: CABLES_CMD_PATCH.compressOps,
      category: "patch",
      icon: "list",
    },
    {
      cmd: "Add space x",
      func: CABLES_CMD_PATCH.addSpaceX,
      category: "patch",
      icon: "list",
    },
    {
      cmd: "Add space y",
      func: CABLES_CMD_PATCH.addSpaceY,
      category: "patch",
      icon: "list",
    },
    {
      cmd: "Save patchfield screenshot",
      func: CABLES_CMD_PATCH.savePatchScreenshot,
      category: "patch",
      icon: "image",
    },
    {
      cmd: "Replace ops",
      func: CABLES_CMD_PATCH.replaceOp,
      category: "patch",
      icon: "op",
    },
    {
      cmd: "Link two selected ops",
      func: CABLES_CMD_PATCH.linkTwoSelectedOps,
      category: "patch",
      icon: "op",
    },

    {
      cmd: "Go to parent subpatch",
      func: CABLES_CMD_PATCH.gotoParentSubpatch,
      category: "patch",
    },
    {
      cmd: "Open params in tab",
      func: CABLES_CMD_PATCH.openParamsTab,
      category: "patch",
      icon: "op",
    },
    {
      cmd: "Show glop information",
      func: CABLES_CMD_PATCH.watchGlOp,
      category: "patch",
      icon: "op",
    },
    {
      cmd: "Uncollide ops",
      func: CABLES_CMD_PATCH.uncollideOps,
      category: "patch",
      icon: "op",
    },
    {
      cmd: "Toggle patch like",
      func: CABLES_CMD_PATCH.togglePatchLike,
      category: "patch",
    },
    {
      cmd: "Create subpatch op",
      func: CABLES_CMD_PATCH.createSubPatchOp,
      category: "patch",
      icon: "op",
    },
    {
      cmd: "Delete unused patch ops",
      func: CABLES_CMD_PATCH.deleteUnusedPatchOps,
      category: "patch",
      icon: "op",
    },
    {
      cmd: "Center ops in subpatch",
      func: CABLES_CMD_PATCH.centerOpsInSubpatch,
      category: "patch",
      icon: "op",
    },
    {
      cmd: "Set patch title",
      func: CABLES_CMD_PATCH.setPatchTitle,
      category: "patch",
      icon: "edit",
    },
    {
      cmd: "Auto position subpatch input output ops",
      func: CABLES_CMD_PATCH.autoPosSubpatchInputOutputOps,
      category: "op",
      icon: "op",
    },
    {
      cmd: "Reload patch",
      category: "patch",
      func: CABLES_CMD_PATCH.reload,
    },
    {
      cmd: "Patch Profiler",
      category: "patch",
      icon: "pie-chart",
      func: CABLES_CMD_PATCH.patchProfiler,
    },
  );

  class CanvasLens {
    constructor(ele) {
      this._origCanvas = Gui$1.gui.canvasManager.currentCanvas();
      this._scale = 7;
      this._size = this._scale * (this._origCanvas.clientWidth / 25);
      this._size2 = this._size / 2;
      this._origPixels = this._size / this._scale;
      this._origPixels2 = this._size / this._scale / 2;

      this._lensCanvas = document.createElement("canvas");
      this._lensCanvas.id = "canvaslens";
      this._lensCanvas.width = this._size;
      this._lensCanvas.height = this._size;
      this._lensCanvas.style["z-index"] = 999999999;
      this._lensCanvas.style.width = this._size + "px";
      this._lensCanvas.style.height = this._size + "px";
      this._lensCanvas.style.left = "-1111px";
      this._lensCanvas.style.top = "-1111px";
      this._lensCanvas.style.position = "absolute";
      this._lensCanvas.style["pointer-events"] = "none";
      this._lensCanvas.style.border = "1px solid black";
      this._lensCanvas.style.background = "black";

      this._ctx = this._lensCanvas.getContext("2d");
      this._ctx.imageSmoothingEnabled = false;

      document.body.appendChild(this._lensCanvas);

      this._endFrameListener = this._onEndframe.bind(this);
      this._endFrameListenerId = gui
        .corePatch()
        .cgl.on("endFrame", this._endFrameListener);

      this._moveListener = this._onMouseMove.bind(this);
      this._origCanvas.addEventListener("mousemove", this._moveListener);

      this._moveLeaveListener = this._onMouseLeave.bind(this);
      this._origCanvas.addEventListener("mouseleave", this._moveLeaveListener);

      this._copyListener = this._onCopy.bind(this);
      document.addEventListener("copy", this._copyListener);

      Gui$1.gui.canvasMagnifier = this;
    }

    _onCopy(e) {
      notify("Color copied");
      e.clipboardData.setData("text/plain", this._hex);
      e.preventDefault();
    }

    _onMouseMove(e) {
      clearTimeout(this.leaveTimeout);
      const rect = e.target.getBoundingClientRect();
      this._x = (e.clientX - rect.left) / Gui$1.gui._corePatch.cgl.canvasScale; // x position within the element.
      this._y = (e.clientY - rect.top) / Gui$1.gui._corePatch.cgl.canvasScale; // y position within the element.

      this._lensCanvas.style.left = e.clientX - this._size2 + "px";
      this._lensCanvas.style.top = e.clientY + 15 + "px";
    }

    _onMouseLeave() {
      this.leaveTimeout = setTimeout(() => {
        this.close();
      }, 500);
    }

    _onEndframe() {
      this._ctx.clearRect(0, 0, this._size, this._size);

      this._ctx.drawImage(
        this._origCanvas,
        this._x - this._origPixels2,
        this._y - this._origPixels2,
        this._origPixels,
        this._origPixels,
        0,
        0,
        this._size,
        this._size,
      );

      this._ctx.strokeStyle = "white";
      this._ctx.beginPath();
      this._ctx.rect(
        (this._origPixels2 - 1) * this._scale + 1,
        (this._origPixels2 - 1) * this._scale + 1,
        this._scale,
        this._scale,
      );
      this._ctx.stroke();

      this._color = this._ctx.getImageData(
        (this._origPixels2 - 1) * this._scale + 3,
        (this._origPixels2 - 1) * this._scale + 3,
        1,
        1,
      ).data;
      this._hex = this.rgbToHex(this._color[0], this._color[1], this._color[2]);

      this._ctx.font = "14px monospace";

      this._ctx.fillStyle = "#000000";
      this._ctx.fillText("#" + this._hex, 5, this._size - 10);
      this._ctx.fillStyle = "#FFFFFF";
      this._ctx.fillText("#" + this._hex, 5 + 1, this._size - 10 + 1);
    }

    close() {
      Gui$1.gui.corePatch().cgl.off(this._endFrameListenerId);
      this._origCanvas.removeEventListener("mousemove", this._moveListener);
      this._origCanvas.removeEventListener("mouseleave", this._moveLeaveListener);
      document.removeEventListener("copy", this._copyListener);

      this._lensCanvas.remove();
    }

    rgbToHex(R, G, B) {
      return this._toHex(R) + this._toHex(G) + this._toHex(B);
    }

    _toHex(n) {
      n = parseInt(n, 10);
      if (isNaN(n)) return "00";
      n = Math.max(0, Math.min(n, 255));
      return (
        "0123456789ABCDEF".charAt((n - (n % 16)) / 16) +
        "0123456789ABCDEF".charAt(n % 16)
      );
    }
  }

  const CABLES_CMD_RENDERER = {};

  const rendererCommands = {
    commands: [],
    functions: CABLES_CMD_RENDERER,
  };

  CABLES_CMD_RENDERER.screenshot = function () {
    Gui$1.gui.canvasManager.currentContext().saveScreenshot();
    Gui$1.gui.corePatch().resume();
  };

  CABLES_CMD_RENDERER.maximizeCanvas = function () {
    Gui$1.gui.cycleFullscreen();
  };

  CABLES_CMD_RENDERER.resetSize = function () {
    Gui$1.gui.rendererWidth = 640;
    Gui$1.gui.rendererHeight = 360;
    Gui$1.gui.setLayout();
  };

  CABLES_CMD_RENDERER.canvasMagnifier = function () {
    Gui$1.gui.canvasMagnifier = new CanvasLens();
  };

  CABLES_CMD_RENDERER.scrollingPage = function () {
    if (ele.byId("testcontent").innerHTML == "") {
      document.body.classList.add("scrollPage");

      let str = "";
      for (let i = 0; i < 1000; i++) {
        str += "- long page...<br/>";
      }

      str +=
        '<div style="position:fixed;bottom:50px;z-index:99999;border-radius:10px;left:40%;cursor:pointer;background-color:#07F78C;color:#000;padding:20px;" class="button-small" onclick="CABLES.CMD.RENDERER.scrollingPage();">exit scrollmode<div>';
      ele.byId("testcontent").innerHTML = str;
    } else {
      document.body.scrollTo({ top: 0, behaviour: "smooth" });
      document.body.classList.remove("scrollPage");
      ele.byId("testcontent").innerHTML = "";
    }
  };

  CABLES_CMD_RENDERER.aspect = function (a = 0) {
    if (!a) {
      new ModalDialog({
        prompt: true,
        title: "Change Aspect Ratio of Renderer",
        text: "Enter an aspect ratio, e.g.: 16:9 or 0.22",
        promptValue: Gui$1.gui.corePatch().cgl.canvasScale,
        promptOk: (r) => {
          if (r.indexOf(":") >= 0) {
            const parts = r.split(":");
            const s = parseInt(parts[0]) / parseInt(parts[1]);
            CABLES_CMD_RENDERER.aspect(s);
          } else {
            const s = parseFloat(r);
            CABLES_CMD_RENDERER.aspect(s);
          }
        },
      });

      return;
    }
    const nh = (Gui$1.gui.rendererWidth * 1) / a;

    if (nh < window.innerHeight * 0.6) {
      Gui$1.gui.rendererHeight = nh;
    } else {
      Gui$1.gui.rendererHeight = window.innerHeight * 0.6;
      Gui$1.gui.rendererWidth = Gui$1.gui.rendererHeight * a;
    }

    Gui$1.gui.emitEvent(Gui$1.gui.EVENT_RESIZE_CANVAS);
    Gui$1.gui.setLayout();
    Gui$1.gui.canvasManager.getCanvasUiBar().updateCanvasIconBar();
  };

  CABLES_CMD_RENDERER.scaleCanvas = function () {
    new ModalDialog({
      prompt: true,
      title: "Change Scale of Renderer",
      text: "Enter a new scale",
      promptValue: Gui$1.gui.corePatch().cgl.canvasScale || 1,
      promptOk: (r) => {
        const s = parseFloat(r);
        Gui$1.gui.corePatch().cgl.canvasScale = s;
        Gui$1.gui.setLayout();
      },
    });
  };

  CABLES_CMD_RENDERER.changeSize = function () {
    let str = "Enter a new size:";

    if (Gui$1.gui.canvasManager.getCanvasUiBar())
      Gui$1.gui.canvasManager.getCanvasUiBar().showCanvasModal(false);

    new ModalDialog({
      prompt: true,
      title: "Change Canvas size",
      text: str,
      promptValue:
        Math.round(Gui$1.gui.rendererWidth) +
        " x " +
        Math.round(Gui$1.gui.rendererHeight),
      promptOk: (r) => {
        const matches = r.match(/\d+/g);
        if (matches.length > 0) {
          Gui$1.gui.rendererWidth = matches[0];
          Gui$1.gui.rendererHeight = matches[1];
          Gui$1.gui.setLayout();
        }
      },
    });
  };

  CABLES_CMD_RENDERER.popoutCanvas = function () {
    Gui$1.gui.canvasManager.popOut();
  };

  rendererCommands.commands.push(
    {
      cmd: "save screenshot",
      category: "canvas",
      func: CABLES_CMD_RENDERER.screenshot,
      icon: "image",
    },
    {
      cmd: "maximize canvas",
      category: "canvas",
      func: CABLES_CMD_RENDERER.maximizeCanvas,
      icon: "canvas_max",
      infotext: "renderer_maximize",
    },
    {
      cmd: "change canvas size",
      category: "canvas",
      func: CABLES_CMD_RENDERER.changeSize,
      icon: "resize_canvas",
    },
    {
      cmd: "reset canvas size",
      category: "canvas",
      func: CABLES_CMD_RENDERER.resetSize,
      icon: "reset_render_size",
    },
    {
      cmd: "set canvas aspect ratio",
      category: "canvas",
      func: CABLES_CMD_RENDERER.aspect,
      icon: "canvas_max",
    },
    {
      cmd: "scale canvas",
      category: "canvas",
      func: CABLES_CMD_RENDERER.scaleCanvas,
      icon: "scale_canvas",
    },
    {
      cmd: "canvas magnifier",
      category: "canvas",
      func: CABLES_CMD_RENDERER.canvasMagnifier,
      icon: "picker",
    },
    {
      cmd: "canvas window",
      category: "canvas",
      func: CABLES_CMD_RENDERER.popoutCanvas,
      icon: "external",
    },
    {
      cmd: "Simulate Scrolling Page",
      category: "canvas",
      func: CABLES_CMD_RENDERER.scrollingPage,
    },
  );

  const CABLES_CMD_TIMELINE = {};

  const timelineCommands = {
    commands: [],
    functions: CABLES_CMD_TIMELINE,
  };

  CABLES_CMD_TIMELINE.TimelineCreateKeyAtCursor = function () {
    Gui$1.gui.glTimeline.createKeyAtCursor();
  };

  CABLES_CMD_TIMELINE.ListAnimatedPorts = function () {
    const panelid = CABLES.uuid();
    const ops = Gui$1.gui.corePatch().ops;
    const ports = [];

    for (let i = 0; i < ops.length; i++) {
      const inputs = ops[i].portsIn;
      for (let j = 0; j < inputs.length; j++)
        if (inputs[j].isAnimated()) ports.push(inputs[j]);
    }

    const htmlgen = new PortHtmlGenerator(panelid);

    let html = '<div class="panel params" ><table>';

    html += htmlgen.getHtmlInputPorts(ports);
    html += "</table></div>";
    const tab = new CABLES.UI.Tab("Animated Ports", {
      icon: "clock",
      infotext: "tab_timeline",
      padding: true,
      singleton: true,
    });
    Gui$1.gui.mainTabs.addTab(tab, true);
    tab.html(html);
    Gui$1.gui.maintabPanel.show(true);

    const paramsListener = new ParamsListener(panelid);
    paramsListener.init({ portsIn: ports });
  };

  CABLES_CMD_TIMELINE.TimelinePlay = function () {
    Gui$1.gui.corePatch().timer.play();
    Gui$1.gui.emitEvent(
      "timelineControl",
      "setPlay",
      true,
      Gui$1.gui.corePatch().timer.getTime(),
    );
  };

  CABLES_CMD_TIMELINE.setLength = function () {
    // Gui.gui.timeLine().setProjectLength();
  };

  CABLES_CMD_TIMELINE.TimelineForward = function () {
    Gui$1.gui.corePatch().timer.setTime(Gui$1.gui.corePatch().timer.getTime() + 2);
    Gui$1.gui.timeLine().view.centerCursor();
  };

  CABLES_CMD_TIMELINE.TimelineRewind = function () {
    Gui$1.gui.corePatch().timer.setTime(Gui$1.gui.corePatch().timer.getTime() - 2);
    Gui$1.gui.timeLine().view.centerCursor();
  };

  CABLES_CMD_TIMELINE.TimelineRewindStart = function () {
    Gui$1.gui.corePatch().timer.setTime(0);
    Gui$1.gui.timeLine().view.centerCursor();
  };

  CABLES_CMD_TIMELINE.TimelinePause = function () {
    Gui$1.gui.corePatch().timer.pause();
    Gui$1.gui.emitEvent(
      "timelineControl",
      "setPlay",
      false,
      Gui$1.gui.corePatch().timer.getTime(),
    );
  };

  CABLES_CMD_TIMELINE.togglePlay = function () {
    if (Gui$1.gui.corePatch().timer.isPlaying()) Gui$1.gui.corePatch().timer.pause();
    else Gui$1.gui.corePatch().timer.play();
  };

  CABLES_CMD_TIMELINE.openGlTimeline = function () {
    Gui$1.gui.glTimeLineTab = new GlTimelineTab(Gui$1.gui.bottomTabs);
  };

  CABLES_CMD_TIMELINE.toggleTimeline = function () {
    Gui$1.gui.toggleTimeline();
  };

  CABLES_CMD_TIMELINE.hideTimeline = function () {
    Gui$1.gui.hideTimeline();
  };

  CABLES_CMD_TIMELINE.showTimeline = function () {
    Gui$1.gui.showTiming();
  };

  timelineCommands.commands.push(
    {
      cmd: "toggle timeline",
      category: "ui",
      func: CABLES_CMD_TIMELINE.toggleTimeline,
      icon: "timeline",
    },
    {
      cmd: "show timeline",
      category: "ui",
      func: CABLES_CMD_TIMELINE.openGlTimeline,
      icon: "timeline",
    },
    {
      cmd: "hide timeline",
      category: "ui",
      func: CABLES_CMD_TIMELINE.hideTimeline,
      icon: "timeline",
    },
    {
      cmd: "timeline play",
      category: "ui",
      func: CABLES_CMD_TIMELINE.TimelinePlay,
      icon: "play",
    },
    {
      cmd: "timeline pause",
      category: "ui",
      func: CABLES_CMD_TIMELINE.TimelinePause,
      icon: "pause",
    },
    {
      cmd: "timeline rewind",
      category: "ui",
      func: CABLES_CMD_TIMELINE.TimelineRewind,
      icon: "rewind",
    },
    {
      cmd: "timeline forward",
      category: "ui",
      func: CABLES_CMD_TIMELINE.TimelineForward,
      icon: "fast-forward",
    },
    {
      cmd: "timeline rewind to 0",
      category: "ui",
      func: CABLES_CMD_TIMELINE.TimelineRewindStart,
      icon: "skip-back",
    },
    {
      cmd: "set timeline length",
      category: "timeline",
      func: CABLES_CMD_TIMELINE.setLength,
    },
    {
      cmd: "show all animated ports",
      category: "timeline",
      func: CABLES_CMD_TIMELINE.ListAnimatedPorts,
    },
    {
      cmd: "add new keyframe at cursor",
      category: "timeline",
      func: CABLES_CMD_TIMELINE.TimelineCreateKeyAtCursor,
    },
  );

  /**
   * tab panel to profile and analyze GPU performance
   *
   * @export
   * @class GpuProfiler
   */
  class GpuProfiler {
    constructor(tabs) {
      this._tab = new Tab("GPU Profiler", {
        icon: "pie-chart",
        singleton: true,
        infotext: "tab_profiler",
        padding: true,
      });
      tabs.addTab(this._tab, true);

      this.colors = [
        "#7AC4E0",
        "#D183BF",
        "#9091D6",
        "#FFC395",
        "#F0D165",
        "#63A8E8",
        "#CF5D9D",
        "#66C984",
        "#D66AA6",
        "#515151",
      ];
      this.intervalId = null;
      this.lastPortTriggers = 0;
      this._subTab = 0;
      this._foundPerfOp = false;

      const glQueryExt = gui
        .corePatch()
        .cgl.gl.getExtension("EXT_disjoint_timer_query_webgl2");
      if (glQueryExt) Gui$1.gui.corePatch().cgl.profileData.doProfileGlQuery = true;

      Gui$1.gui.corePatch().on("performance", this.update.bind(this));
      Gui$1.gui.corePatch().cgl.profileData.glQueryData = {};
      this.update();
    }

    update() {
      let html =
        '<div class="tabContentScrollContainer"><h2>GPU Shader and Mesh Drawcalls</h2>';

      if (!this._foundPerfOp) {
        const ops = gui
          .corePatch()
          .getOpsByObjName(defaultOps.defaultOpNames.performance);
        if (ops && ops.length > 0) {
          this._foundPerfOp = true;

          console.log("found perf op!!!!cxcsdcsd");
        } else {
          html +=
            '<div class="warning-error warning-error-level2">Error: Insert a performance op directly below mainloop to measure all performance related data!</div>';
        }
      }

      const glQueryData = Gui$1.gui.corePatch().cgl.profileData.glQueryData;

      if (glQueryData) {
        let arr = [];
        let allTimes = 0;

        for (let i in glQueryData) {
          arr.push(glQueryData[i]);
          allTimes += glQueryData[i].time || 0;
        }

        for (let i = 0; i < arr.length; i++) {
          arr[i].perc = arr[i].time / allTimes;
        }

        arr = arr.sort((a, b) => {
          return b.perc - a.perc;
        });

        let sum = 0;
        for (let i = 0; i < arr.length; i++) {
          sum += arr[i].time || 0;
        }
        html += "Sum: " + Math.round(sum * 1000) / 1000 + "ms<br/><br/>";
        html += '<div class="editor_spreadsheet">';
        html += '<table class="spreadsheet">';
        html += "<tr>";
        html += '<td class="colname">Milliseconds</td>';
        html += '<td class="colname">Percent</td>';
        html += '<td class="colname">ID</td>';
        html += '<td class="colname"></td>';
        html += "</tr>";

        for (let i = 0; i < arr.length; i++) {
          html += "<tr>";
          html +=
            "<td><span>" +
            Math.round((arr[i].time || 0) * 1000) / 1000 +
            "ms</span></td>";
          html +=
            "<td><span>" + Math.round((arr[i].perc || 0) * 100) + "%</span></td>";
          html += '<td><span class="nobreak">' + arr[i].id + "</span></td>";

          html += "<td>";
          if (arr[i].shaderOp)
            html +=
              "<a onclick=\"Gui.gui.patchView.focusOpAnim('" +
              arr[i].shaderOp +
              "');Gui.gui.patchView.centerSelectOp('" +
              arr[i].shaderOp +
              '\');" class="button" >shader</a></td>';
          if (arr[i].shaderOp)
            html +=
              "<a onclick=\"Gui.gui.patchView.focusOpAnim('" +
              arr[i].meshOp +
              "');Gui.gui.patchView.centerSelectOp('" +
              arr[i].meshOp +
              '\');" class="button" >mesh</a></td>';

          html += "</td>";
          html += "</tr>";
        }
        html += "</table>";
        html += "</div>";
        html += "</div>";
      }

      this._tab.html(html);
      setTimeout(() => {
        this.update();
      }, 500);
    }
  }

  /**
   * show user editor preferences, stored in {@link UserSettings}
   *
   * @export
   * @class Preferences
   */
  class Preferences {
    /**
     * @param {TabPanel} tabs
     */
    constructor(tabs) {
      this._tab = new Tab("Preferences", {
        icon: "settings",
        infotext: "tab_preferences",
        singleton: true,
      });
      tabs.addTab(this._tab, true);

      this.show();
    }

    setInputValue(name, value) {
      if (value === null) value = false;
      const elements = document.getElementsByClassName("valinput");
      for (let i = 0; i < elements.length; i++) {
        if (elements[i].dataset.setting == name) {
          elements[i].value = value;
          // if (elements[i].dataset.value == "" + value || (elements[i].dataset.value == "false" && !value)) elements[i].classList.add("switch-active");
          // else elements[i].classList.remove("switch-active");
        }
      }
    }

    setSwitchValue(name, value) {
      if (value === null) value = false;
      const elements = document.getElementsByClassName("prefswitch");

      for (let i = 0; i < elements.length; i++) {
        if (elements[i].dataset.setting == name) {
          if (
            elements[i].dataset.value == "" + value ||
            (elements[i].dataset.value == "false" && !value)
          )
            elements[i].classList.add("switch-active");
          else elements[i].classList.remove("switch-active");
        }
      }
    }

    updateValues() {
      this.setSwitchValue(
        "snapToGrid2",
        UserSettings.userSettings.get("snapToGrid2"),
      );
      this.setSwitchValue(
        "canvasMode",
        UserSettings.userSettings.get("canvasMode"),
      );

      this.setSwitchValue(
        "hideCanvasUi",
        UserSettings.userSettings.get("hideCanvasUi"),
      );
      this.setSwitchValue(
        "bgpreview",
        UserSettings.userSettings.get("bgpreview"),
      );

      this.setSwitchValue(
        "texpreviewTransparent",
        UserSettings.userSettings.get("texpreviewTransparent") || false,
      );
      this.setSwitchValue(
        "texpreviewMode",
        UserSettings.userSettings.get("texpreviewMode") || "",
      );

      this.setSwitchValue(
        "linetype",
        UserSettings.userSettings.get("linetype") || "curved",
      );
      this.setSwitchValue(
        "touchpadmode",
        UserSettings.userSettings.get("touchpadmode"),
      );
      this.setSwitchValue(
        "presentationmode",
        UserSettings.userSettings.get("presentationmode"),
      );
      this.setSwitchValue(
        "nobrowserWarning",
        UserSettings.userSettings.get("nobrowserWarning"),
      );
      this.setSwitchValue(
        "introCompleted",
        UserSettings.userSettings.get("introCompleted"),
      );
      this.setSwitchValue(
        "randomizePatchName",
        UserSettings.userSettings.get("randomizePatchName", true),
      );
      this.setSwitchValue(
        "showTipps",
        UserSettings.userSettings.get("showTipps"),
      );
      this.setSwitchValue(
        "showMinimap",
        UserSettings.userSettings.get("showMinimap"),
      );
      this.setSwitchValue(
        "hideSizeBar",
        UserSettings.userSettings.get("hideSizeBar"),
      );

      this.setSwitchValue(
        "helperMode",
        UserSettings.userSettings.get("helperMode"),
      );
      this.setSwitchValue("idlemode", UserSettings.userSettings.get("idlemode"));

      this.setInputValue(
        "wheelmultiplier",
        UserSettings.userSettings.get("wheelmultiplier") || 1,
      );
      this.setInputValue(
        "fontsize_ace",
        UserSettings.userSettings.get("fontsize_ace") || 12,
      );
      this.setSwitchValue(
        "wrapmode_ace",
        UserSettings.userSettings.get("wrapmode_ace") || false,
      );

      this.setSwitchValue(
        "quickLinkLongPress",
        UserSettings.userSettings.get("quickLinkLongPress"),
      );
      this.setSwitchValue(
        "quickLinkMiddleMouse",
        UserSettings.userSettings.get("quickLinkMiddleMouse"),
      );
      this.setSwitchValue(
        "doubleClickAction",
        UserSettings.userSettings.get("doubleClickAction"),
      );

      // this.setSwitchValue("forceWebGl1", UserSettings.userSettings.get("forceWebGl1"));
      this.setSwitchValue(
        "devinfos",
        UserSettings.userSettings.get("devinfos") || false,
      );

      this.setSwitchValue(
        "patch_button_scroll",
        UserSettings.userSettings.get("patch_button_scroll") || "2",
      );
      this.setSwitchValue(
        "patch_allowCableDrag",
        UserSettings.userSettings.get("patch_allowCableDrag") || false,
      );

      this.setSwitchValue(
        "miniopselect",
        UserSettings.userSettings.get("miniopselect"),
      );
      this.setSwitchValue(
        "glpatch_cursor",
        UserSettings.userSettings.get("glpatch_cursor"),
      );
      this.setSwitchValue(
        "noFadeOutCables",
        UserSettings.userSettings.get("noFadeOutCables"),
      );

      // this.setSwitchValue("glpatch_showboundings", UserSettings.userSettings.get("glpatch_showboundings") || false);

      this.setSwitchValue(
        "bgpattern",
        UserSettings.userSettings.get("bgpattern") || "bgPatternDark",
      );
      this.setSwitchValue(
        "fontSizeOff",
        UserSettings.userSettings.get("fontSizeOff") || 0,
      );

      this.setSwitchValue(
        "formatcode",
        UserSettings.userSettings.get("formatcode") || false,
      );
      this.setSwitchValue(
        "notlocalizeNumberformat",
        UserSettings.userSettings.get("notlocalizeNumberformat") || false,
      );

      this.setSwitchValue(
        "openlastproject",
        UserSettings.userSettings.get("openlastproject") || false,
      );
      this.setSwitchValue(
        "openfullscreen",
        UserSettings.userSettings.get("openfullscreen") || false,
      );
      this.setSwitchValue(
        "maximizerenderer",
        UserSettings.userSettings.get("maximizerenderer") || false,
      );

      this.setInputValue(
        "authorName",
        UserSettings.userSettings.get("authorName") || "",
      );
      this.setSwitchValue(
        "escape_closetabs",
        UserSettings.userSettings.get("escape_closetabs") || false,
      );

      this.setSwitchValue(
        "ace_keymode",
        UserSettings.userSettings.get("ace_keymode") || "",
      );

      if (platform.frontendOptions.selectableDownloadPath) {
        const currentValue = UserSettings.userSettings.get("downloadPath") || "";
        this.setInputValue("downloadPath", currentValue);
        const pathSelectEle = ele.byId("usersetting_downloadPath");
        if (pathSelectEle) {
          const valueEle = pathSelectEle.querySelector(".value");
          if (valueEle) valueEle.innerText = currentValue;
          pathSelectEle.addEventListener("click", () => {
            platform.talkerAPI.send(
              "selectDir",
              { dir: currentValue },
              (err, dirName) => {
                if (!err) {
                  UserSettings.userSettings.set("downloadPath", dirName);
                }
              },
            );
          });
        }
      }

      this.setSwitchValue(
        "patch_wheelmode",
        UserSettings.userSettings.get("patch_wheelmode") || "zoom",
      );
      this.setInputValue(
        "patch_panspeed",
        UserSettings.userSettings.get("patch_panspeed") || 0.25,
      );
      this.setInputValue(
        "keybind_escape",
        UserSettings.userSettings.get("keybind_escape") || "escape",
      );
    }

    show() {
      const html = getHandleBarHtml("tab_preferences", {
        user: Gui$1.gui.user,
        texts: text.preferences,
      });
      this._tab.html(html);
      this.updateValues();

      let elements = document.getElementsByClassName("prefswitch");
      for (let i = 0; i < elements.length; i++) {
        elements[i].addEventListener("click", (e) => {
          let v = e.target.dataset.value;

          if (v === "true") v = true;
          if (v === "false") v = false;

          UserSettings.userSettings.set(e.target.dataset.setting, v);
        });
      }

      elements = document.getElementsByClassName("valinput");
      for (let i = 0; i < elements.length; i++) {
        elements[i].addEventListener("input", (e) => {
          let v = e.target.value;
          if (e.target.classList.contains("numberinput")) v = parseFloat(v);
          if (v == v) UserSettings.userSettings.set(e.target.dataset.setting, v);
        });
      }

      ele.byId("resetPrefs").addEventListener("click", () => {
        UserSettings.userSettings.reset();
      });

      UserSettings.userSettings.on("change", () => {
        this.updateValues();
      });
    }
  }

  class WatchVarTab extends Events {
    constructor(tabs, patch) {
      super();
      this._tabs = tabs;
      this._patch = patch || Gui$1.gui.corePatch();

      this._varListeners = {};
      this._patchListeners = [
        this._patch.on("variablesChanged", this._html.bind(this)),
        this._patch.on("variableRename", this._html.bind(this)),
      ];

      this._tab = new CABLES.UI.Tab("Variables", {
        icon: "align-justify",
        infotext: "tab_watchvars",
        padding: true,
        singleton: "false",
      });

      this._tab.on("close", () => {
        for (let i = 0; i < this._patchListeners.length; i++)
          this._patch.off(this._patchListeners[i]);

        const vars = this._patch.getVars();
        for (const y in vars) vars[y].off(this._varListeners[vars[y].getName()]);
      });

      this._tabs.addTab(this._tab, true);
      Gui$1.gui.maintabPanel.show(true);

      this._id = "spread" + CABLES.uuid();
      this._tab.html("<div id='" + this._id + "'></div>");
      this._ele = document.getElementById(this._id);
      this._ele.classList.add("editor_spreadsheet");
      this._ele.classList.add("tabcontent-scroll");

      this._eleIconbar = ele.create("div");
      this._ele.appendChild(this._eleIconbar);

      this._eleInfo = ele.create("div");
      this._ele.appendChild(this._eleInfo);
      this._eleInfo.innerHTML =
        '<h2>Variables</h2><input id="varfilter" class="medium info" type="search"/><br/><br/>';

      this._eleTable = ele.create("table");
      this._ele.appendChild(this._eleTable);

      this._html();

      ele.byId("varfilter").addEventListener("input", this._html.bind(this));
      ele.byId("varfilter").focus();
    }

    _html() {
      this._eleTable.innerHTML = "";

      const vars = this._patch.getVars();
      const table = this._eleTable;
      const trHead = ele.create("tr");

      for (let x = 0; x < 3; x++) {
        const tdr = ele.create("td");
        if (x == 0) tdr.innerHTML = "name";
        if (x == 1) tdr.innerHTML = "value";
        if (x == 2) tdr.innerHTML = "type";
        tdr.classList.add("colname");
        trHead.appendChild(tdr);
      }
      table.appendChild(trHead);

      const filter = ele.byId("varfilter").value;

      for (let y in vars) {
        const theVar = vars[y];

        if (
          !filter ||
          y.indexOf(filter) > -1 ||
          String(theVar._v).indexOf(filter) > -1
        ) {
          const tr = ele.create("tr");
          table.appendChild(tr);

          const tdName = ele.create("td");
          tdName.innerHTML = "#" + y;
          tdName.classList.add("rownumleft");
          tr.appendChild(tdName);

          const tdVal = ele.create("td");
          tdVal.innerHTML = '<span id="var' + y + '">' + theVar._v + "</span>";
          tr.appendChild(tdVal);

          const tdType = ele.create("td");
          tdType.innerHTML = theVar.type;
          tdType.classList.add("rownumleft");
          tr.appendChild(tdType);

          this._varListeners[theVar.getName()] = theVar.on(
            "change",
            this._updateVar.bind(this),
          );
        }
      }
    }

    _updateVar(v, vrbl) {
      if (!vrbl) return console.warn("[varwatcher] no variable");
      const el = document.getElementById("var" + vrbl._name);

      if (!el) return console.warn("[varwatcher] var element not found!");
      el.innerHTML = v;
    }

    show() {}
  }

  class JobsTab extends Events {
    constructor(tabs) {
      super();
      this._tabs = tabs;

      this._tab = new Tab("Jobs", {
        icon: "list",
        infotext: "tab_logging",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);

      this._html();

      Gui$1.gui.corePatch().loading.on("finishedTask", this._html.bind(this));
      Gui$1.gui.corePatch().loading.on("addTask", this._html.bind(this));
      Gui$1.gui.corePatch().loading.on("startTask", this._html.bind(this));

      Gui$1.gui.jobs().on("taskAdd", this._html.bind(this));
      Gui$1.gui.jobs().on("taskFinish", this._html.bind(this));
    }

    _html() {
      let list = Gui$1.gui.corePatch().loading.getList();
      let jobs = Gui$1.gui.jobs().getList();

      for (let i = 0; i < jobs.length; i++) {
        jobs[i].name = jobs[i].name || jobs[i].title;
        jobs[i].type = jobs[i].type || "";
        jobs[i].finished = jobs[i].finished || false;
        list.push(jobs[i]);
      }

      list.sort((a, b) => {
        return b.timeStart - a.timeStart;
      });

      const html = getHandleBarHtml("tab_jobs", {
        user: Gui$1.gui.user,
        texts: text.preferences,
        list: list,
      });
      this._tab.html(html);
    }
  }

  /**
   *simple tab to just show html
   *
   * @export
   * @class HtmlTab
   * @extends {Events}
   */
  class HtmlTab extends Events {
    constructor(tabs, html, title, options = {}) {
      super();
      this._tabs = tabs || Gui$1.gui.mainTabs;

      this._tab = new Tab(title, {
        icon: options.icon || "list",
        infotext: "tab_logging",
        padding: true,
        singleton: true,
      });
      this._tabs.addTab(this._tab, true);
      Gui$1.gui.maintabPanel.show(true);

      this._tab.html(html);
    }
  }

  class Keypresenter {
    constructor() {
      this.counter = 0;
      this._lastTextElement = null;
      this._lastKeyEvent = 0;
      this._lastWheel = 0;
      this._lineCounter = 0;
      const body = document.getElementsByTagName("body")[0];
      const keypresenter = document.createElement("div");
      keypresenter.id = "keypresenter";
      body.appendChild(keypresenter);
      this._container = keypresenter;
    }

    addLine() {
      if (Date.now() - this._lastKeyEvent > 500) {
        const elId = "#kp-line" + this._lineCounter;
        setTimeout(function () {
          const el = document.querySelector(elId);
          if (el) el.remove();
        }, 2000);

        this._lineCounter++;

        const newEl = document.createElement("div");
        newEl.id = "kp-line" + this._lineCounter;
        newEl.classList.add("kp-line");
        this._container.appendChild(newEl);
      }
    }

    showAction(title) {
      const id = "kp-ele-" + this.counter;
      const actionEl = document.createElement("span");
      actionEl.id = id;
      actionEl.classList.add("kp-ele");
      actionEl.innerHTML = title;
      const line = document.getElementById("kp-line" + this._lineCounter);
      if (line) line.appendChild(actionEl);
      this.counter++;
      return id;
    }

    start() {
      setInterval(this.addLine.bind(this), 250);

      document.addEventListener(
        "keydown",
        function (e) {
          let str = e.key;
          if (e.key.length === 1) {
            if (e.key === " ") str = "_";
            if (str) {
              str = str.toUpperCase();
              if (
                this._lastTextElement !== null &&
                Date.now() - this._lastKeyEvent < 300
              ) {
                str = this._lastTextElement.innerHTML + str;
                this._lastTextElement.remove();
              }

              const id = this.showAction(str);
              this._lastTextElement = document.getElementById(id);
            }
          } else {
            str = "[" + e.key + "]";
            if (e.key === "ArrowUp")
              str = '<span class="icon icon-arrow-up"></span>';
            if (e.key === "ArrowDown")
              str = '<span class="icon icon-arrow-down"></span>';
            if (e.key === "ArrowLeft")
              str = '<span class="icon icon-arrow-left"></span>';
            if (e.key === "ArrowRight")
              str = '<span class="icon icon-arrow-right"></span>';
            if (e.key === "Enter")
              str = '<span class="icon icon-corner-down-left"></span>';
            if (e.key === "Meta") str = '<span class="icon icon-command"></span>';
            this.showAction(str);
            this._lastTextElement = null;
          }

          this._lastKeyEvent = Date.now();
        }.bind(this),
      );

      document.addEventListener("mousedown", (e) => {
        let which = "left";
        if (e.buttons == 4) which = "middle";
        if (e.buttons == 2) which = "right";
        this.showAction("[click " + which + "]");
        this._lastKeyEvent = Date.now();
      });

      document.addEventListener("wheel", () => {
        if (Date.now() - this._lastWheel > 1000) {
          this.showAction("[mousewheel]");
          this._lastWheel = Date.now();
        }
      });
    }
  }

  /**
   * tips and tricks dialog with animated tips
   *
   * @export
   * @class Tips
   */
  class Tips {
    constructor() {
      this._index = 0;
      this._wasShown = false;
      this._index = Math.round(text.tips.length * Math.random());
    }

    next() {
      this._index++;
      this.show();
    }

    neverShow() {
      UserSettings.userSettings.set("showTipps", false);
      this.show();
    }

    showAlways() {
      UserSettings.userSettings.set("showTipps", true);
      this.show();
    }

    show() {
      if (this._index >= text.tips.length) this._index = 0;
      let html = ""; // '<h2>Tipps</h2>';

      const tip = text.tips[this._index];

      html += "<div>";
      html += "</div>";

      html += '<div class="tip">';
      html +=
        '  <div style="width:320px;max-height:300px;padding:20px;float:left">';
      html +=
        '    <img style="max-width:300px;min-height:273px;max-height:273px;align:left;" src="https://cables.gl/docs/0_howtouse/ui_walkthrough/video/' +
        tip.img +
        '" />';
      html += "  </div>";
      html += '  <div style="width:320px;float:left;">';
      html += "    <h3>" + (tip.title || "Did you know...") + "</h3>";
      html += marked.parse(tip.descr);
      // html += '    <br/>';
      html += "    " + (this._index + 1) + "/" + text.tips.length;
      html += "  </div>";
      html += '<div style="clear:both;"></div>';
      html += "</div>";

      html += '<div style="clear:both;padding:20px;">';
      html += '  <a id="modalClose" class="bluebutton">Close</a>';
      html += '  <a id="tips_next" class="button">Next tip</a>';

      html += '  <div style="float:right;">';
      if (UserSettings.userSettings.get("showTipps"))
        html +=
          '<a id="tips_showNever" class="button-small">Do not show this on startup</a>';
      else
        html +=
          '<a id="tips_showAlways" class="button-small">Show on startup again</a>';
      html += '  </div">';

      html += "</div>";

      new ModalDialog({ html: html, nopadding: true });

      ele.clickable(ele.byId("tips_next"), () => {
        this.next();
      });

      ele.clickable(ele.byId("tips_showAlways"), () => {
        this.showAlways();
      });

      ele.clickable(ele.byId("tips_showNever"), () => {
        this.neverShow();
      });
    }

    showOnce() {
      if (this._wasShown) return;
      this._wasShown = true;
      this.show();
    }
  }

  const CABLES_CMD_UI = {};
  const CMD_UI_COMMANDS = [];

  const uiCommands = {
    commands: CMD_UI_COMMANDS,
    functions: CABLES_CMD_UI,
  };

  CABLES_CMD_UI.settings = function () {
    if (Gui$1.gui.showGuestWarning()) return;
    Gui$1.gui.showSettings();
  };

  CABLES_CMD_UI.showTips = function () {
    this.tips = new Tips();
    this.tips.show();
  };

  CABLES_CMD_UI.canvasLens = function () {
    new CanvasLens();
  };

  CABLES_CMD_UI.activityFeed = function () {
    const url = platform.getCablesUrl() + "/myactivityfeed";
    Gui$1.gui.mainTabs.addIframeTab(
      "Activity Feed",
      url + "?iframe=true",
      { icon: "activity", closable: true, singleton: true, gotoUrl: url },
      true,
    );
  };

  CABLES_CMD_UI.closeAllTabs = function () {
    Gui$1.gui.mainTabs.closeAllTabs();
  };

  CABLES_CMD_UI.openRemoteViewer = function () {
    let projectId = Gui$1.gui.patchId;
    if (Gui$1.gui.project()) {
      projectId = Gui$1.gui.project().shortId || Gui$1.gui.project()._id;
    }
    if (Gui$1.gui.socket)
      Gui$1.gui.socket.startRemoteViewer(() => {
        window.open(platform.getCablesUrl() + "/remote_client/" + projectId);
      });
  };

  CABLES_CMD_UI.files = function () {
    Gui$1.gui.showFileManager(null, true);
  };

  CABLES_CMD_UI.toggleFiles = function () {
    Gui$1.gui.showFileManager(null, true);
  };

  CABLES_CMD_UI.windowFullscreen = function () {
    if (document.documentElement.mozRequestFullScreen)
      document.documentElement.mozRequestFullScreen();
    if (document.documentElement.webkitRequestFullScreen)
      document.documentElement.webkitRequestFullScreen();
  };

  CABLES_CMD_UI.toggleMute = function () {
    if (Gui$1.gui.corePatch().config.masterVolume > 0.0) {
      document.getElementById("timelineVolume").classList.remove("icon-volume-2");
      document.getElementById("timelineVolume").classList.add("icon-volume-x");
      Gui$1.gui.corePatch().setVolume(0.0);
    } else {
      document.getElementById("timelineVolume").classList.add("icon-volume-2");
      document.getElementById("timelineVolume").classList.remove("icon-volume-x");
      Gui$1.gui.corePatch().setVolume(1.0);
    }
  };

  CABLES_CMD_UI.showChat = function () {
    if (Gui$1.gui.socket) Gui$1.gui.socket.showChat();
  };

  CABLES_CMD_UI.toggleBgTexturePreview = function () {
    UserSettings.userSettings.set(
      "bgpreview",
      !UserSettings.userSettings.get("bgpreview"),
    );
  };

  CABLES_CMD_UI.hideMinimap = function () {
    UserSettings.userSettings.set("showMinimap", false);
    Gui$1.gui.hideMiniMap();
  };

  CABLES_CMD_UI.toggleMinimap = function () {
    UserSettings.userSettings.set(
      "showMinimap",
      !UserSettings.userSettings.get("showMinimap"),
    );
    if (UserSettings.userSettings.get("showMinimap")) CABLES.CMD.PATCH.reload();
    else CABLES_CMD_UI.hideMinimap();
  };

  CABLES_CMD_UI.showSearch = function (str) {
    Gui$1.gui.find(str || "");
  };

  CABLES_CMD_UI.toggleMaxRenderer = function () {
    Gui$1.gui.cycleFullscreen();
  };

  CABLES_CMD_UI.togglePatchBgPatchField = function () {
    if (
      gui &&
      Gui$1.gui.canvasManager.mode === Gui$1.gui.canvasManager.CANVASMODE_PATCHBG
    ) {
      Gui$1.gui.patchView.toggleVisibility();
    }
  };

  CABLES_CMD_UI.togglePatchBgRenderer = function () {
    Gui$1.gui.cyclePatchBg();
  };

  CABLES_CMD_UI.showKeys = function () {
    Gui$1.gui.keys.show();
  };

  CABLES_CMD_UI.showCommandPallet = function () {
    Gui$1.gui.cmdPallet.show();
  };

  CABLES_CMD_UI.centerPatchOps = function () {
    Gui$1.gui.patchView.centerView();
  };

  CABLES_CMD_UI.flowVis = function () {
    UserSettings.userSettings.set(
      "glflowmode",
      !UserSettings.userSettings.get("glflowmode"),
    );
  };

  CABLES_CMD_UI.startPresentationMode = function () {
    if (!CABLES.UI.keyPresenter) {
      CABLES.UI.keyPresenter = new Keypresenter();
      CABLES.UI.keyPresenter.start();
    }
  };

  CABLES_CMD_UI.showChangelog = function (since) {
    new ChangelogToast().show(since);
  };

  CABLES_CMD_UI.showBuildInfo = function () {
    let infoHtml = "no info available";
    if (CABLESUILOADER.buildInfo) {
      infoHtml = "";
      const uiBuild = CABLESUILOADER.buildInfo.ui;
      const coreBuild = CABLESUILOADER.buildInfo.core;
      const apiBuild = CABLESUILOADER.buildInfo.api;

      if (coreBuild) {
        infoHtml += "<h3>Core</h3>";
        infoHtml +=
          "created: " +
          moment(coreBuild.created).fromNow() +
          " (" +
          coreBuild.created +
          ")<br/>";
        if (coreBuild.git) {
          infoHtml += "branch: " + coreBuild.git.branch + "<br/>";
          infoHtml += "message: " + coreBuild.git.message + "<br/>";
        }
      }

      if (uiBuild) {
        infoHtml += "<h3>UI</h3>";
        infoHtml +=
          "created: " +
          moment(uiBuild.created).fromNow() +
          " (" +
          uiBuild.created +
          ")<br/>";
        if (uiBuild.git) {
          infoHtml += "branch: " + uiBuild.git.branch + "<br/>";
          infoHtml += "message: " + uiBuild.git.message + "<br/>";
        }
      }

      if (apiBuild) {
        infoHtml += "<h3>Platform</h3>";
        infoHtml +=
          "created: " +
          moment(apiBuild.created).fromNow() +
          " (" +
          apiBuild.created +
          ")<br/>";
        if (apiBuild.git) {
          infoHtml += "branch: " + apiBuild.git.branch + "<br/>";
          infoHtml += "message: " + apiBuild.git.message + "<br/>";
          if (apiBuild.version)
            infoHtml += "version: " + apiBuild.version + "<br/>";
          if (apiBuild.git.tag) infoHtml += "tag: " + apiBuild.git.tag + "<br/>";
        }
        if (apiBuild.platform) {
          if (apiBuild.platform.node)
            infoHtml += "node: " + apiBuild.platform.node + "<br/>";
          if (apiBuild.platform.npm)
            infoHtml += "npm: " + apiBuild.platform.npm + "<br/>";
        }
      }
    }

    new HtmlTab(Gui$1.gui.mainTabs, infoHtml);
  };

  CABLES_CMD_UI.welcomeTab = function (userInteraction) {
    platform.talkerAPI.send("getRecentPatches", {}, (err, r) => {
      const t = new WelcomeTab(Gui$1.gui.mainTabs, { patches: r });
      Gui$1.gui.mainTabs.activateTab(t.id);
      Gui$1.gui.maintabPanel.show(userInteraction);
    });
  };

  CABLES_CMD_UI.toggleOverlays = function () {
    const act = !UserSettings.userSettings.get("overlaysShow");
    UserSettings.userSettings.set("overlaysShow", act);
    Gui$1.gui.emitEvent("overlaysChanged", act);
    Gui$1.gui.transformOverlay.updateVisibility();
    Gui$1.gui.canvasManager.getCanvasUiBar().updateIconState();
  };

  CABLES_CMD_UI.toggleSnapToGrid = function () {
    UserSettings.userSettings.set(
      "snapToGrid",
      !UserSettings.userSettings.get("snapToGrid2"),
    );
  };

  CABLES_CMD_UI.toggleIntroCompleted = function () {
    UserSettings.userSettings.set(
      "introCompleted",
      !UserSettings.userSettings.get("introCompleted"),
    );

    if (!UserSettings.userSettings.get("introCompleted"))
      Gui$1.gui.introduction.showIntroduction();
  };

  CABLES_CMD_UI.showAutomaton = function () {
    new CABLES.UI.AutomatonTab(Gui$1.gui.mainTabs);
  };

  CABLES_CMD_UI.showPreferences = function () {
    if (Gui$1.gui.showGuestWarning()) return;
    new Preferences(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_UI.profileGPU = function () {
    new GpuProfiler(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_UI.profileUI = function () {
    Gui$1.gui.uiProfiler.show();
  };

  CABLES_CMD_UI.zoomOut = function () {
    Gui$1.gui.patchView.zoomStep(1);
  };
  CABLES_CMD_UI.zoomIn = function () {
    Gui$1.gui.patchView.zoomStep(-1);
  };

  CABLES_CMD_UI.watchVars = function () {
    new WatchVarTab(Gui$1.gui.mainTabs);
  };

  CABLES_CMD_UI.jobs = function () {
    new JobsTab(Gui$1.gui.mainTabs);
    Gui$1.gui.maintabPanel.show(true);
  };

  CABLES_CMD_UI.togglePauseVizLayer = function () {
    UserSettings.userSettings.set(
      "vizlayerpaused",
      !UserSettings.userSettings.get("vizlayerpaused"),
    );
  };

  CMD_UI_COMMANDS.push(
    {
      cmd: "Show settings",
      category: "ui",
      func: CABLES_CMD_UI.settings,
      icon: "settings",
      infotext: "cmd_patchsettings",
    },
    {
      cmd: "Show files",
      category: "ui",
      func: CABLES_CMD_UI.files,
      icon: "file",
    },
    {
      cmd: "Toggle files",
      category: "ui",
      func: CABLES_CMD_UI.toggleFiles,
      icon: "file",
    },
    {
      cmd: "Toggle mute",
      category: "ui",
      func: CABLES_CMD_UI.toggleMute,
    },
    {
      cmd: "Search",
      category: "ui",
      func: CABLES_CMD_UI.showSearch,
      icon: "search",
      hotkey: "CMD + f",
    },
    {
      cmd: "Maximize renderer",
      category: "ui",
      func: CABLES_CMD_UI.toggleMaxRenderer,
      icon: "canvas_max",
      hotkey: "CMD + ENTER",
    },
    {
      cmd: "Patch background renderer",
      category: "ui",
      func: CABLES_CMD_UI.togglePatchBgRenderer,
      icon: "canvas_patchbg",
      hotkey: "CMD + SHIFT + ENTER",
    },
    {
      cmd: "Patch background renderer",
      category: "ui",
      func: CABLES_CMD_UI.togglePatchBgPatchField,
      icon: "canvas_op",
      hotkey: "SHIFT + ENTER",
    },
    {
      cmd: "Show command pallet",
      category: "ui",
      func: CABLES_CMD_UI.showCommandPallet,
      icon: "search",
      hotkey: "CMD + P",
    },
    {
      cmd: "Show changelog",
      category: "cables",
      func: CABLES_CMD_UI.showChangelog,
      icon: "info",
    },
    {
      cmd: "Show buildinfo",
      category: "cables",
      func: CABLES_CMD_UI.showBuildInfo,
      icon: "info",
    },
    {
      cmd: "Center patch",
      category: "patch",
      func: CABLES_CMD_UI.centerPatchOps,
      hotkey: "c",
      icon: "patch_center",
      infotext: "cmd_centerpatch",
    },
    {
      cmd: "Start presentation mode",
      category: "ui",
      func: CABLES_CMD_UI.startPresentationMode,
    },
    {
      cmd: "Toggle flow visualization",
      category: "ui",
      func: CABLES_CMD_UI.flowVis,
      icon: "cables",
      hotkey: "f",
    },
    {
      cmd: "Jobs",
      category: "ui",
      func: CABLES_CMD_UI.jobs,
      icon: "cables",
    },
    {
      cmd: "Toggle window fullscreen",
      category: "ui",
      func: CABLES_CMD_UI.windowFullscreen,
      icon: "cables",
    },

    {
      cmd: "Toggle snap to grid",
      category: "ui",
      func: CABLES_CMD_UI.toggleSnapToGrid,
      icon: "command",
    },
    {
      cmd: "Toggle texture preview",
      category: "ui",
      func: CABLES_CMD_UI.toggleBgTexturePreview,
      icon: "monitor",
    },
    {
      cmd: "Ui profiler",
      category: "ui",
      func: CABLES_CMD_UI.profileUI,
      icon: "command",
    },
    {
      cmd: "Preferences",
      category: "ui",
      func: CABLES_CMD_UI.showPreferences,
      icon: "cables_editor",
    },
    {
      cmd: "Chat",
      category: "ui",
      func: CABLES_CMD_UI.showChat,
      icon: "command",
      frontendOption: "hasCommunity",
    },
    {
      cmd: "Open remote viewer",
      category: "ui",
      func: CABLES_CMD_UI.openRemoteViewer,
      icon: "command",
      frontendOption: "showRemoteViewer",
    },
    {
      cmd: "Zoom in",
      category: "ui",
      func: CABLES_CMD_UI.zoomIn,
      icon: "plus",
      hotkey: "+",
      infotext: "cmd_zoomin",
    },
    {
      cmd: "Zoom out",
      category: "ui",
      func: CABLES_CMD_UI.zoomOut,
      icon: "minus",
      hotkey: "-",
      infotext: "cmd_zoomout",
    },
    {
      cmd: "Watch variables",
      category: "ui",
      func: CABLES_CMD_UI.watchVars,
      icon: "align-justify",
      infotext: "cmd_watchvars",
    },
    {
      cmd: "GPU Profiler",
      category: "ui",
      func: CABLES_CMD_UI.profileGPU,
      icon: "align-justify",
      infotext: "",
    },
    {
      cmd: "Toggle Vizlayer Pause",
      category: "ui",
      func: CABLES_CMD_UI.togglePauseVizLayer,
      infotext: "",
    },
    {
      cmd: "Show Activity Feed",
      category: "ui",
      func: CABLES_CMD_UI.activityFeed,
      icon: "activity",
      frontendOption: "hasCommunity",
    },
    {
      cmd: "Show Welcome",
      category: "ui",
      func: CABLES_CMD_UI.welcomeTab,
      icon: "cables",
    },
    {
      cmd: "Close all tabs",
      category: "ui",
      func: CABLES_CMD_UI.closeAllTabs,
    },
    {
      cmd: "Show Canvas Lens",
      category: "ui",
      func: CABLES_CMD_UI.canvasLens,
    },
    {
      cmd: "Show Tips",
      category: "ui",
      func: CABLES_CMD_UI.showTips,
    },
  );

  const CABLES_CMD_FILES = {};
  const CMD_FILE_COMMANDS = [];

  const fileCommands = {
    commands: CMD_FILE_COMMANDS,
    functions: CABLES_CMD_FILES,
  };

  CABLES_CMD_FILES.replaceFilePath = function (from = null, to = null) {
    new ModalDialog({
      prompt: true,
      title: "Replace String Values",
      text: "Search for...",
      promptValue: from || "/assets/",
      promptOk: (search) => {
        new ModalDialog({
          prompt: true,
          title: "Replace String Values",
          text: "...replace with",
          promptValue: to || "/assets/" + Gui$1.gui.project()._id,
          promptOk: (replace) => {
            Gui$1.gui.fileManager.replaceAssetPorts(search, replace);
          },
        });
      },
    });
  };

  CMD_FILE_COMMANDS.push({
    cmd: "Replace file path",
    category: "patch",
    func: CABLES_CMD_FILES.replaceFilePath,
  });

  const CMD = {};
  let commands = [];

  commands = commands.concat(debugCommands.commands);
  commands = commands.concat(patchCommands.commands);
  commands = commands.concat(rendererCommands.commands);
  commands = commands.concat(timelineCommands.commands);
  commands = commands.concat(uiCommands.commands);
  commands = commands.concat(opCommands.commands);
  commands = commands.concat(fileCommands.commands);

  CMD.DEBUG = debugCommands.functions;
  CMD.PATCH = patchCommands.functions;
  CMD.OP = opCommands.functions;
  CMD.RENDERER = rendererCommands.functions;
  CMD.TIMELINE = timelineCommands.functions;
  CMD.UI = uiCommands.functions;
  CMD.FILES = fileCommands.functions;

  CMD.commands = commands;

  for (let i = 0; i < commands.length; i++) {
    if (!commands[i].category)
      console.warn("cmd has no category ", commands[i].cmd);
  }

  CMD.exec = function (cmd) {
    let found = false;
    for (let i = 0; i < CMD.commands.length; i++) {
      if (CMD.commands[i].cmd == cmd) {
        if (CMD.commands[i].func) {
          CMD.commands[i].func();
          found = true;
        } else {
          console.warn("cmd has no func", cmd, CMD.commands[i]);
        }
      }
    }

    if (!found) console.warn("command not found:" + cmd);
  };

  var overlayShaderVert = `{{MODULES_HEAD}}
IN vec3 vPosition; //!@
IN vec2 attrTexCoord;
IN vec3 attrVertNormal;
IN vec3 attrTangent,attrBiTangent;

IN float attrVertIndex;

OUT vec2 texCoord;
OUT vec3 norm;
UNI mat4 projMatrix;
UNI mat4 viewMatrix;
UNI mat4 modelMatrix;

void main()
{
    texCoord=attrTexCoord;
    norm=attrVertNormal;
    vec4 pos=vec4(vPosition,  1.0);
    vec3 tangent=attrTangent;
    vec3 bitangent=attrBiTangent;
    mat4 mMatrix=modelMatrix;
    gl_PointSize=10.0;

    {{MODULE_VERTEX_POSITION}}

    mat4 modelViewMatrix=viewMatrix*mMatrix;
    {{MODULE_VERTEX_MODELVIEW}}



    #ifdef BILLBOARD
        modelViewMatrix[0][0] = mMatrix[0][0];
        modelViewMatrix[0][1] = 0.0;
        modelViewMatrix[0][2] = 0.0;

        modelViewMatrix[1][0] = 0.0;
        modelViewMatrix[1][1] = mMatrix[1][1];
        modelViewMatrix[1][2] = 0.0;

        modelViewMatrix[2][0] = 0.0;
        modelViewMatrix[2][1] = 0.0;
        modelViewMatrix[2][2] = mMatrix[2][2];
    #endif


    gl_Position = projMatrix * modelViewMatrix * pos;
}
`;

  const helperMeshes = {};
  helperMeshes.count = 0;

  helperMeshes.startFramebuffer = function (cgl) {
    if (!helperMeshes.FB || !helperMeshes.FB.fb) {
      helperMeshes.FB = {};

      if (cgl.glVersion == 1) {
        helperMeshes.FB.fb = new CGL.Framebuffer(cgl, 8, 8, {
          isFloatingPointTexture: false,
          depth: true,
          clear: false,
        });
      } else {
        helperMeshes.FB.fb = new CGL.Framebuffer2(cgl, 8, 8, {
          isFloatingPointTexture: false,
          depth: true,
          clear: false,
          multisampling: true,
          multisamplingSamples: 4,
        });
      }
    }

    if (
      helperMeshes.FB.oldWidth != cgl.getViewPort()[2] ||
      helperMeshes.FB.oldHeight != cgl.getViewPort()[3]
    ) {
      helperMeshes.FB.fb.setSize(cgl.getViewPort()[2], cgl.getViewPort()[3]);
      helperMeshes.FB.oldWidth = cgl.getViewPort()[2];
      helperMeshes.FB.oldHeight = cgl.getViewPort()[3];
    }

    helperMeshes.FB.fb.renderStart(cgl);

    if (cgl.frameCycler != helperMeshes.FB.oldFrameCycle) {
      cgl.gl.clearColor(0, 0, 0, 0);
      cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
      helperMeshes.FB.oldFrameCycle = cgl.frameCycler;
    }
  };

  helperMeshes.endFramebuffer = function (cgl) {
    helperMeshes.FB.fb.renderEnd();
  };

  helperMeshes.getDefaultShader = function (cgl, options = {}) {
    let name = "defaultShader";

    if (options.billboarded) name = "defaultShaderBillboard";

    if (!helperMeshes[name]) {
      helperMeshes[name] = new CGL.Shader(cgl, "marker shader");
      helperMeshes[name].setSource(
        overlayShaderVert,
        CGL.Shader.getDefaultFragmentShader(0.6, 0.6, 0.6),
      );
      if (options.billboarded) helperMeshes[name].toggleDefine("BILLBOARD", true);
    }
    return helperMeshes[name];
  };

  helperMeshes.getSelectedShader = function (cgl, options = {}) {
    let name = "selectedShader";

    if (options.billboarded) name = "selectedShaderBillboard";

    if (!helperMeshes[name]) {
      helperMeshes[name] = new CGL.Shader(cgl, "marker shader");
      helperMeshes[name].setSource(
        overlayShaderVert,
        CGL.Shader.getDefaultFragmentShader(0, 1, 1),
      );
      if (options.billboarded) helperMeshes[name].toggleDefine("BILLBOARD", true);
    }
    return helperMeshes[name];
  };

  helperMeshes.drawCircle = function (op, size) {
    const cgl = op.patch.cgl;

    if (!helperMeshes.CIRCLE) {
      helperMeshes.CIRCLE = {};

      helperMeshes.CIRCLE.vScale = create$4();
      function bufferData() {
        let verts = [];
        let tc = [];
        const segments = 80;
        let degInRad = 0;
        const radius = 1;

        for (let i = 0; i <= Math.round(segments); i++) {
          degInRad = (360.0 / Math.round(segments)) * i * CGL.DEG2RAD;
          verts.push(Math.cos(degInRad) * radius, Math.sin(degInRad) * radius, 0);
          tc.push(0, 0);
        }

        let geom = new CGL.Geometry("sphere marker");
        geom.setPointVertices(verts);
        geom.setTexCoords(tc);
        geom.vertexNormals = verts.slice();
        helperMeshes.CIRCLE.mesh = new CGL.Mesh(cgl, geom);
      }

      bufferData();
    }

    if (cgl.lastMesh) cgl.lastMesh.unBind();

    cgl.pushModelMatrix();
    helperMeshes.startFramebuffer(cgl);

    set$4(helperMeshes.CIRCLE.vScale, size, size, size);
    scale$5(cgl.mvMatrix, cgl.mvMatrix, helperMeshes.CIRCLE.vScale);

    let shader = helperMeshes.getDefaultShader(cgl, { billboarded: true });

    if (Gui$1.gui.patchView.isCurrentOp(op))
      shader = helperMeshes.getSelectedShader(cgl, { billboarded: true });
    shader.glPrimitive = cgl.gl.LINE_STRIP;

    helperMeshes.CIRCLE.mesh.render(shader);
    helperMeshes.count++;
    cgl.popModelMatrix();
    helperMeshes.endFramebuffer(cgl);
  };

  helperMeshes.drawSphere = function (op, size) {
    const cgl = op.patch.cgl;

    if (!helperMeshes.SPHERE) {
      helperMeshes.SPHERE = {};

      helperMeshes.SPHERE.vScale = create$4();
      function bufferData() {
        let verts = [];
        let tc = [];
        const segments = 80;
        let i = 0,
          degInRad = 0;
        const radius = 1;

        for (i = 0; i <= Math.round(segments); i++) {
          degInRad = (360.0 / Math.round(segments)) * i * CGL.DEG2RAD;
          verts.push(Math.cos(degInRad) * radius);
          verts.push(0);
          verts.push(Math.sin(degInRad) * radius);
          tc.push(0, 0);
        }

        const geom = new CGL.Geometry("sphere marker");
        geom.setPointVertices(verts);
        geom.setTexCoords(tc);
        geom.vertexNormals = verts.slice();

        //---

        verts = [];
        tc = [];
        for (i = 0; i <= Math.round(segments); i++) {
          degInRad = (360.0 / Math.round(segments)) * i * CGL.DEG2RAD;
          verts.push(Math.cos(degInRad) * radius);
          verts.push(Math.sin(degInRad) * radius);
          verts.push(0);
          tc.push(0, 0);
        }

        const geom2 = new CGL.Geometry("sphere marker");
        geom2.setPointVertices(verts);
        geom2.setTexCoords(tc);
        geom2.vertexNormals = verts.slice();

        //---

        verts = [];
        tc = [];
        for (i = 0; i <= Math.round(segments); i++) {
          degInRad = (360.0 / Math.round(segments)) * i * CGL.DEG2RAD;
          verts.push(0);
          verts.push(Math.cos(degInRad) * radius);
          verts.push(Math.sin(degInRad) * radius);
          tc.push(0, 0);
        }

        const geom3 = new CGL.Geometry("sphere marker");
        geom3.setPointVertices(verts);
        geom3.setTexCoords(tc);
        geom3.vertexNormals = verts.slice();

        geom.merge(geom2);
        geom.merge(geom3);
        helperMeshes.SPHERE.mesh = new CGL.Mesh(cgl, geom);
      }

      bufferData();
    }

    if (cgl.lastMesh) cgl.lastMesh.unBind();

    cgl.pushModelMatrix();
    helperMeshes.startFramebuffer(cgl);

    set$4(helperMeshes.SPHERE.vScale, size, size, size);
    scale$5(cgl.mvMatrix, cgl.mvMatrix, helperMeshes.SPHERE.vScale);

    let shader = helperMeshes.getDefaultShader(cgl);
    if (Gui$1.gui.patchView.isCurrentOp(op))
      shader = helperMeshes.getSelectedShader(cgl);

    shader.glPrimitive = cgl.gl.LINE_STRIP;
    helperMeshes.SPHERE.mesh.render(shader);
    helperMeshes.count++;
    cgl.popModelMatrix();

    helperMeshes.endFramebuffer(cgl);
  };

  helperMeshes.drawAxisMarker = function (op, size) {
    const cgl = op.patch.cgl;

    if (!helperMeshes.MARKER) {
      helperMeshes.MARKER = {};

      const geom = new CGL.Geometry("marker");
      geom.setPointVertices([
        0.00001, 0, 0, 1, 0, 0, 0, 0.00001, 0, 0, 1, 0, 0, 0, 0.00001, 0, 0, 1,
      ]);
      // geom.resetTextureCoords();

      helperMeshes.MARKER.mesh = new CGL.Mesh(cgl, geom, {
        glPrimitive: cgl.gl.LINES,
      });
      helperMeshes.MARKER.mesh.setGeom(geom);

      const frag =
        "".endl() +
        "IN vec3 axisColor;".endl() +
        "void main()".endl() +
        "{".endl() +
        "    vec4 col=vec4(axisColor,1.0);".endl() +
        "    outColor = col;".endl() +
        "}";

      const vert =
        "".endl() +
        "IN vec3 vPosition;".endl() +
        "UNI mat4 projMatrix;".endl() +
        "UNI mat4 mvMatrix;".endl() +
        "OUT vec3 axisColor;".endl() +
        "void main()".endl() +
        "{".endl() +
        "   vec4 pos=vec4(vPosition, 1.0);".endl() +
        "   if(pos.x!=0.0)axisColor=vec3(1.0,0.3,0.0);".endl() +
        "   if(pos.y!=0.0)axisColor=vec3(0.0,1.0,0.2);".endl() +
        "   if(pos.z!=0.0)axisColor=vec3(0.0,0.5,1.0);".endl() +
        "   gl_Position = projMatrix * mvMatrix * pos;".endl() +
        "}";

      helperMeshes.MARKER.shader = new CGL.Shader(cgl, "markermaterial");
      helperMeshes.MARKER.shader.setSource(vert, frag);

      helperMeshes.MARKER.vScale = create$4();
    }

    helperMeshes.startFramebuffer(cgl);

    if (size === undefined) size = 2;
    cgl.pushModelMatrix();

    cgl.pushShader(helperMeshes.MARKER.shader);

    set$4(helperMeshes.MARKER.vScale, size, size, size);
    scale$5(cgl.mvMatrix, cgl.mvMatrix, helperMeshes.MARKER.vScale);

    cgl.pushDepthTest(false);

    helperMeshes.MARKER.mesh.render(cgl.getShader());

    helperMeshes.count++;
    cgl.popDepthTest();
    cgl.popShader();
    cgl.popModelMatrix();

    helperMeshes.endFramebuffer(cgl);
  };

  helperMeshes.drawLineSourceDest = function (
    op,
    sourceX,
    sourceY,
    sourceZ,
    destX,
    destY,
    destZ,
  ) {
    const cgl = op.patch.cgl;
    if (!helperMeshes.ARROW_SRC_DST) {
      helperMeshes.ARROW_SRC_DST = {};

      const verts = [];
      verts.push(sourceX, sourceY, sourceZ);
      verts.push(destX, destY, destZ);

      const tc = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      const geom = new CGL.Geometry("helpermesh");
      geom.vertices = verts;
      geom.setTexCoords(tc);
      geom.vertexNormals = verts.slice();
      helperMeshes.ARROW_SRC_DST.geom = geom;
      helperMeshes.ARROW_SRC_DST.cube = new CGL.Mesh(cgl, geom, {
        glPrimitive: cgl.gl.LINES,
      });
    } else {
      helperMeshes.ARROW_SRC_DST.geom.setVertices([
        sourceX,
        sourceY,
        sourceZ,
        destX,
        destY,
        destZ,
      ]);
      helperMeshes.ARROW_SRC_DST.cube.updateVertices(
        helperMeshes.ARROW_SRC_DST.geom,
      );
    }

    if (cgl.lastMesh) cgl.lastMesh.unBind();

    cgl.pushModelMatrix();
    helperMeshes.startFramebuffer(cgl);

    let shader = helperMeshes.getDefaultShader(cgl);
    if (Gui$1.gui.patchView.isCurrentOp(op))
      shader = helperMeshes.getSelectedShader(cgl);

    helperMeshes.ARROW_SRC_DST.cube.render(shader);
    helperMeshes.count++;

    cgl.popModelMatrix();
    helperMeshes.endFramebuffer(cgl);
  };

  helperMeshes.drawArrow = function (op, sizeX, rotX, rotY, rotZ) {
    const cgl = op.patch.cgl;

    if (!helperMeshes.ARROW) {
      helperMeshes.ARROW = {};
      helperMeshes.ARROW.vScale = create$4();

      function bufferData() {
        const verts = [];

        verts.push(0, -1, 0);
        verts.push(0.25, -0.75, 0);

        verts.push(0, -1, 0);
        verts.push(-0.25, -0.75, 0);

        verts.push(0, -1, 0);
        verts.push(0, 0, 0);

        const tc = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

        const geom = new CGL.Geometry("helpermesh");
        geom.vertices = verts;
        geom.setTexCoords(tc);
        geom.vertexNormals = verts.slice();

        helperMeshes.ARROW.cube = new CGL.Mesh(cgl, geom, {
          glPrimitive: cgl.gl.LINES,
        });
      }

      bufferData();
    }

    if (cgl.lastMesh) cgl.lastMesh.unBind();

    cgl.pushModelMatrix();
    helperMeshes.startFramebuffer(cgl);

    set$4(helperMeshes.ARROW.vScale, sizeX, sizeX, sizeX);
    scale$5(cgl.mvMatrix, cgl.mvMatrix, helperMeshes.ARROW.vScale);

    if (rotX) rotateX$3(cgl.mvMatrix, cgl.mvMatrix, rotX * CGL.DEG2RAD);
    if (rotY) rotateY$3(cgl.mvMatrix, cgl.mvMatrix, rotY * CGL.DEG2RAD);
    if (rotZ) rotateZ$3(cgl.mvMatrix, cgl.mvMatrix, rotZ * CGL.DEG2RAD);

    let shader = helperMeshes.getDefaultShader(cgl);
    if (Gui$1.gui.patchView.isCurrentOp(op))
      shader = helperMeshes.getSelectedShader(cgl);

    helperMeshes.ARROW.cube.render(shader);
    helperMeshes.count++;

    cgl.popModelMatrix();
    helperMeshes.endFramebuffer(cgl);
  };

  helperMeshes.drawXPlane = function (op, sizeX, rotX, rotY, rotZ) {
    const cgl = op.patch.cgl;

    if (!helperMeshes.XPLANE) {
      helperMeshes.XPLANE = {};
      helperMeshes.XPLANE.vScale = create$4();

      function bufferData() {
        const verts = [
          -1, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1,
          -1, 0,
        ];

        const tc = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

        const geom = new CGL.Geometry("helpermesh");
        geom.vertices = verts;
        geom.setTexCoords(tc);
        geom.vertexNormals = verts.slice();

        helperMeshes.XPLANE.mesh = new CGL.Mesh(cgl, geom, cgl.gl.LINE_STRIP);
      }

      bufferData();
    }

    if (cgl.lastMesh) cgl.lastMesh.unBind();

    cgl.pushModelMatrix();
    helperMeshes.startFramebuffer(cgl);

    set$4(helperMeshes.XPLANE.vScale, sizeX, sizeX, sizeX);
    scale$5(cgl.mvMatrix, cgl.mvMatrix, helperMeshes.XPLANE.vScale);

    if (rotX) rotateX$3(cgl.mvMatrix, cgl.mvMatrix, rotX * CGL.DEG2RAD);
    if (rotY) rotateY$3(cgl.mvMatrix, cgl.mvMatrix, rotY * CGL.DEG2RAD);
    if (rotZ) rotateZ$3(cgl.mvMatrix, cgl.mvMatrix, rotZ * CGL.DEG2RAD);

    let shader = helperMeshes.getDefaultShader(cgl);
    if (Gui$1.gui.patchView.isCurrentOp(op))
      shader = helperMeshes.getSelectedShader(cgl);

    helperMeshes.XPLANE.mesh.render(shader);
    helperMeshes.count++;

    cgl.popModelMatrix();
    helperMeshes.endFramebuffer(cgl);
  };

  helperMeshes.drawCube = function (op, sizeX, sizeY, sizeZ) {
    const cgl = op.patch.cgl;

    if (!helperMeshes.CUBE) {
      helperMeshes.CUBE = {};
      helperMeshes.CUBE.vScale = create$4();

      function bufferData() {
        const verts = new Float32Array([
          -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1,

          -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1,

          -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,

          1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1,
        ]);

        const tc = new Float32Array([
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ]);

        const geom = new CGL.Geometry("helpermesh");
        geom.vertices = verts;
        geom.setTexCoords(tc);
        geom.vertexNormals = verts.slice();

        helperMeshes.CUBE.mesh = new CGL.Mesh(cgl, geom, cgl.gl.LINE_STRIP);
      }

      bufferData();
    }

    if (cgl.lastMesh) cgl.lastMesh.unBind();

    cgl.pushModelMatrix();
    helperMeshes.startFramebuffer(cgl);

    if (sizeY == undefined) sizeY = sizeX;
    if (sizeZ == undefined) sizeZ = sizeX;
    set$4(helperMeshes.CUBE.vScale, sizeX, sizeY, sizeZ);
    scale$5(cgl.mvMatrix, cgl.mvMatrix, helperMeshes.CUBE.vScale);

    let shader = helperMeshes.getDefaultShader(cgl);
    if (Gui$1.gui.patchView.isCurrentOp(op))
      shader = helperMeshes.getSelectedShader(cgl);

    helperMeshes.CUBE.mesh.render(shader);
    helperMeshes.count++;

    cgl.popModelMatrix();
    helperMeshes.endFramebuffer(cgl);
  };

  helperMeshes.drawMarkerLayer = function (cgl, size) {
    if (!Gui$1.gui.shouldDrawOverlay) return;

    if (helperMeshes.count == 0) return;
    helperMeshes.count = 0;

    if (!helperMeshes.FB || !helperMeshes.FB.fb) return;

    const currentViewPort = cgl.getViewPort();
    const w = currentViewPort[2];
    const h = currentViewPort[3];

    if (
      !helperMeshes.fullscreenRectMesh ||
      helperMeshes.FSWIDTH != w ||
      helperMeshes.FSHEIGHT != h
    ) {
      const fsGeom = new CGL.Geometry("fullscreen rectangle");

      helperMeshes.FSWIDTH = w;
      helperMeshes.FSHEIGHT = h;

      // prettier-ignore
      fsGeom.vertices = new Float32Array([
              w, h, 0,
              0, h, 0,
              w, 0, 0,
              0, 0, 0
          ]);

      fsGeom.texCoords = new Float32Array([
        1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0,
      ]);

      fsGeom.vertexNormals = new Float32Array([
        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
      ]);

      fsGeom.verticesIndices = new Uint16Array([0, 1, 2, 3, 1, 2]);

      // helperMeshes.fsGeom=fsGeom;
      if (!helperMeshes.fullscreenRectMesh)
        helperMeshes.fullscreenRectMesh = new CGL.Mesh(cgl, fsGeom);
      else helperMeshes.fullscreenRectMesh.setGeom(fsGeom);

      // ------------

      if (!helperMeshes.fullscreenRectShader) {
        const shader = new CGL.Shader(cgl, "marker overlay");

        const shader_frag =
          "".endl() +
          "UNI sampler2D tex;".endl() +
          "IN vec2 texCoord;".endl() +
          "void main()".endl() +
          "{"

            /*
             * .endl()+'   vec3 gray = vec3(dot( vec3(0.2126,0.7152,0.0722),  texture2D(tex,vec2(texCoord.x,(1.0-texCoord.y))).rgb ));'
             * .endl()+'   gl_FragColor = vec4(gray,1.0);'
             */

            .endl() +
          "   gl_FragColor = texture2D(tex,texCoord);"
            // .endl()+'   if(gl_FragColor.a<0.5)gl_FragColor.a=0.7;'

            .endl() +
          "}";

        const shader_vert =
          "".endl() +
          "IN vec3 vPosition;".endl() +
          "UNI mat4 projMatrix;".endl() +
          "UNI mat4 mvMatrix;".endl() +
          "OUT vec2 texCoord;".endl() +
          "IN vec2 attrTexCoord;".endl() +
          "void main()".endl() +
          "{".endl() +
          "   vec4 pos=vec4(vPosition, 1.0);".endl() +
          "   texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);".endl() +
          "   gl_Position = projMatrix * mvMatrix * pos;".endl() +
          "}";

        shader.setSource(shader_vert, shader_frag);
        shader.texUniform = new CGL.Uniform(shader, "t", "tex", 0);

        helperMeshes.fullscreenRectShader = shader;

        /*
         * shader.bindTextures = function ()
         * {
         *     cgl.gl.activeTexture(cgl.gl.TEXTURE0);
         *     cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, helperMeshes.FB.fb.getTextureColor().tex);
         * };
         */
      }
    }

    cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);
    cgl.pushPMatrix();
    identity$2(cgl.pMatrix);
    ortho(cgl.pMatrix, 0, w, h, 0, -10, 1000);

    cgl.pushModelMatrix();
    identity$2(cgl.mvMatrix);

    cgl.pushViewMatrix();
    identity$2(cgl.vMatrix);

    helperMeshes.fullscreenRectShader.popTextures();
    helperMeshes.fullscreenRectShader.pushTexture(
      helperMeshes.fullscreenRectShader.texUniform,
      helperMeshes.FB.fb.getTextureColor().tex,
    );

    cgl.pushShader(helperMeshes.fullscreenRectShader);

    /*
     * helperMeshes.fullscreenRectShader.bind();
     * cgl.getShader().bind
     */

    /*
     * for (var i =0;i< cgl.gl.getProgramParameter(cgl.getShader().getProgram(), cgl.gl.ACTIVE_ATTRIBUTES) ; i++)
     * {
     *     console.log(i, cgl.gl.getActiveAttrib(cgl.getShader().getProgram(), i) );
     * }
     */

    cgl.pushBlend(true);

    cgl.gl.blendEquation(cgl.gl.FUNC_ADD);
    cgl.gl.blendFunc(cgl.gl.ONE, cgl.gl.ONE_MINUS_SRC_ALPHA);

    helperMeshes.fullscreenRectMesh.render(cgl.getShader());
    cgl.gl.blendFunc(cgl.gl.SRC_ALPHA, cgl.gl.ONE_MINUS_SRC_ALPHA);

    cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);
    cgl.popBlend();

    cgl.popShader();

    cgl.popPMatrix();
    cgl.popModelMatrix();
    cgl.popViewMatrix();

    cgl.frameCycler = !cgl.frameCycler;
  };

  const Collapsable = {};

  Collapsable.setup = function (parentEle, childEle, collapsed) {
    if (!parentEle) return;

    parentEle.classList.add("collapsable");

    if (!childEle) {
      if (parentEle.innerHTML.indexOf("icon-chevron") == -1)
        parentEle.innerHTML =
          '<span class="icon icon-chevron-down" style="opacity:0"></span>' +
          parentEle.innerHTML;
      return;
    }

    if (parentEle.innerHTML.indexOf("icon-chevron") == -1)
      parentEle.innerHTML =
        '<span class="icon icon-chevron-down"></span>' + parentEle.innerHTML;

    Collapsable._setGroupCollapsed(parentEle, childEle, collapsed);

    parentEle.addEventListener("click", (event) => {
      Collapsable._toggleGroupElements(parentEle, childEle);
      event.stopImmediatePropagation();
    });
  };

  Collapsable._setGroupCollapsed = (parentEle, childEle, collapsed) => {
    if (!collapsed) {
      childEle.classList.remove("hidden");
      parentEle.children[0].classList.add("icon-chevron-down");
      parentEle.children[0].classList.remove("icon-chevron-right");
    } else {
      childEle.classList.add("hidden");
      parentEle.children[0].classList.remove("icon-chevron-down");
      parentEle.children[0].classList.add("icon-chevron-right");
    }
  };

  Collapsable._toggleGroupElements = (parentEle, childEle) => {
    childEle.classList.toggle("hidden");

    parentEle.children[0].classList.toggle("icon-chevron-down");
    parentEle.children[0].classList.toggle("icon-chevron-right");
  };

  const log = new Logger("dragndrop");

  /**
   * filemanager - dragging and dropping files handler/listener
   *
   * @export
   */
  function DragNDrop() {
    this.internal = false;
  }

  DragNDrop.loadImage = function (_event, p) {
    if (!CABLES.dragImage) {
      CABLES.dragImage = new Image();
      // image file: /ui/img/dragicon.png
      CABLES.dragImage.src =
        "data:image;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAfCAQAAAC7DqDdAAABpUlEQVR4Ad3BO24bVxQA0HM5l6YUqbBV+FMEiJtsJa0b7yMrMwJVqbKMVAFS+wsHMEUNqXk3GMsT2ohq0Zxz8tc/Hz3ZfSqBwgO937zzwnNrlDBKg0vvvXShV8KttHPpo5X71XvkF50B3fnV67w4+8nm3BdlZWNh57Hn/rG3stYMHvvR2t4DvU5z35rOMytbYenDWW5d6Y1KoFwrC1sb1yhhNOiFsLVxbVQCg145hNIrO9zYSkIhhP8rgfK1Ugjh8MokU1oalcDSTiid1AmTpRuUtLS0t9QcTphkKYUSGpoyKqWUSdOMmqYJhVCa5nDKJC+lQgmj0PQe+t0fmkkJZeMHr6RSRqEENk4cRpjkW4OwV8Kp9M4gfOvUwhtN2Cvh1EI5rDxxl+bEXcqpu5RDCqQZKKRZKGkWQpqJNBNpJtJMpJlIM5FmIh2xUibpiIUwSbNQ0iyEdNTKJLcG4VsrC+UYhFEgf3ZmsLcw+MtW5/tXbhXyqQs7JZRA2vlb0/n+hb28duVGIYw6O+X4pM9CKaEQjlH6Tzg+ZZLWzn2CcqscnXPrfwGXq56tCOJVBgAAAABJRU5ErkJggg==";
    }
  };

  DragNDrop.startDragLibraryFile = function (_event, p) {
    _event.dataTransfer.setData("filepath", p);
    const self = this;

    _event.dataTransfer.setDragImage(CABLES.dragImage, 10, 10);

    fileUploader.unBindUploadDragNDrop();

    function dragover(event) {
      self.internal = true;
      fileUploader.unBindUploadDragNDrop();

      event.preventDefault();
      event.stopPropagation();
    }

    function dragleave(event) {
      self.internal = false;
      fileUploader.unBindUploadDragNDrop();

      event.preventDefault();
      event.stopPropagation();
    }

    function drop(event) {
      if (!self.internal) return log.warn("not internal!");

      event.preventDefault();
      event.stopPropagation();

      const filepath = event.dataTransfer.getData("filepath");

      if (event.dataTransfer.files[0]) {
        // this drop is actually a real file...
        return fileUploader.uploadDrop(event);
      }

      Gui$1.gui.patchView.addAssetOpAuto(filepath, event);

      document.getElementById("patchviews").removeEventListener("drop", drop);
      document
        .getElementById("patchviews")
        .removeEventListener("dragover", dragover);
      document
        .getElementById("patchviews")
        .removeEventListener("dragleave", dragleave);
      document
        .getElementById("patchviews")
        .removeEventListener("dragend", dragleave);

      if (platform.frontendOptions.uploadFiles) {
        fileUploader.unBindUploadDragNDrop();
        fileUploader.bindUploadDragNDrop();
      }
      self.internal = false;
    }

    document.getElementById("patchviews").addEventListener("dragover", dragover);
    document
      .getElementById("patchviews")
      .addEventListener("dragleave", dragleave);
    document.getElementById("patchviews").addEventListener("dragend", dragleave);
    document.getElementById("patchviews").addEventListener("drop", drop);
  };

  let pageshowcount = 0;

  /**
   * handle global html events like uncaught exceptions, contextmenu, resize etc
   *
   * @export
   */
  function setHtmlDefaultListeners() {
    const _log = new Logger("errorListener");
    window.addEventListener("pageshow", (_event) => {
      pageshowcount++;

      // handle people use back and then forward and browser caches whole site state...
      if (pageshowcount > 1) {
        Gui$1.gui.hide();
        document.body.prepend(
          "this session has expired... please reload page..........",
        );
      }
    });

    window.addEventListener("beforeunload", (_event) => {});

    document.addEventListener("paste", (e) => {
      if (Gui$1.gui.getRestriction() < Gui$1.gui.RESTRICT_MODE_FULL) return;

      let items = (e.clipboardData || e.originalEvent.clipboardData).items;
      for (let index in items) {
        let item = items[index];
        if (item.kind === "file") {
          let blob = item.getAsFile();
          fileUploader.uploadFile(
            blob,
            "paste_" + CABLES.shortId() + "_" + blob.name,
          );
          return;
        }
      }

      const aEl = document.activeElement;
      if (aEl.tagName == "TEXTAREA" || aEl.tagName == "INPUT") return;
      else if (
        Gui$1.gui.patchView._patchRenderer &&
        Gui$1.gui.patchView._patchRenderer.isFocused()
      )
        Gui$1.gui.patchView._patchRenderer.paste(e);
      else if (Gui$1.gui.timeLine() && Gui$1.gui.timeLine().isFocused())
        Gui$1.gui.timeLine().paste(e);
    });

    document.addEventListener("copy", (e) => {
      if (!Gui$1.gui.patchView._patchRenderer) return;

      const aEl = document.activeElement;

      if (aEl.tagName == "TEXTAREA" || aEl.tagName == "INPUT") return;
      else if (
        Gui$1.gui.patchView._patchRenderer &&
        Gui$1.gui.patchView._patchRenderer.isFocused()
      )
        Gui$1.gui.patchView._patchRenderer.copy(e);
      else if (Gui$1.gui.timeLine() && Gui$1.gui.timeLine().isFocused())
        Gui$1.gui.timeLine().copy(e);
    });

    document.addEventListener("cut", (e) => {
      if (
        Gui$1.gui.patchView._patchRenderer &&
        Gui$1.gui.patchView._patchRenderer.isFocused()
      )
        Gui$1.gui.patchView._patchRenderer.cut(e);
      else if (Gui$1.gui.timeLine() && Gui$1.gui.timeLine().isFocused())
        Gui$1.gui.timeLine().cut(e);
    });

    // show context menu only on input fields/images etc...
    document.body.addEventListener(
      "contextmenu",

      /**
       * @param {Event} e
       */
      (e) => {
        if (e.target.currentSrc) return;
        if (e.target.classList.contains("selectable")) return;
        if (e.target.nodeName == "TEXTAREA" || e.target.nodeName == "INPUT")
          return;

        // if (ele.byId("cablescanvas").contains(e.target)) return;
        e.preventDefault();
      },
    );

    window.addEventListener("unhandledrejection", function (e) {
      if (
        e.reason &&
        e.reason.message &&
        e.reason.message ==
          "The user has exited the lock before this request was completed."
      )
        return true; // ignore this......

      _log.error(e);
    });

    window.addEventListener("error", (e) => {
      if (
        e &&
        e.message &&
        e.message.indexOf("/js/ace/worker-javascript.") > -1
      ) {
        _log.log("yay! suppressed nonsense ace editor exception... ");
        return;
      }

      if (
        e &&
        e.exception &&
        String(e.exception.stack).indexOf("file:blob:") == 0
      ) {
        _log.log("ignore file blob exception...");
        return;
      }

      if (!CABLES.lastError != e) {
        _log.error(e);
        CABLES.lastError = e;
      }
    });

    document.body.addEventListener("dragstart", (e) => {
      if (
        !e.target.draggable ||
        !e.target.classList.contains("draggable") ||
        e.target.nodeName == "TEXTAREA" ||
        e.target.nodeName == "INPUT"
      ) {
        e.preventDefault();
        return false;
      }
    });

    window.addEventListener(
      "resize",
      () => {
        if (window.gui) Gui$1.gui.onResize();
      },
      false,
    );

    window.addEventListener(
      "message",
      (event) => {
        if (CABLESUILOADER.cfg && event.origin !== CABLESUILOADER.cfg.urlCables)
          return;
        if (event.data && event.data.type === "hashchange") {
          window.location.hash = event.data.data;
        }
      },
      false,
    );

    document.addEventListener(
      "visibilitychange",
      function () {
        if (Gui$1.gui && !document.hidden) {
          Gui$1.gui.setLayout();
          Gui$1.gui.patchView.store.checkUpdated(null, false, true);
        }
      },
      false,
    );

    window.addEventListener("focus", () => {
      if (Gui$1.gui && !document.hidden) {
        Gui$1.gui.setLayout();
        Gui$1.gui.patchView.store.checkUpdated(null, false, true);
      }
    });
  }

  /**
   * gradient editor dialog
   *
   * @export
   * @class GradientEditor
   */
  class GradientEditor {
    constructor(opid, portname, options) {
      this._log = new Logger("gradienteditor");
      this._opId = opid;
      this._portName = portname;

      this._keyWidth = this._keyHeight = 7;
      this._keyStrokeWidth = 2;
      this._keyOpacity = 1;
      this._dragDownDeleteThreshold = 120;
      this._width = 512;
      this._height = 100;

      this._oldKeys = [];
      this._keys = [];

      this._movingkey = false;
      this._callback = null;
      this._ctx = null;

      this._currentKey = null;
      this._oldCurrentKey = null;

      this._op = Gui$1.gui.corePatch().getOpById(this._opId);
      this._port = this._op.getPort(this._portName);
      this.type = this._port.uiAttribs.gradientType || "gradient";

      this._anim = new CABLES.Anim();

      this._anim.defaultEasing = CABLES.Anim.EASING_SMOOTHSTEP;

      this._elContainer = null;
      this._bg = new ModalBackground();
      this._bg.on("hide", () => {
        this.close();
      });

      this._options = {};
      this._options.smoothStep = this._port.uiAttribs.gradEditSmoothstep;
      this._options.step = this._port.uiAttribs.gradEditStep;
      this._options.oklab = this._port.uiAttribs.gradOklab;

      this._previousContent = "";
      this._openerEle = (options || {}).openerEle;
    }

    close() {
      this._bg.hide();
      this._elContainer.remove();
    }

    selectKey(i) {
      this.setCurrentKey(this._keys[i]);
    }

    updateCanvas() {
      if (!this._ctx) {
        const canvas = ele.byId("gradientEditorCanvas");
        const canvasCurve = ele.byId("gradientEditorCanvasCurve");
        if (!canvas) {
          this._log.error("[gradienteditor] no canvas found");
          return;
        }
        this._ctx = canvas.getContext("2d");
        this._ctxCurve = canvasCurve.getContext("2d");
        this._imageData = this._ctx.createImageData(this._width, 1);
      }

      let keys = [];
      if (this._keys.length == 0)
        keys.push({
          posy: 0.5,
          pos: 0,
          r: 0,
          g: 0,
          b: 0,
        });
      else
        keys = [
          {
            posy: this._keys[0].posy,
            pos: 0,
            r: this._keys[0].r,
            g: this._keys[0].g,
            b: this._keys[0].b,
          },
        ].concat(this._keys);

      const last = keys[keys.length - 1];
      keys.push({
        posy: last.posy,
        pos: 1,
        r: last.r,
        g: last.g,
        b: last.b,
      });

      if (this.type == "curve") {
        this._ctxCurve.fillStyle = "#444";
        this._ctxCurve.fillRect(0, 0, this._width, this._height);

        // --------- 0.5 line...

        this._ctxCurve.strokeStyle = "#333";
        this._ctxCurve.beginPath();
        this._ctxCurve.moveTo(0, this._height / 2);
        this._ctxCurve.lineTo(this._width, this._height / 2);
        this._ctxCurve.stroke();

        // --------- linear

        this._ctxCurve.strokeStyle = "#777";
        this._ctxCurve.lineWidth = 1;
        this._ctxCurve.beginPath();
        this._ctxCurve.moveTo(
          keys[0].pos * this._width,
          keys[0].posy * this._height - this._keyWidth / 2,
        );

        for (let i = 0; i < keys.length - 1; i++)
          this._ctxCurve.lineTo(
            Math.floor(keys[i].pos * this._width - this._keyWidth / 2),
            Math.floor(keys[i].posy * this._height - this._keyWidth / 2 + 1),
          );

        this._ctxCurve.lineTo(
          keys[keys.length - 1].pos * this._width,
          keys[keys.length - 1].posy * this._height - this._keyWidth / 2,
        );
        this._ctxCurve.stroke();

        // smoothed...
        // this._ctxCurve.strokeStyle = "#aaa";
        // this._ctxCurve.beginPath();
        // this._ctxCurve.lineWidth = 2;
        // let numSteps = 250;
        // for (let i = 0; i < numSteps + 2; i++)
        // {
        //     let x = Math.floor(i / numSteps * this._width);
        //     let y = Math.floor(this._anim.getValue(i / numSteps) * this._height) - 1;
        //     if (i == 0) this._ctxCurve.moveTo(x, y);
        //     else this._ctxCurve.lineTo(x, y);
        // }
        // this._ctxCurve.stroke();
      } else {
        for (let i = 0; i < keys.length - 1; i++) {
          this._setKeyStyle(keys[i]);
          const keyA = keys[i];
          const keyB = keys[i + 1];

          for (let x = keyA.pos * this._width; x < keyB.pos * this._width; x++) {
            x = Math.round(x);
            let p = CABLES.map(
              x,
              keyA.pos * this._width,
              keyB.pos * this._width,
              0,
              1,
            );

            if (this._options.smoothStep) p = CABLES.smoothStep(p);
            if (this._options.step) p = Math.round(p);

            if (this._options.oklab) {
              const klabA = this.rgbToOklab(keyA.r, keyA.g, keyA.b);
              const labA_r = klabA[0];
              const labA_g = klabA[1];
              const labA_b = klabA[2];

              const klabB = this.rgbToOklab(keyB.r, keyB.g, keyB.b);
              const labB_r = klabB[0];
              const labB_g = klabB[1];
              const labB_b = klabB[2];

              const l = p * labB_r + (1.0 - p) * labA_r;
              const a = p * labB_g + (1.0 - p) * labA_g;
              const b = p * labB_b + (1.0 - p) * labA_b;

              const pixCol = this.oklabToRGB(l, a, b);
              this._imageData.data[x * 4 + 0] = Math.round(pixCol[0] * 255);
              this._imageData.data[x * 4 + 1] = Math.round(pixCol[1] * 255);
              this._imageData.data[x * 4 + 2] = Math.round(pixCol[2] * 255);
              this._imageData.data[x * 4 + 3] = 255;
            } else {
              this._imageData.data[x * 4 + 0] =
                (p * keyB.r + (1.0 - p) * keyA.r) * 255;
              this._imageData.data[x * 4 + 1] =
                (p * keyB.g + (1.0 - p) * keyA.g) * 255;
              this._imageData.data[x * 4 + 2] =
                (p * keyB.b + (1.0 - p) * keyA.b) * 255;
              this._imageData.data[x * 4 + 3] = 255;
            }
          }
        }

        this._ctx.putImageData(this._imageData, 0, 0);
      }

      if (this._opId && this._portName) {
        const keyData = [];
        for (let i = 0; i < keys.length; i++) {
          keyData[i] = {
            pos: keys[i].pos,
            posy: keys[i].posy,
            r: keys[i].r,
            g: keys[i].g,
            b: keys[i].b,
          };
        }

        this._port.set(JSON.stringify({ keys: keyData }));
      }
    }

    _setKeyStyle(key) {
      const attr = {};

      if (key.rect) {
        if (this.type == "curve") {
          attr.fill = "#888";
          attr.stroke = "#fff";
        } else {
          attr.fill =
            "rgba(" +
            Math.round(key.r * 255) +
            "," +
            Math.round(key.g * 255) +
            "," +
            Math.round(key.b * 255) +
            "," +
            this._keyOpacity +
            ")";
          attr.stroke = this.getInvStrokeColor(key.r, key.g, key.b);
        }

        key.rect.attr(attr);
      }
    }

    onChange() {
      function compare(a, b) {
        return a.pos - b.pos;
      }

      this._keys.sort(compare);

      this._anim.clear();
      let html = "";
      for (let i = 0; i < this._keys.length; i++) {
        this._keys[i].pos = Math.min(1.0, Math.max(this._keys[i].pos, 0));
        this._keys[i].posy = Math.min(1.0, Math.max(this._keys[i].posy, 0));

        html +=
          '<a data-index="' +
          i +
          '" onclick="CABLES.GradientEditor.editor.selectKey(' +
          i +
          ')" class="keyindex button-small">' +
          i +
          "</a> ";

        this._anim.setValue(this._keys[i].pos, this._keys[i].posy);
      }

      ele.byId("gradienteditorKeys").innerHTML = html;

      this._timeout = setTimeout(() => {
        if (CABLES.GradientEditor.editor)
          CABLES.GradientEditor.editor.updateCanvas();
      }, 3);

      if (this._callback) this._callback();
    }

    deleteKey(k) {
      this._keys.splice(this._keys.indexOf(k), 1);
      this.onChange();
    }

    setCurrentKey(key) {
      if (this._currentKey)
        this._currentKey.rect.attr({ "stroke-width": this._keyStrokeWidth });
      this._currentKey = key;

      if (key == this._currentKey)
        this._currentKey.rect.attr({ "stroke-width": this._keyStrokeWidth * 2 });

      ele.byId("gradientColorInput").style.backgroundColor =
        "rgb(" +
        Math.round(key.r * 255) +
        "," +
        Math.round(key.g * 255) +
        "," +
        Math.round(key.b * 255) +
        ")";
    }

    getInvStrokeColor(r, g, b) {
      if (this.type == "curve") return "rgba(255,255,255,1)";
      let invCol = (r + g + b) / 3;

      if (invCol < 0.5) invCol = 1.0;
      else invCol = 0.0;

      const s =
        "rgba(" +
        invCol * 255 +
        "," +
        invCol * 255 +
        "," +
        invCol * 255 +
        ",1.0)";
      return s;
    }

    addKey(pos, posy, r, g, b) {
      if (r == undefined) {
        r = Math.random();
        g = Math.random();
        b = Math.random();
      }

      const rect = this._paper
        .ellipse(
          pos * this._width - this._keyWidth / 2,
          posy * this._height - this._keyWidth / 2,
          this._keyWidth,
          this._keyHeight,
        )
        .attr({
          fill: "transparent",
          stroke: this.getInvStrokeColor(r, g, b),
          "stroke-width": this._keyStrokeWidth,
        });

      const key = {
        posy: posy,
        pos: pos,
        rect: rect,
        r: r,
        g: g,
        b: b,
      };

      this._setKeyStyle(key);

      this._keys.push(key);
      let shouldDelete = false;
      this.setCurrentKey(key);

      const move = (dx, dy, x, y, e) => {
        this.setCurrentKey(key);
        this._movingkey = true;
        const attribs = {};

        attribs.stroke = this.getInvStrokeColor(key.r, key.g, key.b);

        // e.target == key.rect.node || //|| e.target.tagName == "circle"
        if (
          e.target.tagName == "svg" ||
          e.target.tagName == "circle" ||
          e.target.tagName == "ellipse"
        ) {
          let eX = e.offsetX - this._keyWidth / 2;
          let eY = e.offsetY - this._keyWidth / 2;

          eX = Math.max(eX, 0);
          eY = Math.max(eY, 0);
          eX = Math.min(eX, this._width);
          eY = Math.min(eY, this._height);

          attribs.cx = eX;
          attribs.cy = eY;

          key.pos = (eX + this._keyWidth / 2) / this._width;
          key.posy = (eY + this._keyWidth / 2) / this._height;
        }

        rect.attr(attribs);
        this.onChange();
      };

      const down = (x, y, e) => {
        try {
          e.target.setPointerCapture(e.pointerId);
        } catch (_e) {}

        if (e.buttons == 2) shouldDelete = true;

        this._startMouseY = y;
        this._movingkey = true;
        this.setCurrentKey(key);
      };

      const up = (e) => {
        try {
          e.target.releasePointerCapture(e.pointerId);
        } catch (_e) {}

        setTimeout(() => {
          this._movingkey = false;
        }, 100);

        if (shouldDelete && key.rect) {
          key.rect.remove();
          this.deleteKey(key);
        }
      };

      if (rect) rect.drag(move, down, up);
    }

    show(cb) {
      this._callback = cb;

      if (window.gui && Gui$1.gui.currentModal) Gui$1.gui.currentModal.close();

      const html = getHandleBarHtml("GradientEditor", { name: this._portName });

      this._bg.show(true);

      this._elContainer = document.createElement("div");
      this._elContainer.classList.add("gradientEditorContainer");
      this._elContainer.classList.add("cablesCssUi");

      document.body.appendChild(this._elContainer);
      this._elContainer.innerHTML = html;

      if (this._openerEle) {
        const r = this._openerEle.getBoundingClientRect();
        const rge = this._elContainer.getBoundingClientRect();
        let ry = r.y;
        if (window.innerHeight - ry < this._height * 1.5)
          ry -= this._height * 1.5;
        this._elContainer.style.left = r.x - rge.width - 20 + "px";
        this._elContainer.style.top = ry + "px";
      } else {
        this._elContainer.style.left = 100 + "px";
        this._elContainer.style.top = 100 + "px";
      }
      this._paper = Raphael("gradienteditorbar", 0, 0);
      document
        .querySelector("#gradienteditorbar svg")
        .addEventListener("pointerdown", (e) => {
          try {
            e.target.setPointerCapture(e.pointerId);
          } catch (_e) {}
        });

      document
        .querySelector("#gradienteditorbar svg")
        .addEventListener("pointerup", (e) => {
          try {
            e.target.releasePointerCapture(e.pointerId);
          } catch (_e) {}
        });

      document
        .querySelector("#gradienteditorbar svg")
        .addEventListener("click", (e) => {
          if (this._movingkey) return;
          this.addKey(e.offsetX / this._width, e.offsetY / this._height);
          this.onChange();
        });

      if (this._opId && this._portName) {
        const op = Gui$1.gui.corePatch().getOpById(this._opId);
        if (!op) this.close();
        const data = op.getPort(this._portName).get();
        try {
          this._previousContent = data;
          const keys = JSON.parse(data).keys || [];
          for (let i = 1; i < keys.length - 1; i++)
            this.addKey(
              keys[i].pos,
              keys[i].posy,
              keys[i].r,
              keys[i].g,
              keys[i].b,
            );
        } catch (e) {
          this._log.error(e);
        }
      }

      if (this._keys.length == 0) {
        this.addKey(0, 0.5, 0, 0, 0);
        this.addKey(1, 0.5, 1, 1, 1);
      }

      this.onChange();
      CABLES.GradientEditor.editor = this;

      ele.byId("gradientSaveButton").addEventListener("click", () => {
        this.close();
      });

      ele.byId("gradientCancelButton").addEventListener("click", () => {
        const op = Gui$1.gui.corePatch().getOpById(this._opId);
        op.getPort(this._portName).set(this._previousContent);
        this.close();
      });

      const colEleDel = ele.byId("gradientColorDelete");
      colEleDel.addEventListener("click", (e) => {
        if (this._currentKey) {
          this._currentKey.rect.remove();
          this.deleteKey(this._currentKey);
          this._currentKey = this._keys[0];
        }
      });

      if (this.type == "curve")
        ele.byId("gradientColorInput").classList.add("hidden");
      else ele.byId("gradientColorInput").classList.remove("hidden");

      const colEle = ele.byId("gradientColorInput");

      colEle.addEventListener("click", (e) => {
        if (!this._currentKey) return;
        new ColorRick({
          ele: colEle,
          color: [
            parseInt(this._currentKey.r * 255),
            parseInt(this._currentKey.g * 255),
            parseInt(this._currentKey.b * 255),
          ], // "#ffffff",
          onChange: (col) => {
            if (this._currentKey) {
              this._currentKey.r = col.gl()[0];
              this._currentKey.g = col.gl()[1];
              this._currentKey.b = col.gl()[2];

              CABLES.GradientEditor.editor._ctx = null;
              CABLES.GradientEditor.editor.onChange();

              colEle.style.backgroundColor = col.hex();
            }
          },
        });
      });
    }

    rgbToOklab(r, g, b) {
      let l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
      let m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
      let s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
      l = Math.cbrt(l);
      m = Math.cbrt(m);
      s = Math.cbrt(s);
      return [
        l * 0.2104542553 + m * 0.793617785 + s * -0.0040720468,
        l * 1.9779984951 + m * -2.428592205 + s * 0.4505937099,
        l * 0.0259040371 + m * 0.7827717662 + s * -0.808675766,
      ];
    }

    clamp(value, min, max) {
      return Math.max(Math.min(value, max), min);
    }

    oklabToRGB(L, a, b) {
      let l = L + a * 0.3963377774 + b * 0.2158037573;
      let m = L + a * -0.1055613458 + b * -0.0638541728;
      let s = L + a * -0.0894841775 + b * -1.291485548;
      l **= 3;
      m **= 3;
      s **= 3;
      let rgb_r = l * 4.0767416621 + m * -3.3077115913 + s * 0.2309699292;
      let rgb_g = l * -1.2684380046 + m * 2.6097574011 + s * -0.3413193965;
      let rgb_b = l * -0.0041960863 + m * -0.7034186147 + s * 1.707614701;
      rgb_r = CABLES.clamp(rgb_r, 0, 1);
      rgb_g = CABLES.clamp(rgb_g, 0, 1);
      rgb_b = CABLES.clamp(rgb_b, 0, 1);
      return [rgb_r, rgb_g, rgb_b];
    }
  }

  const oldModalWrap = {
    show: function (content, options) {
      let logger = new Logger("modal");
      logger.stack("deprecated function CABLES.UI.MODAL.show ");

      options = options || {};
      options.html = content;
      new ModalDialog(options);
    },

    showError: function (title, content) {
      let logger = new Logger("modal");
      logger.stack("deprecated function CABLES.UI.MODAL.showError ");
      new ModalDialog({
        warning: true,
        title: title,
        html: content,
      });
    },

    prompt: function (title, text, value, callback) {
      let logger = new Logger("modal");
      logger.stack("deprecated CABLES.UI.MODAL.prompt, use ModalDialog ");

      new ModalDialog({
        prompt: true,
        title: title,
        text: text,
        promptValue: value,
        promptOk: callback,
      });
    },
  };

  /**
   * platform implementation for community (https://cables.gl)
   *
   * @export
   * @class PlatformCommunity
   * @extends {Platform}
   */
  class PlatformCommunity extends Platform {
    constructor(cfg) {
      super(cfg);

      this.frontendOptions.showStartUpLog = this.isDevEnv();

      this.frontendOptions.hasCommunity = // favs/comments/activity feed etc.
        this.frontendOptions.uploadFiles =
        this.frontendOptions.showAssetExternalLink =
        this.frontendOptions.showAssetUpload =
        this.frontendOptions.showPatchSettings =
        this.frontendOptions.showPatchBackups =
        this.frontendOptions.showPatchViewPage =
        this.frontendOptions.showExport =
        this.frontendOptions.showMyLinks =
        this.frontendOptions.needsInternet =
        this.frontendOptions.showRemoteViewer =
        this.frontendOptions.showChangeLogLink =
        this.frontendOptions.sendErrorReports =
        this.frontendOptions.showFormatCodeButton =
        this.frontendOptions.opDependencies =
        this.frontendOptions.showSetProjectTitle =
          true;
    }

    getCablesDocsUrl() {
      return this.getCablesUrl();
    }

    getCablesVersion() {
      return "Community build";
    }

    currentUserIsPatchOwner() {
      return Gui$1.gui.project().userId === Gui$1.gui.user.id;
    }
  }

  /**
   * platform for standalone / electron version
   *
   * @export
   * @class PlatformElectron
   * @extends {Platform}
   */
  class PlatformElectron extends Platform {
    constructor(cfg) {
      super(cfg);

      this.paths = cfg.paths;

      this.frontendOptions.npm = true;
      this.frontendOptions.isElectron =
        this.frontendOptions.openLocalFiles =
        this.frontendOptions.selectableDownloadPath =
        this.frontendOptions.dragDropLocalFiles =
        this.frontendOptions.showLocalAssetDirOpen =
        this.frontendOptions.showLocalOpDirButton =
        this.frontendOptions.editOpSummary =
        this.frontendOptions.hasOpDirectories =
        this.frontendOptions.hasAssetDirectories =
        this.frontendOptions.showWelcome =
        this.frontendOptions.showBuildInfoMenuLink =
        this.frontendOptions.opDependencies =
        this.frontendOptions.showOpenPatch =
        this.frontendOptions.showExport =
        this.frontendOptions.showExportPatch =
        this.frontendOptions.opRenameInEditor =
        this.frontendOptions.opDeleteInEditor =
        this.frontendOptions.showSetProjectTitle =
        this.frontendOptions.showStartUpLog =
          true;
      this.frontendOptions.showFormatCodeButton = false;

      this.bindHrTimer();
    }

    bindHrTimer() {
      const process = window.nodeRequire("node:process");
      const startTime = process.hrtime();
      performance.now = () => {
        let t = process.hrtime(startTime);
        return t[0] * 1000 + t[1] / 1000000;
      };
    }

    isElectron() {
      return true;
    }

    getCablesVersion() {
      let version = "Electron Standalone";

      if (
        CABLESUILOADER &&
        CABLESUILOADER.buildInfo &&
        CABLESUILOADER.buildInfo.api &&
        CABLESUILOADER.buildInfo.api.version
      )
        version += " v" + CABLESUILOADER.buildInfo.api.version;
      else version += " development version";
      return version;
    }

    getCablesDocsUrl() {
      return this._cfg.communityUrl || "https://cables.gl";
    }

    getIssueTrackerUrl() {
      return "https://github.com/cables-gl/cables_electron/issues";
    }

    getCablesStaticUrl() {
      return "";
    }

    noCacheUrl(url) {
      let separator = "?";
      if (url.includes("?")) separator = "&";
      return url + separator + "nc=" + (Date.now() + "").substr(-6);
    }

    showFileSelect(inputId, filterType, opId, previewId) {
      let value = null;
      let inputEle = null;
      if (inputId) {
        inputEle = ele.byQuery(inputId);
        if (inputEle) value = inputEle.value;
      }
      this.talkerAPI.send(
        "selectFile",
        { url: value, filter: filterType, opId: opId },
        (_err, file) => {
          if (file && inputEle) {
            const op = Gui$1.gui.corePatch().getOpById(opId);
            Gui$1.gui.savedState.setUnSaved("filemanager", op.getSubPatch());
            inputEle.value = file;
            const event = document.createEvent("Event");
            event.initEvent("input", true, true);
            inputEle.dispatchEvent(event);
            Gui$1.gui.opParams.show(op);
          }
        },
      );
    }

    createBackup() {
      const showBackupDialog = () => {
        this.talkerAPI.send("patchCreateBackup", {}, (err, result) => {
          if (result.success) notify("Backup created!");
        });
      };

      if (!Gui$1.gui.getSavedState()) {
        new ModalDialog({
          choice: true,
          cancelButton: {
            text: "Backup last saved state",
            callback: showBackupDialog,
          },
          title: "Backup",
          warning: true,
          text: text.projectBackupNotSaved,
        });

        return;
      }

      showBackupDialog();
    }

    showGitBranchWarning() {}

    currentUserIsPatchOwner() {
      return true;
    }

    exportPatch(projectId, exportType = null) {
      let talkerCommand = "exportPatch";
      if (exportType === "patch") talkerCommand = "exportPatchBundle";
      gui
        .jobs()
        .start({ id: "exportPatch", title: "export patch", indicator: "canvas" });
      this.talkerAPI.send(
        talkerCommand,
        { projectId: projectId },
        (err, result) => {
          const modalOptions = {
            title: "Patch Export",
          };
          Gui$1.gui.jobs().finish("exportPatch");
          if (err || result.error) {
            modalOptions.warning = true;
            modalOptions.text =
              "Failed to export patch:<br/>" + (err || "") + (result.error || "");
          } else {
            modalOptions.showOkButton = true;
            modalOptions.okButton = {
              text: "Show",
              callback: (a, b, c) => {
                CABLES.CMD.ELECTRON.openFileManager(result.data.url);
              },
            };
            modalOptions.text = "Successfully exported patch:";
          }
          if (result && result.data && result.data.log) {
            modalOptions.notices = result.data.log.map((l) => {
              return l.text;
            });
          }
          new ModalDialog(modalOptions);
        },
      );
    }

    getPatchOpsNamespace() {
      return "Ops.Local.";
    }

    isSaving() {
      return false;
    }

    getDefaultOpName() {
      return this.getPatchOpsNamespace() + super.getDefaultOpName();
    }
  }

  /**
   * Opens a modal dialog and shows a loading indicator animation
   *
   * @param {String} title
   * @class
   */
  class ModalIframe {
    constructor(options) {
      this._options = {
        title: options.title || "",
        src: options.src,
      };
      this._options.html = this.getHtml();
      this._dialog = new ModalDialog(this._options);
      this.iframeEle = ele.byId("modaliframe");
      const modalEle = this._dialog.getElement();
      modalEle.style.minHeight = "500px";
    }

    getHtml() {
      let html = "";
      html +=
        '<iframe id="modaliframe" frameborder="0" src="' +
        this._options.src +
        '" style="min-height: 500px; width: 100%;" title="' +
        this._options.title +
        '"></iframe>';
      return html;
    }

    close() {
      this._dialog.close();
      this._dialog = null;
    }
  }

  class LibLoader {
    constructor(dependencies, cb, options = {}) {
      this._log = new Logger("libloader");

      this._libsToLoad = dependencies.slice(0);
      this._cb = cb;
      this.id = options.id || "loadlibs";
      this.title = options.title || "loading libs";
      this._list = options.list || [];

      if (dependencies.length > 0) {
        Gui$1.gui.jobs().start({
          id: this.id,
          title: this.title,
        });

        for (const i in dependencies) {
          this.loadLib(dependencies[i]);
        }
      } else {
        if (this._cb) this._cb();
      }
    }

    checkAllLoaded() {
      if (this._libsToLoad.length === 0) {
        if (this._cb) this._cb();
        Gui$1.gui.jobs().finish(this.id);
      }
    }

    loadLib(module) {
      const libName = module.src;
      let libType = module.type;
      const moduleExport = module.export;

      // loading npms is done by electron
      const doLoadLib = libType !== "npm" && !this._list.includes(libName);
      if (doLoadLib) {
        if (!loadjs.isDefined(libName)) {
          let scriptSrc = "";

          // backwards compatibility...
          if (Array.isArray(module.src)) module.src = module.src[0] || "";

          if (!module || !module.src || !module.type) {
            const i = this._libsToLoad.indexOf(libName);
            this._libsToLoad.splice(i, 1);
            this.checkAllLoaded();
            if (gui) Gui$1.gui.emitEvent("libLoadError", libName);
            return;
          }

          if (module.src.startsWith("/assets")) {
            if (
              gui &&
              Gui$1.gui.corePatch() &&
              Gui$1.gui.corePatch().config.prefixAssetPath
            ) {
              scriptSrc = (
                Gui$1.gui.corePatch().config.prefixAssetPath + libName
              ).replace("//", "/");
            } else {
              scriptSrc += module.src;
            }
          } else if (module.src.startsWith("http")) {
            scriptSrc = module.src;
          } else if (module.src.startsWith("./")) {
            scriptSrc =
              platform.getSandboxUrl() +
              "/api/oplib/" +
              module.op +
              module.src.replace(".", "");
          } else {
            const basePath =
              module.type === "corelib" ? "/api/corelib/" : "/api/lib/";
            scriptSrc = platform.getSandboxUrl() + basePath + module.src;
          }

          if (libType === "module") {
            import(/* @vite-ignore */ scriptSrc)
              .then((importedModule) => {
                if (moduleExport) {
                  if (!window.hasOwnProperty(moduleExport))
                    window[moduleExport] = importedModule;
                }
                const i = this._libsToLoad.indexOf(libName);
                this._libsToLoad.splice(i, 1);
                this._list.push(libName);
                this.checkAllLoaded();
              })
              .catch((e) => {
                const i = this._libsToLoad.indexOf(libName);
                this._libsToLoad.splice(i, 1);
                this.checkAllLoaded();
                this._log.error(e);
                if (gui) Gui$1.gui.emitEvent("libLoadError", libName);
              });
          } else if (libType === "op") {
            Gui$1.gui.serverOps.loadOpDependencies(
              module.src,
              () => {
                const i = this._libsToLoad.indexOf(libName);
                this._libsToLoad.splice(i, 1);
                this._list.push(libName);
                this.checkAllLoaded();
              },
              true,
            );
          } else {
            loadjs(scriptSrc, libName, {
              returnPromise: true,
              async: true,
              before: (path, scriptEl) => {
                if (libType === "module") scriptEl.setAttribute("type", "module");
              },
            })
              .then(() => {
                const i = this._libsToLoad.indexOf(libName);
                this._libsToLoad.splice(i, 1);
                this._list.push(libName);
                this.checkAllLoaded();
              })
              .catch((e) => {
                const i = this._libsToLoad.indexOf(libName);
                this._libsToLoad.splice(i, 1);
                this.checkAllLoaded();
                this._log.error(e);
                if (gui) Gui$1.gui.emitEvent("libLoadError", libName);
              });
          }
        } else {
          const i = this._libsToLoad.indexOf(libName);
          this._libsToLoad.splice(i, 1);
          this._list.push(libName);
          this.checkAllLoaded();
        }
      } else {
        const i = this._libsToLoad.indexOf(libName);
        this._libsToLoad.splice(i, 1);
        this.checkAllLoaded();
      }
    }
  }

  // todo: merge serverops and opdocs.js and/or response from server ? ....

  function capitalize(str) {
    if (!str) return "";
    const s = str[0].toUpperCase() + str.slice(1);
    return s;
  }

  class ServerOps {
    constructor(patchId, next) {
      this._log = new Logger("opsserver");
      this._patchId = patchId;
      this._ops = [];

      this.opIdsChangedOnServer = {};

      editorSession.addListener("op", (name, data) => {
        editorSession.startLoadingTab();
        const lastTab = UserSettings.userSettings.get("editortab");

        if (data && data.opId) {
          name = {
            opId: data.opId,
            objName: name,
          };
        }

        this.edit(name, false, () => {
          Gui$1.gui.mainTabs.activateTabByName(lastTab);
          UserSettings.userSettings.set("editortab", lastTab);
          editorSession.finishLoadingTab();
        });
      });

      editorSession.addListener("attachment", (name, data) => {
        editorSession.startLoadingTab();
        if (data && data.opname) {
          const lastTab = UserSettings.userSettings.get("editortab");
          this.editAttachment(
            data.opname,
            data.name,
            false,
            () => {
              Gui$1.gui.mainTabs.activateTabByName(lastTab);
              console.log("act tab", lastTab);
              UserSettings.userSettings.set("editortab", lastTab);
              editorSession.finishLoadingTab();
            },
            true,
          );
        } else {
          console.log("no data", data);
        }
      });

      this.loaded = false;
      CABLESUILOADER.preload.opDocsAll.opDocs.forEach((newOp) => {
        this._ops.push(newOp);
      });
      Gui$1.gui.opDocs.addCoreOpDocs();
      this.load(next);
    }

    addOpIdChangedOnServer(opId, data = {}) {
      if (!opId) return;
      if (!this.opIdsChangedOnServer.hasOwnProperty(opId)) {
        this.opIdsChangedOnServer[opId] = data;
      }
    }

    removeOpIdChangedOnSever(opId) {
      if (!opId) return;
      delete this.opIdsChangedOnServer[opId];
    }

    /**
     * @param {Function} cb
     */
    load(cb) {
      platform.talkerAPI.send("getAllProjectOps", {}, (err, res) => {
        if (err) this._log.error(err);

        res = res || [];

        res.forEach((newOp) => {
          this._ops.push(newOp);
        });
        if (Gui$1.gui.opDocs) {
          Gui$1.gui.opDocs.addOpDocs(res);
        }

        /*
         * ops added to opdocs so they are available in opsearch
         * make sure all libraries are loaded for ops that are actually used in project (or in blueprints)
         */
        const usedOps = res.filter((op) => {
          return op && op.usedInProject;
        });
        this.loadOpsLibs(usedOps, () => {
          Gui$1.gui.corePatch().logStartup("Ops loaded");
          if (cb) cb(this._ops);
          this.loaded = true;
          incrementStartup();
        });
      });
    }

    isServerOp(name) {
      for (let i = 0; i < this._ops.length; i++)
        if (this._ops[i].name === name) return true;
      return false;
    }

    create(name, cb, openEditor, options = {}) {
      Gui$1.gui.savingTitleAnimStart("Creating Op...");

      const createRequest = {
        opname: name,
      };
      if (options && options.opTargetDir)
        createRequest.opTargetDir = options.opTargetDir;

      platform.talkerAPI.send("opCreate", createRequest, (err, res) => {
        if (err) {
          Gui$1.gui.serverOps.showApiError(err);
          Gui$1.gui.savingTitleAnimEnd();
          if (cb) cb();
        } else {
          function done() {
            Gui$1.gui.opSelect().reload();
            Gui$1.gui.endModalLoading();
            Gui$1.gui.savingTitleAnimEnd();
            if (cb) cb(res);
          }

          if (!options.noLoadOp) {
            this.loadOp(res, (newOps) => {
              if (openEditor) {
                Gui$1.gui.maintabPanel.show(true);
                this.edit(res.name, false, null, true);
              }
              Gui$1.gui.serverOps.execute(res.name, () => {
                done();
              });
            });
          } else done();
        }
      });
    }

    saveOpLayout(op) {
      this.timeoutsLayouts = this.timeoutsLayouts || {};

      clearTimeout(this.timeoutsLayouts[op.objName]);
      this.timeoutsLayouts[op.objName] = setTimeout(() => {
        this._saveOpLayout(op);
      }, 500);
    }

    _getOpLayout(op) {
      if (!op) {
        this._log.error("saveoplayout: no op!");
        return;
      }
      let i = 0;
      const opObj = {
        portsIn: [],
        portsOut: [],
      };

      for (i = 0; i < op.portsIn.length; i++) {
        if (
          op.portsIn[i].uiAttribs &&
          op.portsIn[i].uiAttribs.hideParams === true
        ) {
          this._log.log("no hidden params in layout and doc");
          // no hidden ports in layout and documentation
          continue;
        }
        const l = {
          type: op.portsIn[i].type,
          name: op.portsIn[i].name,
        };

        if (op.portsIn[i].uiAttribs.title)
          l.uititle = op.portsIn[i].uiAttribs.title;
        if (op.portsIn[i].uiAttribs.values)
          l.values = op.portsIn[i].uiAttribs.values;
        if (op.portsIn[i].uiAttribs.longPort)
          l.longPort = op.portsIn[i].uiAttribs.longPort;

        if (op.portsIn[i].uiAttribs.group)
          l.group = op.portsIn[i].uiAttribs.group;
        if (op.portsIn[i].uiAttribs.hidePort) continue;
        if (op.portsIn[i].type === portType.number) {
          if (op.portsIn[i].uiAttribs.display === "bool") l.subType = "boolean";
          else if (op.portsIn[i].uiAttribs.display === "boolnum")
            l.subType = "boolean";
          else if (op.portsIn[i].uiAttribs.type === "string")
            l.subType = "string";
          else if (op.portsIn[i].uiAttribs.increment === "integer")
            l.subType = "integer";
          else if (op.portsIn[i].uiAttribs.display === "dropdown")
            l.subType = "select box";
          else l.subType = "number";
        }

        if (op.portsIn[i].uiAttribs.objType)
          l.objType = op.portsIn[i].uiAttribs.objType;
        opObj.portsIn.push(l);
      }

      for (i = 0; i < op.portsOut.length; i++) {
        const l = {
          type: op.portsOut[i].type,
          name: op.portsOut[i].name,
        };

        if (op.portsOut[i].uiAttribs.title)
          l.uititle = op.portsOut[i].uiAttribs.title;
        if (op.portsOut[i].uiAttribs.longPort)
          l.longPort = op.portsOut[i].uiAttribs.longPort;

        if (op.portsOut[i].uiAttribs.hidePort) continue;
        if (op.portsOut[i].type == portType.number) {
          if (op.portsOut[i].uiAttribs.display === "bool") l.subType = "boolean";
          else if (op.portsOut[i].uiAttribs.display === "boolnum")
            l.subType = "boolean";
          else if (op.portsOut[i].uiAttribs.type === "string")
            l.subType = "string";
          else if (op.portsOut[i].uiAttribs.display === "dropdown")
            l.subType = "dropdown";
          else if (op.portsOut[i].uiAttribs.display === "file") l.subType = "url";
          else l.subType = "number";
        }

        if (op.portsOut[i].uiAttribs.objType)
          l.objType = op.portsOut[i].uiAttribs.objType;
        opObj.portsOut.push(l);
      }

      return opObj;
    }

    _saveOpLayout(op) {
      if (!op) {
        this._log.error("saveoplayout: no op!");
        return;
      }

      const opObj = this._getOpLayout(op);

      // check if layout has changed...
      const l = Gui$1.gui.opDocs.getOpDocById(op.opId);
      if (JSON.stringify(l.layout) == JSON.stringify(opObj)) return false; // has not changed

      platform.talkerAPI.send(
        "opSaveLayout",
        {
          opname: op.opId,
          layout: opObj,
        },
        (err, res) => {
          if (err) this._log.error(err);
        },
      );
      return true; // has changed
    }

    /**
     * @param {string} opIdentifier
     * @param {function} next
     * @param {object} options
     */
    execute(opIdentifier, next, options) {
      options = options || {};
      Gui$1.gui.savedState.pause();

      let oldOps = null;
      if (opIdentifier.indexOf(".") > 0) {
        oldOps = Gui$1.gui.corePatch().getOpsByObjName(opIdentifier);
      } else {
        oldOps = Gui$1.gui.corePatch().getOpsByOpId(opIdentifier);
      }

      let name = opIdentifier;
      if (oldOps.length > 0) name = oldOps[0].objName;

      for (let i = 0; i < oldOps.length; i++) {
        if (oldOps[i].uiAttribs) delete oldOps[i].uiAttribs.uierrors;
      }

      Gui$1.gui.jobs().start({ id: "executeop" });

      // const oldLayout = Gui.gui.opDocs.getOpDocById(oldOps[0].opId); //d.......
      this.loadOpDependencies(
        name,
        () => {
          Gui$1.gui.corePatch().reloadOp(
            name,
            (num, newOps) => {
              for (let i = 0; i < newOps.length; i++)
                if (newOps[i].checkLinkTimeWarnings)
                  newOps[i].checkLinkTimeWarnings();

              if (newOps.length > 0) {
                this.saveOpLayout(newOps[0]);
              }
              Gui$1.gui.corePatch().emitEvent("opReloaded", name, newOps[0]);
              // Gui.gui.emitEvent("opReloaded", name, newOps[0]);
              Gui$1.gui.jobs().finish("executeop");

              Gui$1.gui.savedState.resume();
              if (next) next(newOps, options.refOldOp);
            },
            options.refOldOp,
          );
        },
        true,
      );
    }

    clone(oldname, name, cb, options) {
      options = options || { openEditor: true };

      // const loadingModal = options.loadingModal || Gui.gui.startModalLoading("Cloning op...");
      Gui$1.gui.savingTitleAnimStart("Cloning Op...");

      // loadingModal.setTask("cloning " + oldname + " to " + name);

      const cloneRequest = {
        opname: oldname,
        name: name,
      };
      if (options.opTargetDir) cloneRequest.opTargetDir = options.opTargetDir;

      platform.talkerAPI.send("opClone", cloneRequest, (err, res) => {
        if (err) {
          this._log.log("err res", res);
          // Gui.gui.endModalLoading();
          Gui$1.gui.savingTitleAnimEnd();

          CABLES.UI.MODAL.showError("Could not clone op", "");

          return;
        }

        const finished = () => {
          this.loadOp(res, () => {
            if (options.openEditor) this.edit(name);

            // loadingModal.setTask("loading new op: " + name);
            Gui$1.gui.serverOps.execute(name, () => {
              Gui$1.gui.opSelect().reload();
              Gui$1.gui.savingTitleAnimEnd();
              if (cb) cb();
            });
          });
        };

        if (
          res &&
          res.attachments &&
          res.attachments[subPatchOpUtil.blueprintSubpatchAttachmentFilename]
        ) {
          // subpatch op
          const sub = JSON.parse(
            res.attachments[subPatchOpUtil.blueprintSubpatchAttachmentFilename],
          );

          CABLES.Patch.replaceOpIds(sub, {
            oldIdAsRef: true,
          });

          platform.talkerAPI.send(
            "opAttachmentSave",
            {
              opname: name,
              name: subPatchOpUtil.blueprintSubpatchAttachmentFilename,
              content: JSON.stringify(sub),
            },
            (errr, re) => {
              if (re && re.data && re.data.updated)
                Gui$1.gui.patchView.store.setServerDate(re.data.updated);
              finished();
            },
          );
        } else {
          finished();
        }
      });
    }

    addOpLib(opName, libName, next) {
      if (libName === "---") return;
      platform.talkerAPI.send(
        "opAddLib",
        {
          opname: opName,
          name: libName,
        },
        (err, res) => {
          if (err) {
            if (err.msg === "NO_OP_RIGHTS") {
              let html = "";
              html +=
                "you are not allowed to add libraries to this op.<br/><br/>";
              html += "to modify this op, try cloning it";
              new ModalDialog({
                title: "error adding library",
                showOkButton: true,
                html: html,
              });
            } else {
              let html = "";
              html += err.msg + "<br/><br/>";
              new ModalDialog({
                title: "error adding library",
                showOkButton: true,
                html: html,
              });
            }
          } else {
            Gui$1.gui.serverOps.loadOpDependencies(
              opName,
              () => {
                this._log.log("lib added!", opName, libName);
                Gui$1.gui.emitEvent("refreshManageOp", opName);
                if (next) next();
              },
              true,
            );
          }
        },
      );
    }

    removeOpLib(opName, libName, next) {
      const modal = new ModalDialog({
        title: "Really remove library from op?",
        text: "Delete " + libName + " from " + opName + "?",
        choice: true,
      });
      modal.on("onSubmit", () => {
        platform.talkerAPI.send(
          "opRemoveLib",
          {
            opname: opName,
            name: libName,
          },
          (err, res) => {
            if (err) {
              CABLES.UI.MODAL.showError(
                "ERROR",
                "unable to remove library: " + err.msg,
              );
            } else {
              Gui$1.gui.serverOps.loadOpDependencies(
                opName,
                () => {
                  this._log.log("lib removed!", opName, libName);
                  Gui$1.gui.emitEvent("refreshManageOp", opName);
                  if (next) next();
                },
                true,
              );
            }
          },
        );
      });
    }

    addCoreLib(opName, libName, next, options = {}) {
      if (libName === "---") return;

      platform.talkerAPI.send(
        "opAddCoreLib",
        {
          opname: opName,
          name: libName,
        },
        (err, res) => {
          if (err) {
            if (err.msg === "NO_OP_RIGHTS") {
              let html = "";
              html +=
                "you are not allowed to add libraries to this op.<br/><br/>";
              html += "to modify this op, try cloning it";
              new ModalDialog({
                title: "error adding core-lib",
                showOkButton: true,
                html: html,
              });
            } else {
              let html = "";
              html += err.msg + "<br/><br/>";
              new ModalDialog({
                title: "error adding core-lib",
                showOkButton: true,
                html: html,
              });
            }
          } else {
            Gui$1.gui.serverOps.loadOpDependencies(
              opName,
              () => {
                this._log.log("corelib added!", opName, libName);

                Gui$1.gui.emitEvent("refreshManageOp", opName);
                if (next) next();
              },
              true,
            );
          }
        },
      );
    }

    removeCoreLib(opName, libName, next) {
      const modal = new ModalDialog({
        title: "Really remove corelib from op?",
        text: "Delete " + libName + " from " + opName + "?",
        choice: true,
      });
      modal.on("onSubmit", () => {
        platform.talkerAPI.send(
          "opRemoveCoreLib",
          {
            opname: opName,
            name: libName,
          },
          (err, res) => {
            if (err) {
              CABLES.UI.MODAL.showError(
                "ERROR",
                "unable to remove corelib: " + err.msg,
              );
            } else {
              Gui$1.gui.serverOps.loadOpDependencies(
                opName,
                () => {
                  this._log.log("corelib removed!", opName, libName);
                  Gui$1.gui.emitEvent("refreshManageOp", opName);

                  if (next) next();
                },
                true,
              );
            }
          },
        );
      });
    }

    addOpDependency(opName, depSrc, depType, exportName, next = null) {
      if (!opName || !depSrc || !depType) return;

      Gui$1.gui.jobs().start({
        id: "addOpDependency",
        title: "adding " + depSrc + " to " + opName,
      });
      platform.talkerAPI.send(
        "addOpDependency",
        {
          opName: opName,
          src: depSrc,
          type: depType,
          export: exportName,
        },
        (err, res) => {
          Gui$1.gui.jobs().finish("addOpDependency");

          if (err) {
            if (err.msg === "NO_OP_RIGHTS") {
              let html = "";
              html +=
                "You are not allowed to add dependencies to this op.<br/><br/>";
              html += "to modify this op, try cloning it";
              new ModalDialog({
                title: "Error adding op-dependency",
                showOkButton: true,
                html: html,
              });
            } else if (err.msg === "NPM_ERROR" && err.data) {
              const opText =
                err.data.opName || opName
                  ? " for " + err.data.opName || opName
                  : "";
              this._log.error(
                "failed dependency " + opText + ": " + err.data.stderr,
              );
            } else if (
              err.msg === "FAILED_TO_ADD_DEPENDENCY" &&
              depType === "op"
            ) {
              this._log.error(
                "failed op dependency for " + opName + ": " + depSrc,
              );
            } else {
              this._log.error(err.msg, err);
            }
          }
          Gui$1.gui.serverOps.loadOpDependencies(
            opName,
            (op) => {
              this._log.info("op-dependency added: " + opName + " " + depSrc);
              if (res && res.data && res.data.stdout)
                this._log.info("npm: " + res.data.stdout);
              Gui$1.gui.emitEvent("refreshManageOp", opName);
              if (next) next(null, op);
            },
            true,
          );
        },
      );
    }

    removeOpDependency(opName, depSrc, depType, next = null) {
      const modal = new ModalDialog({
        title: "Really remove dependency from op?",
        text: "Delete " + depSrc + " from " + opName + "?",
        choice: true,
      });
      modal.on("onSubmit", () => {
        Gui$1.gui.jobs().start({
          id: "removeOpDependency",
          title: "removing " + depSrc + " from " + opName,
        });
        platform.talkerAPI.send(
          "removeOpDependency",
          {
            opName: opName,
            src: depSrc,
            type: depType,
          },
          (err, res) => {
            Gui$1.gui.jobs().finish("removeOpDependency");
            if (err) {
              this._log.warn("unable to remove op-dependency: " + err.msg);
              Gui$1.gui.emitEvent("refreshManageOp", opName);
            } else {
              Gui$1.gui.serverOps.loadOpDependencies(
                opName,
                () => {
                  this._log.log("op-dependency removed!", opName, depSrc);
                  Gui$1.gui.emitEvent("refreshManageOp", opName);

                  if (next) next();
                },
                true,
              );
            }
          },
        );
      });
    }

    deleteAttachment(opName, opId, attName) {
      const modal = new ModalDialog({
        title: "Delete attachment from op?",
        text: "Delete " + attName + " from " + opName + "?",
        choice: true,
      });
      modal.on("onSubmit", () => {
        platform.talkerAPI.send(
          "opAttachmentDelete",
          {
            opname: opId,
            name: attName,
          },
          (err, res) => {
            if (err) {
              this.showApiError(err);
              return;
            }

            if (res && res.data && res.data.name) {
              const opDoc = Gui$1.gui.opDocs.getOpDocByName(opName);
              if (opDoc) {
                if (opDoc.attachmentFiles)
                  opDoc.attachmentFiles = opDoc.attachmentFiles.filter((att) => {
                    return att !== res.data.name;
                  });
              }
            }

            Gui$1.gui.emitEvent("refreshManageOp", opName);

            if (err) {
              CABLES.UI.MODAL.showError(
                "ERROR",
                "unable to remove attachment: " + err.msg,
              );
            }
          },
        );
      });
    }

    addAttachmentDialog(opName) {
      let opid = opName;
      const docs = Gui$1.gui.opDocs.getOpDocByName(opName);
      if (docs && docs) opid = docs.id;

      let html =
        "Use this attachment in " +
        opName +
        ' by accessing <code>attachments["my_attachment"]</code>.';
      new ModalDialog({
        title: "Create attachment",
        text: html,
        prompt: true,
        promptOk: (attName) => {
          platform.talkerAPI.send(
            "opAttachmentAdd",
            {
              opname: opid,
              name: attName,
            },
            (err, res) => {
              if (err) {
                this.showApiError(err);
                return;
              }

              if (res && res.data && res.data.name) {
                const opDoc = Gui$1.gui.opDocs.getOpDocByName(opName);
                if (opDoc) {
                  if (!opDoc.attachmentFiles) opDoc.attachmentFiles = [];
                  if (
                    opDoc.attachmentFiles &&
                    !opDoc.attachmentFiles.includes(res.data.name)
                  )
                    opDoc.attachmentFiles.push(res.data.name);
                }
              }

              this.editAttachment(opName, "att_" + attName);
              Gui$1.gui.emitEvent("refreshManageOp", opName);
            },
          );
        },
      });
    }

    testServer() {
      let opname = platform.getPatchOpsNamespace() + "test_" + CABLES.shortId();
      let attachmentName = "att_test.js";

      const cont = "// " + CABLES.uuid();

      const atts = {};
      atts[attachmentName] = cont;

      CABLES.shittyTest = CABLES.shittyTest || 1;

      platform.talkerAPI.send(
        "opCreate",
        {
          opname: opname,
        },
        (err3, res) => {
          platform.talkerAPI.send(
            "opUpdate",
            {
              opname: opname,
              update: {
                attachments: atts,
              },

              /*
               * "name": attachmentName,
               * "content": cont,
               */
            },
            (err) => {
              if (err) {
                this.showApiError(err);
              }

              platform.talkerAPI.send(
                "opAttachmentGet",
                {
                  opname: opname,
                  name: attachmentName,
                },
                (err2, res2) => {
                  if (err2) {
                    this.showApiError(err);
                    return;
                  }

                  if (res.content.trim() != cont.trim())
                    this._log.error("response", res.content, cont);
                  else this._log.log("ok");

                  CABLES.shittyTest++;
                  if (CABLES.shittyTest < 30)
                    setTimeout(() => {
                      this.testServer();
                    }, 100);
                  else CABLES.shittyTest = 0;
                },
              );
            },
          );
        },
      );
    }

    /**
     * @param {{}} options
     * @param {string} options.title title of the dialog
     * @param {string} options.shortName shortname of the new op
     * @param {string} options.type type of op (patch/user/team/...)
     * @param {string} options.suggestedNamespace suggested namespace in dropdown
     * @param {boolean} options.showReplace show "create and replace existing" button
     * @param {string|null} options.sourceOpName opname to clone from or create op into
     * @param {function} cb
     */
    opNameDialog(options, cb) {
      const newName = options.sourceOpName || options.shortName;
      let opTargetDir = null;
      const _checkOpName = () => {
        if (!platform.isTrustedPatch()) {
          new ModalDialog({
            title: "Untrusted Patch",
            text: "You need write access in the patch to create ops<br/>Try creating a new patch and try there again",
            showOkButton: true,
          });
          return;
        }

        const checkNameRequest = {
          namespace: options.suggestedNamespace,
          v: newName,
          sourceName: options.sourceOpName,
          rename: options.rename,
        };
        if (opTargetDir) checkNameRequest.opTargetDir = opTargetDir;
        platform.talkerAPI.send(
          "checkOpName",
          checkNameRequest,
          (err, initialRes) => {
            if (err) {
              this.showApiError(err);
              return;
            }

            const modalDialog = new ModalDialog({
              title: options.title,
              text: html,
            });

            if (platform.frontendOptions.hasOpDirectories) {
              ele.clickables(
                modalDialog.getElement(),
                ".clickable",
                (event, dataset) => {
                  const selectElement = ele.byId("opTargetDir");
                  const selectedDir = ele.getSelectValue(selectElement);
                  switch (event.currentTarget.id) {
                    case "addOpTargetDir":
                      platform.talkerAPI.send(
                        "addProjectOpDir",
                        {},
                        (dirErr, dirRes) => {
                          if (!dirErr) {
                            if (selectElement) {
                              selectElement.length = 0;
                              dirRes.forEach((dir, i) => {
                                const selected = i === 0;
                                selectElement.add(
                                  new Option(dir, dir, selected, selected),
                                );
                                if (selected) opTargetDir = dir;
                              });
                            }
                          } else {
                            new ModalDialog({
                              showOkButton: true,
                              warning: true,
                              title: "Warning",
                              text: dirErr.msg,
                            });
                            this._log.info(dirErr.msg);
                          }
                        },
                      );
                      break;
                    case "openOpTargetDir":
                    default:
                      platform.talkerAPI.send("openDir", { dir: selectedDir });
                      break;
                  }
                },
              );
            }

            const opNameInput = ele.byId("opNameDialogInput");
            const checkedName = initialRes.checkedName || options.sourceOpName;
            if (opNameInput.value !== checkedName) {
              opNameInput.value = checkedName;
            }
            _updateFormFromApi(initialRes, checkedName);

            if (opNameInput.value) {
              const parts = opNameInput.value.split(".");
              let lastPartLength = parts[parts.length - 1].length;
              if (parts.length > 1) {
                opNameInput.setSelectionRange(
                  opNameInput.value.length - lastPartLength,
                  opNameInput.value.length,
                );
                opNameInput.focus();
              }
            }

            opNameInput.addEventListener("input", _nameChangeListener);
            ele
              .byId("opNameDialogNamespace")
              .addEventListener("input", _namespaceChangeListener);
            const opTargetDirEle = ele.byId("opTargetDir");
            if (opTargetDirEle) {
              opTargetDirEle.addEventListener("change", () => {
                if (opTargetDirEle) {
                  opTargetDir = opTargetDirEle.value;
                } else {
                  opTargetDir = null;
                }
                _nameChangeListener();
              });
            }

            const cbOptions = {
              replace: false,
            };

            ele.clickable(ele.byId("opNameDialogSubmit"), () => {
              if (opTargetDir) cbOptions.opTargetDir = opTargetDir;
              cb(
                ele.byId("opNameDialogNamespace").value,
                capitalize(opNameInput.value),
                cbOptions,
              );
            });

            if (options.showReplace) {
              ele.clickable(ele.byId("opNameDialogSubmitReplace"), (event) => {
                cbOptions.replace = true;
                if (opTargetDir) cbOptions.opTargetDir = opTargetDir;
                cb(
                  ele.byId("opNameDialogNamespace").value,
                  capitalize(opNameInput.value),
                  cbOptions,
                );
              });
            }
          },
        );
      };

      let html = "";

      if (!platform.isElectron())
        html +=
          'Want to share your op between patches and/or people? <a href="' +
          platform.getCablesUrl() +
          '/myteams" target="_blank">create a team</a><br/><br/>';

      html += "New op name:<br/><br/>";
      html +=
        '<div class="clone"><input type="text" id="opNameDialogInput" value="' +
        options.sourceOpName +
        '" placeholder="' +
        platform.getDefaultOpName() +
        '" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>';
      html += "&nbsp;";
      html += '<select class="left" id="opNameDialogNamespace"></select><br/>';
      html += "</div><br/><br/>";
      html += '<div id="opcreateerrors" class="hidden issues" ></div>';
      html += '<div id="opNameDialogHints" class="hidden hints"></div>';
      html += '<div id="opNameDialogConsequences" class="consequences"></div>';
      html += "<br/><br/>";
      if (options.rename) {
        html +=
          '<a tabindex="0" id="opNameDialogSubmit" class="bluebutton hidden">Rename Op</a>';
      } else {
        html +=
          '<a tabindex="0" id="opNameDialogSubmit" class="bluebutton hidden">Create Op</a>';
      }
      html +=
        '<a tabindex="0" id="opNameDialogSubmitReplace" class="button hidden">Create and replace existing</a>';
      html += "<br/><br/>";

      if (options.hasOpDirectories) {
        platform.talkerAPI.send("getProjectOpDirs", {}, (err, res) => {
          let opDirSelect = "Choose op directory:<br/><br/>";
          opDirSelect += '<select id="opTargetDir" name="opTargetDir">';
          for (let i = 0; i < res.data.length; i++) {
            const dirInfo = res.data[i];
            if (i === 0) opTargetDir = dirInfo.dir;
            opDirSelect +=
              '<option value="' + dirInfo.dir + '">' + dirInfo.dir + "</option>";
          }
          opDirSelect += "</select>";
          opDirSelect +=
            '&nbsp;<a id="addOpTargetDir" class="button-small button-icon tt info clickable" data-info="add op dir" data-tt="add op dir"><span class="icon icon-file-plus"></span></a>\n';
          opDirSelect +=
            '&nbsp;<a id="openOpTargetDir" class="button-small button-icon tt info clickable" data-info="open dir" data-tt="open dir"><span class="icon icon-folder"></span></a>\n';
          opDirSelect += "<hr/>";
          html = opDirSelect + html;
          _checkOpName();
        });
      } else {
        _checkOpName();
      }

      const _namespaceChangeListener = () => {
        const opNameInput = ele.byId("opNameDialogInput");
        const selectEle = ele.byId("opNameDialogNamespace");

        if (selectEle.value && namespace$1.isNamespaceNameValid(selectEle.value)) {
          const opName = opNameInput.value;
          const opBasename = opName.substring(opName.lastIndexOf(".") + 1);
          const newNamespace = selectEle.value;
          const newOpName = newNamespace + opBasename;
          if (opNameInput) {
            opNameInput.value = newOpName;
            _nameChangeListener();
          }
        }
      };

      const _nameChangeListener = () => {
        const newNamespace = ele.byId("opNameDialogNamespace").value;
        let nameInput = ele.byId("opNameDialogInput").value;

        const opUsername = Gui$1.gui.user ? Gui$1.gui.user.usernameLowercase : "";
        const nameParts = nameInput.split(".");
        const capitalizedParts = nameParts.map((part) => {
          if (opUsername && part === opUsername) return part; // username is the only part of ops that can be lowercase
          return capitalize(part);
        });
        const fullName = capitalizedParts.join(".");

        ele.hide(ele.byId("opNameDialogSubmit"));
        ele.hide(ele.byId("opNameDialogSubmitReplace"));

        if (fullName) {
          const checkNameRequest = {
            namespace: newNamespace,
            v: fullName,
            sourceName: options.sourceOpName,
            rename: options.rename,
          };
          const opTargetDirEle = ele.byId("opTargetDir");
          if (opTargetDirEle) checkNameRequest.opTargetDir = opTargetDirEle.value;

          Gui$1.gui.jobs().start({
            id: "checkOpName" + fullName,
            title: "checking op name" + fullName,
          });

          platform.talkerAPI.send("checkOpName", checkNameRequest, (err, res) => {
            if (err) {
              if (!res) res = {};
              if (!res.problems) res.problems = [];
              if (!res.checkedName) res.checkedName = fullName;
              res.problems.push("failed to check op-name with api, try again");
            }

            if (res.checkedName && res.checkedName === fullName) {
              _updateFormFromApi(res, fullName, newNamespace);
            }
            Gui$1.gui.jobs().finish("checkOpName" + fullName);
          });
        }
      };

      const _updateFormFromApi = (res, newOpName, newNamespace = null) => {
        let hintsHtml = "";
        const eleHints = ele.byId("opNameDialogHints");
        const inputField = ele.byId("opNameDialogInput");

        if (eleHints) ele.hide(eleHints);
        if (res.hints && res.hints.length > 0) {
          hintsHtml += "<ul>";
          res.hints.forEach((hint) => {
            hintsHtml += "<li>" + hint + "</li>";
          });
          hintsHtml += "</ul>";

          if (eleHints) {
            eleHints.innerHTML = "<h3>Hints</h3>" + hintsHtml;
            ele.show(eleHints);
          }
        }

        let consequencesHtml = "";
        const eleCons = ele.byId("opNameDialogConsequences");
        if (eleCons) ele.hide(eleCons);
        if (res.consequences && res.consequences.length > 0) {
          consequencesHtml += "<ul>";
          res.consequences.forEach((consequence) => {
            consequencesHtml += "<li>" + consequence + "</li>";
          });
          consequencesHtml += "</ul>";

          if (eleCons) {
            eleCons.innerHTML = "<h3>Consequences</h3>" + consequencesHtml;
            ele.show(eleCons);
          }
        }

        if (newOpName) {
          if (res.problems.length > 0) {
            let htmlIssue = "<h3>Issues</h3>";
            htmlIssue += "<ul>";
            for (let i = 0; i < res.problems.length; i++)
              htmlIssue += "<li>" + res.problems[i] + "</li>";
            htmlIssue += "</ul>";
            const errorsEle = ele.byId("opcreateerrors");
            errorsEle.innerHTML = htmlIssue;
            ele.hide(ele.byId("opNameDialogSubmit"));
            ele.hide(ele.byId("opNameDialogSubmitReplace"));
            errorsEle.classList.remove("hidden");

            const versionSuggestions =
              errorsEle.querySelectorAll(".versionSuggestion");
            if (versionSuggestions)
              versionSuggestions.forEach((suggest) => {
                if (suggest.dataset.nextName) {
                  suggest.addEventListener("pointerdown", (e) => {
                    inputField.value = capitalize(suggest.dataset.nextName);
                    _nameChangeListener();
                  });
                }
              });
          } else {
            ele.byId("opcreateerrors").innerHTML = "";
            ele.byId("opcreateerrors").classList.add("hidden");
            ele.show(ele.byId("opNameDialogSubmit"));
            if (options.showReplace)
              ele.show(ele.byId("opNameDialogSubmitReplace"));
          }
        }

        const namespaceEle = ele.byId("opNameDialogNamespace");
        namespaceEle.innerHTML = "";
        if (res.namespaces) {
          res.namespaces.forEach((ns) => {
            const option = document.createElement("option");
            option.value = ns;
            option.text = ns;
            if (newNamespace && ns === newNamespace) option.selected = true;
            namespaceEle.add(option);
          });
        }

        ele.byId("opNameDialogInput").focus();
      };
    }

    createDialog(name, options) {
      options = options || {};
      if (!options.hasOwnProperty("showEditor")) options.showEditor = true;

      if (Gui$1.gui.project().isOpExample) {
        notifyError("Not possible in op example patch!");
        return;
      }

      let suggestedNamespace = platform.getPatchOpsNamespace();

      const dialogOptions = {
        title: "Create operator",
        shortName: name || platform.getDefaultOpName(),
        type: "patch",
        suggestedNamespace: suggestedNamespace,
        showReplace: false,
        sourceOpName: null,
        hasOpDirectories: platform.frontendOptions.hasOpDirectories,
      };

      this.opNameDialog(dialogOptions, (newNamespace, newName, cbOptions) => {
        let opname = newName;
        this.create(
          opname,
          (newOp) => {
            Gui$1.gui.closeModal();

            opname = newOp && newOp.name ? newOp.name : opname;

            Gui$1.gui.serverOps.loadOpDependencies(opname, function () {
              // add new op
              Gui$1.gui.patchView.addOp(opname, {
                onOpAdd: (op) => {
                  op.setUiAttrib({
                    translate: {
                      x: Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchX,
                      y: Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchY,
                    },
                  });

                  if (op) Gui$1.gui.patchView.focusOp(op.id);
                  if (op)
                    Gui$1.gui.patchView.patchRenderer.viewBox.animateScrollTo(
                      Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchX,
                      Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchY,
                    );
                  if (options.cb) options.cb(op);
                },
              });
            });
          },
          options.showEditor,
          cbOptions,
        );
      });
    }

    renameDialogIframe(opName) {
      if (!platform.isTrustedPatch()) {
        new ModalDialog({
          title: "You need write access in the patch to rename ops",
          showOkButton: true,
        });
        return;
      }

      const iframeSrc =
        platform.getCablesUrl() +
        "/op/rename?iframe=true&op=" +
        opName +
        "&new=" +
        opName;
      const modal = new ModalIframe({
        title: "Rename Op",
        src: iframeSrc,
      });
      const iframeEle = modal.iframeEle;
      const talkerAPI = new TalkerAPI(iframeEle.contentWindow);
      const renameListenerId = talkerAPI.addEventListener(
        "opRenamed",
        (newOp) => {
          talkerAPI.removeEventListener(renameListenerId);
          const renameDoneListenerId = talkerAPI.addEventListener(
            "closeRenameDialog",
            () => {
              talkerAPI.removeEventListener(renameDoneListenerId);
              Gui$1.gui.closeModal();
            },
          );
          this._afterOpRename(newOp);
        },
      );
    }

    // rename dialog for non-api platforms like electron
    renameDialog(oldName) {
      if (!platform.frontendOptions.opRenameInEditor) return;

      if (Gui$1.gui.showGuestWarning()) return;

      this._log.log("renamedialog");

      let name = "";
      let parts = oldName.split(".");
      if (parts) name = parts[parts.length - 1];
      let suggestedNamespace = namespace$1.getNamespace(oldName);

      const dialogOptions = {
        title: "Rename operator",
        shortName: name,
        type: "patch",
        suggestedNamespace: suggestedNamespace,
        showReplace: false,
        sourceOpName: oldName,
        rename: true,
        hasOpDirectories: false,
      };

      this.opNameDialog(dialogOptions, (newNamespace, newName, cbOptions) => {
        const opname = newName;

        let nameOrId = oldName;
        const doc = Gui$1.gui.opDocs.getOpDocByName(oldName);
        if (doc && doc.id) nameOrId = doc.id;
        cbOptions = cbOptions || { openEditor: true };
        const renameRequest = {
          opname: nameOrId,
          name: opname,
          namespace: newNamespace,
        };
        if (cbOptions.opTargetDir)
          renameRequest.opTargetDir = cbOptions.opTargetDir;

        platform.talkerAPI.send("opRename", renameRequest, (err, res) => {
          if (err) {
            this._log.log("err res", res);
            CABLES.UI.MODAL.showError("Could not rename op", "");
          } else {
            Gui$1.gui.closeModal();
            this._afterOpRename(res.data);
          }
        });
      });
    }

    deleteDialog(opName) {
      if (!platform.frontendOptions.opDeleteInEditor) return;

      if (Gui$1.gui.showGuestWarning()) return;

      const modal = new ModalDialog({
        title: "Really delete op?",
        text: "Delete " + opName + "?",
        choice: true,
      });
      modal.on("onSubmit", () => {
        platform.talkerAPI.send("opDelete", { opName: opName }, (err, res) => {
          if (err) {
            new ModalDialog({
              title: "Failed to delete op",
              text: err.message,
            });
          } else {
            const patch = Gui$1.gui.corePatch();
            const ops = patch.getOpsByObjName(opName);
            ops.forEach((op) => {
              patch.deleteOp(op.id, true);
            });
          }
        });
      });
    }

    _deletePropertyByPath(obj, path) {
      if (!obj || !path) {
        return;
      }

      if (typeof path === "string") {
        path = path.split(".");
      }

      for (let i = 0; i < path.length - 1; i++) {
        obj = obj[path[i]];

        if (typeof obj === "undefined") {
          return;
        }
      }

      delete obj[path.pop()];
    }

    _afterOpRename(newOp) {
      this._log.info("renamed op" + newOp.objName + "to" + newOp.oldName);
      this.loadOp(
        newOp,
        () => {
          let properties = newOp.oldName.split(".");
          properties.shift();
          const path = properties.join(".");
          this._deletePropertyByPath(Ops, path);
          const usedOps = Gui$1.gui.corePatch().getOpsByOpId(newOp.opId);
          usedOps.forEach((usedOp) => {
            Gui$1.gui.patchView.replaceOp(usedOp.id, newOp.objName);
          });
          Gui$1.gui.opSelect().reload();
          Gui$1.gui.opSelect().prepare();
        },
        true,
      );
    }

    cloneDialog(oldName, origOp) {
      if (Gui$1.gui.showGuestWarning()) return;

      if (Gui$1.gui.project().isOpExample) {
        notifyError("Not possible in op example patch!");
        return;
      }

      let name = "";
      let parts = oldName.split(".");
      if (parts) name = parts[parts.length - 1];
      let suggestedNamespace = platform.getPatchOpsNamespace();
      if (namespace$1.isTeamOp(oldName))
        suggestedNamespace = namespace$1.getNamespace(oldName);

      const dialogOptions = {
        title: "Clone operator",
        shortName: name,
        type: "patch",
        suggestedNamespace: suggestedNamespace,
        showReplace: true,
        sourceOpName: oldName,
        hasOpDirectories: platform.frontendOptions.hasOpDirectories,
      };

      this.opNameDialog(dialogOptions, (newNamespace, newName, cbOptions) => {
        const opname = newName;

        let nameOrId = oldName;
        const doc = Gui$1.gui.opDocs.getOpDocByName(oldName);

        if (doc && doc.id) nameOrId = doc.id;

        Gui$1.gui.serverOps.clone(
          nameOrId,
          opname,
          () => {
            Gui$1.gui.closeModal();

            Gui$1.gui.serverOps.loadOpDependencies(opname, function () {
              if (cbOptions && cbOptions.replace) {
                // replace existing ops
                const ops = Gui$1.gui.corePatch().getOpsByObjName(oldName);
                for (let i = 0; i < ops.length; i++) {
                  Gui$1.gui.patchView.replaceOp(ops[i].id, opname);
                }
              } else {
                // add new op
                Gui$1.gui.patchView.addOp(opname, {
                  onOpAdd: (op) => {
                    op.setUiAttrib({
                      translate: {
                        x: Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchX,
                        y: Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchY,
                      },
                    });

                    if (op) {
                      if (origOp) Gui$1.gui.patchView.copyOpInputPorts(origOp, op);

                      Gui$1.gui.patchView.focusOp(op.id);
                      Gui$1.gui.patchView.patchRenderer.viewBox.animateScrollTo(
                        Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchX,
                        Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchY,
                      );
                    }
                  },
                });
              }
            });
          },
          { opTargetDir: cbOptions.opTargetDir },
        );
      });
    }

    editAttachment(op, attachmentName, readOnly, cb, fromListener = false) {
      let opname = op;
      let opId = opname;

      if (typeof opname == "object") {
        opname = op.objName;
        opId = op.opId;
      } else {
        const docs = Gui$1.gui.opDocs.getOpDocByName(opname);
        if (docs) opId = docs.id;
        else this._log.warn("could not find opid for ", opname);
      }

      const parts = opname.split(".");
      const shortname = parts[parts.length - 1];
      const title = shortname + "/" + attachmentName;
      const userInteraction = !fromListener;

      let existingTab = Gui$1.gui.maintabPanel.tabs.getTabByTitle(title);
      if (existingTab) {
        Gui$1.gui.mainTabs.activateTabByName(existingTab.title);
        Gui$1.gui.maintabPanel.show(true);
        return;
      }

      let editorObj = null;
      Gui$1.gui.jobs().start({
        id: "load_attachment_" + attachmentName,
        title: "loading attachment " + attachmentName,
      });

      const apiParams = {
        opname: opId,
        name: attachmentName,
      };
      let syntax = "text";

      if (attachmentName.endsWith(".wgsl") || attachmentName.endsWith("_wgsl"))
        syntax = "glsl";
      if (attachmentName.endsWith(".glsl") || attachmentName.endsWith("_glsl"))
        syntax = "glsl";
      if (attachmentName.endsWith(".frag") || attachmentName.endsWith("_frag"))
        syntax = "glsl";
      if (attachmentName.endsWith(".vert") || attachmentName.endsWith("_vert"))
        syntax = "glsl";
      if (attachmentName.endsWith(".json") || attachmentName.endsWith("_json"))
        syntax = "json";
      if (attachmentName.endsWith(".js") || attachmentName.endsWith("_js"))
        syntax = "js";
      if (attachmentName.endsWith(".css") || attachmentName.endsWith("_css"))
        syntax = "css";

      const lastTab = UserSettings.userSettings.get("editortab");
      let inactive = false;
      if (fromListener) if (lastTab !== title) inactive = true;

      let editorTab = new EditorTab({
        title: title,
        name: opId, // "content": content,
        loading: true,
        syntax: syntax,
        editorObj: editorObj,
        allowEdit: this.canEditAttachment(Gui$1.gui.user, opname),
        showSaveButton: true,
        inactive: inactive,
        onClose: (which) => {
          if (editorObj && editorObj.name)
            editorSession.remove(editorObj.type, editorObj.name);
        },
      });

      platform.talkerAPI.send(
        "opAttachmentGet",
        apiParams,
        (err, res) => {
          if (err) {
            this.showApiError(err);
            return;
          }

          Gui$1.gui.jobs().finish("load_attachment_" + attachmentName);

          if (err || !res || res.content === undefined) {
            if (err) this._log.log("[editAttachment] err", err);
            if (editorObj) editorSession.remove(editorObj.type, editorObj.name);
            return;
          }

          editorObj = editorSession.rememberOpenEditor(
            "attachment",
            title,
            {
              opname: opname,
              opid: opId,
              name: attachmentName,
            },
            true,
          );

          if (err || !res || res.content == undefined) {
            if (err) this._log.log("[editAttachment] err", err);
            if (editorObj) editorSession.remove(editorObj.type, editorObj.name);
            return;
          }
          const content = res.content || "";
          editorTab.setContent(content);

          if (editorObj) {
            editorTab.on("save", (_setStatus, _content) => {
              Gui$1.gui.savingTitleAnimStart("Saving Attachment...");
              platform.talkerAPI.send(
                "opAttachmentSave",
                {
                  opname: opId,
                  name: attachmentName,
                  content: _content,
                },
                (errr, re) => {
                  if (platform.warnOpEdit(opname))
                    notifyError("WARNING: op editing on live environment");

                  if (errr) {
                    notifyError("error: op not saved");
                    this._log.warn("[opAttachmentSave]", errr);
                    return;
                  }

                  if (re && re.data && re.data.updated)
                    Gui$1.gui.patchView.store.setServerDate(re.data.updated);

                  _setStatus("saved");

                  if (
                    attachmentName ==
                    subPatchOpUtil.blueprintPortJsonAttachmentFilename
                  ) {
                    let ports = null;
                    try {
                      ports = JSON.parse(_content);
                    } catch (e) {
                      ports = { ports: [] };
                    }

                    subPatchOpUtil.savePortJsonSubPatchOpAttachment(
                      ports,
                      opname,
                      () => {
                        subPatchOpUtil.executeBlueprintIfMultiple(opname, () => {
                          Gui$1.gui.opParams.refresh();
                          Gui$1.gui.savingTitleAnimEnd();
                        });
                      },
                    );
                  } else
                    subPatchOpUtil.executeBlueprintIfMultiple(opname, () => {
                      Gui$1.gui.opParams.refresh();
                      Gui$1.gui.savingTitleAnimEnd();
                    });
                },
              );
            });
          }

          if (cb) cb();
          else Gui$1.gui.maintabPanel.show(userInteraction);
        },
        (err) => {
          Gui$1.gui.jobs().finish("load_attachment_" + attachmentName);
          this._log.error("error opening attachment " + attachmentName);
          this._log.log(err);
          if (editorObj) editorSession.remove(editorObj.type, editorObj.name);
        },
      );

      if (!editorObj) {
        Gui$1.gui.mainTabs.activateTabByName(title);
        Gui$1.gui.maintabPanel.show(userInteraction);
      }
    }

    // Shows the editor and displays the code of an op in it
    edit(op, readOnly, cb, userInteraction) {
      if (Gui$1.gui.isGuestEditor()) {
        CABLES.UI.MODAL.showError("Demo Editor", text.guestHint);
        return;
      }

      let opid = op;
      let opname = opid;

      if (typeof op == "object") {
        opid = op.opId;
        opname = op.objName;
      } else {
        const docs = Gui$1.gui.opDocs.getOpDocByName(op);
        if (!docs)
          return this._log.warn("[opsserver] could not find docs", op, opid);
        opid = docs.id;

        if (!opid)
          this._log.warn(
            "[opsserver]deprecated: use serverOps.edit with op not just opname!",
          );
      }

      if (!opname || opname == "") {
        this._log.log("UNKNOWN OPNAME ", opname);
        return;
      }

      Gui$1.gui.jobs().start({
        id: "load_opcode_" + opname,
        title: "loading op code " + opname,
      });

      const parts = opname.split(".");
      const title = "Op " + parts[parts.length - 1];
      const editorObj = editorSession.rememberOpenEditor("op", opname);
      let editorTab;

      if (editorObj) {
        editorTab = new EditorTab({
          title: title,
          name: editorObj.name,
          loading: true,
          singleton: true,
          syntax: "js",
          allowEdit: this.canEditOp(Gui$1.gui.user, editorObj.name),
          showSaveButton: true,
          editorObj: editorObj,
          onClose: (which) => {
            if (which.editorObj)
              editorSession.remove(which.editorObj.type, which.editorObj.name);
          },
        });

        platform.talkerAPI.send(
          "getOpCode",
          {
            opname: opid,
            projectId: this._patchId,
          },
          (er, rslt) => {
            Gui$1.gui.jobs().finish("load_opcode_" + opname);

            if (er) {
              notifyError("Error receiving op code!");
              editorTab.setContent("");
              editorSession.remove("op", opname);
              return;
            }
            editorTab.setContent(rslt.code);

            if (!readOnly && editorTab) {
              editorTab.on("save", (setStatus, content, editor) => {
                Gui$1.gui.savingTitleAnimStart("Saving Op...");

                platform.talkerAPI.send(
                  "saveOpCode",
                  {
                    opname: opid,
                    code: content,
                    format: UserSettings.userSettings.get("formatcode") || false,
                  },
                  (err, res) => {
                    const selOps = Gui$1.gui.patchView.getSelectedOps();
                    let selOpTranslate = null;
                    if (selOps && selOps.length > 0)
                      selOpTranslate = selOps[0].uiAttribs.translate;

                    if (err) {
                      Gui$1.gui.endModalLoading();
                      setStatus("Error: " + err.msg || "Unknown error");
                      return;
                    }

                    if (!res.success) {
                      Gui$1.gui.savingTitleAnimEnd();

                      if (res && res.error && res.error.line != undefined)
                        setStatus(
                          "Error: Line " +
                            res.error.line +
                            " : " +
                            res.error.message,
                          true,
                        );
                      else if (err)
                        setStatus("Error: " + err.msg || "Unknown error");
                    } else {
                      if (res.updated)
                        Gui$1.gui.patchView.store.setServerDate(res.updated);
                      if (platform.warnOpEdit(opname))
                        notifyError("WARNING: op editing on live environment");
                      if (!CABLES.Patch.getOpClass(opname))
                        Gui$1.gui.opSelect().reload();

                      Gui$1.gui.serverOps.execute(opid, () => {
                        setStatus("Saved " + opname);
                        editor.focus();

                        if (selOpTranslate)
                          for (let i = 0; i < Gui$1.gui.corePatch().ops.length; i++)
                            if (
                              Gui$1.gui.corePatch().ops[i].uiAttribs &&
                              Gui$1.gui.corePatch().ops[i].uiAttribs.translate &&
                              Gui$1.gui.corePatch().ops[i].uiAttribs.translate.x ==
                                selOpTranslate.x &&
                              Gui$1.gui.corePatch().ops[i].uiAttribs.translate.y ==
                                selOpTranslate.y
                            ) {
                              Gui$1.gui.opParams.show(
                                Gui$1.gui.corePatch().ops[i].id,
                              );
                              Gui$1.gui.patchView.setSelectedOpById(
                                Gui$1.gui.corePatch().ops[i].id,
                              );
                            }

                        Gui$1.gui.savingTitleAnimEnd();
                        Gui$1.gui.endModalLoading();
                      });
                    }
                  },
                  (result) => {
                    setStatus("ERROR: not saved - " + result.msg);
                    this._log.log("err result", result);

                    // Gui.gui.endModalLoading();
                    Gui$1.gui.savingTitleAnimEnd();
                  },
                );
              });
            }

            if (cb) cb();
            else Gui$1.gui.maintabPanel.show(userInteraction);
          },
        );
      } else {
        Gui$1.gui.jobs().finish("load_opcode_" + opname);

        Gui$1.gui.mainTabs.activateTabByName(title);
        Gui$1.gui.maintabPanel.show(userInteraction);
      }
    }

    getOpLibs(opName) {
      const perf = Gui$1.gui.uiProfiler.start("[opsserver] getOpLibs");
      const opDoc = Gui$1.gui.opDocs.getOpDocByName(opName);
      const libs = [];
      if (opDoc && opDoc.libs) {
        for (let j = 0; j < opDoc.libs.length; j++) {
          const libName = opDoc.libs[j];
          libs.push({
            name: libName,
            type: "commonjs",
            src: libName,
            op: opDoc.name,
          });
        }
      }
      perf.finish();
      return libs;
    }

    getCoreLibs(opName) {
      const perf = Gui$1.gui.uiProfiler.start("[opsserver] getCoreLibs");
      const opDoc = Gui$1.gui.opDocs.getOpDocByName(opName);
      const coreLibs = [];
      if (opDoc && opDoc.coreLibs) {
        for (let j = 0; j < opDoc.coreLibs.length; j++) {
          const libName = opDoc.coreLibs[j];
          coreLibs.push({
            name: libName,
            type: "corelib",
            src: libName,
            op: opDoc.name,
          });
        }
      }
      perf.finish();
      return coreLibs;
    }

    getOpDeps(opThing) {
      const perf = Gui$1.gui.uiProfiler.start("[opsserver] getOpDeps");

      let opDoc = null;
      if (typeof opThing === "string")
        opDoc = Gui$1.gui.opDocs.getOpDocByName(opThing);
      else {
        if (opThing.opId) {
          // probably serialized patch
          opDoc = Gui$1.gui.opDocs.getOpDocById(opThing.opId);
        } else if (opThing.objName) {
          // probably op instance
          opDoc = Gui$1.gui.opDocs.getOpDocByName(opThing.objName);
        } else {
          // probably opDoc object
          opDoc = Gui$1.gui.opDocs.getOpDocById(opThing.id);
        }
      }

      if (!opDoc) {
        return [];
      }

      const opLibs = this.getOpLibs(opDoc.name);
      const opCoreLibs = this.getCoreLibs(opDoc.name);
      const opDependencies = [];
      if (opDoc && opDoc.dependencies) {
        const platformDeps = platform.getSupportedOpDependencyTypes();
        const opDeps = opDoc.dependencies.filter((dep) => {
          return platformDeps.includes(dep.type);
        });
        for (let i = 0; i < opDeps.length; i++) {
          const dep = opDeps[i];
          dep.op = opDoc.name;
          opDependencies.push(dep);
        }
      }
      perf.finish();

      return [...opLibs, ...opCoreLibs, ...opDependencies];
    }

    loadOpDependencies(opIdentifier, _next, reload = false) {
      if (!opIdentifier) this._log.error("no opIdentifier:", opIdentifier);
      let project = { ops: [{ objName: opIdentifier }] };
      if (!opIdentifier.startsWith("Ops."))
        project = { ops: [{ opId: opIdentifier }] };
      this.loadProjectDependencies(project, _next, reload);
    }

    loadProjectDependencies(proj, _next, loadAll = false) {
      let missingOps = [];
      if (loadAll) {
        missingOps = proj.ops;
      } else {
        missingOps = this.getMissingOps(proj);
      }
      this.loadOps(missingOps, (newOps, newIds) => {
        const perf2 = Gui$1.gui.uiProfiler.start(
          "[opsserver] loadProjectDependencies",
        );

        if (gui && Gui$1.gui.opSelect() && newOps.length > 0) {
          Gui$1.gui.opSelect().reload();
          Gui$1.gui.opSelect().prepare();
        }

        if (proj && proj.ops) {
          for (let i = 0; i < proj.ops.length; i++) {
            if (proj.ops[i]) {
              if (newIds.hasOwnProperty(proj.ops[i].opId)) {
                proj.ops[i].opId = newIds[proj.ops[i].opId];
              }
            }
          }
        }

        perf2.finish();
        this.loadOpsLibs(proj.ops, () => {
          if (_next) {
            proj.ops = proj.ops
              ? proj.ops.filter((op) => {
                  return this.isLoaded(op);
                })
              : [];
            _next(proj);
          }
        });
      });
    }

    opCodeLoaded(op) {
      return (
        CABLES &&
        CABLES.OPS &&
        (CABLES.OPS.hasOwnProperty(op.opId) || CABLES.OPS.hasOwnProperty(op.id))
      );
    }

    loadOpLibs(op, finishedCb) {
      this.loadOpsLibs([op], finishedCb);
    }

    loadOpsLibs(ops, finishedCb) {
      if (!ops || ops.length === 0) {
        finishedCb();
        return;
      }

      let depsToLoad = {};

      ops.forEach((op) => {
        const opDeps = this.getOpDeps(op);
        opDeps.forEach((lib) => {
          depsToLoad[lib.src] = lib;
        });
      });
      new LibLoader(Object.values(depsToLoad), finishedCb);
    }

    finished() {
      return this.loaded;
    }

    canEditOp(user, opName) {
      if (!platform.isTrustedPatch()) return false;
      if (!user) return false;
      if (user.isAdmin) return true;
      const op = this._ops.find((o) => {
        return o.name === opName;
      });
      if (!op) return false;
      return op.allowEdit || false;
    }

    canEditAttachment(user, opName) {
      return this.canEditOp(user, opName);
    }

    getMissingOps(proj) {
      const perf = Gui$1.gui.uiProfiler.start("[opsserver] gerMissingOps");

      let missingOps = [];
      const missingOpsFound = [];
      if (proj.ops)
        proj.ops.forEach((op) => {
          const opIdentifier = this.getOpIdentifier(op);
          if (!missingOpsFound.includes(opIdentifier)) {
            const opInfo = {
              opId: op.opId,
              objName: op.objName,
            };
            if (!this.isLoaded(op)) {
              missingOps.push(opInfo);
              missingOpsFound.push(opIdentifier);
            }
          }
        });
      missingOps = missingOps.filter((obj, index) => {
        return (
          missingOps.findIndex((item) => {
            return item.opId === obj.opId;
          }) === index
        );
      });

      perf.finish();
      return missingOps;
    }

    isLoaded(op) {
      const opDocs = Gui$1.gui.opDocs.getOpDocs();
      const opIdentifier = this.getOpIdentifier(op);
      // FIXME: this is very convoluted since opdocs have .id and .name but projectops have .opId and .objName and the likes...unify some day :/
      let foundOp = opDocs.find((loadedOp) => {
        return loadedOp.id === opIdentifier;
      });
      if (!foundOp)
        foundOp = opDocs.find((loadedOp) => {
          return loadedOp.objName === opIdentifier;
        });
      if (!foundOp)
        foundOp = opDocs.find((loadedOp) => {
          return loadedOp.name === opIdentifier;
        });
      if (!foundOp)
        foundOp = this._ops.find((loadedOp) => {
          return loadedOp.id === opIdentifier;
        });
      if (!foundOp)
        foundOp = this._ops.find((loadedOp) => {
          return op.objName && loadedOp.objName === opIdentifier;
        });
      if (!foundOp)
        foundOp = this._ops.find((loadedOp) => {
          return op.name && loadedOp.name === opIdentifier;
        });
      let loaded = false;
      if (foundOp) {
        // we found an op in opdocs, check if we also have the code and needed libraries
        loaded = this.opCodeLoaded(foundOp);
      }
      return loaded;
    }

    loadOps(ops, cb) {
      let count = ops.length;
      const newOps = [];
      const newIds = {};
      if (count === 0) {
        cb(newOps, newIds);
      } else {
        ops.forEach((op) => {
          this.loadOp(op, (createdOps) => {
            if (createdOps) {
              createdOps.forEach((newOp) => {
                if (newOp.oldOpId) newIds[newOp.oldOpId] = newOp.opId;
                newOps.push(newOp);
              });
            }
            count--;
            if (count === 0) {
              cb(newOps, newIds);
            }
          });
        });
      }
    }

    loadOp(op, cb, forceReload = false) {
      if (op) {
        const opIdentifier = this.getOpIdentifier(op);
        const oldName = this.getOpNameByIdentifier(opIdentifier);
        Gui$1.gui.jobs().start({
          id: "getopdocs",
          title: "load opdocs for " + oldName,
        });
        platform.talkerAPI.send("getOpDocs", opIdentifier, (err, res) => {
          Gui$1.gui.jobs().finish("getopdocs");
          if (err) {
            let title = "Failed to load op";
            let footer = "";
            let otherEnvName = "dev.cables.gl";
            let editorLink =
              "https://" + otherEnvName + "/edit/" + Gui$1.gui.project().shortId;
            let otherEnvButton = "Try " + otherEnvName;
            let errMsg = "";
            let opLinks = [];
            let hideEnvButton = false;
            if (err.data) {
              if (err.data.text) errMsg = err.data.text;
              if (err.data.footer) footer = err.data.footer;
              if (err.data.otherEnvName) otherEnvName = err.data.otherEnvName;
              if (err.data.reasons) opLinks = err.data.reasons;
              if (err.data.otherEnvUrl)
                editorLink =
                  err.data.otherEnvUrl + "/edit/" + Gui$1.gui.project().shortId;
              if (err.data.otherEnvButton)
                otherEnvButton = err.data.otherEnvButton;
              if (err.data.editorLink) editorLink = err.data.editorLink;
              if (err.data.hideEnvButton) hideEnvButton = true;
            }

            const continueLoadingCallback = () => {
              cb([]);
            };

            const tryOtherEnvCallback = () => {
              window.open(editorLink);
            };

            const modalOptions = {
              title: title,
              footer: footer,
              text: errMsg,
              notices: opLinks,
            };
            if (!hideEnvButton) {
              modalOptions.choice = true;
              modalOptions.okButton = { text: otherEnvButton };
              modalOptions.cancelButton = {
                text: "Continue loading",
                callback: continueLoadingCallback,
              };
            } else {
              modalOptions.showOkButton = true;
            }
            const modal = new ModalDialog(modalOptions);
            if (!hideEnvButton) {
              modal.on("onSubmit", tryOtherEnvCallback);
              modal.on("onClose", continueLoadingCallback);
            }
          } else {
            let allIdentifiers = [opIdentifier];
            if (res.newOps && res.newOps.length > 0) {
              res.newOps.forEach((newOp) => {
                if (newOp.opId) allIdentifiers.push(newOp.opId);
              });
            }

            let lid = "missingops_" + CABLES.uuid();
            const missingOpUrl = [];
            allIdentifiers.forEach((identifier) => {
              let url =
                CABLESUILOADER.noCacheUrl(
                  platform.getCablesUrl() + "/api/op/" + identifier,
                ) +
                "?p=" +
                this._patchId;
              if (platform.config.previewMode) url += "&preview=true";
              missingOpUrl.push(url);
            });

            Gui$1.gui.jobs().start({
              id: "missingops",
              title: "load missing ops",
            });

            loadjs.ready(lid, () => {
              let newOps = res.newOps;
              if (!err && res && res.opDocs) {
                let collectionsToLoad = [];
                res.opDocs.forEach((opDoc) => {
                  const opName = opDoc.name;
                  if (opName) {
                    if (namespace$1.isCollectionOp(opName)) {
                      collectionsToLoad.push(namespace$1.getCollectionName(opName));
                    }
                  }
                  this._ops.push(opDoc);
                });
                if (forceReload && oldName) {
                  const oldDocs = Gui$1.gui.opDocs.getOpDocByName(oldName);
                  if (oldDocs) Gui$1.gui.opDocs.removeOpDoc(oldDocs);
                }

                if (Gui$1.gui.opDocs) {
                  Gui$1.gui.opDocs.addOpDocs(res.opDocs);
                }
                collectionsToLoad = CABLES.uniqueArray(collectionsToLoad);
                collectionsToLoad.forEach((collectionNamespace) => {
                  this.loadCollectionOps(collectionNamespace, () => {
                    Gui$1.gui.opSelect().reload();
                  });
                });
              }
              Gui$1.gui.jobs().finish("missingops");
              cb(newOps);
            });
            loadjs(missingOpUrl, lid, {
              before: (path, scriptEl) => {
                scriptEl.setAttribute("crossorigin", "use-credentials");
              },
            });
          }
        });
      } else {
        incrementStartup();
        cb();
      }
    }

    loadCollectionOps(name, cb = null) {
      if (!name) {
        if (cb) cb();
        return;
      }
      let endpoint = "";
      let collectionName = namespace$1.getCollectionName(name);
      if (namespace$1.isExtension(collectionName)) {
        endpoint = "/api/ops/code/extension/";
      } else if (namespace$1.isTeamNamespace(collectionName)) {
        endpoint = "/api/ops/code/team/";
      }

      if (endpoint) {
        const collectionOpUrl = [];
        let apiUrl = CABLESUILOADER.noCacheUrl(
          platform.getCablesUrl() + endpoint + collectionName,
        );
        if (platform.config.previewMode) apiUrl += "?preview=true";
        collectionOpUrl.push(apiUrl);
        const lid = "collection ops" + collectionName + CABLES.uuid();
        Gui$1.gui.jobs().start({ id: "getCollectionOpDocs" });
        platform.talkerAPI.send(
          "getCollectionOpDocs",
          { name: collectionName },
          (err, res) => {
            Gui$1.gui.jobs().finish("getCollectionOpDocs");
            if (!err && res && res.opDocs) {
              Gui$1.gui.jobs().start({ id: "loadjsopdocs" });
              loadjs.ready(lid, () => {
                Gui$1.gui.jobs().finish("loadjsopdocs");
                res.opDocs.forEach((newOp) => {
                  this._ops.push(newOp);
                });
                if (Gui$1.gui.opDocs) {
                  Gui$1.gui.opDocs.addOpDocs(res.opDocs);
                }
                incrementStartup();
                if (cb) cb();
              });
            } else {
              incrementStartup();
              if (cb) cb();
            }
          },
        );
        loadjs(collectionOpUrl, lid, {
          before: (path, scriptEl) => {
            scriptEl.setAttribute("crossorigin", "use-credentials");
          },
        });
      } else {
        incrementStartup();
        if (cb) cb();
      }
    }

    showApiError(err) {
      if (err && err.msg == "ILLEGAL_OPS") {
        new ModalDialog({
          title: "Namespace Hierarchy Problem",
          showOkButton: true,
          html:
            'SubPatchOp can not contain this op because of their namespaces: <br/><br/><span class="warning-error-level2">' +
            err.data.msg +
            "</span><br/><br/>Try to move or create the op outside of the subPatch.",
        });
      } else {
        const options = {
          title: "Error/Invalid response from server",
          codeText: JSON.stringify(err, false, 4),
        };

        if (err && err.data && err.data.msg) options.text = err.data.msg;

        new ModalError(options);
      }
    }

    getOpIdentifier(op) {
      if (!op) return undefined;
      return op.opId || op.objName || op.id;
    }

    getOpNameByIdentifier(opIdentifier) {
      if (!opIdentifier) return undefined;
      if (opIdentifier.startsWith(defaultOps.prefixes.op)) return opIdentifier;
      const opDoc = Gui$1.gui.opDocs.getOpDocById(opIdentifier);
      return opDoc ? opDoc.name : undefined;
    }
  }

  class NoPatchEditor extends Events {
    constructor(cgl) {
      super();
      Gui$1.gui.patchView.setPatchRenderer(null, this);
    }

    get name() {
      return "nopatch";
    }

    isDraggingPort() {
      return false;
    }

    setSize() {}

    setProject() {}

    clear() {}

    dispose() {}

    focus() {}

    setCurrentSubPatch() {}

    getCurrentSubPatch() {
      return 0;
    }
  }

  class Tracking {
    constructor() {
      this.gui = gui;
      this._initListeners();

      this._trackEvent("ui", "userIsGuest", "", {
        isGuest: Gui$1.gui.isGuestEditor(),
      });

      this._trackEvent("ui", "loadStartupFiles", "", {
        seconds: CABLESUILOADER.uiLoadFiles / 1000,
      });
    }

    _initListeners() {
      this.Gui.gui._corePatch.on(
        CABLES.Patch.EVENT_OP_ADDED,
        (op, fromDeserialize) => {
          if (
            !fromDeserialize &&
            !(
              op.objName.startsWith("Ops.Ui.PatchInput") ||
              op.objName.startsWith("Ops.Ui.PatchOutput")
            )
          ) {
            // do not track patchload, multiplayer-session, subpatch and blueprint init
            this._trackEvent("ui", "opAdd", op.objName, {
              shortName: op._shortOpName,
            });
          }
        },
      );

      this.Gui.gui.on("uiIdleEnd", (idleSeconds) => {
        this._trackEvent("ui", "idleEnd", "end", { seconds: idleSeconds });
      });

      this.Gui.gui.on("uiIdleStart", (activeSeconds) => {
        this._trackEvent("ui", "activeDuration", "", { seconds: activeSeconds });
      });

      this.Gui.gui.on("logEvent", (initiator, level, args) => {
        if (!["error"].includes(level)) return;
        const perf = Gui$1.gui.uiProfiler.start("logEvent");
        this._trackLogEvent("logging", level, initiator, args);
        perf.finish();
      });

      this.Gui.gui.on("uncaughtError", (report) => {
        let initiator = "unknown";
        if (report.url) initiator = report.url;
        if (report.exception)
          initiator = report.exception.filename + ":" + report.exception.lineno;
        if (report.opName) initiator = report.opName;
        this._trackLogEvent("logging", "uncaught", initiator, report);
      });
    }

    _trackLogEvent(actionName, level, initiator, args) {
      const payload = {
        initiator: initiator,
        arguments: args,
      };
      const project = this.Gui.gui.project();
      if (project) payload.projectId = project._id;
      if (platform.talkerAPI) {
        payload.platform = platformLib;
        this._trackEvent("ui", actionName, level, payload);
      } else {
        this._trackEvent("ui", actionName, level, payload);
      }
    }

    _trackEvent(eventCategory, eventAction, eventLabel, meta = {}) {
      if (this.Gui.gui.socket) {
        this.Gui.gui.socket.track(eventCategory, eventAction, eventLabel, meta);
      }
    }
  }

  class HtmlInspector {
    constructor() {
      document.addEventListener("mousemove", this._move.bind(this));

      this._offsetEle = 0;

      this._hoveringOpId = null;
      this._timeoutHide = null;
      this._inspectEle = document.getElementById("inspectHtmlOverlay");

      this._inspectEle.addEventListener(
        "mousedown",
        () => {
          Gui$1.gui.patchView.centerSelectOp(this._hoveringOpId);
          Gui$1.gui.opParams.show(this._hoveringOpId);
        },
        { passive: true },
      );

      this._inspectEle.addEventListener(
        "mouseleave",
        () => {
          this._inspectEle.classList.add("hidden");
        },
        { passive: true },
      );

      this._inspectEle.addEventListener(
        "wheel",
        (e) => {
          this._offsetEle++;
          this._move(e);
          e.preventDefault();
        },
        { passive: true },
      );
    }

    _move(e) {
      clearTimeout(this._timeoutHide);

      if (!e.ctrlKey) return;

      const eles = ele.byClassAll("cablesEle");

      /** @type {Array<HTMLElement>} */
      const found = [];

      for (let i = 0; i < eles.length; i++) {
        const r = eles[i].getBoundingClientRect();

        if (
          e.pageX > r.x &&
          e.pageX < r.x + r.width &&
          e.pageY > r.y &&
          e.pageY < r.y + r.height
        ) {
          found.push(eles[i]);
        }
      }

      if (found.length) {
        const index = this._offsetEle % found.length;

        /** @type {HTMLElement} */
        const theEle = found[index];

        this._hoveringOpId = theEle.dataset.op;

        const r = theEle.getBoundingClientRect();

        this._inspectEle.classList.remove("hidden");

        this._inspectEle.style.left = r.x + "px";
        this._inspectEle.style.top = r.y + "px";
        this._inspectEle.style.width = r.width + "px";
        this._inspectEle.style.height = r.height + "px";
      }
    }
  }

  const PatchConnectionReceiver = function (patch, options, connector) {
    this._patch = patch;
    this.connector = connector;
    this._log = new Logger("PatchConnectionReceiver");
  };

  PatchConnectionReceiver.prototype._addOp = function (data) {
    let uiAttribs = null;
    if (data.vars.uiAttribs) uiAttribs = data.vars.uiAttribs;
    const op = this._patch.addOp(
      data.vars.objName,
      uiAttribs,
      data.vars.opId,
      true,
    );
    if (op) {
      op.id = data.vars.opId;
      if (data.vars.portsIn) {
        data.vars.portsIn.forEach((portInfo) => {
          const port = op.getPortByName(portInfo.name);
          if (port) port.set(portInfo.value);
        });
      }
    }
  };

  PatchConnectionReceiver.prototype._receive = function (ev) {
    let data = {};
    if (ev.hasOwnProperty("event")) data = ev;
    else data = JSON.parse(ev.data);

    if (data.event === CABLES.PACO_OP_CREATE) {
      if (this._patch.getOpById(data.vars.opId)) return;
      this._log.verbose("op create:", data.vars.objName);

      if (window.gui) {
        Gui$1.gui.serverOps.loadOpDependencies(data.vars.objName, () => {
          this._addOp(data);
        });
      } else {
        this._addOp(data);
      }
    } else if (data.event === CABLES.PACO_DESERIALIZE) {
      if (data.vars.json) {
        if (window.gui) {
          Gui$1.gui.serverOps.loadProjectDependencies(data.vars.json, () => {
            this._patch.deSerialize(data.vars.json, { genIds: data.vars.genIds });
          });
        } else {
          this._patch.deSerialize(data.vars.json, { genIds: data.vars.genIds });
        }
      }
    } else if (data.event === CABLES.PACO_LOAD) {
      this._log.verbose("PACO load patch.....");
      this._patch.clear();
      if (window.gui) {
        Gui$1.gui.serverOps.loadProjectDependencies(
          JSON.parse(data.vars.patch),
          () => {
            this._patch.deSerialize(data.vars.patch);
          },
        );
      } else {
        this._patch.deSerialize(data.vars.patch);
      }
    } else if (data.event === CABLES.PACO_CLEAR) {
      this._patch.clear();
      this._log.log("clear");
    } else if (data.event === CABLES.PACO_OP_DELETE) {
      this._log.verbose("op delete", data.vars.objName);
      this._patch.getOpById(data.vars.op);
      this._patch.deleteOp(data.vars.op, true);
    } else if (data.event === CABLES.PACO_OP_ENABLE) {
      const op = this._patch.getOpById(data.vars.op);
      if (op) op.enabled = true;
    } else if (data.event === CABLES.PACO_OP_DISABLE) {
      const op = this._patch.getOpById(data.vars.op);
      if (op) op.enabled = false;
    } else if (data.event === CABLES.PACO_UIATTRIBS) {
      const op = this._patch.getOpById(data.vars.op);
      op?.setUiAttrib(data.vars.uiAttribs);
    } else if (data.event === CABLES.PACO_UNLINK) {
      const op1 = this._patch.getOpById(data.vars.op1);
      const op2 = this._patch.getOpById(data.vars.op2);
      const port1 = op1?.getPort(data.vars.port1);
      const port2 = op2?.getPort(data.vars.port2);

      if (port1 && port2) port1.removeLinkTo(port2);
      else this._log.warn("paco unlink could not find port...");
    } else if (data.event === CABLES.PACO_LINK) {
      const op1 = this._patch.getOpById(data.vars.op1);
      const op2 = this._patch.getOpById(data.vars.op2);
      if (op1 && op2)
        this._patch.link(op1, data.vars.port1, op2, data.vars.port2);
    } else if (data.event === CABLES.PACO_VALUECHANGE) {
      // do not handle variable creation events
      if (data.vars.v === "+ create new one") return;
      const op = this._patch.getOpById(data.vars.op);
      if (op) {
        const p = op.getPort(data.vars.port);
        if (p) p.set(data.vars.v);
      }
    } else if (data.event === CABLES.PACO_VARIABLES) {
      const op = this._patch.getOpById(data.vars.opId);
      if (op) {
        if (op.varName) op.varName.set(data.vars.varName);
      }
    } else if (data.event === CABLES.PACO_TRIGGERS) {
      const op = this._patch.getOpById(data.vars.opId);
      if (op) {
        if (op.varName) op.varName.set(data.vars.varName);
      }
    } else if (data.event === CABLES.PACO_PORT_SETVARIABLE) {
      const op = this._patch.getOpById(data.vars.opId);
      if (op) {
        const p = op.getPortByName(data.vars.portName);
        if (p) p.setVariable(data.vars.variableName);
      }
    } else if (data.event === CABLES.PACO_PORT_SETANIMATED) {
      const op = this._patch.getOpById(data.vars.opId);
      if (op) {
        const p = op.portsIn[data.vars.portIndex];
        if (p) {
          if (data.vars.hasOwnProperty("targetState")) {
            this._patch.emitEvent(
              "pacoPortValueSetAnimated",
              op,
              data.vars.portIndex,
              data.vars.targetState,
              data.vars.defaultValue,
            );
          }
        }
      }
    } else if (data.event === CABLES.PACO_PORT_ANIM_UPDATED) {
      const op = this._patch.getOpById(data.vars.opId);
      if (op) {
        const p = op.getPortByName(data.vars.portName);
        if (p) {
          const objPort = p.getSerialized();
          objPort.anim = data.vars.anim;
          p.anim = null;
          p.deSerializeSettings(objPort);
          this._patch.emitEvent("pacoPortAnimUpdated", p);
        }
      }
    } else if (data.event === CABLES.PACO_OP_RELOAD) {
      const serops = Gui$1.gui.corePatch().getOpsByObjName(data.vars.opName);

      // const ser = Gui.gui.patchView.serializeOps(serops);

      for (let i = 0; i < serops.length; i++) {
        // serops[i].patch.deleteOp(serops[i].id);
      }

      // Gui.gui.serverOps.execute(data.vars.opName);

      if (gui)
        Gui$1.gui.serverOps.loadOpDependencies(
          data.vars.opName,
          (ops) => {
            // todo: needs to reconnect etc...
            //     loadOpDependencies
            //     // Gui.gui.serverOps.loadProjectDependencies(ser, () =>
            //     // {
            //     //     console.log("ser", ser);
            //     //     this._patch.deSerialize(ser, { "genIds": false });
            //     // });
            //     console.log(ops);
          },
          true,
        );
    } else {
      this._log.warn("unknown patchConnectionEvent!", ev);
    }
  };

  // ---------------

  const PatchConnectionSender = function (patch) {
    this.connectors = [];
    this.paused = false;

    patch.addEventListener("opReloaded", (opName) => {
      this.send(CABLES.PACO_OP_RELOAD, { opName: opName });
    });

    patch.addEventListener("onOpDelete", (op) => {
      this.send(CABLES.PACO_OP_DELETE, { op: op.id, objName: op.objName });
    });

    patch.addEventListener("patchClearStart", () => {
      this.paused = true;
    });

    patch.addEventListener("patchClearEnd", () => {
      this.paused = false;
    });

    patch.addEventListener("patchLoadStart", () => {
      this.paused = true;
    });

    patch.addEventListener("patchLoadEnd", (newOps, json, genIds) => {
      this.paused = false;
      this.send(CABLES.PACO_DESERIALIZE, { json: json, genIds: genIds });
    });

    patch.addEventListener("onOpAdd", (op) => {
      const portsIn = [];
      op.portsIn.forEach((portIn) => {
        const port = {
          id: portIn.id,
          name: portIn.name,
          value: portIn.get(),
        };
        portsIn.push(port);
      });
      let newUiAttribs = {};
      if (op.uiAttribs) {
        newUiAttribs = { ...op.uiAttribs };
      }
      this.send(CABLES.PACO_OP_CREATE, {
        opId: op.id,
        objName: op.objName,
        uiAttribs: newUiAttribs,
        portsIn: portsIn,
      });
    });

    patch.addEventListener("onUnLink", (p1, p2) => {
      this.send(CABLES.PACO_UNLINK, {
        op1: p1.op.id,
        op2: p2.op.id,
        port1: p1.getName(),
        port2: p2.getName(),
      });
    });

    patch.addEventListener("onUiAttribsChange", (op, newAttribs) => {
      if (!newAttribs) return;

      delete newAttribs.extendTitle;
      delete newAttribs.history;
      delete newAttribs.translate;
      if (Object.keys(newAttribs).length > 0) {
        this.send(CABLES.PACO_UIATTRIBS, { op: op.id, uiAttribs: newAttribs });
      }
    });

    patch.addEventListener("opVariableNameChanged", (op, varName) => {
      const vars = {
        opId: op.id,
        varName: varName,
      };
      this.send(CABLES.PACO_VARIABLES, vars);
    });

    patch.addEventListener("opTriggerNameChanged", (op, varName) => {
      const vars = {
        opId: op.id,
        varName: varName,
      };
      this.send(CABLES.PACO_TRIGGERS, vars);
    });

    patch.addEventListener("onLink", (p1, p2) => {
      this.send(CABLES.PACO_LINK, {
        op1: p1.op.id,
        op2: p2.op.id,
        port1: p1.name,
        port2: p2.name,
      });
    });

    patch.addEventListener("portSetVariable", (op, port, variableName) => {
      const vars = {
        opId: op.id,
        portName: port.name,
        variableName: variableName,
      };
      this.send(CABLES.PACO_PORT_SETVARIABLE, vars);
    });

    patch.addEventListener("portAnimUpdated", (op, port, anim) => {
      if (op && port) {
        const vars = {
          opId: op.id,
          portName: port.name,
          anim: anim.getSerialized(),
        };
        this.send(CABLES.PACO_PORT_ANIM_UPDATED, vars);
      }
    });
  };

  PatchConnectionSender.prototype.send = function (event, vars) {
    if (this.paused) return;
    // do not send variable creation events
    if (event === CABLES.PACO_VALUECHANGE && vars.v === "+ create new one")
      return;
    for (let i = 0; i < this.connectors.length; i++) {
      this.connectors[i].send(event, vars);
    }
  };

  class PacoConnector extends Events {
    constructor(connection, paco) {
      super();
      this._connection = connection;
      this._paco = paco;
      this.initialized = false;
      this.paused = false;
      this._delays = {};
      this._delays[CABLES.PACO_PORT_ANIM_UPDATED] = 500;
      this._delays[CABLES.PACO_VALUECHANGE] = 300;
      this._timeouts = {};
    }

    send(event, vars) {
      if (!this._connection || this._connection.client.isRemoteClient) {
        return;
      }

      if (this.paused) return;

      const data = { event: event, vars: vars };
      if (this._delays.hasOwnProperty(event)) {
        if (this._timeouts[event]) return;

        this._timeouts[event] = setTimeout(() => {
          this._connection.sendPaco({ data: data });
          this._timeouts[event] = null;
        }, this._delays[event]);
      } else {
        this._connection.sendPaco({ data: data });
      }
    }

    receive(pacoMsg) {
      if (!this._receiver) {
        this._receiver = new PatchConnectionReceiver(
          Gui$1.gui.corePatch(),
          {},
          this,
        );
      }

      // wait for initial patch sync before handling other messages
      if (pacoMsg.event === CABLES.PACO_VALUECHANGE) {
        if (this._connection.state) {
          this._connection.emitEvent("onPortValueChanged", pacoMsg.vars);
        }
      }
      this._receiver._receive(pacoMsg);
      this.initialized = true;
    }
  }

  class ScClient {
    constructor(payload, ownClient) {
      let isOwnAnswer = false;
      if (ownClient && ownClient.clientId) {
        isOwnAnswer = payload.clientId === ownClient.clientId;
      }

      this.username = payload.username;
      this.userid = payload.userid;
      this.shortname = payload.username.substr(0, 2).toUpperCase();
      this.clientId = payload.clientId;
      this.lastSeen = payload.lastSeen;
      this.isMe = isOwnAnswer;
      this.connectedSince = payload.connectedSince;
      this.inSessionSince = payload.inSessionSince;
      this.following =
        isOwnAnswer && ownClient ? ownClient.following : payload.following;
      this.isRemoteClient = payload.isRemoteClient;
      this.platform = payload.platform;
      if (this.platform) {
        this.platform.isMobile =
          /Android/i.test(this.platform.ua) ||
          /iPhone|iPad|iPod/i.test(this.platform.ua);
      }
      this.x = payload.x;
      this.y = payload.y;
      this.subpatch = payload.subpatch;
      this.zoom = payload.zoom;
      this.scrollX = payload.scrollX;
      this.scrollY = payload.scrollY;
      this.inMultiplayerSession = payload.inMultiplayerSession;
      this.multiplayerCapable = payload.multiplayerCapable;
      this.isPilot = payload.isPilot;
    }
  }

  CABLES = CABLES || {};

  class ScState extends Events {
    constructor(connection) {
      super();

      this.PILOT_REQUEST_TIMEOUT = 20000;

      this._log = new Logger("scstate");

      this._connection = connection;

      this._clients = {};
      this._clients[connection.clientId] = new ScClient({
        username: Gui$1.gui.user.username,
        userid: Gui$1.gui.user.id,
        clientId: connection.clientId,
        isMe: true,
        isRemoteClient: Gui$1.gui.isRemoteClient,
        multiplayerCapable: this._connection.multiplayerCapable,
        isPilot: false,
      });
      this._followers = [];
      this._colors = {};
      this._pilot = null;
      this._timeoutRefresh = null;

      this._registerEventListeners();
    }

    get clients() {
      return this._clients;
    }

    get followers() {
      return this._followers;
    }

    getUserId(clientId) {
      if (this._clients[clientId]) return this._clients[clientId].userid;
    }

    getUserInSubpatch(subPatch) {
      const userIds = [];
      for (const i in this._clients) {
        if (!this._clients[i].isMe && this._clients[i].subpatch == subPatch)
          userIds.push(this._clients[i].userid);
      }

      return userIds;
    }

    _onPingAnswer(payload) {
      let userListChanged = false;
      if (payload.isDisconnected) {
        if (this._clients[payload.clientId]) {
          const wasInMultiplayerSession =
            this._clients[payload.clientId].inMultiplayerSession;
          if (this._connection.clientId !== payload.clientId) {
            delete this._clients[payload.clientId];
            this.emitEvent(
              "clientDisconnected",
              payload,
              wasInMultiplayerSession,
            );
            userListChanged = true;
          }
        }
      } else {
        const client = new ScClient(payload, this._connection.client);
        if (this._clients[payload.clientId]) {
          if (
            !payload.inMultiplayerSession &&
            this._clients[payload.clientId].inMultiplayerSession
          ) {
            this.emitEvent("clientLeft", payload);
            userListChanged = true;
          }
          if (
            payload.inMultiplayerSession &&
            !this._clients[payload.clientId].inMultiplayerSession
          ) {
            this.emitEvent("clientJoined", payload);
            userListChanged = true;
          }
        } else {
          userListChanged = true;
        }
        this._clients[payload.clientId] = client;
      }

      if (this._connection.inMultiplayerSession) {
        let newPilot = null;
        if (payload.isPilot && !payload.isRemoteClient) {
          const keys = Object.keys(this._clients);
          for (let i = 0; i < keys.length; i++) {
            const client = this._clients[keys[i]];
            if (client.clientId !== payload.clientId) {
              client.isPilot = false;
            } else {
              if (
                client.clientId === this._connection.clientId &&
                Gui$1.gui.isRemoteClient
              )
                continue;
              client.isPilot = true;
              newPilot = client;
            }
          }
          if (
            newPilot &&
            (!this._pilot || newPilot.clientId !== this._pilot.clientId)
          ) {
            if (!newPilot.isRemoteClient) {
              userListChanged = true;
              this._pilot = newPilot;
              this.emitEvent("pilotChanged", newPilot);
            }
          }
        } else if (this._pilot) {
          if (this._pilot.clientId === payload.clientId && !payload.isPilot) {
            // pilot left the multiplayer session but is still in socketcluster
            this._pilot = null;
            this.emitEvent("pilotRemoved");
          }
        }

        if (
          payload.following &&
          payload.following === this._connection.clientId &&
          !this._followers.includes(payload.clientId)
        ) {
          this._followers.push(payload.clientId);
          userListChanged = true;
        } else if (
          !payload.following &&
          this._followers.includes(payload.clientId)
        ) {
          this._followers = this._followers.filter((followerId) => {
            return followerId !== payload.clientId;
          });
          userListChanged = true;
        }
      } else if (payload.startedSession) {
        userListChanged = true;
      }

      const cleanupChange = this._cleanUpUserList();
      if (userListChanged || cleanupChange) {
        this.emitEvent("userListChanged");
      }
    }

    getNumClients() {
      return Object.keys(this._clients).length;
    }

    _cleanUpUserList() {
      // wait for patch to be in a synced state to update userlist
      if (!this._connection.synced) {
        return false;
      }

      const timeOutSeconds =
        this._connection.PING_INTERVAL * this._connection.PINGS_TO_TIMEOUT;

      let cleanupChange = false;

      Object.keys(this._clients).forEach((clientId) => {
        const client = this._clients[clientId];

        if (
          client.lastSeen &&
          this._connection.getTimestamp() - client.lastSeen > timeOutSeconds
        ) {
          if (this._connection.clientId !== clientId) {
            this.emitEvent("clientRemoved", this._clients[client.clientId]);
            delete this._clients[client.clientId];
          }
          if (this._pilot && this._pilot.clientId === client.clientId) {
            this._pilot = null;
            this.emitEvent("pilotRemoved");
          }
          if (this.followers.includes(client.clientId))
            this._followers = this._followers.filter((followerId) => {
              return followerId != client.clientId;
            });
          cleanupChange = true;
        }
      });

      if (
        this.getNumClients() < 2 &&
        this._clients[this._connection.clientId] &&
        !this._clients[this._connection.clientId].isPilot
      ) {
        if (this._connection.inMultiplayerSession && !Gui$1.gui.isRemoteClient) {
          this._clients[this._connection.clientId].isPilot = true;
          cleanupChange = true;
        }
      }

      if (!this.hasPilot() && this._connection.inMultiplayerSession) {
        let pilot = null;
        let earliestConnection = this._connection.getTimestamp();
        Object.keys(this._clients).forEach((key) => {
          const client = this._clients[key];
          if (client && client.isPilot) pilot = client;
        });

        if (!pilot) {
          // connection has no pilot, try to find the longest connected client that is also in a multiplayer session
          Object.keys(this._clients).forEach((key) => {
            const client = this._clients[key];
            if (
              !client.isRemoteClient &&
              client.inMultiplayerSession &&
              client.inSessionSince &&
              client.inSessionSince < earliestConnection
            ) {
              pilot = client;
              earliestConnection = client.inSessionSince;
            }
          });
        }

        if (pilot && !pilot.isRemoteClient) {
          this._clients[pilot.clientId].isPilot = true;
          if (pilot.clientId === this._connection.clientId) {
            this.becomePilot();
          }
        }
      }

      return cleanupChange;
    }

    getPilot() {
      return this._pilot;
    }

    hasPilot() {
      return !!this._pilot;
    }

    becomePilot() {
      if (!Gui$1.gui.isRemoteClient) {
        this._connection.client.isPilot = true;
        this.emitEvent("becamePilot");
        Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_FULL);
      }
    }

    requestPilotSeat() {
      const client = this._clients[this._connection.clientId];
      if (!Gui$1.gui.isRemoteClient && client && !client.isPilot) {
        this._connection.sendControl("pilotRequest", {
          username: client.username,
          state: "request",
        });
        const myAvatar = document.querySelector(
          "#multiplayerbar .sc-userlist .item.me",
        );
        if (myAvatar) myAvatar.classList.add("pilot-request");
        this._pendingPilotRequest = setTimeout(() => {
          if (this._pendingPilotRequest) {
            this.acceptPilotSeatRequest();
            this._pendingPilotRequest = null;
          }
        }, this.PILOT_REQUEST_TIMEOUT + 2000);
      }
    }

    hasPendingPilotSeatRequest() {
      return !!this._pendingPilotRequest;
    }

    acceptPilotSeatRequest() {
      const client = this._clients[this._connection.clientId];
      if (client && !client.isPilot && this._pendingPilotRequest) {
        clearTimeout(this._pendingPilotRequest);
        const myAvatar = document.querySelector(
          "#multiplayerbar .sc-userlist .item.me",
        );
        if (myAvatar) myAvatar.classList.add("pilot-request");
        this.becomePilot();
      }
    }

    cancelPilotSeatRequest() {
      const client = this._clients[this._connection.clientId];
      if (client && this._pendingPilotRequest) {
        clearTimeout(this._pendingPilotRequest);
        const myAvatar = document.querySelector(
          "#multiplayerbar .sc-userlist .item.me",
        );
        if (myAvatar) myAvatar.classList.remove("pilot-request");
      }
    }

    _registerEventListeners() {
      this._connection.on("onPingAnswer", this._onPingAnswer.bind(this));
      this._connection.on("netCursorPos", (msg) => {
        if (this._connection.client.isRemoteClient) return;
        if (this._clients[msg.clientId]) {
          if (this._clients[msg.clientId].subpatch != msg.subpatch) {
            this._clients[msg.clientId].subpatch = msg.subpatch;
            Gui$1.gui.emitEvent(
              "multiUserSubpatchChanged",
              msg.clientId,
              msg.subpatch,
            );
          }

          this._clients[msg.clientId].x = msg.x;
          this._clients[msg.clientId].y = msg.y;
          this._clients[msg.clientId].subpatch = msg.subpatch;
          this._clients[msg.clientId].zoom = msg.zoom;
          this._clients[msg.clientId].center = msg.center;
          this._clients[msg.clientId].scrollX = msg.scrollX;
          this._clients[msg.clientId].scrollY = msg.scrollY;
        }
      });

      this.on("clientDisconnected", (client, wasInMultiplayerSession = false) => {
        Gui$1.gui.emitEvent("netClientRemoved", { clientId: client.clientId });
      });

      this.on("clientLeft", (client) => {
        Gui$1.gui.emitEvent("netClientRemoved", { clientId: client.clientId });
      });

      this.on("patchSynchronized", () => {
        if (this._connection.client.isRemoteClient) {
          const menubar = document.getElementById("menubar");
          if (menubar) menubar.classList.add("hidden");
        }
      });

      this._connection.on("clientRemoved", (msg) => {
        this._connection.sendUi("netClientRemoved", msg, true);
        Gui$1.gui.emitEvent("netClientRemoved", msg);
      });

      Gui$1.gui.patchView.on("mouseMove", (x, y) => {
        this._sendCursorPos(x, y);
      });

      Gui$1.gui.on("timelineControl", (command, value) => {
        if (!this._connection.inMultiplayerSession) return;
        if (this._connection.client && this._connection.client.isPilot) {
          if (command !== "scrollTime") {
            const payload = {
              command: command,
              value: value,
            };
            this._connection.sendUi("timelineControl", payload);
          } else {
            if (this._timelineTimeout) return;

            const payload = {
              command: "setTime",
              value: value,
            };
            this._timelineTimeout = setTimeout(() => {
              this._connection.sendUi("timelineControl", payload);
              this._timelineTimeout = null;
            }, this._connection.netTimelineScrollDelay);
          }
        }
      });

      Gui$1.gui.on("portValueEdited", (op, port, value) => {
        if (!this._connection.inMultiplayerSession) return;
        if (this._connection.client) {
          // && this._connection.client.isPilot)
          if (op && port) {
            const payload = {};
            payload.data = {
              event: CABLES.PACO_VALUECHANGE,
              vars: {
                op: op.id,
                port: port.name,
                v: value,
              },
            };
            this._connection.sendPaco(payload);
          }
        }
      });

      gui
        .corePatch()
        .on(
          "pacoPortValueSetAnimated",
          (op, index, targetState, defaultValue) => {
            if (!this._connection.inMultiplayerSession) return;
            paramsHelper.setPortAnimated(op, index, targetState, defaultValue);
          },
        );

      Gui$1.gui.corePatch().on("pacoPortAnimUpdated", (port) => {
        if (!port.anim) return;
        if (!this._connection.inMultiplayerSession) return;
        Gui$1.gui.metaKeyframes.showAnim(port.parent.id, port.name);
      });

      Gui$1.gui.on(
        "portValueSetAnimated",
        (op, portIndex, targetState, defaultValue) => {
          if (!this._connection.inMultiplayerSession) return;
          if (this._connection.client && this._connection.client.isPilot) {
            if (op) {
              const payload = {};
              payload.data = {
                event: CABLES.PACO_PORT_SETANIMATED,
                vars: {
                  opId: op.id,
                  portIndex: portIndex,
                  targetState: targetState,
                  defaultValue: defaultValue,
                },
              };
              this._connection.sendPaco(payload);
            }
          }
        },
      );

      Gui$1.gui.corePatch().on("opReloaded", (opName) => {
        if (!this._connection.inMultiplayerSession) return;
        if (this._connection.client && this._connection.client.isPilot) {
          this._connection.sendControl("reloadOp", { opName: opName });
        }
      });

      Gui$1.gui.on("gizmoMove", (opId, portName, newValue) => {
        if (!this._connection.inMultiplayerSession) return;
        if (this._connection.client && this._connection.client.isPilot) {
          if (opId && portName) {
            const payload = {};
            payload.data = {
              event: CABLES.PACO_VALUECHANGE,
              vars: {
                op: opId,
                port: portName,
                v: newValue,
              },
            };
            this._connection.sendPaco(payload);
          }
        }
      });

      this._connection.on("netCursorPos", (msg) => {
        delete msg.zoom;
        Gui$1.gui.emitEvent("netCursorPos", msg);
      });

      this._connection.on("resyncWithPilot", (msg) => {
        if (!this._connection.inMultiplayerSession) return;
        if (!this._connection.client.isRemoteClient) return;
        if (this._connection.clientId !== msg.reloadClient) return;
        this._connection.requestPilotPatch();
      });

      this._connection.on("onPortValueChanged", (vars) => {
        if (!this._connection.inMultiplayerSession) return;
        if (this._connection.client.isRemoteClient) return;
        if (this._connection.client.isPilot) return;

        const selectedOp = Gui$1.gui.patchView.getSelectedOps().find((op) => {
          return op.id === vars.op;
        });
        if (selectedOp) {
          const portIndex = selectedOp.portsIn.findIndex((port) => {
            return port.name === vars.port;
          });
          if (portIndex) {
            clearTimeout(this._timeoutRefresh);
            this._timeoutRefresh = setTimeout(() => {
              selectedOp.refreshParams();
            }, 50);
          }
        }
      });
    }

    _sendCursorPos(x, y) {
      if (!this._connection.isConnected()) return;
      if (this._lastMouseX === x || this._lastMouseY === y) return;

      this._lastMouseX = x;
      this._lastMouseY = y;

      if (this._mouseTimeout) return;

      const subPatch = Gui$1.gui.patchView.getCurrentSubPatch();
      const zoom = Gui$1.gui.patchView.patchRenderer.viewBox
        ? Gui$1.gui.patchView.patchRenderer.viewBox.zoom
        : null;
      const scrollX = Gui$1.gui.patchView.patchRenderer.viewBox
        ? Gui$1.gui.patchView.patchRenderer.viewBox.scrollX
        : null;
      const scrollY = Gui$1.gui.patchView.patchRenderer.viewBox
        ? Gui$1.gui.patchView.patchRenderer.viewBox.scrollY
        : null;

      this._mouseTimeout = setTimeout(() => {
        const payload = {
          x: this._lastMouseX,
          y: this._lastMouseY,
          subpatch: subPatch,
          zoom: zoom,
          scrollX: scrollX,
          scrollY: scrollY,
        };
        this._connection.sendUi("netCursorPos", payload);
        this._mouseTimeout = null;
      }, this._connection.netMouseCursorDelay);
    }
  }

  class ScUiMultiplayer extends Events {
    constructor(connection) {
      super();

      this._connection = connection;
      this._lastMouseX = this._lastMouseY = 0;
      this._mouseTimeout = null;

      if (this._connection.client.isRemoteClient) {
        Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_REMOTEVIEW);
      }

      this._pilotRequestTimeout = null;

      this._registerEventListeners();
    }

    updateMultiplayerBar() {
      if (Gui$1.gui.unload) return;
      if (!this._connection.isConnected()) {
        ele.byId("multiplayerbar").style.display = "none";
        return;
      }

      if (this._connection.multiplayerCapable) {
        const el = document.querySelector(".nav_remote_viewer");
        if (el) el.classList.remove("hidden");
      }

      let shownClients = Object.values(this._connection.clients).filter((c) => {
        return c.multiplayerCapable;
      });
      if (this._connection.showGuestUsers)
        shownClients = Object.values(this._connection.clients);
      const clientList = shownClients.sort((a, b) => {
        if (!a.username) a.username = "";
        if (!b.username) b.username = "";
        return a.username.localeCompare(b.username);
      });

      if (clientList.length < 2) {
        if (!this._connection.client.isPilot)
          ele.byId("multiplayerbar").style.display = "none";
        Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_FULL);
        return;
      }

      const data = {
        clients: clientList,
        multiplayerCapable: this._connection.multiplayerCapable,
        showMoreOptions: true,
        cablesurl: platform.getCablesUrl(),
      };

      const html = getHandleBarHtml("sc_userlist", data);
      const userList = ele.byId("nav-clientlist");
      userList.innerHTML = html;

      const userListItems = userList.querySelectorAll(".item");
      userListItems.forEach((elem) => {
        const itemId = elem.dataset.clientId;
        let client = this._connection.clients[itemId];
        if (client) {
          if (client.isMe) {
            elem.classList.add("me");
          } else {
            elem.classList.remove("me");
          }
        }
        elem.addEventListener("pointerdown", (event) => {
          contextMenu.show(
            {
              items: this._getContextMenuItems(
                event.currentTarget.dataset.clientId,
              ),
            },
            event.currentTarget,
          );
        });
      });

      Gui$1.gui.restriction.setMessage(null);
      Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_FULL);

      const startButton = userList.querySelector(".start-button");
      const joinButton = userList.querySelector(".join-button");
      const leaveButton = userList.querySelector(".leave-button");

      if (startButton) {
        startButton.addEventListener("pointerdown", () => {
          this._connection.startMultiplayerSession();
        });
        if (
          this._connection.multiplayerCapable &&
          this._connection.hasOtherMultiplayerCapableClients &&
          !(
            this._connection.runningMultiplayerSession ||
            this._connection.inMultiplayerSession
          )
        ) {
          startButton.classList.add("visible");
        } else {
          startButton.classList.remove("visible");
        }
      }

      if (joinButton) {
        joinButton.addEventListener("pointerdown", () => {
          this._modalJoinMultiplayerSession();
        });
        if (this._connection.onlyRemoteClientsConnected) {
          joinButton.textContent = "Remote Viewer";
        } else {
          joinButton.textContent = "Join";
        }
        if (
          this._connection.multiplayerCapable &&
          this._connection.runningMultiplayerSession &&
          !this._connection.inMultiplayerSession
        ) {
          joinButton.classList.add("visible");
        } else {
          joinButton.classList.remove("visible");
        }
      }

      if (leaveButton) {
        leaveButton.addEventListener("pointerdown", () => {
          this._connection.leaveMultiplayerSession();
        });
        if (
          this._connection.multiplayerCapable &&
          this._connection.inMultiplayerSession
        ) {
          leaveButton.classList.add("visible");
        } else {
          leaveButton.classList.remove("visible");
        }
      }

      const moreOptions = userList.querySelector(".more-options");
      if (moreOptions) {
        moreOptions.addEventListener("pointerdown", (event) => {
          const items = [];

          items.push({
            title: "open chat",
            iconClass: "icon icon-message",
            func: () => {
              CABLES.CMD.UI.showChat();
            },
          });

          if (items.length > 0) {
            contextMenu.show({ items: items }, event.currentTarget);
          }
        });
      }
      const mpBar = ele.byId("multiplayerbar");
      if (mpBar) mpBar.style.display = "block";
    }

    _jumpToCursor(client) {
      const guiEvent = {};
      if (client.hasOwnProperty("x")) {
        guiEvent.x = client.x;
      }
      if (client.hasOwnProperty("y")) {
        guiEvent.y = client.y;
      }
      if (client.hasOwnProperty("subpatch")) {
        guiEvent.subpatch = client.subpatch;
      }

      if (client.hasOwnProperty("scrollX") && client.hasOwnProperty("scrollY")) {
        guiEvent.scrollX = client.scrollX;
        guiEvent.scrollY = client.scrollY;
      }
      if (Object.keys(guiEvent).length > 0) {
        Gui$1.gui.emitEvent("netGotoPos", guiEvent);
      }
    }

    _getContextMenuItems(clientId) {
      if (!this._connection.multiplayerCapable) return;

      const client = this._connection.clients[clientId];
      const items = [];
      if (client) {
        let displayName = client.username;
        items.push({ title: displayName, func: () => {} });

        if (this._connection.inMultiplayerSession) {
          if (client.isRemoteClient) {
            let title = "remoteviewer";
            const platformInfo = client.platform || {};
            if (platformInfo) {
              title = "";
              if (platformInfo.name) {
                title += " " + platformInfo.name;
              }
              if (platformInfo.os && platformInfo.os.family) {
                title += " on " + platformInfo.os.family;
              }
            }
            const icon = platformInfo.isMobile
              ? "icon-smartphone"
              : "icon-remoteviewer";
            items.push({
              title: title,
              iconClass: "icon " + icon,
              func: () => {},
            });
            const projectId = Gui$1.gui.project().shortId;
            if (projectId && client.userid) {
              items.push({
                title: "Open in new window",
                func: () => {
                  window.open(
                    platform.getCablesUrl() +
                      "/remote_client/" +
                      projectId +
                      "?u=" +
                      client.userid,
                  );
                },
              });
            }
          }
        }
      }
      return items;
    }

    _sendForceResync(client) {
      if (!this._connection.inMultiplayerSession) return;
      this._connection.sendUi("resyncWithPilot", {
        reloadClient: client.clientId,
      });
    }

    _modalJoinMultiplayerSession() {
      if (
        !Gui$1.gui.getSavedState() &&
        !this._connection.onlyRemoteClientsConnected
      ) {
        let content =
          "Your unsaved changes will be lost, once you enter a multiplayer session.";
        const options = {
          title: "Joining Multiplayer",
          html: content,
          warning: true,
          choice: true,
        };

        const modal = new ModalDialog(options);
        modal.on("onSubmit", () => {
          this._connection.joinMultiplayerSession();
        });
      } else {
        if (this._connection.onlyRemoteClientsConnected) {
          this._connection.reconnectRemoteViewer();
        } else {
          this._connection.joinMultiplayerSession();
        }
      }
    }

    _registerEventListeners() {
      if (this._connection.client.isRemoteClient) return;

      this._connection.state.on("enableMultiplayer", (msg) => {
        if (!msg.started) {
          const multiplayerBar = ele.byId("multiplayerbar");
          if (multiplayerBar) multiplayerBar.classList.add("syncing");
        }
      });
      this._connection.state.on("startPatchSync", () => {
        const multiplayerBar = ele.byId("multiplayerbar");
        if (multiplayerBar) multiplayerBar.classList.add("syncing");
      });
      this._connection.state.on("patchSynchronized", () => {
        const multiplayerBar = ele.byId("multiplayerbar");
        if (multiplayerBar) multiplayerBar.classList.remove("syncing");
      });
      this._connection.on(
        "netLeaveSession",
        this.updateMultiplayerBar.bind(this),
      );
      this._connection.on(
        "connectionError",
        this.updateMultiplayerBar.bind(this),
      );
      this._connection.state.on(
        "enableMultiplayer",
        this.updateMultiplayerBar.bind(this),
      );
      this._connection.state.on(
        "userListChanged",
        this.updateMultiplayerBar.bind(this),
      );
      this._connection.state.on(
        "becamePilot",
        this.updateMultiplayerBar.bind(this),
      );
      this._connection.on(
        "connectionChanged",
        this.updateMultiplayerBar.bind(this),
      );

      this._connection.on("onInfoMessage", (payload) => {
        if (payload.name === "notify") {
          notify(payload.title, payload.text, payload.options);
        }
      });

      this._connection.state.on("pilotChanged", (pilot) => {
        if (!this._connection.inMultiplayerSession) return;
        if (this._connection.onlyRemoteClientsConnected) return;

        if (this._connection.state.getNumClients() > 1) {
          pilot.username + " is";
          if (pilot.clientId === this._connection.clientId) {
            // unfollow on becoming pilot
            this._connection.client.following = null;
          } else {
            // follow the pilot
            this._connection.client.following = pilot.clientId;
            // this._jumpToCursor(pilot);
          }
          this.updateMultiplayerBar();
          // notify(username + " the pilot");
        }
      });

      this._connection.state.on("clientRemoved", (msg) => {
        if (
          this._connection.client.following &&
          this._connection.client.following === msg.clientId
        ) {
          const multiPlayerBar = ele.byId("multiplayerbar");
          if (multiPlayerBar) delete multiPlayerBar.dataset.multiplayerFollow;
          this._connection.client.following = null;
        }
      });

      this._connection.on("reloadOp", (msg) => {
        if (!this._connection.inMultiplayerSession) return;
        if (msg.opName) {
          const opName = msg.opName;
          notify("reloaded code for op", opName);
        }
      });

      this._connection.on("onPilotRequest", (msg) => {
        if (!this._connection.multiplayerCapable) return;

        if (msg.state === "request") {
          if (
            this._connection.inMultiplayerSession &&
            this._connection.client.isPilot
          ) {
            if (!this._pilotRequestTimeout) {
              let content =
                "You have 20 seconds to react to this request, if you do not react, the request will be accepted<br/><br/>";
              content += '<a class="button accept">Accept</a>&nbsp;&nbsp;';
              content += '<a class="button decline">Decline</a>';

              const options = {
                title: msg.username + " wants to be the pilot",
                html: content,
              };
              const modal = new ModalDialog(options, false);
              const closeListener = () => {
                clearTimeout(this._pilotRequestTimeout);
                this._pilotRequestTimeout = null;
                this._connection.sendControl("pilotRequest", {
                  state: "declined",
                  username: Gui$1.gui.user.usernameLowercase,
                  initiator: msg.clientId,
                });
              };
              const closeListenerId = modal.on("onClose", closeListener);
              modal.on("onShow", () => {
                const modalElement = modal.getElement();
                const acceptButton = modalElement.querySelector(".button.accept");
                const declineButton =
                  modalElement.querySelector(".button.decline");

                if (acceptButton) {
                  acceptButton.addEventListener("pointerdown", () => {
                    clearTimeout(this._pilotRequestTimeout);
                    this._pilotRequestTimeout = null;
                    modal.off(closeListenerId);
                    this._connection.sendControl("pilotRequest", {
                      state: "accepted",
                      username: Gui$1.gui.user.usernameLowercase,
                      initiator: msg.clientId,
                    });
                    modal.close();
                  });
                }
                if (declineButton) {
                  declineButton.addEventListener("pointerdown", () => {
                    clearTimeout(this._pilotRequestTimeout);
                    this._pilotRequestTimeout = null;
                    modal.off(closeListenerId);
                    this._connection.sendControl("pilotRequest", {
                      state: "declined",
                      username: Gui$1.gui.user.usernameLowercase,
                      initiator: msg.clientId,
                    });
                    modal.close();
                  });
                }
              });

              this._pilotRequestTimeout = setTimeout(() => {
                modal.off(closeListenerId);
                this._connection.sendControl("pilotRequest", {
                  state: "accepted",
                  username: Gui$1.gui.user.usernameLowercase,
                  initiator: msg.clientId,
                });
                modal.close();
              }, this._connection.state.PILOT_REQUEST_TIMEOUT);
              modal.show();
            } else {
              // already waiting for pilot request approval/denial, deny other requests
              this._connection.sendControl("pilotRequest", {
                state: "declined",
                username: Gui$1.gui.user.usernameLowercase,
                initiator: msg.clientId,
                reason: "PENDING_REQUEST",
              });
            }
          }
        } else if (msg.state === "accepted") {
          if (msg.initiator && this._connection.clientId === msg.initiator) {
            if (
              this._connection.state &&
              this._connection.state.hasPendingPilotSeatRequest()
            ) {
              this._connection.state.acceptPilotSeatRequest();
              notify(msg.username, "accepted your pilot seat request");
            }
          }
        } else if (msg.state === "declined") {
          if (msg.initiator && this._connection.clientId === msg.initiator) {
            if (
              this._connection.state &&
              this._connection.state.hasPendingPilotSeatRequest()
            ) {
              this._connection.state.cancelPilotSeatRequest();
              let reason = "declined your pilot seat request";
              if (msg.reason && msg.reason === "PENDING_REQUEST")
                reason = "already has a pending pilot seat request";
              notify(msg.username, reason);
            }
          }
        }
      });

      this._connection.on("onChatMessage", (payload) => {
        if (payload.clientId === this._connection.clientId) return;
        if (this._connection.chat && this._connection.chat.isOpen()) return;

        // remove html, cut length
        let text = payload.text;
        const el = document.createElement("div");
        el.innerHTML = text;
        text = el.textContent || el.innerText || "";
        const maxLength = 32;
        if (text.length > maxLength) {
          text = text.substring(0, maxLength) + "...";
        }

        notify(payload.username + " says:", text, {
          closeable: true,
          buttons: [
            [
              "<button>Open Chat</button>",
              function () {
                CABLES.CMD.UI.showChat();
              },
            ],
          ],
        });
      });
    }
  }

  class Chat extends Events {
    constructor(tabs, socket) {
      super();
      this._msgs = [];
      this._connection = socket;
      this._tabs = tabs;
      this.activityCounterIn = 0;
      this.activityCounterOut = 0;

      this._connection.on("onChatMessage", this.onChatMsg.bind(this));

      this._connection.on("connectionChanged", this._updateClientList.bind(this));
      this._connection.state.on(
        "userListChanged",
        this._updateClientList.bind(this),
      );

      this._connection.on("netActivityIn", this._activityIn.bind(this));
      this._connection.on("netActivityOut", this._activityOut.bind(this));
    }

    onChatMsg(payload) {
      // remove html
      const el = document.createElement("div");
      el.innerHTML = payload.text;
      payload.text = el.textContent || el.innerText || "";
      this._msgs.push(payload);
      this._updateText();
      this._updateClientList();
    }

    _activityIn() {
      const ele = document.getElementById("netactivityIn");
      if (!ele) return;
      this.activityCounterIn++;

      ele.innerHTML = this.activityCounterIn;
    }

    _activityOut() {
      const ele = document.getElementById("netactivityOut");
      if (!ele) return;
      this.activityCounterOut++;

      ele.innerHTML = this.activityCounterOut;
    }

    show() {
      this._tab = new Tab("chat", {
        icon: "pie-chart",
        infotext: "tab_chat",
        padding: true,
        singleton: "true",
      });
      this._tabs.addTab(this._tab, true);

      const html = getHandleBarHtml("tab_chat", {});
      this._tab.html(html);
      const inputEle = document.getElementById("newchatmsg");

      const submitAction = (event) => {
        if (event.key === "Enter") {
          Gui$1.gui.socket.chat.send(document.getElementById("newchatmsg").value);
          document.getElementById("newchatmsg").value = "";
        }
      };
      if (inputEle) {
        inputEle.removeEventListener("keyup", submitAction);
        inputEle.addEventListener("keyup", submitAction);
      }
      this._updateText();
    }

    isOpen() {
      return (
        this._tab &&
        this._tab.active &&
        this._tab.contentEle &&
        this._tab.contentEle.offsetParent
      );
    }

    _updateClientList() {
      const ele = document.getElementById("chat-clientlist");

      if (ele) {
        const html = getHandleBarHtml("chat_clientlist", {
          numClients: this._connection.state.getNumClients(),
          clients: this._connection.state.clients,
          connected: this._connection.isConnected(),
        });
        ele.innerHTML = html;
      }
    }

    _updateText() {
      let html = "";
      const logEle = document.getElementById("chatmsgs");
      if (!logEle) return;

      for (let i = 0; i < this._msgs.length; i++) {
        if (this._msgs[i].name === "info") {
          html += "<b>";
          html += this._msgs[i].text;
          html += "</b>";
        } else {
          html += "- ";
          html += this._msgs[i].username + ": ";
          html += this._msgs[i].text;
        }
        html += "<br/>";
      }

      logEle.innerHTML = html;
      this._updateClientList();
    }

    send(text) {
      this._connection.sendChat(text);
    }
  }

  class ScUi {
    constructor(connection) {
      this._connection = connection;
      this._registerEventListeners();
    }

    _registerEventListeners() {
      if (!this._connection) return;

      if (Gui$1.gui.isRemoteClient) {
        this._connection.on("createdSubPatchOp", (_msg) => {
          platform.talkerAPI.send("reload");
        });
      } else {
        Gui$1.gui.on("createdSubPatchOp", (newOp, subPatchId) => {
          this._connection.sendControl("createdSubPatchOp", {
            opId: newOp.opId,
            opName: newOp.objName,
            subPatchId: subPatchId,
          });
        });
      }
      this._connection.on("onInfoMessage", (payload) => {
        const data = payload.data;
        if (!data || !data.action) return;

        switch (data.action) {
          case "patchOpSaved":
            this._patchOpSaved(payload);
            break;
          case "patchSaved":
            this._patchSaved(payload);
            break;
          case "backupCreated":
            this._backupCreated(payload);
            break;
        }
      });
    }

    _patchOpSaved(payload) {
      const data = payload.data || {};
      if (!payload.isOwn) {
        Gui$1.gui.serverOps.addOpIdChangedOnServer(data.opId, data);

        let opNames = "";
        for (let i in Gui$1.gui.serverOps.opIdsChangedOnServer) {
          opNames += Gui$1.gui.serverOps.opIdsChangedOnServer[i].opName + " ";
        }

        if (!Gui$1.gui.isRemoteClient)
          Gui$1.gui.restriction.setMessage(
            "cablesupdate",
            "Some ops in this patch have changed: " +
              opNames +
              '  <a class="button" onclick="CABLES.CMD.OP.reloadChangedOps();"><span class="icon icon-refresh"></span>reload ops</a>',
          );
      }
    }

    _patchSaved(payload) {
      const data = payload.data || {};
      if (payload.isOwn) {
        platform.setSaving(false);
        if (data.error) {
          this._connection._log.warn("[save patch error] ", data.msg);
          const modalOptions = {
            warning: true,
            title: "Patch not saved",
            text: "Could not save patch: " + data.msg,
          };
          new ModalDialog(modalOptions);
        } else if (data.updated) {
          const serverDate = moment(data.updated);
          const localDate = moment(Gui$1.gui.patchView.store.getServerDate());
          if (serverDate.isAfter(localDate))
            Gui$1.gui.patchView.store.setServerDate(data.updated);
        }
      } else {
        if (!data.error) {
          if (data.updatedByUser) {
            notify(data.updatedByUser + " saved patch in other window");
          } else {
            notify("Patch saved in other window");
          }
        }
      }
    }

    _backupCreated(payload) {
      const data = payload.data || {};
      if (payload.isOwn) {
        Gui$1.gui.jobs().finish("patchCreateBackup");
        if (data.error) {
          notifyWarn("Backup failed! " + data.msg);
        } else {
          notify("Backup created!");
        }
      }
    }
  }

  class ScConnection extends Events {
    constructor(cfg) {
      super();

      this.PING_INTERVAL = 5000;
      this.PINGS_TO_TIMEOUT = 5;
      this.OWN_PINGS_TO_TIMEOUT = 5;

      this._log = new Logger("scconnection");
      this._verboseLog = false;

      this._scConfig = cfg;
      this._active = cfg.hasOwnProperty("enabled") ? cfg.enabled : false;
      this._lastPingReceived = this.getTimestamp();

      this._socket = null;
      this._connected = false;
      this._connectedSince = null;
      this._inSessionSince = null;

      this._paco = null;
      this._pacoEnabled = false;
      this._patchConnection = new PatchConnectionSender(Gui$1.gui.corePatch());
      this._pacoSynced = false;
      this._pacoChannel = null;
      this._pacoLoopReady = false;

      this.patchChannelName = this._scConfig.patchChannel;
      this.userChannelName = this._scConfig.userChannel;
      this.userPatchChannelName = this._scConfig.userPatchChannel;
      this.multiplayerCapable = this._scConfig.multiplayerCapable;
      if (cfg) {
        this._init((isActive) => {
          let showMultiplayerUi = isActive && this.multiplayerCapable;
          if (this.showGuestUsers) showMultiplayerUi = true;
          if (Gui$1.gui.isRemoteClient) showMultiplayerUi = false;

          this._scUi = new ScUi(this);
          if (showMultiplayerUi) {
            this._multiplayerUi = new ScUiMultiplayer(this);
            this._chat = new Chat(Gui$1.gui.mainTabs, this);
          }
        });
      }
    }

    getTimestamp() {
      return performance.timing.navigationStart + performance.now();
    }

    get showGuestUsers() {
      return (
        gui &&
        Gui$1.gui.project() &&
        Gui$1.gui.project() &&
        Gui$1.gui.project().settings &&
        Gui$1.gui.project().visibility === "public"
      );
    }

    get netMouseCursorDelay() {
      return 100;
    }

    get netTimelineScrollDelay() {
      return 100;
    }

    get chat() {
      return this._chat;
    }

    get state() {
      return this._state;
    }

    get connected() {
      return this._connected;
    }

    get client() {
      return this.state.clients[this.clientId];
    }

    get clientId() {
      return this._socket.clientId;
    }

    get followers() {
      return this.state.followers;
    }

    get clients() {
      return this.state.clients;
    }

    get synced() {
      if (!this._pacoEnabled) {
        return true;
      } else {
        return this._pacoSynced;
      }
    }

    get inMultiplayerSession() {
      return this._pacoEnabled;
    }

    get hasOtherMultiplayerCapableClients() {
      if (!this.state) return false;
      let clientsInSession = false;
      const clients = Object.values(this.clients);
      for (let i = 0; i < clients.length; i++) {
        const client = clients[i];
        if (client.clientId === this.clientId) continue;
        if (client.multiplayerCapable) {
          clientsInSession = true;
          break;
        }
      }
      return clientsInSession;
    }

    get runningMultiplayerSession() {
      if (!this.state) return false;
      let clientsInSession = false;
      const clients = Object.values(this.clients);
      for (let i = 0; i < clients.length; i++) {
        const client = clients[i];
        if (client.inMultiplayerSession) {
          clientsInSession = true;
          break;
        }
      }
      return clientsInSession;
    }

    get onlyRemoteClientsConnected() {
      if (!this.state) return false;
      let onlyRemoteClients = true;
      const clients = Object.values(this.clients);
      for (let i = 0; i < clients.length; i++) {
        const client = clients[i];
        if (!client.inMultiplayerSession) continue;
        if (!client.isRemoteClient) onlyRemoteClients = false;
      }
      return onlyRemoteClients;
    }

    enableVerboseLogging() {
      this._verboseLog = true;
    }

    isConnected() {
      return this._connected;
    }

    getPilot() {
      return this.state.getPilot();
    }

    hasPilot() {
      return this.state.hasPilot();
    }

    canSaveInMultiplayer() {
      if (this._pacoEnabled) {
        return this.connected && this.client && this.client.isPilot;
      } else {
        return true;
      }
    }

    showChat() {
      this._chat.show();
    }

    setPacoPaused(paused) {
      if (this._paco) this._paco.paused = paused;
    }

    startMultiplayerSession() {
      if (this.runningMultiplayerSession) {
        this.joinMultiplayerSession();
      } else {
        if (this.multiplayerCapable) {
          if (!this.client.isRemoteClient) {
            this.client.isPilot = true;
          }
          this._inSessionSince = this.getTimestamp();
          this.client.inMultiplayerSession = true;
          this._sendPing(true);
          this._state.emitEvent("enableMultiplayer", {
            username: this.client.username,
            clientId: this.clientId,
            started: true,
          });
        }
      }
    }

    joinMultiplayerSession() {
      this.client.isPilot = false;
      this.client.following = null;
      this.client.inMultiplayerSession = true;
      this._inSessionSince = this.getTimestamp();
      this._state.emitEvent("enableMultiplayer", {
        username: this.client.username,
        clientId: this.clientId,
        started: false,
      });
      this._sendPing();
    }

    reconnectRemoteViewer() {
      let startSessionListener = null;

      if (!this.runningMultiplayerSession) {
        startSessionListener = this.on("multiplayerEnabled", () => {
          this._reconnectViewer(startSessionListener);
        });
        this.startMultiplayerSession();
      } else {
        this._reconnectViewer(startSessionListener);
      }
    }

    _reconnectViewer(startSessionListener) {
      if (startSessionListener) this._state.off(startSessionListener);
      Gui$1.gui.setRestriction(Gui$1.gui.RESTRICT_MODE_FULL);
      this.client.isPilot = true;
      this.client.following = null;
      this.client.inMultiplayerSession = true;
      this._inSessionSince = this.getTimestamp();
      this._state.emitEvent("enableMultiplayer", {
        username: this.client.username,
        clientId: this.clientId,
        started: true,
      });
      this._sendPing(true);
      this._startPacoSend(this.clientId, true);
    }

    startRemoteViewer(doneCallback) {
      const listener = () => {
        this._state.off(listenerId);
        doneCallback();
      };
      const listenerId = this._state.on("enableMultiplayer", listener);

      if (!this.inMultiplayerSession) {
        if (this.runningMultiplayerSession) {
          this.joinMultiplayerSession();
        } else {
          this.startMultiplayerSession();
        }
      } else {
        doneCallback();
      }
    }

    leaveMultiplayerSession() {
      this.client.isPilot = false;
      this._pacoChannel = this._socket.unsubscribe(
        this.userPatchChannelName + "/paco",
      );
      this._pacoEnabled = false;
      this.client.inMultiplayerSession = false;
      this.client.following = null;
      this._inSessionSince = null;
      this.emitEvent("netLeaveSession");
      this._sendPing();
    }

    sendCurrentVersion() {
      if (this.client.isPilot) {
        this._startPacoSend(this.clientId, true);
      }
    }

    _startPacoSend(requestedBy, forceResync = false) {
      if (this.inMultiplayerSession) {
        if (!this._paco) {
          this._paco = new PacoConnector(this, this._patchConnection);
          this._patchConnection.connectors.push(this._paco);
        }

        const json = Gui$1.gui.corePatch().serialize({ asObject: true });
        const payload = {
          patch: JSON.stringify(json),
          requestedBy: requestedBy,
          forceResync: forceResync,
        };
        this._paco.send(CABLES.PACO_LOAD, payload);
        this._pacoSynced = true;
        if (Gui$1.gui.scene().timer) {
          this.sendUi("timelineControl", {
            command: "setPlay",
            value: Gui$1.gui.scene().timer.isPlaying(),
            time: Gui$1.gui.scene().timer.getTime(),
          });
        }
        this.state.emitEvent("patchSynchronized");
      }
    }

    requestPilotPatch() {
      if (this.inMultiplayerSession && !this.client.isPilot) {
        this.sendPaco({ requestedBy: this.client.clientId }, "resync");
      }
    }

    track(eventCategory, eventAction, eventLabel, meta = {}) {
      if (!this._scConfig.enableTracking) return;

      const payload = {
        eventCategory,
        eventAction,
        eventLabel,
        meta,
      };
      this.sendControl("track", payload);
    }

    sendNotification(title, text) {
      this._send(this.patchChannelName, "info", {
        name: "notify",
        title: title,
        text: text,
      });
    }

    sendControl(name, payload) {
      payload = payload || {};
      payload.name = name;

      this._send(this.patchChannelName, "control", payload);
    }

    sendUi(name, payload, sendOnEmptyClientList = false) {
      if (sendOnEmptyClientList || this.state.getNumClients() > 1) {
        payload = payload || {};
        payload.name = name;
        this._send(this.patchChannelName, "ui", payload);
      }
    }

    sendChat(text) {
      // remove html
      const el = document.createElement("div");
      el.innerHTML = text;
      text = el.textContent || el.innerText || "";
      this._send(this.patchChannelName, "chat", {
        name: "chatmsg",
        text,
        username: Gui$1.gui.user.username,
      });
    }

    sendPaco(payload, name = "paco") {
      if (!this._pacoEnabled) return;
      if (this.client && (!this.client.isRemoteClient || name === "resync")) {
        payload.name = name || "paco";
        this._send(this.userPatchChannelName, "paco", payload);
      }
    }

    _init(doneCallback) {
      if (!this._active) {
        this._log.info(
          "CABLES-SOCKETCLUSTER NOT ACTIVE, WON'T SEND MESSAGES (enable in config)",
        );
        doneCallback(false);
      }

      this._token = this._scConfig.token;
      this._socket = socketClusterClient.create(this._scConfig);
      this._socket.patchChannelName = this.patchChannelName;
      this._socket.userChannelName = this.userChannelName;
      this._socket.userPatchChannelName = this.userPatchChannelName;

      this._state = new ScState(this);
      if (this.multiplayerCapable) {
        this._state.on("becamePilot", () => {
          this._sendPing();
          this._startPacoSend(this.clientId);
        });

        this._state.on("enableMultiplayer", (payload) => {
          this._pacoEnabled = true;

          (async () => {
            if (!this._pacoEnabled) return;
            if (!this._pacoChannel) {
              this._pacoChannel = this._socket.subscribe(
                this.userPatchChannelName + "/paco",
              );
              if (!this._pacoLoopReady) {
                this._pacoLoopReady = true;
                for await (const msg of this._pacoChannel) {
                  this._handlePacoMessage(msg);
                  this.emitEvent("netActivityIn");
                }
              }
            }
          })();

          if (!payload.started) {
            this.requestPilotPatch();
          }
          this.emitEvent("multiplayerEnabled");
        });
      }

      (async () => {
        for await (const { error } of this._socket.listener("error")) {
          if (!this.isConnected()) return;
          if (this.inMultiplayerSession) {
            // notifyError("multiplayer server disconnected!", "wait for reconnection to rejoin session");
            this.leaveMultiplayerSession();
          }
          // socketcluster reports "hung up" errors during own reconnection/keepalive phase
          if (error.code !== 1006 && error.code !== 4001)
            this._log.info(error.code + " - " + error.message);
          this._connected = false;

          this.emitEvent("connectionError", error);
          this.emitEvent("connectionChanged");
          this.emitEvent("netActivityIn");
        }
      })();
      (async () => {
        for await (const event of this._socket.listener("connect")) {
          this.emitEvent("netActivityIn");
          // this._log.verbose("sc connected!");
          this._connected = true;
          this._connectedSince = this.getTimestamp();

          this.emitEvent("connectionChanged");

          // send me patch
          this._updateMembers();

          if (this.client.isRemoteClient) {
            this.joinMultiplayerSession();
          } else {
            this._reconnectViewer();
          }
        }
      })();

      if (this.userChannelName) {
        (async () => {
          const userChannel = this._socket.subscribe(
            this.userChannelName + "/activity",
          );
          for await (const msg of userChannel) {
            if (msg && msg.data) {
              Gui$1.gui.updateActivityFeedIcon(msg.data);
            }
          }
        })();
      }

      (async () => {
        const controlChannel = this._socket.subscribe(
          this.patchChannelName + "/control",
        );

        for await (const msg of controlChannel) {
          this._handleControlChannelMessage(msg);
          this.emitEvent("netActivityIn");
        }
      })();

      (async () => {
        const uiChannel = this._socket.subscribe(this.patchChannelName + "/ui");
        for await (const msg of uiChannel) {
          this._handleUiChannelMsg(msg);
          this.emitEvent("netActivityIn");
        }
      })();

      (async () => {
        const infoChannel = this._socket.subscribe(
          this.patchChannelName + "/info",
        );
        for await (const msg of infoChannel) {
          this._handleInfoChannelMsg(msg);
          this.emitEvent("netActivityIn");
        }
      })();

      (async () => {
        const chatChannel = this._socket.subscribe(
          this.patchChannelName + "/chat",
        );
        for await (const msg of chatChannel) {
          this._handleChatChannelMsg(msg);
          this.emitEvent("netActivityIn");
        }
      })();

      if (this.userPatchChannelName) {
        (async () => {
          const userChannel = this._socket.subscribe(
            this.userPatchChannelName + "/info",
          );
          for await (const msg of userChannel) {
            this._handleInfoChannelMsg(msg);
            this.emitEvent("netActivityIn");
          }
        })();
      }

      window.addEventListener("beforeunload", () => {
        if (!this.client) return;

        this.client.isDisconnected = true;
        if (this.inMultiplayerSession) {
          this.leaveMultiplayerSession(true);
        } else {
          this._sendPing();
        }
        if (this._socket && this._socket.destroy) {
          this._socket.destroy();
        }
      });

      doneCallback(true);
    }

    _updateMembers() {
      this.sendControl("pingMembers", {});

      setTimeout(() => {
        this._updateMembers();
      }, this.PING_INTERVAL);
    }

    _sendPing(startedSession = false) {
      const x = Gui$1.gui.patchView.patchRenderer.viewBox
        ? Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchX
        : null;
      const y = Gui$1.gui.patchView.patchRenderer.viewBox
        ? Gui$1.gui.patchView.patchRenderer.viewBox.mousePatchY
        : null;
      const subPatch = Gui$1.gui.patchView.getCurrentSubPatch();
      const zoom = Gui$1.gui.patchView.patchRenderer.viewBox
        ? Gui$1.gui.patchView.patchRenderer.viewBox.zoom
        : null;
      const scrollX = Gui$1.gui.patchView.patchRenderer.viewBox
        ? Gui$1.gui.patchView.patchRenderer.viewBox.scrollX
        : null;
      const scrollY = Gui$1.gui.patchView.patchRenderer.viewBox
        ? Gui$1.gui.patchView.patchRenderer.viewBox.scrollY
        : null;

      const payload = {
        username: Gui$1.gui.user.usernameLowercase,
        userid: Gui$1.gui.user.id,
        connectedSince: this._connectedSince,
        inSessionSince: this._inSessionSince,
        isRemoteClient: Gui$1.gui.isRemoteClient,
        inMultiplayerSession: this.client.inMultiplayerSession,
        multiplayerCapable: this.multiplayerCapable,
        startedSession: startedSession,
      };

      if (this.client) {
        payload.isPilot = this.client.isPilot;
        payload.following = this.client.following;
        if (this.client.isDisconnected) {
          payload.isDisconnected = true;
        }
        if (this.inMultiplayerSession) {
          payload.x = x;
          payload.y = y;
          payload.subpatch = subPatch;
          payload.zoom = zoom;
          payload.scrollX = scrollX;
          payload.scrollY = scrollY;
        }
      }
      if (
        payload.isRemoteClient &&
        platform.talkerAPI &&
        !payload.isDisconnected
      ) {
        payload.platform = platformLib;
        this.sendControl("pingAnswer", payload);
      } else {
        this.sendControl("pingAnswer", payload);
      }
    }

    _send(channel, topic, payload) {
      if (!this.client) return;

      if (this._active && this._connected) {
        try {
          // try to serialize payload to handle errors in scconnection early
          JSON.stringify(payload);
          const finalPayload = {
            token: this._token,
            clientId: this.client.clientId,
            username: this.client.username,
            topic,
            ...payload,
          };

          this.emitEvent("netActivityOut");
          const perf = Gui$1.gui.uiProfiler.start("[sc] send");
          const scTopic = channel + "/" + topic;
          this._logVerbose("send:", scTopic, finalPayload);
          this._socket.transmitPublish(scTopic, finalPayload);
          perf.finish();
        } catch (e) {
          this._log.info(
            "failed to serialize object before send, ignoring",
            payload,
          );
        }
      }
    }

    _handleChatChannelMsg(msg) {
      if (!this.client) return;
      this._logVerbose("received:", this.patchChannelName + "/chat", msg);
      if (
        msg.data &&
        msg.data.senderEditorId &&
        msg.data.senderEditorId === Gui$1.gui.editorSessionId
      )
        msg.isOwn = true;

      if (msg.name === "chatmsg") {
        this.emitEvent("onChatMessage", msg);
      }
    }

    _handlePacoMessage(msg) {
      if (!this.client) return;
      if (msg.clientId === this._socket.clientId) return;
      if (
        msg.data &&
        msg.data.senderEditorId &&
        msg.data.senderEditorId === Gui$1.gui.editorSessionId
      )
        msg.isOwn = true;

      this._logVerbose("received:", this.patchChannelName + "/paco", msg);

      if (this.inMultiplayerSession && msg.name === "paco") {
        if (!this.client.isRemoteClient) return;

        const foreignRequest =
          msg.data &&
          msg.data.vars &&
          msg.data.vars.requestedBy &&
          this.client &&
          msg.data.vars.requestedBy !== this.clientId;

        if (!this._paco) {
          if (msg.data.event !== CABLES.PACO_LOAD) {
            return;
          }

          this._log.info("first paco message !");
          this._paco = new PacoConnector(this, this._patchConnection);
          this._patchConnection.connectors.push(this._paco);
          this._synchronizePatch(msg.data);
        } else if (msg.data.event === CABLES.PACO_LOAD) {
          if (!foreignRequest || (msg.data.vars && msg.data.vars.forceResync)) {
            this._synchronizePatch(msg.data, msg.data.vars.forceResync);
          }
        } else {
          const perf = Gui$1.gui.uiProfiler.start("[sc] paco receive");
          this._paco.receive(msg.data);
          perf.finish();
          this._pacoSynced = true;
          this.state.emitEvent("patchSynchronized");
        }
      } else if (msg.name === "resync") {
        if (msg.clientId === this._socket.clientId) return;
        const resyncPatch = () => {
          if (this._pacoEnabled && this.client) {
            // && this.client.isPilot)
            this._log.info("RESYNC sending paco patch....");
            this._startPacoSend(msg.clientId);
          }
        };
        if (this.inMultiplayerSession) {
          resyncPatch();
        }
      }
    }

    _synchronizePatch(data) {
      if (!this._paco) return;
      this._pacoSynced = false;
      this.state.emitEvent("startPatchSync");
      const perf = Gui$1.gui.uiProfiler.start("[sc] paco sync");
      const cbId = Gui$1.gui.corePatch().on("patchLoadEnd", () => {
        this._log.verbose("patchloadend in paco");
        Gui$1.gui.corePatch().off(cbId);
        this._pacoSynced = true;
        this.state.emitEvent("patchSynchronized");
        perf.finish();
      });
      Gui$1.gui.patchView.clearPatch();
      this._paco.receive(data);
    }

    _handleControlChannelMessage(msg) {
      if (!this.client) return;
      this._logVerbose("received:", this.patchChannelName + "/control", msg);
      if (
        msg.data &&
        msg.data.senderEditorId &&
        msg.data.senderEditorId === Gui$1.gui.editorSessionId
      )
        msg.isOwn = true;

      if (msg.name === "pingMembers") {
        const timeOutSeconds = this.PING_INTERVAL * this.OWN_PINGS_TO_TIMEOUT;
        const pingOutTime = this.getTimestamp() - timeOutSeconds;
        if (this._lastPingReceived < pingOutTime) {
          msg.seconds = timeOutSeconds / 1000;
          this.emitEvent("onPingTimeout", msg);
          this._log.info(
            "didn't receive ping for more than",
            msg.seconds,
            "seconds",
          );
        }
        if (msg.clientId !== this.clientId) {
          this._sendPing();
        } else {
          this._lastPingReceived = msg.lastSeen;
        }
      }
      if (msg.name === "pingAnswer") {
        msg.lastSeen = this.getTimestamp();
        this._lastPingReceived = msg.lastSeen;
        this.emitEvent("onPingAnswer", msg);
      }
      if (msg.name === "pilotRequest") {
        if (msg.clientId === this._socket.clientId) return;
        this.emitEvent("onPilotRequest", msg);
      }
      if (msg.name === "reloadOp") {
        if (!this.inMultiplayerSession) return;
        if (msg.clientId === this._socket.clientId) return;
        this.emitEvent("reloadOp", msg);
      }
      if (msg.name === "createdSubPatchOp") {
        this.emitEvent("createdSubPatchOp", msg);
      }
    }

    _handleUiChannelMsg(msg) {
      if (!this.client) return;
      this._logVerbose("received:", this.patchChannelName + "/ui", msg);
      if (
        msg.data &&
        msg.data.senderEditorId &&
        msg.data.senderEditorId === Gui$1.gui.editorSessionId
      )
        msg.isOwn = true;

      if (msg.clientId === this._socket.clientId) return;
      this.emitEvent(msg.name, msg);
    }

    _handleInfoChannelMsg(msg) {
      if (!this.client) return;
      this._logVerbose("received:", this.patchChannelName + "/info", msg);
      if (
        msg.data &&
        msg.data.senderEditorId &&
        msg.data.senderEditorId === Gui$1.gui.editorSessionId
      )
        msg.isOwn = true;

      if (msg.clientId === this._socket.clientId) return;
      this.emitEvent("onInfoMessage", msg);
    }

    _logVerbose(prefix, channel, msg) {
      if (this._verboseLog) {
        const { token, ...logMsg } = msg;
        this._logVerbose(prefix, channel, logMsg);
      }
    }
  }

  let idling = false;
  let idleTimeout = null;
  let idleModeStart = 0;
  let idleFocus = false;
  let idleModal = null;
  let activeModeStart = performance.now();

  const logger = new Logger("idlemode");

  function startIdleMode() {
    if (
      Gui$1.gui.canvasManager.mode == Gui$1.gui.canvasManager.CANVASMODE_POPOUT ||
      Gui$1.gui.canvasManager.mode == Gui$1.gui.canvasManager.CANVASMODE_FULLSCREEN
    )
      return;
    if (Gui$1.gui.patchView.hasFocus() && idleFocus) return;

    if (!window.gui || !Gui$1.gui.finishedLoading()) return;
    if (idling) return;
    if (!UserSettings.userSettings.get("idlemode")) return;
    if (Gui$1.gui.socket && Gui$1.gui.socket.inMultiplayerSession) return;

    const wasActiveSeconds = (performance.now() - activeModeStart) / 1000;
    if (
      window.gui &&
      !(
        Gui$1.gui.currentModal &&
        Gui$1.gui.currentModal.persistInIdleMode &&
        Gui$1.gui.currentModal.persistInIdleMode()
      )
    ) {
      Gui$1.gui.restriction.setMessage(
        "idlemode",
        "cables is paused! Click to resume",
      );
      idleModal = new ModalBackground();
      idleModal.show();
    }

    Gui$1.gui.corePatch().pause();
    Gui$1.gui.emitEvent("uiIdleStart", wasActiveSeconds);
    idling = true;

    clearTimeout(idleTimeout);
    idleModeStart = Date.now();
  }

  function idleInteractivity() {
    idleFocus = true;

    if (idling) stopIdleMode();
    if (!document.hidden) {
      clearTimeout(idleTimeout);
      idleTimeout = setTimeout(startIdleMode, uiConfig.idleModeTimeout * 1000);
    }
  }

  function stopIdleMode() {
    if (!window.gui || !Gui$1.gui.finishedLoading()) return;
    if (!idling) return;

    const idleSeconds = Math.round((Date.now() - idleModeStart) / 1000);
    logger.log("idled for ", idleSeconds + " seconds");

    Gui$1.gui.corePatch().resume();
    // if (idleModal) idleModal.close();
    if (idleModal) {
      idleModal.hide();
      Gui$1.gui.restriction.setMessage("idlemode", null);
    }
    // Gui.gui.closeModal();
    idling = false;
    clearTimeout(idleTimeout);
    Gui$1.gui.emitEvent("uiIdleEnd", idleSeconds);
    activeModeStart = performance.now();
  }

  function visibilityChanged(e) {
    idleTimeout = clearTimeout(idleTimeout);
    if (document.hidden) idleTimeout = setTimeout(startIdleMode, 1000);
    else stopIdleMode();
  }

  function startIdleListeners() {
    if (Gui$1.gui.isRemoteClient) return;

    window.addEventListener("focus", (event) => {
      idleFocus = true;
      clearTimeout(idleTimeout);
      stopIdleMode();
    });

    window.addEventListener("blur", (event) => {
      idleFocus = false;
      clearTimeout(idleTimeout);
      idleTimeout = setTimeout(startIdleMode, uiConfig.idleModeTimeout * 1000);
    });

    document.addEventListener("keydown", idleInteractivity, false);
    document.addEventListener("pointermove", idleInteractivity);
    document.addEventListener("visibilitychange", visibilityChanged);
    Gui$1.gui.on("userActivity", idleInteractivity);

    idleTimeout = setTimeout(startIdleMode, uiConfig.idleModeTimeout * 1000);
  }

  class GlGuiFull {
    constructor(patch) {
      const views = document.getElementById("patchviews");
      const ele = document.createElement("div");

      views.appendChild(ele);
      const id = "glpatch" + views.children.length;
      ele.id = id;
      ele.classList.add("glpatchcontainer");

      if (!patch.cgl.gl) {
        console.log("webgl not available! :/");
        return;
      }

      const a = new GlUiCanvas(patch, ele);

      Gui$1.gui.patchView.setPatchRenderer(id, a.glPatch);
      Gui$1.gui.patchView.switch(ele.id);

      a.parentResized();

      Gui$1.gui.on("setLayout", () => {
        a.parentResized();
      });
    }
  }

  /**
   * manage the start of the ui/editor
   *
   * @export
   * @param {*} cfg
   */
  function startUi(cfg) {
    if (window.logStartup) logStartup("Init UI");
    HandlebarsHelper$1.initHandleBarsHelper();

    new Gui$1(cfg);

    Gui$1.gui.on("uiloaded", () => {
      new Tracking();
    });

    if (Gui$1.gui.isRemoteClient) new NoPatchEditor();
    else new GlGuiFull(Gui$1.gui.corePatch());

    incrementStartup();
    Gui$1.gui.serverOps = new ServerOps(cfg.patchId, () => {
      Gui$1.gui.init();
      Gui$1.gui.checkIdle();
      Gui$1.gui.initCoreListeners();

      Gui$1.gui.corePatch().timer.setTime(0);

      if (!Gui$1.gui.corePatch().cgl.gl) {
        // ele.byId("loadingstatus").remove();
        // ele.byId("loadingstatusLog").remove();

        new ModalDialog({
          title: "GL Error",
          html: "Could not initialize webgl, or it crashed. Try to restart your browser, or try another one...",
        });
        return;
      }

      Gui$1.gui.bind(() => {
        incrementStartup();
        platform.initRouting(() => {
          incrementStartup();
          Gui$1.gui.opSelect().prepare();
          UserSettings.userSettings.init();
          incrementStartup();

          Gui$1.gui.opSelect().reload();
          Gui$1.gui.showWelcomeNotifications();
          incrementStartup();
          Gui$1.gui.showUiElements();
          Gui$1.gui.setLayout();
          Gui$1.gui.opSelect().prepare();
          incrementStartup();
          Gui$1.gui.opSelect().search();
          Gui$1.gui.setElementBgPattern(ele.byId("cablescanvas"));

          editorSession.open();

          Gui$1.gui.setFontSize(UserSettings.userSettings.get("fontSizeOff"));

          UserSettings.userSettings.on("change", function (key, v) {
            if (key == "fontSizeOff") {
              Gui$1.gui.setFontSize(v);
            }

            if (key == "bgpattern") {
              Gui$1.gui.setElementBgPattern(ele.byId("cablescanvas"));
              Gui$1.gui.setElementBgPattern(ele.byId("bgpreview"));
            }

            if (key == "hideSizeBar") {
              Gui$1.gui.setLayout();
            }
          });

          if (!UserSettings.userSettings.get("introCompleted"))
            Gui$1.gui.introduction.showIntroduction();

          Gui$1.gui.bindKeys();
          ele.byId("maincomponents").style.display = "inline";

          const socketClusterConfig = platform.getSocketclusterConfig();
          if (!Gui$1.gui.socket && socketClusterConfig.enabled) {
            Gui$1.gui.socket = new ScConnection(socketClusterConfig);
          }

          startIdleListeners();

          new HtmlInspector();

          if (UserSettings.userSettings.get("openLogTab") == true)
            CABLES.CMD.DEBUG.logConsole();

          Gui$1.gui.maintabPanel.init();

          Gui$1.gui.corePatch().logStartup("finished loading cables");

          setTimeout(() => {
            if (UserSettings.userSettings.get("forceWebGl1"))
              notifyError("Forcing WebGl v1 ");
          }, 1000);

          Gui$1.gui.patchView.checkPatchErrors();

          Gui$1.gui.patchView.setCurrentSubPatch(0);

          ele.byId("patchnavhelperEmpty").innerHTML =
            text.patch_hint_overlay_empty;
          ele.byId("patchnavhelperBounds").innerHTML =
            text.patch_hint_overlay_outofbounds;

          document.getElementById("loadingstatusLog").style.display = "none";

          let projectId = Gui$1.gui.patchId;
          if (Gui$1.gui.project()) {
            projectId = Gui$1.gui.project().shortId || Gui$1.gui.project()._id;
          }
          new QRCode(document.getElementById("remote_view_qr"), {
            text: platform.getCablesUrl() + "/remote_client/" + projectId,
            width: 200,
            height: 200,
            colorDark: "#000000",
            colorLight: "#ffffff",
            correctLevel: QRCode.CorrectLevel.H,
          });

          new QRCode(document.getElementById("patch_view_qr"), {
            text: platform.getCablesUrl() + "/p/" + projectId,
            width: 200,
            height: 200,
            colorDark: "#000000",
            colorLight: "#ffffff",
            correctLevel: QRCode.CorrectLevel.H,
          });

          if (Gui$1.gui.user)
            Gui$1.gui.updateActivityFeedIcon(Gui$1.gui.user.activityFeed);

          CABLES.UI.loaded = true;
          CABLES.UI.loadedTime = performance.now();

          Gui$1.gui.corePatch().clearSubPatchCache();

          for (let i = 0; i < Gui$1.gui.corePatch().ops.length; i++)
            if (Gui$1.gui.corePatch().ops[i].checkLinkTimeWarnings)
              Gui$1.gui.corePatch().ops[i].checkLinkTimeWarnings();

          Gui$1.gui.patchParamPanel.show();

          setTimeout(() => {
            window.Gui.gui.emitEvent("uiloaded");
            Gui$1.gui.corePatch().timer.setTime(0);
          }, 100);
        });
      });
    });

    Gui$1.gui.corePatch().logStartup("Init UI done");
  }

  class TabPortObjectInspect extends Events {
    constructor(opid, portName) {
      super();
      this.tabs = Gui$1.gui.mainTabs;
      this.tab = new CABLES.UI.Tab("Inspect " + portName, {
        icon: "op",
        infotext: "tab_objectinspect",
        padding: true,
        singleton: "false",
      });
      const tt = this.tabs.addTab(this.tab, true);

      if (tt != this.tab) return;
      this._id = CABLES.uuid();

      this.tab.on("onActivate", () => {
        this._showPortValue();
      });

      this.op = Gui$1.gui.corePatch().getOpById(opid);
      if (!this.op) {
        this._log.warn("opid not found:", opid);
        return;
      }
      this.port = this.op.getPort(portName);
      if (!this.port) {
        this._log.warn("port not found:", portName);
        return;
      }

      this._deletelistener = Gui$1.gui.corePatch().on("onOpDelete", (op) => {
        if (op == this.op) this.tabs.closeTab(this.tab.id);
      });
      this.tab.on("close", () => {
        Gui$1.gui.corePatch().off(this._deletelistener);
      });

      this._showPortValue();

      Gui$1.gui.maintabPanel.show(true);
    }

    _showPortValue() {
      const port = this.port;
      function convertHTML(str) {
        const regex = /[&|<|>|"|']/g;
        const htmlString = str.replace(regex, function (match) {
          if (match === "&") return "&amp;";
          else if (match === "<") return "&lt;";
          else if (match === ">") return "&gt;";
          else if (match === '"') return "&quot;";
          else return "&apos;";
        });
        return htmlString;
      }

      try {
        const thing = port.get();
        let serializedThing = thing;
        if (typeof thing !== "string")
          serializedThing = JSON.stringify(thing, null, 2);

        let html = "";
        html += '<div class="tabRows">';
        html += '<div class="tabRow">';
        html +=
          '<h2><span class="splitter icon icon-search"></span>&nbsp;Inspect: ' +
          this.op.name +
          ": " +
          this.port.name +
          "</h2>";
        html += "<br/>";
        html +=
          '<a class="button" id="portvaluejsonbutton' +
          this._id +
          '" ><span class="icon icon-refresh"></span>Update</a>';
        html += "&nbsp;";
        html +=
          '<a id="copybutton' +
          this._id +
          '" class="button " ><span class="icon icon-copy"></span>Copy</a>';
        html += "<br/><br/>";

        if (thing && thing.constructor) {
          html += "class name:" + thing.constructor.name + " \n";

          if (thing.constructor.name == "Array")
            html += " - length: " + thing.length + "\n";
          if (thing.constructor.name == "Float32Array")
            html += " - length: " + thing.length + "\n";
        }

        html += "</div>";

        html += '<div class="tabRowExpand">';
        // html += "<div style=\"max-height:100%;height:100%;\">";
        html +=
          '<code><pre id="portvaluejson' +
          this._id +
          '"class="hljs language-json">' +
          convertHTML(serializedThing) +
          "</code></pre>";
        // html += "</div>";
        html += "</div>";
        html += "</div>";
        this.tab.html(html);
        const el = ele.byId("portvaluejson" + this._id);

        ele
          .byId("portvaluejsonbutton" + this._id)
          .addEventListener("click", () => {
            this._showPortValue();
          });

        hljs.highlightElement(el);

        ele.byId("copybutton" + this._id).addEventListener("click", (e) => {
          this.copyPortValuePreview(e, port.name);
        });
      } catch (ex) {
        let html = "";
        html +=
          '<h2><span class="splitter icon icon-search"></span>&nbsp;Inspect Failed</h2>';
        html += "Port: <b>" + port.name + "</b> of <b>" + port.op.name + "</b> ";
        html += "<br/><br/>";

        const thing = port.get();

        if (thing && thing.constructor) {
          html += "" + thing.constructor.name + " \n";

          if (thing.constructor.name === "Array")
            html += " - length: " + thing.length + "\n";
          if (thing.constructor.name === "Float32Array")
            html += " - length: " + thing.length + "\n";
        }

        html += "<br/><br/>";
        html +=
          '<pre><code id="portvalue" class="code hljs json">Unable to serialize Array/Object:<br/>' +
          ex.message +
          "</code></pre>";

        this.tab.html(html);
      }
    }

    copyPortValuePreview(e, title) {
      navigator.clipboard
        .writeText(JSON.stringify(this.port.get()))
        .then(() => {
          notify("Copied value to clipboard");
        })
        .catch((err) => {
          console.warn("copy to clipboard failed", err);
        });
    }
  }

  /**
   * Opens a modal dialog and shows a loading indicator animation
   *
   * @param {String} title
   * @class
   */
  class ModalSourceCode {
    constructor(options) {
      this._tasks = [];
      this._options = {
        title: options.title || "Source",
        html: '<div class"loading"></div>',
        url: options.url,
        line: options.line,
        lang: options.lang,
      };

      this._dialog = new ModalDialog(this._options);

      if (this._options.url) {
        this._getFileSnippet(this._options.url, (txt) => {
          const html = this._getHtmlFromSrc(
            txt,
            [this._options.line - 1],
            this._options.line - 6,
            this._options.line + 7,
            this._options.lang || "javascript",
          );

          this._dialog.updateHtml("" + this._options.url + "<br/><br/>" + html);
        });
      } else {
        this._log.warn("no url given...");
      }
    }

    _getHtmlFromSrc(str, badLines, from, to, lang) {
      let htmlWarning =
        '<code><pre style="margin-bottom:0px;"><code class="shaderErrorCode language-glsl" style="padding-bottom:0px;max-height: initial;max-width: initial;">';

      str = str || "";
      from = from || 0;
      to = to || 1;

      let lines = [];
      try {
        lines = str.match(/^.*((\r\n|\n|\r)|$)/gm);
        while (lines.length < to) lines.push("// EOF\n");
      } catch (e) {
        return "could not parse lines.";
      }

      for (let i = from; i < to; i++) {
        const line = i + ": " + (lines[i] || "???");

        let isBadLine = false;
        for (const bj in badLines) if (badLines[bj] == i) isBadLine = true;

        if (isBadLine) {
          htmlWarning += "</code></pre>";
          htmlWarning +=
            '<pre style="margin:0"><code class="language-' +
            lang +
            '" style="background-color:#660000;padding-top:0px;padding-bottom:0px">';
        }

        htmlWarning += escapeHTML(line);

        if (isBadLine) {
          htmlWarning += "</code></pre>";
          htmlWarning +=
            '<pre style="margin:0"><code class="language-' +
            lang +
            '" style=";padding-top:0px;padding-bottom:0px">';
        }
      }

      htmlWarning = "" + htmlWarning + "<br/><br/>";
      htmlWarning += "</code></pre>";

      return htmlWarning;
    }

    _getFileSnippet(url, cb) {
      CABLES.ajax(
        url,
        (err, _data) => {
          if (err) {
            cb(err);
          }
          cb(_data);
        },
        "GET",
        null,
        null,
        false,
        {},
        { credentials: true },
      );
    }

    close() {
      this._dialog.close();
      this._dialog = null;
    }
  }

  function getBadLines(infoLog) {
    const basLines = [];
    const lines = infoLog.split("\n");
    for (const i in lines) {
      const divide = lines[i].split(":");
      if (parseInt(divide[2], 10)) basLines.push(parseInt(divide[2], 10));
    }
    return basLines;
  }

  function showShaderError(shader) {
    if (!shader.error) {
      console.log("shader has no erorr ?!");
      return;
    }
    let infoLog = shader.error.infoLog;
    const badLines = getBadLines(infoLog);

    const lines = shader.error.str.match(/^.*((\r\n|\n|\r)|$)/gm);

    let htmlWarning =
      '<pre style="margin-bottom:0px;"><code class="shaderErrorCode language-glsl" style="padding-bottom:0px;max-height: initial;max-width: initial;">';
    if (infoLog) {
      // if (type == cgl.gl.VERTEX_SHADER) this._log.log("VERTEX_SHADER");
      // if (type == cgl.gl.FRAGMENT_SHADER) this._log.log("FRAGMENT_SHADER");

      for (const i in lines) {
        const j = parseInt(i, 10) + 1;
        const line = j + ": " + lines[i];

        let isBadLine = false;
        for (const bj in badLines) if (badLines[bj] == j) isBadLine = true;

        if (isBadLine) {
          htmlWarning += "</code></pre>";
          htmlWarning +=
            '<pre style="margin:0"><code class="language-glsl" style="background-color:#660000;padding-top:0px;padding-bottom:0px">';

          // cglShader._log.log("bad line: `" + line + "`");
        }
        htmlWarning += escapeHTML(line);

        if (isBadLine) {
          htmlWarning += "</code></pre>";
          htmlWarning +=
            '<pre style="margin:0"><code class="language-glsl" style=";padding-top:0px;padding-bottom:0px">';
        }
      }
    }

    infoLog = infoLog.replace(/\n/g, "<br/>");

    let html = infoLog;
    html +=
      '<a id="alwaysshowbutton" class="button-small right">' +
      getShowAlwaysButtonText$1() +
      "</a>";
    html += "<br/>" + htmlWarning + "<br/>";
    html += "</code></pre>";

    new ModalDialog({ html: html, title: "Shader Error" });

    ele.clickable(ele.byId("alwaysshowbutton"), () => {
      UserSettings.userSettings.set(
        "showAllShaderErrors",
        !UserSettings.userSettings.get("showAllShaderErrors"),
      );
      ele.byId("alwaysshowbutton").innerHTML = getShowAlwaysButtonText$1();
    });
  }

  function getShowAlwaysButtonText$1() {
    if (!UserSettings.userSettings.get("showAllShaderErrors"))
      return '<icon class="icon icon-x"></icon>Always open on shader errors';
    return '<icon class="icon icon-check"></icon>Always open on shader errors';
  }

  /**
   * @param {CgpShader} shader
   * @param {GPUCompilationInfo} nfo
   */
  function showShaderErrorCgp(shader, nfo, src) {
    const badLines = {};
    let infoLog = "";

    for (const msg of nfo.messages) {
      infoLog +=
        msg.type +
        " at line " +
        msg.lineNum +
        ":" +
        msg.linePos +
        " :" +
        msg.message +
        "<br/>";
      if (msg.type == "error") badLines[msg.lineNum] = msg.lineNum;
    }

    const lines = src.split("\n");
    let htmlWarning =
      '<pre style="margin-bottom:0px;"><code class="shaderErrorCode language-glsl" style="padding-bottom:0px;max-height: initial;max-width: initial;">';

    for (const i in lines) {
      const j = parseInt(i, 10) + 1;
      const line = j + ": " + lines[i];

      let isBadLine = false;
      for (const bj in badLines) if (badLines[bj] == j) isBadLine = true;

      if (isBadLine) {
        htmlWarning += "</code></pre>";
        htmlWarning +=
          '<pre style="margin:0"><code class="language-glsl" style="background-color:#660000;padding-top:0px;padding-bottom:0px">';
      }
      htmlWarning += escapeHTML(line) + "\n";

      if (isBadLine) {
        htmlWarning += "</code></pre>";
        htmlWarning +=
          '<pre style="margin:0"><code class="language-glsl" style=";padding-top:0px;padding-bottom:0px">';
      }
    }

    let html = infoLog;
    html +=
      '<a id="alwaysshowbutton" class="button-small right">' +
      getShowAlwaysButtonText() +
      "</a>";
    html += "<br/>" + htmlWarning + "<br/>";
    html += "</code></pre>";

    new ModalDialog({ html: html, title: "Shader Error" });

    ele.clickable(ele.byId("alwaysshowbutton"), () => {
      UserSettings.userSettings.set(
        "showAllShaderErrors",
        !UserSettings.userSettings.get("showAllShaderErrors"),
      );
      ele.byId("alwaysshowbutton").innerHTML = getShowAlwaysButtonText();
    });
  }

  function getShowAlwaysButtonText() {
    if (!UserSettings.userSettings.get("showAllShaderErrors"))
      return '<icon class="icon icon-x"></icon>Always open on shader errors';
    return '<icon class="icon icon-check"></icon>Always open on shader errors';
  }

  window.glMatrix = undefined;
  window.mat2 = mat2;
  window.mat2d = mat2d;
  window.mat3 = mat3;
  window.mat4 = mat4$1;
  window.quat = quat;
  window.quat2 = quat2;
  window.vec2 = vec2$1;
  window.vec3 = vec3$1;
  window.vec4 = vec4$1;

  const CABLES$1 = {};
  window.CABLES = CABLES$1 || {};

  CABLES$1.CGL = CGL$1;
  CABLES$1.CG = CG;
  CABLES$1.CGP = CGP;
  CABLES$1.EMBED = EMBED;
  CABLES$1.Link = Link;
  CABLES$1.Port = Port;
  CABLES$1.Op = Op;
  CABLES$1.Profiler = Profiler$1;
  CABLES$1.Patch = Patch;
  CABLES$1.Timer = Timer;
  CABLES$1.WEBAUDIO = WEBAUDIO;
  CABLES$1.Variable = Variable;
  CABLES$1.LoadingStatus = LoadingStatus;
  CABLES$1.now = now;
  CABLES$1.internalNow = internalNow;
  CABLES$1.Anim = Anim;
  CABLES$1.AnimKey = AnimKey;

  CABLES$1.shortId = shortId;
  CABLES$1.uuid = uuid;
  CABLES$1.getShortOpName = getShortOpName;
  CABLES$1.simpleId = simpleId;
  CABLES$1.clamp = clamp;
  CABLES$1.map = map;
  CABLES$1.shuffleArray = shuffleArray;
  CABLES$1.generateUUID = generateUUID;
  CABLES$1.prefixedHash = prefixedHash;
  CABLES$1.smoothStep = smoothStep;
  CABLES$1.smootherStep = smootherStep;
  CABLES$1.cacheBust = cacheBust;
  CABLES$1.copyArray = copyArray;
  CABLES$1.basename = basename;
  CABLES$1.logStack = logStack;
  CABLES$1.filename = filename;
  CABLES$1.ajaxSync = ajaxSync;
  CABLES$1.ajax = ajax;
  CABLES$1.request = request;
  CABLES$1.logErrorConsole = logErrorConsole;
  CABLES$1.isNumeric = isNumeric;
  CABLES$1.isArray = isArray;
  CABLES$1.float32Concat = float32Concat;
  CABLES$1.uniqueArray = uniqueArray;
  CABLES$1.CGState = CgContext;
  CABLES$1.CgContext = CgContext;

  /** @type {Array<Op>} */
  CABLES$1.OPS = [];

  Object.assign(
    CABLES$1,
    CONSTANTS.PORT,
    CONSTANTS.PACO,
    CONSTANTS.ANIM,
    CONSTANTS.OP,
  );

  CABLES$1.UI = CABLES$1.UI || {};
  CABLES$1.GLGUI = CABLES$1.GLGUI || {};
  CABLES$1.GLUI = CABLES$1.GLUI || {};
  CABLES$1.GLGUI.CURSOR_NORMAL = 0;
  CABLES$1.GLGUI.CURSOR_HAND = 1;
  CABLES$1.GLGUI.CURSOR_POINTER = 2;

  CABLES$1.UI.userSettings = new UserSettings();

  // create "mock" to load dependencies, specific class is set in footer.html
  CABLES$1.PlatformElectron = PlatformElectron;
  CABLES$1.PlatformCommunity = PlatformCommunity;
  CABLES$1.platform = new Platform({
    urlCables: "",
    patchVersion: "",
  });
  // expose global classes
  CABLES$1.GLUI.glUiConfig = gluiconfig; // todo: could be removed, needs workaround in gltf ops
  CABLES$1.UI.TabPortObjectInspect = TabPortObjectInspect;

  window.ele = ele;

  CABLES$1.GradientEditor = GradientEditor;
  CABLES$1.UI.Tab = Tab; // needs to stay - is used in ops
  CABLES$1.UI.FindTab = FindTab; // move to command ?

  CABLES$1.UI.DEFAULTOPNAMES = defaultOps.defaultOpNames;

  CABLES$1.UI.DEFAULTOPS = defaultOps;
  // expose global objects
  CABLES$1.contextMenu = contextMenu; // TODO: delete when old timeline is replaced
  CABLES$1.UI.Collapsable = Collapsable;

  CABLES$1.UI.TEXTS = text;

  CABLES$1.UI.ModalDialog = ModalDialog; // needs to stay - is used in ops
  CABLES$1.UI.ModalError = ModalError;

  // expose global functions

  CABLES$1.DragNDrop = DragNDrop;

  CABLES$1.CMD = CMD;

  CABLES$1.UI.logFilter = new LogFilter();

  CABLES$1.GL_MARKER = helperMeshes;
  CABLES$1.UI.OverlayMeshes = helperMeshes;

  CABLES$1.UI.paramsHelper = paramsHelper;

  CABLES$1.UI.undo = undo;

  CABLES$1.UI.MODAL = oldModalWrap;
  CABLES$1.UI.Gizmo = Gizmo;
  CABLES$1.UI.ModalSourceCode = ModalSourceCode;
  CABLES$1.UI.showShaderError = showShaderError;
  CABLES$1.UI.showShaderErrorCgp = showShaderErrorCgp;

  setHtmlDefaultListeners();

  CABLES$1.UI.startUi = startUi;

  // added during webpack build
  CABLES$1.UI.build = window.BUILD_INFO;

})();
//# sourceMappingURL=cables-ui.js.map
