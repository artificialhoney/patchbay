import { html, css, LitElement } from "lit";


export class CablesWebComponent extends LitElement {
  static styles = css`
    {{ style }}
  `;

  static properties = {
    talker: { type: Object },
  };

  constructor() {
    super();
  }

  render() {
    return html`
      {{ html }}
    `;
  }

  async connectedCallback() {
    super.connectedCallback()
    if (!process.client) {
      return;
    }

    await import("../libs/index.js");
    await import("../ui/index.js");

        var CABLESUILOADER = CABLESUILOADER || {};

    CABLESUILOADER.GlobalVarTester = (function ()
    {
        var fields = {};
        var before = function (w)
        {
            for (var field in w)
                fields[field] = true;
        };

        var after = function (w)
        {
            for (var field in w)
                if (!fields[field])
                    console.log(field + " has been added");
        };
        return {
            before: before,
            after: after
        };
    }());

    CABLESUILOADER.preload = {};
    CABLESUILOADER.GlobalVarTester.before(window);

    CABLESUILOADER.uiLoadStart = performance.now();
    CABLESUILOADER.startup = {};
    CABLESUILOADER.startup.log = [];
    CABLESUILOADER.startup.maxEvents = 15 - 1;
    CABLESUILOADER.startup.numEvents = 0;

    CABLESUILOADER.buildInfo = {};

    function incrementStartup()
    {
        CABLESUILOADER.startup.numEvents++;
        // if(CABLESUILOADER.startup.numEvents>CABLESUILOADER.startup.maxEvents)console.warn("too many cables startup events!",CABLESUILOADER.startup.numEvents,CABLESUILOADER.startup.maxEvents)
        const loadingBarEle = document.getElementById("loadingstatusBar");
        if (loadingBarEle) loadingBarEle.style.width = (CABLESUILOADER.startup.numEvents / CABLESUILOADER.startup.maxEvents) * 100 + "%";
    }

    function logStartup(title)
    {
        if(window.gui && gui.finishedLoading()) return;

        const timeUsed = Math.round((performance.now() - CABLESUILOADER.uiLoadStart) / 1000 * 100) / 100;

        CABLESUILOADER.startup.log.push(
            {
                "title": title,
                "time": timeUsed
            });

        if (!window.CABLES || !CABLES.platform || !CABLES.platform.isDevEnv()) return;
        document.getElementById("loadingstatusLog").innerHTML += title + " (" + timeUsed + ") <br/>";
    }

    CABLESUILOADER.noCacheUrl = function (url)
    {
        if(window.CABLES && CABLES.platform) return CABLES.platform.noCacheUrl(url);
        return url;
    };

    CABLESUILOADER.builtVersionUrl = function (component, url)
    {
        let ncUrl = CABLESUILOADER.noCacheUrl(url);
        if (CABLESUILOADER.buildInfo)
        {
            if (CABLESUILOADER.buildInfo[component])
            {
                ncUrl = url;// + "?nc=" + CABLESUILOADER.buildInfo[component].timestamp;
            }
        }
        return ncUrl;
    };

    incrementStartup();
    if (window.logStartup) logStartup("start ui");

    CABLESUILOADER.loadAll = function (cfg)
    {
        CABLESUILOADER.cfg = cfg;
        if (!window.hasOwnProperty("loadjs"))
        {
            setTimeout(CABLESUILOADER.loadAll, 100);
            console.log("wait for loadjs...");
            return;
        }

        logStartup("loaded minimum libs / starting up...");

        incrementStartup();

        logStartup("loaded cables core");
        incrementStartup();

        let platformClass = "PlatformCommunity";
        if(cfg && cfg.platformClass) {
            if(CABLES.hasOwnProperty(cfg.platformClass)) {
                platformClass = cfg.platformClass;
                console.info("using sandbox from", platformClass);
            }else{
                console.error("could not find class for sandbox", cfg.platformClass, "using", platformClass);
            }

        }
        CABLES.platform = new CABLES[platformClass](cfg);

        incrementStartup();
        logStartup("loaded ui");

        CABLESUILOADER.talkerAPI.send("getOpDocsAll", { "projectId": cfg.patchId }, (err, _data) =>
        {

            if (err)
            {
                console.error("preloading error", err);
            }
            else
            {
                CABLESUILOADER.preload.opDocsAll = _data;
            }
        }, (response) =>
        {
            console.error("preloading error", response);
        });

        incrementStartup();
        logStartup('loaded cables ops');

        waitForAce();
    };

    function waitForAce()
    {
        if (!CABLESUILOADER.preload.opDocsAll)
        {
            setTimeout(waitForAce, 100);
        }
        else
        {
            CABLESUILOADER.uiLoadFiles = performance.now() - CABLESUILOADER.uiLoadStart;

            CABLES.UI.startUi(CABLESUILOADER.cfg);
        }
    }


        CABLESUILOADER.talkerAPI = this.talker;

        const reqTimeout=setTimeout(()=>
        {
            document.getElementById("loadingstatus").style.display="none";
            document.getElementById("loadingstatusLog").innerHTML += "error: could not get response from talker api. editor not in iframe? <br/>";
        },1000);

        CABLESUILOADER.talkerAPI.send("requestPatchData", {}, function (error, response)
        {
            clearTimeout(reqTimeout);

            if (response.buildInfo)
            {
                CABLESUILOADER.buildInfo = response.buildInfo;
            }
            CABLESUILOADER.loadAll(response);
        });

  }
}

customElements.define("cables-ui", CablesWebComponent);
